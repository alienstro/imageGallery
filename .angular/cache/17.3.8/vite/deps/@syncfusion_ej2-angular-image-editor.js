import {
  Ajax,
  Animation,
  Base,
  Browser,
  ChildProperty,
  Collection,
  Complex,
  Component,
  Draggable,
  Droppable,
  Event,
  EventHandler,
  Fetch,
  Internationalization,
  KeyboardEvents,
  L10n,
  NotifyPropertyChanges,
  Observer,
  Property,
  SanitizeHtmlHelper,
  Touch,
  addClass,
  animationMode,
  append,
  attributes,
  classList,
  closest,
  compareElementParent,
  compile,
  createElement,
  deleteObject,
  detach,
  extend,
  formatUnit,
  getComponent,
  getElement,
  getInstance,
  getNumericObject,
  getRandomId,
  getTemplateEngine,
  getUniqueID,
  getValue,
  initializeCSPTemplate,
  isBlazor,
  isNullOrUndefined,
  isObject,
  isRippleEnabled,
  isUndefined,
  isVisible,
  matches,
  merge,
  onIntlChange,
  prepend,
  remove,
  removeClass,
  rippleEffect,
  select,
  selectAll,
  setStyleAttribute,
  setTemplateEngine,
  setValue
} from "./chunk-EATDXRY4.js";
import {
  CommonModule
} from "./chunk-W7R5N76A.js";
import {
  ChangeDetectionStrategy,
  Component as Component2,
  ContentChild,
  ElementRef,
  EventEmitter,
  Injector,
  NgModule,
  Renderer2,
  ViewContainerRef,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵloadQuery,
  ɵɵqueryRefresh
} from "./chunk-SIMXHNJ2.js";
import "./chunk-SB7K7NPI.js";
import "./chunk-XLRD4WBL.js";
import {
  __decorate
} from "./chunk-JMJQA5TZ.js";
import "./chunk-J4B6MK7R.js";

// node_modules/@syncfusion/ej2-angular-base/src/util.js
function applyMixins(derivedClass, baseClass) {
  baseClass.forEach(function(baseClass2) {
    Object.getOwnPropertyNames(baseClass2.prototype).forEach(function(name) {
      if (!Object.prototype.hasOwnProperty.call(derivedClass.prototype, name) || baseClass2.isFormBase && name !== "constructor") {
        derivedClass.prototype["".concat(name)] = baseClass2.prototype["".concat(name)];
      }
    });
  });
}
function ComponentMixins(baseClass) {
  return function(derivedClass) {
    applyMixins(derivedClass, baseClass);
  };
}
function registerEvents(eventList, obj, direct) {
  var ngEventsEmitter = {};
  if (eventList && eventList.length) {
    for (var _i = 0, eventList_1 = eventList; _i < eventList_1.length; _i++) {
      var event_1 = eventList_1[_i];
      if (direct === true) {
        obj.propCollection["".concat(event_1)] = new EventEmitter(false);
        obj["".concat(event_1)] = obj.propCollection["".concat(event_1)];
      } else {
        ngEventsEmitter["".concat(event_1)] = new EventEmitter(false);
      }
    }
    if (direct !== true) {
      obj.setProperties(ngEventsEmitter, true);
    }
  }
}
function clearTemplate(_this, templateNames, index) {
  var regTemplates = Object.keys(_this.registeredTemplate);
  if (regTemplates.length) {
    var regProperties = templateNames && templateNames.filter(function(val) {
      return /\./g.test(val) ? false : true;
    });
    var tabaccordionTemp = /tab|accordion|toolbar/.test(_this.getModuleName());
    for (var _i = 0, _a = regProperties && regProperties || regTemplates; _i < _a.length; _i++) {
      var registeredTemplate = _a[_i];
      if (index && index.length) {
        for (var e = 0; e < index.length; e++) {
          if (tabaccordionTemp) {
            for (var m = 0; m < _this.registeredTemplate["".concat(registeredTemplate)].length; m++) {
              var value = _this.registeredTemplate["".concat(registeredTemplate)][parseInt(m.toString(), 10)];
              if (value && value === index["".concat(e)]) {
                value.destroy();
                _this.registeredTemplate["".concat(registeredTemplate)].splice(m, 1);
              }
            }
          } else {
            for (var m = 0; m < _this.registeredTemplate.template.length; m++) {
              var value = _this.registeredTemplate.template[parseInt(m.toString(), 10)].rootNodes[0];
              if (value === index["".concat(e)]) {
                var rt = _this.registeredTemplate["".concat(registeredTemplate)];
                rt[parseInt(m.toString(), 10)].destroy();
              }
            }
          }
        }
      } else {
        if (_this.registeredTemplate["".concat(registeredTemplate)]) {
          for (var _b = 0, _c = _this.registeredTemplate["".concat(registeredTemplate)]; _b < _c.length; _b++) {
            var rt = _c[_b];
            if (!rt.destroyed) {
              if (rt._view) {
                var pNode = rt._view.renderer.parentNode(rt.rootNodes[0]);
                if (!isNullOrUndefined(pNode)) {
                  for (var m = 0; m < rt.rootNodes.length; m++) {
                    pNode.appendChild(rt.rootNodes[parseInt(m.toString(), 10)]);
                  }
                }
              }
              rt.destroy();
            }
          }
        }
      }
      if (!tabaccordionTemp || !index) {
        delete _this.registeredTemplate["".concat(registeredTemplate)];
      }
    }
  }
  var _loop_1 = function(tagObject2) {
    if (tagObject2.instance) {
      tagObject2.instance.clearTemplate(templateNames && templateNames.filter(function(val) {
        var regExp = RegExp;
        return new regExp(tagObject2.name).test(val) ? true : false;
      }));
    }
  };
  for (var _d = 0, _e = _this.tagObjects; _d < _e.length; _d++) {
    var tagObject = _e[_d];
    _loop_1(tagObject);
  }
}
function setValue2(nameSpace, value, object) {
  var keys = nameSpace.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  var fromObj = object || {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[parseInt(i.toString(), 10)];
    if (i + 1 === keys.length) {
      fromObj["".concat(key)] = value === void 0 ? {} : value;
    } else if (fromObj["".concat(key)] === void 0) {
      fromObj["".concat(key)] = {};
    }
    fromObj = fromObj["".concat(key)];
  }
  return fromObj;
}

// node_modules/@syncfusion/ej2-angular-base/src/complex-array-base.js
var refRegex = /Ref$/;
var ComplexBase = (
  /** @class */
  function() {
    function ComplexBase2() {
      this.hasChanges = false;
      this.propCollection = {};
      this.dataSource = {};
      this.tags = [];
      this.tagObjects = [];
    }
    ComplexBase2.prototype.ngOnInit = function() {
      this.registeredTemplate = {};
      for (var _i = 0, _a = this.tags; _i < _a.length; _i++) {
        var tag = _a[_i];
        var objInstance = getValue("child" + tag.substring(0, 1).toUpperCase() + tag.substring(1), this);
        if (objInstance) {
          this.tagObjects.push({ instance: objInstance, name: tag });
        }
      }
      var templateProperties = Object.keys(this);
      for (var i = 0; i < templateProperties.length; i++) {
        var tempProp = getValue(templateProperties[parseInt(i.toString(), 10)], this);
        if (typeof tempProp === "object" && tempProp && tempProp.elementRef) {
          if (!getValue(templateProperties[parseInt(i.toString(), 10)].indexOf("Ref") !== -1 ? templateProperties[parseInt(i.toString(), 10)] : templateProperties[parseInt(i.toString(), 10)] + "Ref", this)) {
            setValue(templateProperties[parseInt(i.toString(), 10)].indexOf("Ref") !== -1 ? templateProperties[parseInt(i.toString(), 10)] : templateProperties[parseInt(i.toString(), 10)] + "Ref", tempProp, this);
          }
          if (getValue("viewContainerRef", this) && !getValue("_viewContainerRef", tempProp.elementRef.nativeElement) && !getValue("propName", tempProp.elementRef.nativeElement)) {
            setValue("_viewContainerRef", getValue("viewContainerRef", this), tempProp.elementRef.nativeElement);
            setValue("propName", templateProperties[parseInt(i.toString(), 10)].replace("Ref", ""), tempProp.elementRef.nativeElement);
          }
        }
      }
      templateProperties = Object.keys(this);
      templateProperties = templateProperties.filter(function(val) {
        return /Ref$/i.test(val);
      });
      for (var _b = 0, templateProperties_1 = templateProperties; _b < templateProperties_1.length; _b++) {
        var tempName = templateProperties_1[_b];
        var propName = tempName.replace("Ref", "");
        setValue(propName.replace("_", "."), getValue(propName, this), this.propCollection);
      }
      var propList = Object.keys(this);
      if (this.directivePropList) {
        for (var k = 0; k < this.directivePropList.length; k++) {
          var dirPropName = this.directivePropList[parseInt(k.toString(), 10)];
          if (propList.indexOf(dirPropName) !== -1 && (getValue(dirPropName, this) === false || getValue(dirPropName, this))) {
            setValue(dirPropName, getValue(dirPropName, this), this.propCollection);
          }
        }
        this.hasChanges = true;
      }
      this.isInitChanges = true;
    };
    ComplexBase2.prototype.registerEvents = function(eventList) {
      registerEvents(eventList, this, true);
    };
    ComplexBase2.prototype.ngOnChanges = function(changes) {
      for (var _i = 0, _a = Object.keys(changes); _i < _a.length; _i++) {
        var propName = _a[_i];
        var changedVal = changes["".concat(propName)];
        this.propCollection["".concat(propName)] = changedVal.currentValue;
      }
      this.isUpdated = false;
      this.hasChanges = true;
    };
    ComplexBase2.prototype.clearTemplate = function(templateNames) {
      clearTemplate(this, templateNames);
    };
    ComplexBase2.prototype.getProperties = function() {
      for (var _i = 0, _a = this.tagObjects; _i < _a.length; _i++) {
        var tagObject = _a[_i];
        this.propCollection[tagObject.name] = tagObject.instance.getProperties();
      }
      return this.propCollection;
    };
    ComplexBase2.prototype.isChanged = function() {
      var result = this.hasChanges;
      if (!isNullOrUndefined(this.propCollection[this.property])) {
        var tempProps = this.propCollection[this.property];
        var props = Object.keys(tempProps[0]);
        for (var d = 0; d < props.length; d++) {
          if (!isNullOrUndefined(this.propCollection[props[parseInt(d.toString(), 10)]])) {
            var val = getValue(props[parseInt(d.toString(), 10)], this);
            var propVal = this.propCollection[this.property][0][props[parseInt(d.toString(), 10)]];
            if (!isNullOrUndefined(val) && this.propCollection[props[parseInt(d.toString(), 10)]] !== val && propVal !== val) {
              setValue(props[parseInt(d.toString(), 10)], val, this.propCollection[this.property][0]);
              setValue(props[parseInt(d.toString(), 10)], val, this.propCollection);
              this.hasChanges = true;
              this.isUpdated = false;
            }
          }
        }
      }
      for (var _i = 0, _a = this.tagObjects; _i < _a.length; _i++) {
        var item = _a[_i];
        result = result || item.instance.hasChanges;
      }
      return result || this.hasChanges;
    };
    ComplexBase2.prototype.ngAfterContentChecked = function() {
      this.hasChanges = this.isChanged();
      if (this.isInitChanges || this.hasChanges) {
        var templateProperties = Object.keys(this);
        templateProperties = templateProperties.filter(function(val) {
          return refRegex.test(val);
        });
        for (var _i = 0, templateProperties_2 = templateProperties; _i < templateProperties_2.length; _i++) {
          var tempName = templateProperties_2[_i];
          var propName = tempName.replace("Ref", "");
          setValue(propName.replace("_", "."), getValue(propName, this), this.propCollection);
        }
      }
    };
    ComplexBase2.prototype.ngAfterViewChecked = function() {
      if (this.isUpdated) {
        this.hasChanges = false;
      }
    };
    ComplexBase2.prototype.ngAfterViewInit = function() {
      this.isInitChanges = false;
    };
    ComplexBase2.prototype.ngOnDestroy = function() {
      this.directivePropList = [];
    };
    return ComplexBase2;
  }()
);
var ArrayBase = (
  /** @class */
  function() {
    function ArrayBase2(propertyName) {
      this.list = [];
      this.hasChanges = false;
      this.propertyName = propertyName;
    }
    ArrayBase2.prototype.ngOnInit = function() {
      this.isInitChanges = true;
    };
    ArrayBase2.prototype.ngAfterContentInit = function() {
      var _this = this;
      var index = 0;
      this.list = this.children.map(function(child) {
        child.dirIndex = index++;
        child.property = _this.propertyName;
        return child;
      });
      this.hasChanges = true;
    };
    ArrayBase2.prototype.getProperties = function() {
      var onlyProp = [];
      for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
        var item = _a[_i];
        onlyProp.push(item.getProperties());
      }
      return onlyProp;
    };
    ArrayBase2.prototype.isChanged = function() {
      var _this = this;
      var result = false;
      var index = 0;
      var isSourceChanged = false;
      var childrenDataSource = this.children.map(function(child) {
        return child;
      });
      if (this.list.length === this.children.length) {
        for (var i = 0; i < this.list.length; i++) {
          if (this.list[parseInt(i.toString(), 10)].propCollection.dataSource) {
            if (this.list[parseInt(i.toString(), 10)].dataSource && this.list[parseInt(i.toString(), 10)].propCollection.dataSource !== this.list[parseInt(i.toString(), 10)].dataSource) {
              this.list[parseInt(i.toString(), 10)].propCollection.dataSource = this.list[parseInt(i.toString(), 10)].dataSource;
              this.list[parseInt(i.toString(), 10)].hasChanges = true;
            }
            if (this.list[parseInt(i.toString(), 10)].property !== "series") {
              isSourceChanged = JSON.stringify(this.list[parseInt(i.toString(), 10)].propCollection.dataSource) !== JSON.stringify(childrenDataSource[parseInt(i.toString(), 10)].propCollection.dataSource);
            }
          }
          isSourceChanged = this.list[parseInt(i.toString(), 10)].hasChanges !== childrenDataSource[parseInt(i.toString(), 10)].hasChanges;
        }
      }
      this.hasNewChildren = this.list.length !== this.children.length || isSourceChanged ? true : null;
      if (this.hasNewChildren) {
        this.list = this.children.map(function(child) {
          child.dirIndex = index++;
          child.property = _this.propertyName;
          return child;
        });
      }
      for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
        var item = _a[_i];
        result = result || item.hasChanges;
      }
      return !!this.list.length && result;
    };
    ArrayBase2.prototype.clearTemplate = function(templateNames) {
      var _this = this;
      for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
        var item = _a[_i];
        item.clearTemplate(templateNames && templateNames.map(function(val) {
          var regExp = RegExp;
          return new regExp(_this.propertyName).test(val) ? val.replace(_this.propertyName + ".", "") : val;
        }));
      }
    };
    ArrayBase2.prototype.ngAfterContentChecked = function() {
      this.hasChanges = this.isChanged();
      for (var i = 0; i < this.list.length; i++) {
        if (getValue("childColumns", this.list[parseInt(i.toString(), 10)]) && getValue("property", this.list[parseInt(i.toString(), 10)]) === "columns") {
          setValue("columns", getValue("childColumns", this.list[parseInt(i.toString(), 10)]).getProperties(), this.list[parseInt(i.toString(), 10)].propCollection);
        }
        this.list[parseInt(i.toString(), 10)].isUpdated = true;
      }
    };
    ArrayBase2.prototype.ngAfterViewInit = function() {
      this.isInitChanges = false;
    };
    ArrayBase2.prototype.ngOnDestroy = function() {
      this.list = [];
    };
    return ArrayBase2;
  }()
);

// node_modules/@syncfusion/ej2-angular-base/src/component-base.js
var ComponentBase = (
  /** @class */
  function() {
    function ComponentBase2() {
      this.isProtectedOnChange = true;
      this.isFormInit = true;
    }
    ComponentBase2.prototype.saveChanges = function(key, newValue, oldValue) {
      if (this.isProtectedOnChange) {
        return;
      }
      this.oldProperties["".concat(key)] = oldValue;
      this.changedProperties["".concat(key)] = newValue;
      this.finalUpdate();
      var changeTime = setTimeout(this.dataBind.bind(this));
      var clearUpdate = function() {
        clearTimeout(changeTime);
      };
      this.finalUpdate = clearUpdate;
    };
    ComponentBase2.prototype.ngOnInit = function(isTempRef) {
      var tempOnThis = isTempRef || this;
      tempOnThis.registeredTemplate = {};
      tempOnThis.ngBoundedEvents = {};
      tempOnThis.isAngular = true;
      tempOnThis.isFormInit = true;
      if (isTempRef) {
        this.tags = isTempRef.tags;
      }
      tempOnThis.tags = this.tags || [];
      tempOnThis.complexTemplate = this.complexTemplate || [];
      tempOnThis.tagObjects = [];
      tempOnThis.ngAttr = this.getAngularAttr(tempOnThis.element);
      tempOnThis.createElement = function(tagName, prop) {
        var ele = tempOnThis.srenderer ? tempOnThis.srenderer.createElement(tagName) : createElement(tagName);
        if (typeof prop === "undefined") {
          return ele;
        }
        ele.innerHTML = prop.innerHTML ? prop.innerHTML : "";
        if (prop.className !== void 0) {
          ele.className = prop.className;
        }
        if (prop.id !== void 0) {
          ele.id = prop.id;
        }
        if (prop.styles !== void 0) {
          ele.setAttribute("style", prop.styles);
        }
        if (tempOnThis.ngAttr !== void 0) {
          ele.setAttribute(tempOnThis.ngAttr, "");
        }
        if (prop.attrs !== void 0) {
          attributes(ele, prop.attrs);
        }
        return ele;
      };
      for (var _i = 0, _a = tempOnThis.tags; _i < _a.length; _i++) {
        var tag = _a[_i];
        var tagObject = {
          instance: getValue("child" + tag.substring(0, 1).toUpperCase() + tag.substring(1), tempOnThis),
          name: tag
        };
        tempOnThis.tagObjects.push(tagObject);
      }
      var complexTemplates = Object.keys(tempOnThis);
      for (var i = 0; i < complexTemplates.length; i++) {
        var compProp = getValue(complexTemplates[parseInt(i.toString(), 10)], tempOnThis);
        if (typeof compProp === "object" && compProp && compProp.elementRef) {
          if (typeof compProp === "object" && compProp && compProp.elementRef && complexTemplates[parseInt(i.toString(), 10)].indexOf("_") !== -1 && complexTemplates[parseInt(i.toString(), 10)].indexOf("Ref") === -1) {
            setValue(complexTemplates[parseInt(i.toString(), 10)] + "Ref", compProp, tempOnThis);
          }
          if (tempOnThis.viewContainerRef && !getValue("_viewContainerRef", compProp.elementRef.nativeElement) && !getValue("propName", compProp.elementRef.nativeElement)) {
            setValue("_viewContainerRef", tempOnThis.viewContainerRef, compProp.elementRef.nativeElement);
            setValue("propName", complexTemplates[parseInt(i.toString(), 10)].replace("Ref", ""), compProp.elementRef.nativeElement);
          }
        }
      }
      complexTemplates = Object.keys(tempOnThis);
      complexTemplates = complexTemplates.filter(function(val2) {
        return /Ref$/i.test(val2) && /_/i.test(val2);
      });
      for (var _b = 0, complexTemplates_1 = complexTemplates; _b < complexTemplates_1.length; _b++) {
        var tempName = complexTemplates_1[_b];
        var propName = tempName.replace("Ref", "");
        var val = {};
        setValue(propName.replace("_", "."), getValue(propName, tempOnThis), val);
        tempOnThis.setProperties(val, true);
      }
    };
    ComponentBase2.prototype.getAngularAttr = function(ele) {
      var attributes2 = ele.attributes;
      var length = attributes2.length;
      var ngAr;
      for (var i = 0; i < length; i++) {
        if (/_ngcontent/g.test(attributes2[parseInt(i.toString(), 10)].name)) {
          ngAr = attributes2[parseInt(i.toString(), 10)].name;
        }
      }
      return ngAr;
    };
    ComponentBase2.prototype.ngAfterViewInit = function(isTempRef) {
      var tempAfterViewThis = isTempRef || this;
      var regExp = /ejs-tab|ejs-accordion/g;
      if (regExp.test(tempAfterViewThis.ngEle.nativeElement.outerHTML)) {
        tempAfterViewThis.ngEle.nativeElement.style.visibility = "hidden";
      }
      var templateProperties = Object.keys(tempAfterViewThis);
      templateProperties = templateProperties.filter(function(val) {
        return /Ref$/i.test(val);
      });
      var ngtempRef = tempAfterViewThis.getModuleName() === "DocumentEditor";
      for (var _i = 0, templateProperties_1 = templateProperties; _i < templateProperties_1.length; _i++) {
        var tempName = templateProperties_1[_i];
        var propName = tempName.replace("Ref", "");
        setValue(propName.replace("_", "."), getValue(propName + "Ref", tempAfterViewThis), tempAfterViewThis);
      }
      var appendToComponent = function(tempAfterViewThis2) {
        if (typeof window !== "undefined" && tempAfterViewThis2.element || tempAfterViewThis2.getModuleName().includes("btn")) {
          tempAfterViewThis2.appendTo(tempAfterViewThis2.element);
          tempAfterViewThis2.ngEle.nativeElement.style.visibility = "";
        }
      };
      if (!ngtempRef) {
        setTimeout(function() {
          appendToComponent(tempAfterViewThis);
        });
      } else {
        appendToComponent(tempAfterViewThis);
      }
    };
    ComponentBase2.prototype.ngOnDestroy = function(isTempRef) {
      var tempOnDestroyThis = isTempRef || this;
      setTimeout(function() {
        if (typeof window !== "undefined" && tempOnDestroyThis.element.classList.contains("e-control")) {
          if (tempOnDestroyThis.ngOnFocus !== void 0 && tempOnDestroyThis.ngOnBlur !== void 0) {
            var ele = tempOnDestroyThis.inputElement || tempOnDestroyThis.element;
            ele.removeEventListener("focus", tempOnDestroyThis.ngOnFocusBound);
            ele.removeEventListener("blur", tempOnDestroyThis.ngOnBlurBound);
            tempOnDestroyThis.ngOnFocusBound = null;
            tempOnDestroyThis.ngOnBlurBound = null;
          }
          tempOnDestroyThis.destroy();
          tempOnDestroyThis.clearTemplate(null);
          setTimeout(function() {
            for (var _i = 0, _a = Object.keys(tempOnDestroyThis); _i < _a.length; _i++) {
              var key = _a[_i];
              var value = tempOnDestroyThis["".concat(key)];
              if (value && /object/.test(typeof value) && Object.keys(value).length !== 0) {
                if (/properties|changedProperties|childChangedProperties|oldProperties|moduleLoader/.test(key)) {
                  for (var _b = 0, _c = Object.keys(tempOnDestroyThis["".concat(key)]); _b < _c.length; _b++) {
                    var propKey = _c[_b];
                    var propValue = value["".concat(propKey)];
                    if (propValue && /object/.test(typeof propValue) && Object.keys(propValue).length !== 0 && (propValue.parent || propValue.parentObj)) {
                      tempOnDestroyThis["".concat(key)]["".concat(propKey)] = null;
                    }
                  }
                } else {
                  if (value.parent || value.parentObj) {
                    tempOnDestroyThis["".concat(key)] = null;
                  }
                }
              }
            }
          });
        }
      });
    };
    ComponentBase2.prototype.clearTemplate = function(templateNames, index) {
      clearTemplate(this, templateNames, index);
    };
    ComponentBase2.prototype.ngAfterContentChecked = function(isTempRef) {
      var tempAfterContentThis = isTempRef || this;
      for (var _i = 0, _a = tempAfterContentThis.tagObjects; _i < _a.length; _i++) {
        var tagObject = _a[_i];
        if (!isUndefined(tagObject.instance) && (tagObject.instance.isInitChanges || tagObject.instance.hasChanges || tagObject.instance.hasNewChildren)) {
          var propObj = {};
          if (tagObject.instance.isInitChanges) {
            var complexDirProps = void 0;
            var list = getValue("instance.list", tagObject);
            if (list && list.length) {
              complexDirProps = list[0].directivePropList;
            }
            var skip = true;
            if (tempAfterContentThis.getModuleName && tempAfterContentThis.getModuleName() === "gantt") {
              skip = false;
            }
            if (complexDirProps && skip && complexDirProps.indexOf(tagObject.instance.propertyName) === -1) {
              var compDirPropList = Object.keys(tagObject.instance.list[0].propCollection);
              for (var h = 0; h < tagObject.instance.list.length; h++) {
                tagObject.instance.list["".concat(h)].propCollection[tagObject.instance.propertyName] = [];
                var obj = {};
                for (var k = 0; k < compDirPropList.length; k++) {
                  var complexPropName = compDirPropList[parseInt(k.toString(), 10)];
                  obj["".concat(complexPropName)] = tagObject.instance.list["".concat(h)].propCollection["".concat(complexPropName)];
                }
                var _loop_1 = function(i2) {
                  var tag = tagObject.instance.list["".concat(h)].tags[parseInt(i2.toString(), 10)];
                  var childObj = getValue("child" + tag.substring(0, 1).toUpperCase() + tag.substring(1), tagObject.instance.list["".concat(h)]);
                  if (childObj) {
                    var innerchildObj = tagObject.instance.list["".concat(h)]["child" + tag.substring(0, 1).toUpperCase() + tag.substring(1)];
                    var updateChildTag_1 = function(innerchild) {
                      var innerLevelTag = [];
                      if (innerchild) {
                        for (var j = 0; j < innerchild.list.length; j++) {
                          var innerTag = innerchild.list[0].tags[0];
                          if (innerTag) {
                            var innerchildTag = getValue("child" + innerTag.substring(0, 1).toUpperCase() + innerTag.substring(1), innerchild.list[parseInt(j.toString(), 10)]);
                            if (innerchildTag) {
                              innerchild.list[parseInt(j.toString(), 10)].tagObjects.push({ instance: innerchildTag, name: innerTag });
                              innerLevelTag.push(innerchildTag);
                            }
                          }
                        }
                      }
                      if (innerLevelTag.length !== 0) {
                        for (var l = 0; l < innerLevelTag.length; l++) {
                          updateChildTag_1(innerLevelTag[parseInt(l.toString(), 10)]);
                        }
                      }
                    };
                    updateChildTag_1(innerchildObj);
                    tagObject.instance.list["".concat(h)].tagObjects.push({ instance: childObj, name: tag });
                  }
                };
                for (var i = 0; i < tagObject.instance.list["".concat(h)].tags.length; i++) {
                  _loop_1(i);
                }
                tagObject.instance.list["".concat(h)].propCollection[tagObject.instance.propertyName].push(obj);
              }
            }
            propObj[tagObject.name] = tagObject.instance.getProperties();
            tempAfterContentThis.setProperties(propObj, tagObject.instance.isInitChanges);
          } else {
            var hasDiffLength = false;
            if (tempAfterContentThis[tagObject.name].length !== tagObject.instance.list.length || /diagram|DashboardLayout/.test(tempAfterContentThis.getModuleName())) {
              tempAfterContentThis[tagObject.name] = tagObject.instance.list;
              hasDiffLength = true;
            }
            for (var _b = 0, _c = tagObject.instance.list; _b < _c.length; _b++) {
              var list = _c[_b];
              var curIndex = tagObject.instance.list.indexOf(list);
              var curChild = getValue(tagObject.name, tempAfterContentThis)["".concat(curIndex)];
              var complexTemplates = Object.keys(curChild);
              complexTemplates = complexTemplates.filter(function(val) {
                return /Ref$/i.test(val);
              });
              if (curChild.properties && Object.keys(curChild.properties).length !== 0) {
                for (var _d = 0, complexTemplates_2 = complexTemplates; _d < complexTemplates_2.length; _d++) {
                  var complexPropName = complexTemplates_2[_d];
                  complexPropName = complexPropName.replace(/Ref/, "");
                  curChild.properties["".concat(complexPropName)] = !curChild.properties["".concat(complexPropName)] ? curChild.propCollection["".concat(complexPropName)] : curChild.properties["".concat(complexPropName)];
                }
              }
              if (!isUndefined(curChild) && !isUndefined(curChild.setProperties)) {
                if (/diagram|DashboardLayout/.test(tempAfterContentThis.getModuleName())) {
                  curChild.setProperties(list.getProperties(), true);
                } else {
                  curChild.setProperties(list.getProperties());
                }
              }
              list.isUpdated = true;
            }
            if (/grid/.test(tempAfterContentThis.getModuleName()) && hasDiffLength || tempAfterContentThis.getModuleName() === "chart") {
              propObj[tagObject.name] = tagObject.instance.getProperties();
              tempAfterContentThis.setProperties(propObj, tagObject.instance.isInitChanges);
            }
          }
        }
      }
    };
    ComponentBase2.prototype.registerEvents = function(eventList) {
      registerEvents(eventList, this);
    };
    ComponentBase2.prototype.twoWaySetter = function(newVal, prop) {
      var oldVal = getValue(prop, this.properties);
      if (oldVal === newVal) {
        return;
      }
      this.saveChanges(prop, newVal, oldVal);
      setValue(prop, isNullOrUndefined(newVal) ? null : newVal, this.properties);
      getValue(prop + "Change", this).emit(newVal);
    };
    ComponentBase2.prototype.addTwoWay = function(propList) {
      var _this = this;
      var _loop_2 = function(prop2) {
        getValue(prop2, this_1);
        Object.defineProperty(this_1, prop2, {
          get: function() {
            return getValue(prop2, _this.properties);
          },
          set: function(newVal) {
            return _this.twoWaySetter(newVal, prop2);
          }
        });
        setValue(prop2 + "Change", new EventEmitter(), this_1);
      };
      var this_1 = this;
      for (var _i = 0, propList_1 = propList; _i < propList_1.length; _i++) {
        var prop = propList_1[_i];
        _loop_2(prop);
      }
    };
    ComponentBase2.prototype.addEventListener = function(eventName, handler) {
      var eventObj = getValue(eventName, this);
      if (!isUndefined(eventObj)) {
        if (!this.ngBoundedEvents["".concat(eventName)]) {
          this.ngBoundedEvents["".concat(eventName)] = /* @__PURE__ */ new Map();
        }
        this.ngBoundedEvents["".concat(eventName)].set(handler, eventObj.subscribe(handler));
      }
    };
    ComponentBase2.prototype.removeEventListener = function(eventName, handler) {
      var eventObj = getValue(eventName, this);
      if (!isUndefined(eventObj)) {
        this.ngBoundedEvents["".concat(eventName)].get(handler).unsubscribe();
      }
    };
    ComponentBase2.prototype.trigger = function(eventName, eventArgs, success) {
      var eventObj = getValue(eventName, this);
      var prevDetection = this.isProtectedOnChange;
      this.isProtectedOnChange = false;
      if (eventArgs) {
        eventArgs.name = eventName;
      }
      if (!isUndefined(eventObj)) {
        eventObj.next(eventArgs);
      }
      var localEventObj = getValue("local" + eventName.charAt(0).toUpperCase() + eventName.slice(1), this);
      if (!isUndefined(localEventObj)) {
        localEventObj.call(this, eventArgs);
      }
      this.isProtectedOnChange = prevDetection;
      if (success) {
        this.preventChange = this.isPreventChange;
        success.call(this, eventArgs);
      }
      this.isPreventChange = false;
    };
    return ComponentBase2;
  }()
);

// node_modules/@syncfusion/ej2-angular-base/src/form-base.js
var FormBase = (
  /** @class */
  function() {
    function FormBase2() {
    }
    FormBase2.prototype.propagateChange = function(_) {
      return;
    };
    FormBase2.prototype.propagateTouch = function() {
      return;
    };
    FormBase2.prototype.localChange = function(e) {
      var value = e.checked === void 0 ? e.value : e.checked;
      this.objCheck = isObject(value);
      if (this.isUpdated === true) {
        this.angularValue = this.oldValue;
      }
      if (this.objCheck === true) {
        this.duplicateValue = JSON.stringify(value);
        this.duplicateAngularValue = JSON.stringify(this.angularValue);
        if (this.duplicateValue !== this.duplicateAngularValue && this.propagateChange !== void 0 && value !== void 0) {
          this.propagateChange(value);
          this.angularValue = value;
        }
      } else {
        if (value !== this.angularValue && this.propagateChange !== void 0 && value !== void 0) {
          if (value !== "" && value !== null) {
            this.propagateChange(value);
            this.angularValue = value;
          } else {
            var optionalValue = value;
            this.propagateChange(optionalValue);
            this.angularValue = value;
          }
        }
      }
      this.cdr.markForCheck();
    };
    FormBase2.prototype.registerOnChange = function(registerFunction) {
      this.propagateChange = registerFunction;
    };
    FormBase2.prototype.registerOnTouched = function(registerFunction) {
      this.propagateTouch = registerFunction;
    };
    FormBase2.prototype.twoWaySetter = function(newVal, prop) {
      var oldVal = this.oldValue || getValue(prop, this.properties);
      var ele = this.inputElement || this.element;
      if (ele && oldVal === newVal && this.value === newVal && (ele.value === void 0 || ele.value === "")) {
        return;
      }
      this.saveChanges(prop, newVal, oldVal);
      setValue(prop, isNullOrUndefined(newVal) ? null : newVal, this.properties);
      getValue(prop + "Change", this).emit(newVal);
    };
    FormBase2.prototype.ngAfterViewInit = function(isTempRef) {
      var tempFormAfterViewThis = isTempRef || this;
      tempFormAfterViewThis.ngOnBlurBound = this.ngOnBlur.bind(this);
      tempFormAfterViewThis.ngOnFocusBound = this.ngOnFocus.bind(this);
      if (typeof window !== "undefined") {
        if (tempFormAfterViewThis.getModuleName().includes("dropdowntree")) {
          setTimeout(function() {
            tempFormAfterViewThis.appendTo(tempFormAfterViewThis.element);
          });
        } else {
          tempFormAfterViewThis.appendTo(tempFormAfterViewThis.element);
        }
        var ele = tempFormAfterViewThis.inputElement || tempFormAfterViewThis.element;
        ele.addEventListener("focus", tempFormAfterViewThis.ngOnFocusBound);
        ele.addEventListener("blur", tempFormAfterViewThis.ngOnBlurBound);
      }
      this.isFormInit = false;
    };
    FormBase2.prototype.setDisabledState = function(disabled) {
      this.enabled = !disabled;
      this.disabled = disabled;
    };
    FormBase2.prototype.writeValue = function(value) {
      var regExp = /ejs-radiobutton/g;
      if (this.checked === void 0) {
        this.value = value;
      } else {
        if (this.ngEle) {
          if (typeof value === "boolean") {
            if (regExp.test(this.ngEle.nativeElement.outerHTML)) {
              this.checked = value === this.value;
            } else {
              this.checked = value;
            }
          } else {
            this.checked = value === this.value;
          }
        }
      }
      this.angularValue = value;
      this.isUpdated = true;
      this.preventChange = this.isFormInit ? false : true;
      this.cdr.markForCheck();
      if (value === null) {
        return;
      }
    };
    FormBase2.prototype.ngOnFocus = function(e) {
      if (this.skipFromEvent !== true) {
        this.focus.emit(e);
      }
      this.cdr.markForCheck();
    };
    FormBase2.prototype.ngOnBlur = function(e) {
      this.propagateTouch();
      if (this.skipFromEvent !== true) {
        this.blur.emit(e);
      }
      this.cdr.markForCheck();
    };
    FormBase2.isFormBase = true;
    return FormBase2;
  }()
);

// node_modules/@syncfusion/ej2-angular-base/src/template.js
var stringCompiler = getTemplateEngine();
function compile2(templateEle, helper) {
  if (typeof templateEle === "string" || typeof templateEle === "function" && templateEle.prototype && templateEle.prototype.CSPTemplate) {
    return stringCompiler(templateEle, helper);
  } else {
    var contRef_1 = templateEle.elementRef.nativeElement._viewContainerRef;
    var pName_1 = templateEle.elementRef.nativeElement.propName;
    return function(data, component, propName) {
      var context = { $implicit: data };
      var conRef = contRef_1 ? contRef_1 : component.viewContainerRef;
      var viewRef = conRef.createEmbeddedView(templateEle, context);
      if (/EJS-MENTION|EJS-DROPDOWNLIST/.test(getValue("currentInstance.element.nodeName", conRef)) || /E-TABITEM/.test(getValue("element.nativeElement.nodeName", conRef))) {
        viewRef.detectChanges();
      } else {
        viewRef.markForCheck();
      }
      var viewCollection = component && component.registeredTemplate ? component.registeredTemplate : getValue("currentInstance.registeredTemplate", conRef);
      propName = propName && component.registeredTemplate ? propName : pName_1;
      if (typeof viewCollection["".concat(propName)] === "undefined") {
        viewCollection["".concat(propName)] = [];
      }
      viewCollection["".concat(propName)].push(viewRef);
      return viewRef.rootNodes;
    };
  }
}
function Template(defaultValue) {
  return function(target, key) {
    var propertyDescriptor = {
      set: setter(key),
      get: getter(key, defaultValue),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
  };
}
function setter(key) {
  return function(val) {
    if (val === void 0) {
      return;
    }
    setValue(key + "Ref", val, this);
    if (typeof val !== "string") {
      val.elementRef.nativeElement._viewContainerRef = this.viewContainerRef;
      val.elementRef.nativeElement.propName = key;
    } else {
      if (this.saveChanges) {
        this.saveChanges(key, val, void 0);
        this.dataBind();
      }
    }
  };
}
function getter(key, defaultValue) {
  return function() {
    return getValue(key + "Ref", this) || defaultValue;
  };
}
setTemplateEngine({ compile: compile2 });

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/crop.js
var Crop = (
  /** @class */
  function() {
    function Crop2(parent) {
      this.croppedDegree = 0;
      this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
      this.tempFlipPanPoint = { x: 0, y: 0 };
      this.isPreventScaling = false;
      this.isInitCrop = false;
      this.isTransformCrop = false;
      this.parent = parent;
      this.addEventListener();
    }
    Crop2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Crop2.prototype.addEventListener = function() {
      this.parent.on("crop", this.cropping, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Crop2.prototype.removeEventListener = function() {
      this.parent.off("crop", this.cropping);
      this.parent.off("destroyed", this.destroy);
    };
    Crop2.prototype.cropping = function(args) {
      this.updateCropPvtVar();
      switch (args.prop) {
        case "cropCircle":
          this.cropCircle(args.value["context"], args.value["isSave"], args.value["isFlip"]);
          break;
        case "setCurrSelPoints":
          this.setCurrSelPoints(args.value["isSetDimension"]);
          break;
        case "updateRotatePan":
          this.updateRotatePan();
          break;
        case "crop":
          this.crop(args.value["obj"]);
          break;
        case "calcRatio":
          this.calcRatio(args.value["obj"], args.value["dimension"]);
          break;
        case "isObjInImage":
          this.isObjInImage(args.value["obj"], args.value["object"]);
          break;
        case "getCurrFlipState":
          this.getCurrFlipState(args.value["panObj"]);
          break;
        case "getPreviousCropCurrentObj":
          args.value["obj"]["prevObj"] = this.prevCropCurrObj;
          break;
        case "setPreviousCropCurrentObj":
          this.prevCropCurrObj = args.value["obj"];
          break;
        case "setCropDestPoints":
          this.cropDestPoints = args.value["point"];
          break;
        case "getTempFlipPanPoint":
          args.value["obj"]["point"] = this.tempFlipPanPoint;
          break;
        case "setTempFlipPanPoint":
          if (isNullOrUndefined(args.value["isAdd"])) {
            this.tempFlipPanPoint = args.value["point"];
          } else {
            this.tempFlipPanPoint.x += args.value["point"].x;
            this.tempFlipPanPoint.y += args.value["point"].y;
          }
          break;
        case "getPreventScaling":
          args.value["obj"]["bool"] = this.isPreventScaling;
          break;
        case "adjustStraightenForShapes":
          this.adjustStraightenForShapes(args.value["type"], args.value["isInitialRotated"]);
          break;
        case "resizeWrapper":
          this.resizeWrapper();
          break;
        case "setTransformCrop":
          this.isTransformCrop = args.value["bool"];
          break;
        case "setInitCrop":
          this.isInitCrop = args.value["bool"];
          break;
        case "reset":
          this.reset();
          break;
      }
    };
    Crop2.prototype.getModuleName = function() {
      return "crop";
    };
    Crop2.prototype.updateCropPvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    Crop2.prototype.reset = function() {
      this.prevCropCurrObj = null;
      this.croppedDegree = 0;
      this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
      this.tempFlipPanPoint = { x: 0, y: 0 };
      this.isPreventScaling = false;
      this.isInitCrop = false;
      this.isTransformCrop = false;
    };
    Crop2.prototype.cropImg = function(isRotateCrop) {
      var parent = this.parent;
      var isNullCrop = isNullOrUndefined(isRotateCrop);
      var resizeIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
      var actPoint = parent.activeObj.activePoint;
      var img = parent.img;
      var isRotated = false;
      for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
        var currentValue = parent.rotateFlipColl[i];
        if (currentValue === 90 || currentValue === -90) {
          isRotated = true;
        }
      }
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      if (isNullCrop || resizeIcon) {
        this.croppedDegree = parent.transform.degree;
      }
      if (isNullCrop && parent.transform.degree !== 0 || isRotated) {
        this.updateCropObj();
        var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
        this.rotateCrop();
      } else if (isNullCrop && parent.transform.currFlipState !== "") {
        this.updateCropObj();
        var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
        this.flipCrop();
      } else {
        this.adjustStraightenForShapes("initial", false);
        parent.notify("draw", { prop: "setTempZoomFactor", onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
        var ratio = this.calcRatio();
        if (isNullCrop || !isRotateCrop) {
          this.updateCropObj();
          parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
          parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
          parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
          this.cropDestPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        }
        var obj = { width: 0, height: 0 };
        parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: {
          width: actPoint.width * ratio.width,
          height: actPoint.height * ratio.height,
          obj,
          isImgShape: null
        } });
        var maxDimension = obj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.img = {
          srcLeft: actPoint.startX * ratio.width - img.destLeft * ratio.width,
          srcTop: actPoint.startY * ratio.height - img.destTop * ratio.height,
          srcWidth: actPoint.width * ratio.width,
          srcHeight: actPoint.height * ratio.height,
          destLeft: (parent.lowerCanvas.clientWidth - maxDimension.width) / 2,
          destTop: (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2,
          destWidth: maxDimension.width,
          destHeight: maxDimension.height
        };
        var temp = this.lowerContext.filter;
        parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
        this.lowerContext.filter = "none";
        var activeObj = extend({}, parent.activeObj, {}, true);
        this.cropObjColl();
        parent.transform.straighten = 0;
        parent.activeObj = activeObj;
        this.cropFreehandDrawColl();
        parent.shapeColl = [];
        parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          this.cropCircle(this.lowerContext);
        } else {
          parent.isCircleCrop = false;
        }
        this.lowerContext.filter = temp;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.currObjType.isCustomCrop = false;
        parent.pan(false);
        parent.transform.defaultZoomFactor = 0;
      }
    };
    Crop2.prototype.adjustStraightenForShapes = function(type, isInitialRotated) {
      var parent = this.parent;
      var center = {
        x: parent.img.destLeft + parent.img.destWidth / 2,
        y: parent.img.destTop + parent.img.destHeight / 2
      };
      for (var _i = 0, _a = parent.objColl; _i < _a.length; _i++) {
        var obj = _a[_i];
        if (["rectangle", "ellipse", "text", "image"].indexOf(obj.shape) !== -1) {
          if (isInitialRotated || obj.rotatedAngle !== 0) {
            var _b = obj.activePoint, startX = _b.startX, startY = _b.startY, width = _b.width, height = _b.height;
            var angle = type === "initial" ? obj.rotatedAngle : -obj.rotatedAngle;
            var diffX = startX + width / 2 - center.x;
            var diffY = startY + height / 2 - center.y;
            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);
            var centerX = cosAngle * diffX - sinAngle * diffY + center.x;
            var centerY = sinAngle * diffX + cosAngle * diffY + center.y;
            var diffXUpdated = centerX - startX - width / 2;
            var diffYUpdated = centerY - startY - height / 2;
            obj.activePoint.startX += diffXUpdated;
            obj.activePoint.startY += diffYUpdated;
            obj.activePoint.endX += diffXUpdated;
            obj.activePoint.endY += diffYUpdated;
          }
        }
      }
    };
    Crop2.prototype.updateCropObj = function() {
      this.parent.afterCropActions = [];
      var object = { currObj: {} };
      this.parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var obj = object["currObj"];
      obj.straighten = this.parent.transform.straighten;
      this.parent.cropObj = extend({}, obj, {}, true);
    };
    Crop2.prototype.rotateCrop = function() {
      var parent = this.parent;
      var flipState = this.getCurrFlipState();
      var shape = parent.activeObj.shape || "";
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
      parent.objColl.push(parent.activeObj);
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var tempCurrSelObj = extend({}, parent.currSelectionPoint, {}, true);
      var preventSelObj = { bool: null };
      parent.notify("transform", { prop: "getPreventSelect", onPropertyChange: false, value: { obj: preventSelObj } });
      parent.notify("transform", { prop: "setPreventSelect", onPropertyChange: false, value: { bool: true } });
      var coll = extend([], parent.rotateFlipColl, [], true);
      this.panToSelRangle(true);
      activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
      parent.objColl.pop();
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.objColl.push(parent.activeObj);
      var straighten = parent.transform.straighten;
      if (straighten !== 0) {
        parent.transform.straighten = 0;
        parent.straightenBaseImageCanvas();
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      }
      this.resetZoom();
      var afterCropActions = extend([], parent.afterCropActions, [], true);
      this.revertTransform("initial", coll);
      if (straighten !== 0) {
        parent.transform.straighten = flipState === "horizontal" || flipState === "vertical" ? -straighten : straighten;
        parent.straightenBaseImageCanvas();
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
      parent.objColl.pop();
      parent.transform.degree = 0;
      var object = { isIntersect: null };
      parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      var count = 0;
      while (straighten !== 0 && object["isIntersect"]) {
        count++;
        if (count === 50) {
          break;
        }
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: 0.025, zoomPoint: null },
          isResize: null
        });
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      }
      this.cropImg(true);
      this.revertTransform("reverse", coll);
      parent.afterCropActions = afterCropActions;
      parent.currSelectionPoint = tempCurrSelObj;
      parent.notify("transform", { prop: "setPreventSelect", onPropertyChange: false, value: { bool: preventSelObj["bool"] } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      if (shape === "crop-circle") {
        this.cropCircle(this.lowerContext);
      }
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
    };
    Crop2.prototype.revertTransform = function(type, coll) {
      var parent = this.parent;
      var obj = { isRotate: false };
      if (type === "initial") {
        for (var i = coll.length - 1; i >= 0; i--) {
          var value = coll[i];
          switch (value) {
            case 90:
              parent.notify("transform", { prop: "rotate", value: { degree: -90, obj } });
              break;
            case -90:
              parent.notify("transform", { prop: "rotate", value: { degree: 90, obj } });
              break;
            default:
              parent.notify("transform", { prop: "flipImage", value: { direction: parent.toPascalCase(value.toString()) } });
              break;
          }
        }
      } else {
        this.updateFlipState();
        for (var i = 0, len = coll.length; i < len; i++) {
          var value = coll[i];
          switch (value) {
            case 90:
              parent.notify("transform", { prop: "rotate", value: { degree: 90, obj } });
              break;
            case -90:
              parent.notify("transform", { prop: "rotate", value: { degree: -90, obj } });
              break;
            default:
              parent.notify("transform", { prop: "flipImage", value: { direction: parent.toPascalCase(value.toString()) } });
              break;
          }
        }
      }
    };
    Crop2.prototype.updateFlipState = function() {
      var parent = this.parent;
      var objColl = parent.objColl;
      for (var i = 0, len = objColl.length; i < len; i++) {
        objColl[i].shapeFlip = "";
      }
      var pointColl = parent.pointColl;
      for (var i = 0; i < parent.freehandCounter; i++) {
        pointColl[i].shapeFlip = "";
      }
    };
    Crop2.prototype.resetZoom = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor > 0) {
        var zoomFactor = parent.transform.zoomFactor;
        var isUndoRedo = parent.isUndoRedo;
        parent.setProperties({ zoomSettings: { zoomFactor: zoomFactor * 10 } }, true);
        parent.notify("transform", {
          prop: "setPreviousZoomValue",
          onPropertyChange: false,
          value: { previousZoomValue: parent.zoomSettings.zoomFactor }
        });
        for (var i = 0; i < zoomFactor * 10; i++) {
          parent.isUndoRedo = true;
          parent.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -0.1, zoomPoint: null },
            isResize: null
          });
        }
        parent.isUndoRedo = isUndoRedo;
        parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
      }
    };
    Crop2.prototype.flipCrop = function() {
      var parent = this.parent;
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: true } });
      parent.panPoint.totalPannedPoint.x += this.tempFlipPanPoint.x;
      parent.panPoint.totalPannedPoint.y += this.tempFlipPanPoint.y;
      var tempCurrFlipState = parent.transform.currFlipState;
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      var tempFlipColl = obj["flipColl"];
      parent.notify("transform", { prop: "setFlipColl", onPropertyChange: false, value: { flipColl: [] } });
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.objColl.push(parent.activeObj);
      if (parent.transform.degree === 0) {
        var panX = -parent.cropObj.totalPannedPoint.x;
        var panY = -parent.cropObj.totalPannedPoint.y;
        parent.img.destLeft += panX;
        parent.img.destTop += panY;
        parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        parent.objColl.pop();
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
      }
      this.resetZoom();
      parent.currSelectionPoint = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.updateFlipState();
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
      parent.notify("freehand-draw", {
        prop: "flipFHDColl",
        onPropertyChange: false,
        value: { value: this.getCurrFlipState() }
      });
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      parent.objColl.pop();
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.cropImg(true);
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: true } });
      this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      parent.transform.currFlipState = tempCurrFlipState;
      parent.notify("transform", { prop: "setFlipColl", onPropertyChange: false, value: { flipColl: tempFlipColl } });
      this.lowerContext.filter = "none";
      this.updateFlipState();
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
      parent.notify("freehand-draw", {
        prop: "flipFHDColl",
        onPropertyChange: false,
        value: { value: this.getCurrFlipState() }
      });
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = temp;
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        this.cropCircle(this.lowerContext);
      }
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: false } });
      parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
      this.tempFlipPanPoint = { x: 0, y: 0 };
    };
    Crop2.prototype.cropObjColl = function() {
      var parent = this.parent;
      var point;
      var shape;
      var obj;
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          obj = parent.objColl[i];
          point = obj.activePoint;
          var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
          shape = obj.shape;
          obj.imageRatio = {
            startX: (point.startX - startX) / width,
            startY: (point.startY - startY) / height,
            endX: (point.endX - startX) / width,
            endY: (point.endY - startY) / height,
            width: width / point.width,
            height: height / point.height
          };
          var degree = void 0;
          var size = void 0;
          switch (shape) {
            case "text":
              degree = obj.shapeDegree === 0 ? parent.transform.degree : parent.transform.degree - obj.shapeDegree;
              size = degree === 0 || Math.abs(degree) === 180 ? point.width : point.height;
              obj.textSettings.fontRatio = size / obj.textSettings.fontSize;
              break;
            case "line":
            case "arrow":
              this.cropPointCollection(i);
              if (shape === "arrow") {
                parent.notify("shape", { prop: "updateArrowRatio", onPropertyChange: false, value: { obj } });
              }
              break;
            case "path":
              this.cropPointCollection(i);
              break;
          }
        }
      }
    };
    Crop2.prototype.cropPointCollection = function(i) {
      var parent = this.parent;
      var shape = parent.objColl[i].shape;
      var x;
      var y;
      var width;
      var height;
      var point = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (shape === "path") {
        x = point.startX;
        y = point.startY;
        width = point.width;
        height = point.height;
      } else {
        x = destLeft;
        y = destTop;
        width = destWidth;
        height = destHeight;
      }
      var pointColl = parent.objColl[i].pointColl;
      for (var n = 0, len = pointColl.length; n < len; n++) {
        pointColl[n].ratioX = (pointColl[n].x - x) / width;
        pointColl[n].ratioY = (pointColl[n].y - y) / height;
      }
    };
    Crop2.prototype.cropFreehandDrawColl = function() {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          parent.points[l].ratioX = (parent.points[l].x - startX) / width;
          parent.points[l].ratioY = (parent.points[l].y - startY) / height;
        }
      }
      parent.notify("freehand-draw", { prop: "updateCropPtsForSel", onPropertyChange: false });
    };
    Crop2.prototype.resetAnnotations = function() {
      var parent = this.parent;
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
    };
    Crop2.prototype.setCurrSelPoints = function(isSetDimension) {
      var parent = this.parent;
      parent.allowDownScale = false;
      var destPoint = this.cropDestPoints;
      var filter = this.lowerContext.filter;
      var isCropTab = parent.isCropTab;
      parent.img = {
        srcLeft: 0,
        srcTop: 0,
        srcWidth: parent.baseImgCanvas.width,
        srcHeight: parent.baseImgCanvas.height,
        destLeft: destPoint.startX,
        destTop: destPoint.startY,
        destWidth: destPoint.width,
        destHeight: destPoint.height
      };
      var img = parent.img;
      var currSelPoint = parent.currSelectionPoint;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      if (isSetDimension) {
        parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      }
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      if (this.croppedDegree === 0 && parent.transform.degree === 0 && currSelPoint && currSelPoint.shape !== "crop-circle" && currSelPoint.shape !== "crop-square") {
        img.destLeft = destPoint.startX;
        img.destTop = destPoint.startY;
        img.destWidth = destPoint.width;
        img.destHeight = destPoint.height;
      }
      if (parent.transform.degree === 0) {
        img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = filter;
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, context: null, isPreventCircleCrop: true }
      });
      var cropObjColl = extend([], parent.objColl, null, true);
      var cropPointColl = extend([], parent.pointColl, null, true);
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", {
        prop: "getStraightenPoint",
        onPropertyChange: false,
        value: { obj: straightenObj }
      });
      this.resetAnnotations();
      if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
        parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
      }
      this.panToSelRangle();
      parent.isCropTab = isCropTab;
      parent.objColl = cropObjColl;
      parent.pointColl = cropPointColl;
      parent.freehandCounter = parent.pointColl.length;
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        parent.notify("freehand-draw", {
          prop: "setStraightenPoint",
          onPropertyChange: false,
          value: {
            x: straightenObj["straightenPoint"]["x"],
            y: straightenObj["straightenPoint"]["y"],
            ratioX: straightenObj["straightenPoint"]["ratioX"],
            ratioY: straightenObj["straightenPoint"]["ratioY"]
          }
        });
      }
      if (parent.cropObj.activeObj.shape) {
        var destPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        if (currSelPoint && currSelPoint.activePoint) {
          var _a = currSelPoint.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
          img.destLeft = startX;
          img.destTop = startY;
          img.destWidth = width;
          img.destHeight = height;
        }
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        img.destLeft = destPoints.startX;
        img.destTop = destPoints.startY;
        img.destWidth = destPoints.width;
        img.destHeight = destPoints.height;
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        cropObjColl = extend([], parent.objColl, null, true);
        cropPointColl = extend([], parent.pointColl, null, true);
        parent.notify("freehand-draw", { prop: "getStraightenPoint", onPropertyChange: false, value: { obj: straightenObj } });
        this.resetAnnotations();
        var object = { selPointColl: null };
        parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: object } });
        var cropSelPointColl = object["selPointColl"];
        parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: [] } } });
        parent.cropObj.filter = this.lowerContext.filter;
        var actObj = extend({}, parent.currSelectionPoint, null, true);
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: null } });
        parent.activeObj = extend({}, actObj, null, true);
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.currSelectionPoint = null;
        parent.isCircleCrop = false;
        if (parent.transform.degree !== 0) {
          if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
            parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
          }
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
        parent.objColl = cropObjColl;
        parent.pointColl = cropPointColl;
        parent.freehandCounter = parent.pointColl.length;
        if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
          parent.notify("freehand-draw", {
            prop: "setStraightenPoint",
            onPropertyChange: false,
            value: {
              x: straightenObj["straightenPoint"]["x"],
              y: straightenObj["straightenPoint"]["y"],
              ratioX: straightenObj["straightenPoint"]["ratioX"],
              ratioY: straightenObj["straightenPoint"]["ratioY"]
            }
          });
        }
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: cropSelPointColl } }
        });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.adjustStraightenForShapes("reverse", false);
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply: true } });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        if (parent.transform.degree === 0) {
          parent.notify("transform", {
            prop: "drawPannImage",
            onPropertyChange: false,
            value: { point: { x: 0, y: 0 } }
          });
        } else {
          if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
            parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
          }
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
        parent.activeObj = activeObj;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
        parent.notify("transform", {
          prop: "setTempPanMove",
          onPropertyChange: false,
          value: { point: null }
        });
        if (!this.isInitCrop && parent.transform.degree === 0 && parent.cropObj.currFlipState !== "" && parent.cropObj.cropZoom !== 0) {
          this.isInitCrop = true;
          var obj = { activeObj: null };
          parent.notify("draw", { prop: "getStraightenActObj", onPropertyChange: false, value: { obj } });
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
          parent.notify("draw", { prop: "setStraightenActObj", onPropertyChange: false, value: { activeObj: obj["activeObj"] } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "croptransform",
            isApplyBtn: false,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          this.isInitCrop = false;
        }
      } else {
        this.adjustStraightenForShapes("reverse", true);
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply: true } });
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.lowerContext.filter = temp;
        parent.currSelectionPoint = null;
      }
      if (document.querySelector(".e-ie-straighten-value-span")) {
        document.querySelector(".e-ie-straighten-value-span").innerHTML = parent.transform.straighten.toString() + "&#176";
      }
    };
    Crop2.prototype.panToSelRangle = function(isReverse) {
      var parent = this.parent;
      var pannedPoint = parent.cropObj.totalPannedClientPoint;
      var panX = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.x : pannedPoint.x : 0;
      var panY = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.y : pannedPoint.y : 0;
      if (parent.transform.degree !== 0) {
        parent.panPoint.currentPannedPoint = { x: panX, y: panY };
        parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
        parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
      }
    };
    Crop2.prototype.cropCircle = function(context, isSave, isFlip) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (isFlip && parent.transform.currFlipState !== "") {
        parent.notify("draw", {
          prop: "setTransform",
          onPropertyChange: false,
          value: { context, value: parent.transform.currFlipState, isReverse: null }
        });
      }
      var temp = context.filter;
      context.filter = "none";
      context.globalCompositeOperation = "destination-in";
      context.beginPath();
      var centerX = isNullOrUndefined(isSave) ? destLeft + destWidth / 2 : context.canvas.width / 2;
      var centerY = isNullOrUndefined(isSave) ? destTop + destHeight / 2 : context.canvas.height / 2;
      var radius = isSave ? context.canvas.width / 2 : destWidth / 2;
      context.arc(centerX, centerY, radius, 0, Math.PI * 2);
      context.closePath();
      context.fill();
      context.restore();
      context.globalCompositeOperation = "source-over";
      parent.currObjType.isActiveObj = parent.isCircleCrop = true;
      context.filter = temp;
      if (isFlip && parent.transform.currFlipState !== "") {
        parent.notify("draw", {
          prop: "setTransform",
          onPropertyChange: false,
          value: { context, value: parent.transform.currFlipState, isReverse: null }
        });
      }
    };
    Crop2.prototype.getCurrCropState = function() {
      var parent = this.parent;
      var flipState = "";
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      flipState = this.getCurrFlipState();
      if (parent.transform.degree === -90 || parent.transform.degree === -270) {
        if (flipState === "horizontal") {
          flipState = "vertical";
        } else if (flipState === "vertical") {
          flipState = "horizontal";
        }
      }
      if (flipState === "") {
        flipState = obj["flipColl"].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
      }
      return flipState;
    };
    Crop2.prototype.updateRotatePan = function() {
      var parent = this.parent;
      if (isNullOrUndefined(parent.panPoint.currentPannedPoint)) {
        return;
      }
      var panRegion = "";
      var degree = parent.transform.degree;
      var _a = parent.panPoint.currentPannedPoint, x = _a.x, y = _a.y;
      if (parent.rotateFlipColl.length > 0 && typeof parent.rotateFlipColl[0] === "number" && degree < 0) {
        panRegion = this.getCurrCropState();
      } else {
        panRegion = this.getCurrFlipState();
      }
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (degree === 90 || degree === -90 && (panRegion === "horizontal" || panRegion === "vertical") || degree === -270 && (panRegion === "" || panRegion === "verticalHorizontal" || panRegion === "horizontalVertical")) {
          if (panRegion === "horizontal" || panRegion === "") {
            parent.img.destLeft += y;
          } else {
            parent.img.destLeft -= y;
          }
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destTop -= x;
          } else {
            parent.img.destTop += x;
          }
        } else if (degree === 270 || degree === -270 && (panRegion === "horizontal" || panRegion === "vertical") || degree === -90 && (panRegion === "" || panRegion === "verticalHorizontal" || panRegion === "horizontalVertical")) {
          if (panRegion === "" || panRegion === "horizontal") {
            parent.img.destLeft -= y;
          } else {
            parent.img.destLeft += y;
          }
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destTop += x;
          } else {
            parent.img.destTop -= x;
          }
        }
      } else {
        if (degree === 180 || degree === -180) {
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destLeft -= x;
          } else {
            parent.img.destLeft += x;
          }
          if (panRegion === "" || panRegion === "horizontal") {
            parent.img.destTop -= y;
          } else {
            parent.img.destTop += y;
          }
        }
      }
    };
    Crop2.prototype.crop = function(obj) {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (!parent.disabled && parent.isImageLoaded) {
        var object = { isCropToolbar: parent.isCropToolbar };
        if (parent.currObjType.isUndoAction && !object["isCropToolbar"]) {
          parent.notify("undo-redo", { prop: "refreshUrc", value: { bool: null } });
        }
        var transitionArgs = {
          cancel: false,
          startPoint: { x: startX, y: startY },
          endPoint: { x: endX, y: endY },
          preventScaling: false
        };
        if (!object["isCropToolbar"]) {
          parent.trigger("cropping", transitionArgs);
        }
        this.cropEvent(transitionArgs, obj, object);
      }
    };
    Crop2.prototype.cropEvent = function(transitionArgs, obj, object) {
      var parent = this.parent;
      var splitWords;
      if (!transitionArgs.cancel) {
        splitWords = parent.activeObj.shape ? parent.activeObj.shape.split("-") : [];
        if (!parent.disabled && parent.activeObj.horTopLine && (parent.currObjType.isCustomCrop || splitWords.length > 0 && splitWords[0] === "crop")) {
          obj.isCrop = true;
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var prevObj = extend({}, this.prevCropCurrObj, {}, true);
          if (transitionArgs.preventScaling) {
            this.isPreventScaling = true;
          } else {
            this.isPreventScaling = false;
          }
          this.cropImg();
          if (this.isPreventScaling) {
            parent.aspectWidth = parent.img.destWidth;
            parent.aspectHeight = parent.img.destHeight;
          }
          parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
          parent.isCropTab = false;
          parent.transform.zoomFactor = 0;
          parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
          parent.notify("transform", {
            prop: "setPreviousZoomValue",
            onPropertyChange: false,
            value: { previousZoomValue: parent.zoomSettings.zoomFactor }
          });
          if (!Browser.isDevice) {
            this.updateUndoRedoColl(prevObj, prevCropObj, object);
          }
          parent.notify("transform", {
            prop: "setCropDimension",
            onPropertyChange: false,
            value: { width: parent.cropObj.destPoints.width, height: parent.cropObj.destPoints.height }
          });
          var aspectIcon = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
          var nonAspectIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
          if (!object["isCropToolbar"] && (isNullOrUndefined(aspectIcon) && isNullOrUndefined(nonAspectIcon))) {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "main",
              isApplyBtn: false,
              isCropping: false,
              isZooming: null,
              cType: null
            } });
          }
          this.resizeWrapper();
          if (Browser.isDevice) {
            this.updateUndoRedoColl(prevObj, prevCropObj, object);
          }
        }
      }
    };
    Crop2.prototype.updateUndoRedoColl = function(prevObj, prevCropObj, object) {
      var parent = this.parent;
      var currSelPtObj = { prevCurrSelectionPoint: parent.prevCurrSelectionPoint };
      prevObj.currSelectionPoint = extend({}, currSelPtObj["prevCurrSelectionPoint"], {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "crop",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: parent.isCircleCrop
        }
      });
      if (!object["isCropToolbar"]) {
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    Crop2.prototype.resizeWrapper = function() {
      var parent = this.parent;
      if (Browser.isDevice) {
        var elem = parent.element;
        var ctxToolbar = elem.querySelector("#" + elem.id + "_contextualToolbarArea");
        if (ctxToolbar && ctxToolbar.style.position === "" && !this.isTransformCrop) {
          ctxToolbar.style.position = "absolute";
          parent.isStraightening = false;
          parent.update();
          parent.notify("filter", { prop: "setAdjustmentValue", value: { adjustmentValue: parent.canvasFilter } });
        }
      }
    };
    Crop2.prototype.calcRatio = function(obj, dimension) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var _b = dimension || parent.baseImgCanvas, width = _b.width, height = _b.height;
      var widthRatio = degree === 0 || degree % 180 === 0 ? width / destWidth : height / destWidth;
      var heightRatio = degree === 0 || degree % 180 === 0 ? height / destHeight : width / destHeight;
      if (obj) {
        obj["width"] = widthRatio;
        obj["height"] = heightRatio;
      }
      return { width: widthRatio, height: heightRatio };
    };
    Crop2.prototype.isObjInImage = function(obj, dummyObj) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var _b = obj.activePoint, startX = _b.startX, endX = _b.endX, startY = _b.startY, endY = _b.endY;
      var isInside = startX >= destLeft && endX <= destLeft + destWidth || startX <= destLeft && endX >= destLeft || startX <= destLeft + destWidth && endX >= destLeft + destWidth || startY >= destTop && endY <= destTop + destHeight || startY <= destTop && endY >= destTop || startY <= destTop + destHeight && endY >= destTop + destHeight;
      if (dummyObj) {
        dummyObj["isInside"] = isInside;
      }
      return isInside;
    };
    Crop2.prototype.getCurrFlipState = function(panObj) {
      var parent = this.parent;
      var obj = { panRegion: "" };
      var object = { collection: parent.rotateFlipColl };
      parent.notify("shape", {
        prop: "alignRotateFlipColl",
        onPropertyChange: false,
        value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: object }
      });
      parent.rotateFlipColl = object["collection"];
      for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
        parent.notify("transform", {
          prop: "setCurrPanRegion",
          onPropertyChange: false,
          value: { region: obj["panRegion"], type: parent.rotateFlipColl[i], obj }
        });
      }
      if (panObj) {
        panObj["panRegion"] = obj["panRegion"];
      }
      return obj["panRegion"];
    };
    return Crop2;
  }()
);

// node_modules/@syncfusion/ej2-popups/src/common/position.js
var elementRect;
var popupRect;
var element;
var parentDocument;
var fixedParent = false;
function calculateRelativeBasedPosition(anchor, element2) {
  var fixedElement = false;
  var anchorPos = { left: 0, top: 0 };
  var tempAnchor = anchor;
  if (!anchor || !element2) {
    return anchorPos;
  }
  if (isNullOrUndefined(element2.offsetParent) && element2.style.position === "fixed") {
    fixedElement = true;
  }
  while ((element2.offsetParent || fixedElement) && anchor && element2.offsetParent !== anchor) {
    anchorPos.left += anchor.offsetLeft;
    anchorPos.top += anchor.offsetTop;
    anchor = anchor.offsetParent;
  }
  anchor = tempAnchor;
  while ((element2.offsetParent || fixedElement) && anchor && element2.offsetParent !== anchor) {
    anchorPos.left -= anchor.scrollLeft;
    anchorPos.top -= anchor.scrollTop;
    anchor = anchor.parentElement;
  }
  return anchorPos;
}
function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
  popupRect = void 0;
  popupRect = targetValues;
  fixedParent = parentElement ? true : false;
  if (!currentElement) {
    return { left: 0, top: 0 };
  }
  if (!positionX) {
    positionX = "left";
  }
  if (!positionY) {
    positionY = "top";
  }
  parentDocument = currentElement.ownerDocument;
  element = currentElement;
  var pos = { left: 0, top: 0 };
  return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
}
function setPosx(value, pos) {
  pos.left = value;
}
function setPosy(value, pos) {
  pos.top = value;
}
function updatePosition(posX, posY, pos) {
  elementRect = element.getBoundingClientRect();
  switch (posY + posX) {
    case "topcenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementTop(), pos);
      break;
    case "topright":
      setPosx(getElementRight(), pos);
      setPosy(getElementTop(), pos);
      break;
    case "centercenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "centerright":
      setPosx(getElementRight(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "centerleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "bottomcenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementBottom(), pos);
      break;
    case "bottomright":
      setPosx(getElementRight(), pos);
      setPosy(getElementBottom(), pos);
      break;
    case "bottomleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementBottom(), pos);
      break;
    default:
    case "topleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementTop(), pos);
      break;
  }
  element = null;
  return pos;
}
function getBodyScrollTop() {
  return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
}
function getBodyScrollLeft() {
  return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
}
function getElementBottom() {
  return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop();
}
function getElementVCenter() {
  return getElementTop() + elementRect.height / 2;
}
function getElementTop() {
  return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop();
}
function getElementLeft() {
  return elementRect.left + getBodyScrollLeft();
}
function getElementRight() {
  var popupWidth = element && (element.classList.contains("e-date-wrapper") || element.classList.contains("e-datetime-wrapper") || element.classList.contains("e-ddl") && element.classList.contains("e-rtl") || element.classList.contains("e-date-range-wrapper")) ? popupRect ? popupRect.width : 0 : popupRect && elementRect.width >= popupRect.width ? popupRect.width : 0;
  return elementRect.right + getBodyScrollLeft() - popupWidth;
}
function getElementHCenter() {
  return getElementLeft() + elementRect.width / 2;
}

// node_modules/@syncfusion/ej2-popups/src/common/collision.js
var parentDocument2;
var targetContainer;
function fit(element2, viewPortElement, axis, position) {
  if (viewPortElement === void 0) {
    viewPortElement = null;
  }
  if (axis === void 0) {
    axis = { X: false, Y: false };
  }
  if (!axis.Y && !axis.X) {
    return { left: 0, top: 0 };
  }
  var elemData = element2.getBoundingClientRect();
  targetContainer = viewPortElement;
  parentDocument2 = element2.ownerDocument;
  if (!position) {
    position = calculatePosition(element2, "left", "top");
  }
  if (axis.X) {
    var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
    var containerLeft = ContainerLeft();
    var containerRight = ContainerRight();
    var overLeft = containerLeft - position.left;
    var overRight = position.left + elemData.width - containerRight;
    if (elemData.width > containerWidth) {
      if (overLeft > 0 && overRight <= 0) {
        position.left = containerRight - elemData.width;
      } else if (overRight > 0 && overLeft <= 0) {
        position.left = containerLeft;
      } else {
        position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;
      }
    } else if (overLeft > 0) {
      position.left += overLeft;
    } else if (overRight > 0) {
      position.left -= overRight;
    }
  }
  if (axis.Y) {
    var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
    var containerTop = ContainerTop();
    var containerBottom = ContainerBottom();
    var overTop = containerTop - position.top;
    var overBottom = position.top + elemData.height - containerBottom;
    if (elemData.height > containerHeight) {
      if (overTop > 0 && overBottom <= 0) {
        position.top = containerBottom - elemData.height;
      } else if (overBottom > 0 && overTop <= 0) {
        position.top = containerTop;
      } else {
        position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;
      }
    } else if (overTop > 0) {
      position.top += overTop;
    } else if (overBottom > 0) {
      position.top -= overBottom;
    }
  }
  return position;
}
function isCollide(element2, viewPortElement, x, y) {
  if (viewPortElement === void 0) {
    viewPortElement = null;
  }
  var elemOffset = calculatePosition(element2, "left", "top");
  if (x) {
    elemOffset.left = x;
  }
  if (y) {
    elemOffset.top = y;
  }
  var data = [];
  targetContainer = viewPortElement;
  parentDocument2 = element2.ownerDocument;
  var elementRect2 = element2.getBoundingClientRect();
  var top = elemOffset.top;
  var left = elemOffset.left;
  var right = elemOffset.left + elementRect2.width;
  var bottom = elemOffset.top + elementRect2.height;
  var yAxis = topCollideCheck(top, bottom);
  var xAxis = leftCollideCheck(left, right);
  if (yAxis.topSide) {
    data.push("top");
  }
  if (xAxis.rightSide) {
    data.push("right");
  }
  if (xAxis.leftSide) {
    data.push("left");
  }
  if (yAxis.bottomSide) {
    data.push("bottom");
  }
  return data;
}
function flip(element2, target, offsetX, offsetY, positionX, positionY, viewPortElement, axis, fixedParent2) {
  if (viewPortElement === void 0) {
    viewPortElement = null;
  }
  if (axis === void 0) {
    axis = { X: true, Y: true };
  }
  if (!target || !element2 || !positionX || !positionY || !axis.X && !axis.Y) {
    return;
  }
  var tEdge = {
    TL: null,
    TR: null,
    BL: null,
    BR: null
  }, eEdge = {
    TL: null,
    TR: null,
    BL: null,
    BR: null
    /* eslint-enable */
  };
  var elementRect2;
  if (window.getComputedStyle(element2).display === "none") {
    var oldVisibility = element2.style.visibility;
    element2.style.visibility = "hidden";
    element2.style.display = "block";
    elementRect2 = element2.getBoundingClientRect();
    element2.style.removeProperty("display");
    element2.style.visibility = oldVisibility;
  } else {
    elementRect2 = element2.getBoundingClientRect();
  }
  var pos = {
    posX: positionX,
    posY: positionY,
    offsetX,
    offsetY,
    position: { left: 0, top: 0 }
  };
  targetContainer = viewPortElement;
  parentDocument2 = target.ownerDocument;
  updateElementData(target, tEdge, pos, fixedParent2, elementRect2);
  setPosition(eEdge, pos, elementRect2);
  if (axis.X) {
    leftFlip(target, eEdge, tEdge, pos, elementRect2, true);
  }
  if (axis.Y && tEdge.TL.top > -1) {
    topFlip(target, eEdge, tEdge, pos, elementRect2, true);
  }
  setPopup(element2, pos, elementRect2);
}
function setPopup(element2, pos, elementRect2) {
  var left = 0;
  var top = 0;
  if (element2.offsetParent != null && (getComputedStyle(element2.offsetParent).position === "absolute" || getComputedStyle(element2.offsetParent).position === "relative")) {
    var data = calculatePosition(element2.offsetParent, "left", "top", false, elementRect2);
    left = data.left;
    top = data.top;
  }
  var scaleX = 1;
  var scaleY = 1;
  if (element2.offsetParent) {
    var transformStyle = getComputedStyle(element2.offsetParent).transform;
    if (transformStyle !== "none") {
      var matrix = new DOMMatrix(transformStyle);
      scaleX = matrix.a;
      scaleY = matrix.d;
    }
  }
  element2.style.top = pos.position.top / scaleY + pos.offsetY - top + "px";
  element2.style.left = pos.position.left / scaleX + pos.offsetX - left + "px";
}
function updateElementData(target, edge, pos, fixedParent2, elementRect2) {
  pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent2, elementRect2);
  edge.TL = calculatePosition(target, "left", "top", fixedParent2, elementRect2);
  edge.TR = calculatePosition(target, "right", "top", fixedParent2, elementRect2);
  edge.BR = calculatePosition(target, "left", "bottom", fixedParent2, elementRect2);
  edge.BL = calculatePosition(target, "right", "bottom", fixedParent2, elementRect2);
}
function setPosition(eStatus, pos, elementRect2) {
  eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };
  eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect2.width };
  eStatus.BL = {
    top: eStatus.TL.top + elementRect2.height,
    left: eStatus.TL.left
  };
  eStatus.BR = {
    top: eStatus.TL.top + elementRect2.height,
    left: eStatus.TL.left + elementRect2.width
  };
}
function leftCollideCheck(left, right) {
  var leftSide = false, rightSide = false;
  if (left - getBodyScrollLeft2() < ContainerLeft()) {
    leftSide = true;
  }
  if (right > ContainerRight()) {
    rightSide = true;
  }
  return { leftSide, rightSide };
}
function leftFlip(target, edge, tEdge, pos, elementRect2, deepCheck) {
  var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);
  if (tEdge.TL.left - getBodyScrollLeft2() <= ContainerLeft()) {
    collideSide.leftSide = false;
  }
  if (tEdge.TR.left > ContainerRight()) {
    collideSide.rightSide = false;
  }
  if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {
    if (pos.posX === "right") {
      pos.posX = "left";
    } else {
      pos.posX = "right";
    }
    pos.offsetX = pos.offsetX + elementRect2.width;
    pos.offsetX = -1 * pos.offsetX;
    pos.position = calculatePosition(target, pos.posX, pos.posY, false);
    setPosition(edge, pos, elementRect2);
    if (deepCheck) {
      leftFlip(target, edge, tEdge, pos, elementRect2, false);
    }
  }
}
function topFlip(target, edge, tEdge, pos, elementRect2, deepCheck) {
  var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);
  if (tEdge.TL.top - getBodyScrollTop2() <= ContainerTop()) {
    collideSide.topSide = false;
  }
  if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {
    collideSide.bottomSide = false;
  }
  if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {
    if (pos.posY === "top") {
      pos.posY = "bottom";
    } else {
      pos.posY = "top";
    }
    pos.offsetY = pos.offsetY + elementRect2.height;
    pos.offsetY = -1 * pos.offsetY;
    pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect2);
    setPosition(edge, pos, elementRect2);
    if (deepCheck) {
      topFlip(target, edge, tEdge, pos, elementRect2, false);
    }
  }
}
function topCollideCheck(top, bottom) {
  var topSide = false, bottomSide = false;
  if (top - getBodyScrollTop2() < ContainerTop()) {
    topSide = true;
  }
  if (bottom > ContainerBottom()) {
    bottomSide = true;
  }
  return { topSide, bottomSide };
}
function getTargetContainerWidth() {
  return targetContainer.getBoundingClientRect().width;
}
function getTargetContainerHeight() {
  return targetContainer.getBoundingClientRect().height;
}
function getTargetContainerLeft() {
  return targetContainer.getBoundingClientRect().left;
}
function getTargetContainerTop() {
  return targetContainer.getBoundingClientRect().top;
}
function ContainerTop() {
  if (targetContainer) {
    return getTargetContainerTop();
  }
  return 0;
}
function ContainerLeft() {
  if (targetContainer) {
    return getTargetContainerLeft();
  }
  return 0;
}
function ContainerRight() {
  if (targetContainer) {
    return getBodyScrollLeft2() + getTargetContainerLeft() + getTargetContainerWidth();
  }
  return getBodyScrollLeft2() + getViewPortWidth();
}
function ContainerBottom() {
  if (targetContainer) {
    return getBodyScrollTop2() + getTargetContainerTop() + getTargetContainerHeight();
  }
  return getBodyScrollTop2() + getViewPortHeight();
}
function getBodyScrollTop2() {
  return parentDocument2.documentElement.scrollTop || parentDocument2.body.scrollTop;
}
function getBodyScrollLeft2() {
  return parentDocument2.documentElement.scrollLeft || parentDocument2.body.scrollLeft;
}
function getViewPortHeight() {
  return window.innerHeight;
}
function getViewPortWidth() {
  var windowWidth = window.innerWidth;
  var documentReact = document.documentElement.getBoundingClientRect();
  var offsetWidth = isNullOrUndefined(document.documentElement) ? 0 : documentReact.width;
  return windowWidth - (windowWidth - offsetWidth);
}
function destroy() {
  targetContainer = null;
  parentDocument2 = null;
}

// node_modules/@syncfusion/ej2-popups/src/popup/popup.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PositionData = (
  /** @class */
  function(_super) {
    __extends(PositionData2, _super);
    function PositionData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate2([
      Property("left")
    ], PositionData2.prototype, "X", void 0);
    __decorate2([
      Property("top")
    ], PositionData2.prototype, "Y", void 0);
    return PositionData2;
  }(ChildProperty)
);
var CLASSNAMES = {
  ROOT: "e-popup",
  RTL: "e-rtl",
  OPEN: "e-popup-open",
  CLOSE: "e-popup-close"
};
var Popup = (
  /** @class */
  function(_super) {
    __extends(Popup2, _super);
    function Popup2(element2, options) {
      return _super.call(this, options, element2) || this;
    }
    Popup2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(newProp.width) });
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            break;
          case "zIndex":
            setStyleAttribute(this.element, { "zIndex": newProp.zIndex });
            break;
          case "enableRtl":
            this.setEnableRtl();
            break;
          case "position":
          case "relateTo":
            this.refreshPosition();
            break;
          case "offsetX": {
            var x = newProp.offsetX - oldProp.offsetX;
            this.element.style.left = (parseInt(this.element.style.left, 10) + x).toString() + "px";
            break;
          }
          case "offsetY": {
            var y = newProp.offsetY - oldProp.offsetY;
            this.element.style.top = (parseInt(this.element.style.top, 10) + y).toString() + "px";
            break;
          }
          case "content":
            this.setContent();
            break;
          case "actionOnScroll":
            if (newProp.actionOnScroll !== "none") {
              this.wireScrollEvents();
            } else {
              this.unwireScrollEvents();
            }
            break;
        }
      }
    };
    Popup2.prototype.getModuleName = function() {
      return "popup";
    };
    Popup2.prototype.resolveCollision = function() {
      this.checkCollision();
    };
    Popup2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Popup2.prototype.destroy = function() {
      if (this.element.classList.contains("e-popup-open")) {
        this.unwireEvents();
      }
      this.element.classList.remove(CLASSNAMES.ROOT, CLASSNAMES.RTL, CLASSNAMES.OPEN, CLASSNAMES.CLOSE);
      this.content = null;
      this.relateTo = null;
      destroy();
      _super.prototype.destroy.call(this);
    };
    Popup2.prototype.render = function() {
      this.element.classList.add(CLASSNAMES.ROOT);
      var styles = {};
      if (this.zIndex !== 1e3) {
        styles.zIndex = this.zIndex;
      }
      if (this.width !== "auto") {
        styles.width = formatUnit(this.width);
      }
      if (this.height !== "auto") {
        styles.height = formatUnit(this.height);
      }
      setStyleAttribute(this.element, styles);
      this.fixedParent = false;
      this.setEnableRtl();
      this.setContent();
    };
    Popup2.prototype.wireEvents = function() {
      if (Browser.isDevice) {
        EventHandler.add(window, "orientationchange", this.orientationOnChange, this);
      }
      if (this.actionOnScroll !== "none") {
        this.wireScrollEvents();
      }
    };
    Popup2.prototype.wireScrollEvents = function() {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_1 = _a[_i];
          EventHandler.add(parent_1, "scroll", this.scrollRefresh, this);
        }
      }
    };
    Popup2.prototype.unwireEvents = function() {
      if (Browser.isDevice) {
        EventHandler.remove(window, "orientationchange", this.orientationOnChange);
      }
      if (this.actionOnScroll !== "none") {
        this.unwireScrollEvents();
      }
    };
    Popup2.prototype.unwireScrollEvents = function() {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_2 = _a[_i];
          EventHandler.remove(parent_2, "scroll", this.scrollRefresh);
        }
      }
    };
    Popup2.prototype.getRelateToElement = function() {
      var relateToElement = this.relateTo === "" || isNullOrUndefined(this.relateTo) ? document.body : this.relateTo;
      this.setProperties({ relateTo: relateToElement }, true);
      return typeof this.relateTo === "string" ? document.querySelector(this.relateTo) : this.relateTo;
    };
    Popup2.prototype.scrollRefresh = function(e) {
      if (this.actionOnScroll === "reposition") {
        if (!isNullOrUndefined(this.element) && !(this.element.offsetParent === e.target || this.element.offsetParent && this.element.offsetParent.tagName === "BODY" && e.target.parentElement == null)) {
          this.refreshPosition();
        }
      } else if (this.actionOnScroll === "hide") {
        this.hide();
      }
      if (this.actionOnScroll !== "none") {
        if (this.getRelateToElement()) {
          var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);
          if (!targetVisible && !this.targetInvisibleStatus) {
            this.trigger("targetExitViewport");
            this.targetInvisibleStatus = true;
          } else if (targetVisible) {
            this.targetInvisibleStatus = false;
          }
        }
      }
    };
    Popup2.prototype.isElementOnViewport = function(relateToElement, scrollElement) {
      var scrollParents = this.getScrollableParent(relateToElement);
      for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
        if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
          continue;
        } else {
          return false;
        }
      }
      return true;
    };
    Popup2.prototype.isElementVisible = function(relateToElement, scrollElement) {
      var rect = this.checkGetBoundingClientRect(relateToElement);
      if (!rect.height || !rect.width) {
        return false;
      }
      if (!isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
        var parent_4 = scrollElement.getBoundingClientRect();
        return !(rect.bottom < parent_4.top) && (!(rect.bottom > parent_4.bottom) && (!(rect.right > parent_4.right) && !(rect.left < parent_4.left)));
      } else {
        var win = window;
        var windowView = {
          top: win.scrollY,
          left: win.scrollX,
          right: win.scrollX + win.outerWidth,
          bottom: win.scrollY + win.outerHeight
        };
        var off = calculatePosition(relateToElement);
        var ele = {
          top: off.top,
          left: off.left,
          right: off.left + rect.width,
          bottom: off.top + rect.height
        };
        var elementView = {
          top: windowView.bottom - ele.top,
          left: windowView.right - ele.left,
          bottom: ele.bottom - windowView.top,
          right: ele.right - windowView.left
        };
        return elementView.top > 0 && elementView.left > 0 && elementView.right > 0 && elementView.bottom > 0;
      }
    };
    Popup2.prototype.preRender = function() {
    };
    Popup2.prototype.setEnableRtl = function() {
      this.reposition();
      if (this.enableRtl) {
        this.element.classList.add(CLASSNAMES.RTL);
      } else {
        this.element.classList.remove(CLASSNAMES.RTL);
      }
    };
    Popup2.prototype.setContent = function() {
      if (!isNullOrUndefined(this.content)) {
        this.element.innerHTML = "";
        if (typeof this.content === "string") {
          this.element.textContent = this.content;
        } else {
          var relateToElem = this.getRelateToElement();
          var props = this.content.props;
          if (!relateToElem.classList.contains("e-dropdown-btn") || isNullOrUndefined(props)) {
            this.element.appendChild(this.content);
          }
        }
      }
    };
    Popup2.prototype.orientationOnChange = function() {
      var _this = this;
      setTimeout(function() {
        _this.refreshPosition();
      }, 200);
    };
    Popup2.prototype.refreshPosition = function(target, collision) {
      if (!isNullOrUndefined(target)) {
        this.checkFixedParent(target);
      }
      this.reposition();
      if (!collision) {
        this.checkCollision();
      }
    };
    Popup2.prototype.reposition = function() {
      var pos;
      var position;
      var relateToElement = this.getRelateToElement();
      if (typeof this.position.X === "number" && typeof this.position.Y === "number") {
        pos = { left: this.position.X, top: this.position.Y };
      } else if (typeof this.position.X === "string" && typeof this.position.Y === "number" || typeof this.position.X === "number" && typeof this.position.Y === "string") {
        var parentDisplay = void 0;
        var display = this.element.style.display;
        this.element.style.display = "block";
        if (this.element.classList.contains("e-dlg-modal")) {
          parentDisplay = this.element.parentElement.style.display;
          this.element.parentElement.style.display = "block";
        }
        position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
        if (typeof this.position.X === "string") {
          pos = { left: position.left, top: this.position.Y };
        } else {
          pos = { left: this.position.X, top: position.top };
        }
        this.element.style.display = display;
        if (this.element.classList.contains("e-dlg-modal")) {
          this.element.parentElement.style.display = parentDisplay;
        }
      } else if (relateToElement) {
        var height = this.element.clientHeight;
        var display = this.element.style.display;
        this.element.style.display = "block";
        pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY, height);
        this.element.style.display = display;
      } else {
        pos = { left: 0, top: 0 };
      }
      if (!isNullOrUndefined(pos)) {
        this.element.style.left = pos.left + "px";
        this.element.style.top = pos.top + "px";
      }
    };
    Popup2.prototype.checkGetBoundingClientRect = function(ele) {
      var eleRect;
      try {
        eleRect = ele.getBoundingClientRect();
        return eleRect;
      } catch (error) {
        return null;
      }
    };
    Popup2.prototype.getAnchorPosition = function(anchorEle, ele, position, offsetX, offsetY, height) {
      if (height === void 0) {
        height = 0;
      }
      var eleRect = this.checkGetBoundingClientRect(ele);
      var anchorRect = this.checkGetBoundingClientRect(anchorEle);
      if (isNullOrUndefined(eleRect) || isNullOrUndefined(anchorRect)) {
        return null;
      }
      var anchor = anchorEle;
      var anchorPos = { left: 0, top: 0 };
      if (ele.offsetParent && ele.offsetParent.tagName === "BODY" && anchorEle.tagName === "BODY") {
        anchorPos = calculatePosition(anchorEle);
      } else {
        if (ele.classList.contains("e-dlg-modal") && anchor.tagName !== "BODY") {
          ele = ele.parentElement;
        }
        anchorPos = calculateRelativeBasedPosition(anchor, ele);
      }
      switch (position.X) {
        default:
        case "left":
          break;
        case "center":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.left += window.innerWidth / 2 - eleRect.width / 2;
          } else if (this.targetType === "container") {
            anchorPos.left += anchorRect.width / 2 - eleRect.width / 2;
          } else {
            anchorPos.left += anchorRect.width / 2;
          }
          break;
        case "right":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.left += window.innerWidth - eleRect.width;
          } else if (this.targetType === "container") {
            anchorPos.left += anchorRect.width - eleRect.width;
          } else {
            anchorPos.left += anchorRect.width;
          }
          break;
      }
      switch (position.Y) {
        default:
        case "top":
          break;
        case "center":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.top += window.innerHeight / 2 - eleRect.height / 2;
          } else if (this.targetType === "container") {
            anchorPos.top += anchorRect.height / 2 - eleRect.height / 2;
          } else {
            anchorPos.top += anchorRect.height / 2;
          }
          break;
        case "bottom":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.top += window.innerHeight - eleRect.height;
          } else if (this.targetType === "container" && !ele.classList.contains("e-dialog")) {
            anchorPos.top += anchorRect.height - eleRect.height;
          } else if (this.targetType === "container" && ele.classList.contains("e-dialog")) {
            anchorPos.top += anchorRect.height - height;
          } else {
            anchorPos.top += anchorRect.height;
          }
          break;
      }
      anchorPos.left += offsetX;
      anchorPos.top += offsetY;
      return anchorPos;
    };
    Popup2.prototype.callFlip = function(param) {
      var relateToElement = this.getRelateToElement();
      flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
    };
    Popup2.prototype.callFit = function(param) {
      if (isCollide(this.element, this.viewPortElement).length !== 0) {
        if (isNullOrUndefined(this.viewPortElement)) {
          var data = fit(this.element, this.viewPortElement, param);
          if (param.X) {
            this.element.style.left = data.left + "px";
          }
          if (param.Y) {
            this.element.style.top = data.top + "px";
          }
        } else {
          var elementRect2 = this.checkGetBoundingClientRect(this.element);
          var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);
          if (isNullOrUndefined(elementRect2) || isNullOrUndefined(viewPortRect)) {
            return null;
          }
          if (param && param.Y === true) {
            if (viewPortRect.top > elementRect2.top) {
              this.element.style.top = "0px";
            } else if (viewPortRect.bottom < elementRect2.bottom) {
              this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect2.bottom - viewPortRect.bottom) + "px";
            }
          }
          if (param && param.X === true) {
            if (viewPortRect.right < elementRect2.right) {
              this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect2.right - viewPortRect.right) + "px";
            } else if (viewPortRect.left > elementRect2.left) {
              this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect2.left) + "px";
            }
          }
        }
      }
    };
    Popup2.prototype.checkCollision = function() {
      var horz = this.collision.X;
      var vert = this.collision.Y;
      if (horz === "none" && vert === "none") {
        return;
      }
      if (horz === "flip" && vert === "flip") {
        this.callFlip({ X: true, Y: true });
      } else if (horz === "fit" && vert === "fit") {
        this.callFit({ X: true, Y: true });
      } else {
        if (horz === "flip") {
          this.callFlip({ X: true, Y: false });
        } else if (vert === "flip") {
          this.callFlip({ Y: true, X: false });
        }
        if (horz === "fit") {
          this.callFit({ X: true, Y: false });
        } else if (vert === "fit") {
          this.callFit({ X: false, Y: true });
        }
      }
    };
    Popup2.prototype.show = function(animationOptions, relativeElement) {
      var _this = this;
      var relateToElement = this.getRelateToElement();
      if (relateToElement.classList.contains("e-filemanager")) {
        this.fmDialogContainer = this.element.getElementsByClassName("e-file-select-wrap")[0];
      }
      this.wireEvents();
      if (!isNullOrUndefined(this.fmDialogContainer) && Browser.isIos) {
        this.fmDialogContainer.style.display = "block";
      }
      if (this.zIndex === 1e3 || !isNullOrUndefined(relativeElement)) {
        var zIndexElement = isNullOrUndefined(relativeElement) ? this.element : relativeElement;
        this.zIndex = getZindexPartial(zIndexElement);
        setStyleAttribute(this.element, { "zIndex": this.zIndex });
      }
      animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === "object" ? animationOptions : this.showAnimation;
      if (this.collision.X !== "none" || this.collision.Y !== "none") {
        removeClass([this.element], CLASSNAMES.CLOSE);
        addClass([this.element], CLASSNAMES.OPEN);
        this.checkCollision();
        removeClass([this.element], CLASSNAMES.OPEN);
        addClass([this.element], CLASSNAMES.CLOSE);
      }
      if (!isNullOrUndefined(animationOptions)) {
        animationOptions.begin = function() {
          if (!_this.isDestroyed) {
            removeClass([_this.element], CLASSNAMES.CLOSE);
            addClass([_this.element], CLASSNAMES.OPEN);
          }
        };
        animationOptions.end = function() {
          if (!_this.isDestroyed) {
            _this.trigger("open");
          }
        };
        new Animation(animationOptions).animate(this.element);
      } else {
        removeClass([this.element], CLASSNAMES.CLOSE);
        addClass([this.element], CLASSNAMES.OPEN);
        this.trigger("open");
      }
    };
    Popup2.prototype.hide = function(animationOptions) {
      var _this = this;
      animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === "object" ? animationOptions : this.hideAnimation;
      if (!isNullOrUndefined(animationOptions)) {
        animationOptions.end = function() {
          if (!_this.isDestroyed) {
            removeClass([_this.element], CLASSNAMES.OPEN);
            addClass([_this.element], CLASSNAMES.CLOSE);
            _this.trigger("close");
          }
        };
        new Animation(animationOptions).animate(this.element);
      } else {
        removeClass([this.element], CLASSNAMES.OPEN);
        addClass([this.element], CLASSNAMES.CLOSE);
        this.trigger("close");
      }
      this.unwireEvents();
    };
    Popup2.prototype.getScrollableParent = function(element2) {
      this.checkFixedParent(element2);
      return getScrollableParent(element2, this.fixedParent);
    };
    Popup2.prototype.checkFixedParent = function(element2) {
      var parent = element2.parentElement;
      while (parent && parent.tagName !== "HTML") {
        var parentStyle = getComputedStyle(parent);
        if ((parentStyle.position === "fixed" || parentStyle.position === "sticky") && !isNullOrUndefined(this.element) && this.element.offsetParent && this.element.offsetParent.tagName === "BODY" && getComputedStyle(this.element.offsetParent).overflow !== "hidden") {
          this.element.style.top = window.scrollY > parseInt(this.element.style.top, 10) ? formatUnit(window.scrollY - parseInt(this.element.style.top, 10)) : formatUnit(parseInt(this.element.style.top, 10) - window.scrollY);
          this.element.style.position = "fixed";
          this.fixedParent = true;
        }
        parent = parent.parentElement;
        if (!isNullOrUndefined(this.element) && isNullOrUndefined(this.element.offsetParent) && parentStyle.position === "fixed" && this.element.style.position === "fixed") {
          this.fixedParent = true;
        }
      }
    };
    __decorate2([
      Property("auto")
    ], Popup2.prototype, "height", void 0);
    __decorate2([
      Property("auto")
    ], Popup2.prototype, "width", void 0);
    __decorate2([
      Property(null)
    ], Popup2.prototype, "content", void 0);
    __decorate2([
      Property("container")
    ], Popup2.prototype, "targetType", void 0);
    __decorate2([
      Property(null)
    ], Popup2.prototype, "viewPortElement", void 0);
    __decorate2([
      Property({ X: "none", Y: "none" })
    ], Popup2.prototype, "collision", void 0);
    __decorate2([
      Property("")
    ], Popup2.prototype, "relateTo", void 0);
    __decorate2([
      Complex({}, PositionData)
    ], Popup2.prototype, "position", void 0);
    __decorate2([
      Property(0)
    ], Popup2.prototype, "offsetX", void 0);
    __decorate2([
      Property(0)
    ], Popup2.prototype, "offsetY", void 0);
    __decorate2([
      Property(1e3)
    ], Popup2.prototype, "zIndex", void 0);
    __decorate2([
      Property(false)
    ], Popup2.prototype, "enableRtl", void 0);
    __decorate2([
      Property("reposition")
    ], Popup2.prototype, "actionOnScroll", void 0);
    __decorate2([
      Property(null)
    ], Popup2.prototype, "showAnimation", void 0);
    __decorate2([
      Property(null)
    ], Popup2.prototype, "hideAnimation", void 0);
    __decorate2([
      Event()
    ], Popup2.prototype, "open", void 0);
    __decorate2([
      Event()
    ], Popup2.prototype, "close", void 0);
    __decorate2([
      Event()
    ], Popup2.prototype, "targetExitViewport", void 0);
    Popup2 = __decorate2([
      NotifyPropertyChanges
    ], Popup2);
    return Popup2;
  }(Component)
);
function getScrollableParent(element2, fixedParent2) {
  var eleStyle = getComputedStyle(element2);
  var scrollParents = [];
  var overflowRegex = /(auto|scroll)/;
  var parent = element2.parentElement;
  while (parent && parent.tagName !== "HTML") {
    var parentStyle = getComputedStyle(parent);
    if (!(eleStyle.position === "absolute" && parentStyle.position === "static") && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
      scrollParents.push(parent);
    }
    parent = parent.parentElement;
  }
  if (!fixedParent2) {
    scrollParents.push(document);
  }
  return scrollParents;
}
function getZindexPartial(element2) {
  var parent = element2.parentElement;
  var parentZindex = [];
  while (parent) {
    if (parent.tagName !== "BODY") {
      var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue("z-index");
      var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue("position");
      if (index !== "auto" && position !== "static") {
        parentZindex.push(index);
      }
      parent = parent.parentElement;
    } else {
      break;
    }
  }
  var childrenZindex = [];
  for (var i = 0; i < document.body.children.length; i++) {
    if (!element2.isEqualNode(document.body.children[i])) {
      var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue("z-index");
      var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue("position");
      if (index !== "auto" && position !== "static") {
        childrenZindex.push(index);
      }
    }
  }
  childrenZindex.push("999");
  var siblingsZindex = [];
  if (!isNullOrUndefined(element2.parentElement) && element2.parentElement.tagName !== "BODY") {
    var childNodes = [].slice.call(element2.parentElement.children);
    for (var i = 0; i < childNodes.length; i++) {
      if (!element2.isEqualNode(childNodes[i])) {
        var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue("z-index");
        var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue("position");
        if (index !== "auto" && position !== "static") {
          siblingsZindex.push(index);
        }
      }
    }
  }
  var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
  var currentZindexValue = Math.max.apply(Math, finalValue) + 1;
  return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
}

// node_modules/@syncfusion/ej2-buttons/src/common/common.js
function wrapperInitialize(createElement2, tag, type, element2, WRAPPER4, role) {
  var input = element2;
  if (element2.tagName === tag) {
    var ejInstance = getValue("ej2_instances", element2);
    input = createElement2("input", { attrs: { "type": type } });
    var props = ["change", "cssClass", "label", "labelPosition", "id"];
    for (var index = 0, len = element2.attributes.length; index < len; index++) {
      if (props.indexOf(element2.attributes[index].nodeName) === -1) {
        input.setAttribute(element2.attributes[index].nodeName, element2.attributes[index].nodeValue);
      }
    }
    attributes(element2, { "class": WRAPPER4 });
    element2.appendChild(input);
    element2.classList.add(role);
    element2.classList.remove(role);
    setValue("ej2_instances", ejInstance, input);
    deleteObject(element2, "ej2_instances");
  }
  return input;
}
function getTextNode(element2) {
  var node;
  var childnode = element2.childNodes;
  for (var i = 0; i < childnode.length; i++) {
    node = childnode[i];
    if (node.nodeType === 3) {
      return node;
    }
  }
  return null;
}
function destroy2(ejInst, wrapper, tagName) {
  if (tagName === "INPUT") {
    wrapper.parentNode.insertBefore(ejInst.element, wrapper);
    detach(wrapper);
    ejInst.element.checked = false;
    ["name", "value", "disabled"].forEach(function(key) {
      ejInst.element.removeAttribute(key);
    });
  } else {
    ["role", "aria-checked", "class"].forEach(function(key) {
      wrapper.removeAttribute(key);
    });
    wrapper.innerHTML = "";
    ejInst.element = wrapper;
  }
}
function preRender(proxy, control, wrapper, element2, moduleName) {
  element2 = wrapperInitialize(proxy.createElement, control, "checkbox", element2, wrapper, moduleName);
  proxy.element = element2;
  if (proxy.element.getAttribute("type") !== "checkbox") {
    proxy.element.setAttribute("type", "checkbox");
  }
  if (!proxy.element.id) {
    proxy.element.id = getUniqueID("e-" + moduleName);
  }
}
function createCheckBox(createElement2, enableRipple, options) {
  if (enableRipple === void 0) {
    enableRipple = false;
  }
  if (options === void 0) {
    options = {};
  }
  var wrapper = createElement2("div", { className: "e-checkbox-wrapper e-css" });
  if (options.cssClass) {
    addClass([wrapper], options.cssClass.split(" "));
  }
  if (options.enableRtl) {
    wrapper.classList.add("e-rtl");
  }
  if (enableRipple) {
    var rippleSpan = createElement2("span", { className: "e-ripple-container" });
    rippleEffect(rippleSpan, { isCenterRipple: true, duration: 400 });
    wrapper.appendChild(rippleSpan);
  }
  var frameSpan = createElement2("span", { className: "e-frame e-icons" });
  if (options.checked) {
    frameSpan.classList.add("e-check");
  }
  wrapper.appendChild(frameSpan);
  if (options.label) {
    var labelSpan = createElement2("span", { className: "e-label" });
    if (options.disableHtmlEncode) {
      labelSpan.textContent = options.label;
    } else {
      labelSpan.innerHTML = options.label;
    }
    wrapper.appendChild(labelSpan);
  }
  return wrapper;
}
function rippleMouseHandler(e, rippleSpan) {
  if (rippleSpan) {
    var event_1 = document.createEvent("MouseEvents");
    event_1.initEvent(e.type, false, true);
    rippleSpan.dispatchEvent(event_1);
  }
}
function setHiddenInput(proxy, wrap) {
  if (proxy.element.getAttribute("ejs-for")) {
    wrap.appendChild(proxy.createElement("input", {
      attrs: { "name": proxy.name || proxy.element.name, "value": "false", "type": "hidden" }
    }));
  }
}

// node_modules/@syncfusion/ej2-buttons/src/button/button.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IconPosition;
(function(IconPosition2) {
  IconPosition2["Left"] = "Left";
  IconPosition2["Right"] = "Right";
  IconPosition2["Top"] = "Top";
  IconPosition2["Bottom"] = "Bottom";
})(IconPosition || (IconPosition = {}));
var buttonObserver = new Observer();
var cssClassName = {
  RTL: "e-rtl",
  BUTTON: "e-btn",
  PRIMARY: "e-primary",
  ICONBTN: "e-icon-btn"
};
var Button = (
  /** @class */
  function(_super) {
    __extends2(Button2, _super);
    function Button2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    Button2.prototype.preRender = function() {
    };
    Button2.prototype.render = function() {
      this.initialize();
      this.removeRippleEffect = rippleEffect(this.element, { selector: "." + cssClassName.BUTTON });
      this.renderComplete();
    };
    Button2.prototype.initialize = function() {
      if (this.cssClass) {
        addClass([this.element], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.isPrimary) {
        this.element.classList.add(cssClassName.PRIMARY);
      }
      if (!isBlazor() || isBlazor() && this.getModuleName() !== "progress-btn") {
        if (this.content) {
          var tempContent = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(this.content) : this.content;
          this.element.innerHTML = tempContent;
        }
        this.setIconCss();
      }
      if (this.enableRtl) {
        this.element.classList.add(cssClassName.RTL);
      }
      if (this.disabled) {
        this.controlStatus(this.disabled);
      } else {
        this.wireEvents();
      }
    };
    Button2.prototype.controlStatus = function(disabled) {
      this.element.disabled = disabled;
    };
    Button2.prototype.setIconCss = function() {
      if (this.iconCss) {
        var span = this.createElement("span", { className: "e-btn-icon " + this.iconCss });
        if (!this.element.textContent.trim()) {
          this.element.classList.add(cssClassName.ICONBTN);
        } else {
          span.classList.add("e-icon-" + this.iconPosition.toLowerCase());
          if (this.iconPosition === "Top" || this.iconPosition === "Bottom") {
            this.element.classList.add("e-" + this.iconPosition.toLowerCase() + "-icon-btn");
          }
        }
        var node = this.element.childNodes[0];
        if (node && (this.iconPosition === "Left" || this.iconPosition === "Top")) {
          this.element.insertBefore(span, node);
        } else {
          this.element.appendChild(span);
        }
      }
    };
    Button2.prototype.wireEvents = function() {
      if (this.isToggle) {
        EventHandler.add(this.element, "click", this.btnClickHandler, this);
      }
    };
    Button2.prototype.unWireEvents = function() {
      if (this.isToggle) {
        EventHandler.remove(this.element, "click", this.btnClickHandler);
      }
    };
    Button2.prototype.btnClickHandler = function() {
      if (this.element.classList.contains("e-active")) {
        this.element.classList.remove("e-active");
      } else {
        this.element.classList.add("e-active");
      }
    };
    Button2.prototype.destroy = function() {
      var classList2 = [
        cssClassName.PRIMARY,
        cssClassName.RTL,
        cssClassName.ICONBTN,
        "e-success",
        "e-info",
        "e-danger",
        "e-warning",
        "e-flat",
        "e-outline",
        "e-small",
        "e-bigger",
        "e-active",
        "e-round",
        "e-top-icon-btn",
        "e-bottom-icon-btn"
      ];
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.split(" "));
      }
      _super.prototype.destroy.call(this);
      removeClass([this.element], classList2);
      if (!this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      if (this.disabled) {
        this.element.removeAttribute("disabled");
      }
      if (this.content) {
        this.element.innerHTML = this.element.innerHTML.replace(this.content, "");
      }
      var span = this.element.querySelector("span.e-btn-icon");
      if (span) {
        detach(span);
      }
      this.unWireEvents();
      if (isRippleEnabled) {
        this.removeRippleEffect();
      }
    };
    Button2.prototype.getModuleName = function() {
      return "btn";
    };
    Button2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Button2.Inject = function() {
    };
    Button2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var span = this.element.querySelector("span.e-btn-icon");
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "isPrimary":
            if (newProp.isPrimary) {
              this.element.classList.add(cssClassName.PRIMARY);
            } else {
              this.element.classList.remove(cssClassName.PRIMARY);
            }
            break;
          case "disabled":
            this.controlStatus(newProp.disabled);
            break;
          case "iconCss": {
            span = this.element.querySelector("span.e-btn-icon");
            if (span) {
              if (newProp.iconCss) {
                span.className = "e-btn-icon " + newProp.iconCss;
                if (this.element.textContent.trim()) {
                  if (this.iconPosition === "Left") {
                    span.classList.add("e-icon-left");
                  } else {
                    span.classList.add("e-icon-right");
                  }
                }
              } else {
                detach(span);
              }
            } else {
              this.setIconCss();
            }
            break;
          }
          case "iconPosition":
            removeClass([this.element], ["e-top-icon-btn", "e-bottom-icon-btn"]);
            span = this.element.querySelector("span.e-btn-icon");
            if (span) {
              detach(span);
            }
            this.setIconCss();
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.element.classList.add(cssClassName.RTL);
            } else {
              this.element.classList.remove(cssClassName.RTL);
            }
            break;
          case "content": {
            var node = getTextNode(this.element);
            if (!node) {
              this.element.classList.remove(cssClassName.ICONBTN);
            }
            if (!isBlazor() || isBlazor() && !this.isServerRendered && this.getModuleName() !== "progress-btn") {
              if (this.enableHtmlSanitizer) {
                newProp.content = SanitizeHtmlHelper.sanitize(newProp.content);
              }
              this.element.innerHTML = newProp.content;
              this.setIconCss();
            }
            break;
          }
          case "isToggle":
            if (newProp.isToggle) {
              EventHandler.add(this.element, "click", this.btnClickHandler, this);
            } else {
              EventHandler.remove(this.element, "click", this.btnClickHandler);
              removeClass([this.element], ["e-active"]);
            }
            break;
        }
      }
    };
    Button2.prototype.click = function() {
      this.element.click();
    };
    Button2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate3([
      Property("Left")
    ], Button2.prototype, "iconPosition", void 0);
    __decorate3([
      Property("")
    ], Button2.prototype, "iconCss", void 0);
    __decorate3([
      Property(false)
    ], Button2.prototype, "disabled", void 0);
    __decorate3([
      Property(false)
    ], Button2.prototype, "isPrimary", void 0);
    __decorate3([
      Property("")
    ], Button2.prototype, "cssClass", void 0);
    __decorate3([
      Property("")
    ], Button2.prototype, "content", void 0);
    __decorate3([
      Property(false)
    ], Button2.prototype, "isToggle", void 0);
    __decorate3([
      Property()
    ], Button2.prototype, "locale", void 0);
    __decorate3([
      Property(true)
    ], Button2.prototype, "enableHtmlSanitizer", void 0);
    __decorate3([
      Event()
    ], Button2.prototype, "created", void 0);
    Button2 = __decorate3([
      NotifyPropertyChanges
    ], Button2);
    return Button2;
  }(Component)
);

// node_modules/@syncfusion/ej2-buttons/src/check-box/check-box.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CHECK = "e-check";
var DISABLED = "e-checkbox-disabled";
var FRAME = "e-frame";
var INDETERMINATE = "e-stop";
var LABEL = "e-label";
var RIPPLE = "e-ripple-container";
var RIPPLECHECK = "e-ripple-check";
var RIPPLEINDETERMINATE = "e-ripple-stop";
var RTL = "e-rtl";
var WRAPPER = "e-checkbox-wrapper";
var containerAttr = ["title", "class", "style", "disabled", "readonly", "name", "value", "id", "tabindex"];
var CheckBox = (
  /** @class */
  function(_super) {
    __extends3(CheckBox2, _super);
    function CheckBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isFocused = false;
      _this.isMouseClick = false;
      _this.clickTriggered = false;
      _this.validCheck = true;
      return _this;
    }
    CheckBox2.prototype.changeState = function(state, isInitialize) {
      var wrapper = this.getWrapper();
      var rippleSpan = null;
      var frameSpan = null;
      if (wrapper) {
        frameSpan = wrapper.getElementsByClassName(FRAME)[0];
        if (isRippleEnabled) {
          rippleSpan = wrapper.getElementsByClassName(RIPPLE)[0];
        }
      }
      if (state === "check") {
        if (frameSpan) {
          frameSpan.classList.remove(INDETERMINATE);
          frameSpan.classList.add(CHECK);
        }
        if (rippleSpan) {
          rippleSpan.classList.remove(RIPPLEINDETERMINATE);
          rippleSpan.classList.add(RIPPLECHECK);
        }
        this.element.checked = true;
        if ((this.element.required || closest(this.element, "form") && closest(this.element, "form").classList.contains("e-formvalidator")) && this.validCheck && !isInitialize) {
          this.element.checked = false;
          this.validCheck = false;
        } else if (this.element.required || closest(this.element, "form") && closest(this.element, "form").classList.contains("e-formvalidator")) {
          this.validCheck = true;
        }
      } else if (state === "uncheck") {
        if (frameSpan) {
          removeClass([frameSpan], [CHECK, INDETERMINATE]);
        }
        if (rippleSpan) {
          removeClass([rippleSpan], [RIPPLECHECK, RIPPLEINDETERMINATE]);
        }
        this.element.checked = false;
        if ((this.element.required || closest(this.element, "form") && closest(this.element, "form").classList.contains("e-formvalidator")) && this.validCheck && !isInitialize) {
          this.element.checked = true;
          this.validCheck = false;
        } else if (this.element.required || closest(this.element, "form") && closest(this.element, "form").classList.contains("e-formvalidator")) {
          this.validCheck = true;
        }
      } else {
        if (frameSpan) {
          frameSpan.classList.remove(CHECK);
          frameSpan.classList.add(INDETERMINATE);
        }
        if (rippleSpan) {
          rippleSpan.classList.remove(RIPPLECHECK);
          rippleSpan.classList.add(RIPPLEINDETERMINATE);
        }
        this.element.indeterminate = true;
        this.indeterminate = true;
      }
    };
    CheckBox2.prototype.clickHandler = function(event) {
      if (event.target.tagName === "INPUT" && this.clickTriggered) {
        if (this.isVue) {
          this.changeState(this.checked ? "check" : "uncheck");
        }
        this.clickTriggered = false;
        return;
      }
      if (event.target.tagName === "SPAN" || event.target.tagName === "LABEL" || closest(event.target, ".e-label")) {
        this.clickTriggered = true;
      }
      if (this.isMouseClick) {
        this.focusOutHandler();
        this.isMouseClick = false;
      }
      if (this.indeterminate) {
        this.changeState(this.checked ? "check" : "uncheck");
        this.indeterminate = false;
        this.element.indeterminate = false;
      } else if (this.checked) {
        this.changeState("uncheck");
        this.checked = false;
      } else {
        this.changeState("check");
        this.checked = true;
      }
      var changeEventArgs = { checked: this.updateVueArrayModel(false), event };
      this.trigger("change", changeEventArgs);
      event.stopPropagation();
    };
    CheckBox2.prototype.destroy = function() {
      var _this = this;
      var wrapper = this.getWrapper();
      _super.prototype.destroy.call(this);
      if (this.wrapper) {
        wrapper = this.wrapper;
        if (!this.disabled) {
          this.unWireEvents();
        }
        if (this.tagName === "INPUT") {
          if (this.getWrapper() && wrapper.parentNode) {
            wrapper.parentNode.insertBefore(this.element, wrapper);
          }
          detach(wrapper);
          this.element.checked = false;
          if (this.indeterminate) {
            this.element.indeterminate = false;
          }
          ["name", "value", "disabled"].forEach(function(key) {
            _this.element.removeAttribute(key);
          });
        } else {
          ["class"].forEach(function(key) {
            wrapper.removeAttribute(key);
          });
          wrapper.innerHTML = "";
          this.element = wrapper;
          if (this.refreshing) {
            ["e-control", "e-checkbox", "e-lib"].forEach(function(key) {
              _this.element.classList.add(key);
            });
            setValue("ej2_instances", [this], this.element);
          }
        }
      }
    };
    CheckBox2.prototype.focusHandler = function() {
      this.isFocused = true;
    };
    CheckBox2.prototype.focusOutHandler = function() {
      var wrapper = this.getWrapper();
      if (wrapper) {
        wrapper.classList.remove("e-focus");
      }
      this.isFocused = false;
    };
    CheckBox2.prototype.getModuleName = function() {
      return "checkbox";
    };
    CheckBox2.prototype.getPersistData = function() {
      return this.addOnPersist(["checked", "indeterminate"]);
    };
    CheckBox2.prototype.getWrapper = function() {
      if (this.element && this.element.parentElement) {
        return this.element.parentElement.parentElement;
      } else {
        return null;
      }
    };
    CheckBox2.prototype.getLabel = function() {
      if (this.element) {
        return this.element.parentElement;
      } else {
        return null;
      }
    };
    CheckBox2.prototype.initialize = function() {
      if (isNullOrUndefined(this.initialCheckedValue)) {
        this.initialCheckedValue = this.checked;
      }
      if (this.name) {
        this.element.setAttribute("name", this.name);
      }
      if (this.value) {
        this.element.setAttribute("value", this.value);
        if (this.isVue && typeof this.value === "boolean" && this.value === true) {
          this.setProperties({ "checked": true }, true);
        }
      }
      if (this.checked) {
        this.changeState("check", true);
      }
      if (this.indeterminate) {
        this.changeState();
      }
      if (this.disabled) {
        this.setDisabled();
      }
    };
    CheckBox2.prototype.initWrapper = function() {
      var wrapper = this.element.parentElement;
      if (!wrapper.classList.contains(WRAPPER)) {
        wrapper = this.createElement("div", {
          className: WRAPPER
        });
        if (this.element.parentNode) {
          this.element.parentNode.insertBefore(wrapper, this.element);
        }
      }
      var label = this.createElement("label", { attrs: { for: this.element.id } });
      var frameSpan = this.createElement("span", { className: "e-icons " + FRAME });
      wrapper.classList.add("e-wrapper");
      if (this.enableRtl) {
        wrapper.classList.add(RTL);
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      wrapper.appendChild(label);
      label.appendChild(this.element);
      setHiddenInput(this, label);
      label.appendChild(frameSpan);
      if (isRippleEnabled) {
        var rippleSpan = this.createElement("span", { className: RIPPLE });
        if (this.labelPosition === "Before") {
          label.appendChild(rippleSpan);
        } else {
          label.insertBefore(rippleSpan, frameSpan);
        }
        rippleEffect(rippleSpan, { duration: 400, isCenterRipple: true });
      }
      if (this.label) {
        this.setText(this.label);
      }
    };
    CheckBox2.prototype.keyUpHandler = function() {
      if (this.isFocused) {
        this.getWrapper().classList.add("e-focus");
      }
    };
    CheckBox2.prototype.labelMouseDownHandler = function(e) {
      this.isMouseClick = true;
      var rippleSpan = this.getWrapper().getElementsByClassName(RIPPLE)[0];
      rippleMouseHandler(e, rippleSpan);
    };
    CheckBox2.prototype.labelMouseLeaveHandler = function(e) {
      var rippleSpan = this.getLabel().getElementsByClassName(RIPPLE)[0];
      if (rippleSpan) {
        var rippleElem = rippleSpan.querySelectorAll(".e-ripple-element");
        for (var i = rippleElem.length - 1; i > 0; i--) {
          rippleSpan.removeChild(rippleSpan.childNodes[i]);
        }
        rippleMouseHandler(e, rippleSpan);
      }
    };
    CheckBox2.prototype.labelMouseUpHandler = function(e) {
      this.isMouseClick = true;
      var rippleSpan = this.getWrapper().getElementsByClassName(RIPPLE)[0];
      if (rippleSpan) {
        var rippleElem = rippleSpan.querySelectorAll(".e-ripple-element");
        for (var i = 0; i < rippleElem.length - 1; i++) {
          rippleSpan.removeChild(rippleSpan.childNodes[i]);
        }
        rippleMouseHandler(e, rippleSpan);
      }
    };
    CheckBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var wrapper = this.getWrapper();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "checked":
            this.indeterminate = false;
            this.element.indeterminate = false;
            this.changeState(newProp.checked ? "check" : "uncheck");
            break;
          case "indeterminate":
            if (newProp.indeterminate) {
              this.changeState();
            } else {
              this.element.indeterminate = false;
              this.changeState(this.checked ? "check" : "uncheck");
            }
            break;
          case "disabled":
            if (newProp.disabled) {
              this.setDisabled();
              this.wrapper = this.getWrapper();
              this.unWireEvents();
            } else {
              this.element.disabled = false;
              wrapper.classList.remove(DISABLED);
              wrapper.setAttribute("aria-disabled", "false");
              this.wireEvents();
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([wrapper], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([wrapper], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              wrapper.classList.add(RTL);
            } else {
              wrapper.classList.remove(RTL);
            }
            break;
          case "label":
            this.setText(newProp.label);
            break;
          case "labelPosition": {
            var label = wrapper.getElementsByClassName(LABEL)[0];
            var labelWrap = wrapper.getElementsByTagName("label")[0];
            detach(label);
            if (newProp.labelPosition === "After") {
              labelWrap.appendChild(label);
            } else {
              labelWrap.insertBefore(label, wrapper.getElementsByClassName(FRAME)[0]);
            }
            break;
          }
          case "name":
            this.element.setAttribute("name", newProp.name);
            break;
          case "value":
            if (this.isVue && typeof newProp.value === "object") {
              break;
            }
            this.element.setAttribute("value", newProp.value);
            break;
          case "htmlAttributes":
            this.updateHtmlAttributeToWrapper();
            break;
        }
      }
    };
    CheckBox2.prototype.preRender = function() {
      var element2 = this.element;
      this.tagName = this.element.tagName;
      element2 = wrapperInitialize(this.createElement, "EJS-CHECKBOX", "checkbox", element2, WRAPPER, "checkbox");
      this.element = element2;
      if (this.element.getAttribute("type") !== "checkbox") {
        this.element.setAttribute("type", "checkbox");
      }
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
    };
    CheckBox2.prototype.render = function() {
      this.initWrapper();
      this.initialize();
      if (!this.disabled) {
        this.wireEvents();
      }
      this.updateHtmlAttributeToWrapper();
      this.updateVueArrayModel(true);
      this.renderComplete();
      this.wrapper = this.getWrapper();
    };
    CheckBox2.prototype.setDisabled = function() {
      var wrapper = this.getWrapper();
      this.element.disabled = true;
      wrapper.classList.add(DISABLED);
      wrapper.setAttribute("aria-disabled", "true");
    };
    CheckBox2.prototype.setText = function(text) {
      var wrapper = this.getWrapper();
      if (!wrapper) {
        return;
      }
      var label = wrapper.getElementsByClassName(LABEL)[0];
      if (label) {
        label.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(text) : text;
      } else {
        text = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(text) : text;
        label = this.createElement("span", { className: LABEL, innerHTML: text });
        var labelWrap = wrapper.getElementsByTagName("label")[0];
        if (this.labelPosition === "Before") {
          labelWrap.insertBefore(label, wrapper.getElementsByClassName(FRAME)[0]);
        } else {
          labelWrap.appendChild(label);
        }
      }
    };
    CheckBox2.prototype.changeHandler = function(e) {
      e.stopPropagation();
    };
    CheckBox2.prototype.formResetHandler = function() {
      this.checked = this.initialCheckedValue;
      this.element.checked = this.initialCheckedValue;
    };
    CheckBox2.prototype.unWireEvents = function() {
      var wrapper = this.wrapper;
      EventHandler.remove(wrapper, "click", this.clickHandler);
      EventHandler.remove(this.element, "keyup", this.keyUpHandler);
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "focusout", this.focusOutHandler);
      var label = wrapper.getElementsByTagName("label")[0];
      if (label) {
        EventHandler.remove(label, "mousedown", this.labelMouseDownHandler);
        EventHandler.remove(label, "mouseup", this.labelMouseUpHandler);
        EventHandler.remove(label, "mouseleave", this.labelMouseLeaveHandler);
      }
      var formElem = closest(this.element, "form");
      if (formElem) {
        EventHandler.remove(formElem, "reset", this.formResetHandler);
      }
      if (this.tagName === "EJS-CHECKBOX") {
        EventHandler.remove(this.element, "change", this.changeHandler);
      }
    };
    CheckBox2.prototype.wireEvents = function() {
      var wrapper = this.getWrapper();
      EventHandler.add(wrapper, "click", this.clickHandler, this);
      EventHandler.add(this.element, "keyup", this.keyUpHandler, this);
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "focusout", this.focusOutHandler, this);
      var label = wrapper.getElementsByTagName("label")[0];
      EventHandler.add(label, "mousedown", this.labelMouseDownHandler, this);
      EventHandler.add(label, "mouseup", this.labelMouseUpHandler, this);
      EventHandler.add(label, "mouseleave", this.labelMouseLeaveHandler, this);
      var formElem = closest(this.element, "form");
      if (formElem) {
        EventHandler.add(formElem, "reset", this.formResetHandler, this);
      }
      if (this.tagName === "EJS-CHECKBOX") {
        EventHandler.add(this.element, "change", this.changeHandler, this);
      }
    };
    CheckBox2.prototype.updateVueArrayModel = function(init) {
      if (this.isVue && typeof this.value === "object") {
        var value = this.element.value;
        if (value && this.value) {
          if (init) {
            for (var i = 0; i < this.value.length; i++) {
              if (value === this.value[i]) {
                this.changeState("check");
                this.setProperties({ "checked": true }, true);
              }
            }
          } else {
            var index = this.value.indexOf(value);
            if (this.checked) {
              if (index < 0) {
                this.value.push(value);
              }
            } else {
              if (index > -1) {
                this.value.splice(index, 1);
              }
            }
            return this.value;
          }
        }
      }
      return this.validCheck ? this.element.checked : !this.element.checked;
    };
    CheckBox2.prototype.updateHtmlAttributeToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          var wrapper = this.getWrapper();
          if (containerAttr.indexOf(key) > -1) {
            if (key === "class") {
              addClass([wrapper], this.htmlAttributes["" + key].split(" "));
            } else if (key === "title") {
              wrapper.setAttribute(key, this.htmlAttributes["" + key]);
            } else if (key === "style") {
              var frameSpan = this.getWrapper().getElementsByClassName(FRAME)[0];
              frameSpan.setAttribute(key, this.htmlAttributes["" + key]);
            } else if (key === "disabled") {
              if (this.htmlAttributes["" + key] === "true") {
                this.setDisabled();
              }
              this.element.setAttribute(key, this.htmlAttributes["" + key]);
            } else {
              this.element.setAttribute(key, this.htmlAttributes["" + key]);
            }
          } else {
            wrapper.setAttribute(key, this.htmlAttributes["" + key]);
          }
        }
      }
    };
    CheckBox2.prototype.click = function() {
      this.element.click();
    };
    CheckBox2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate4([
      Event()
    ], CheckBox2.prototype, "change", void 0);
    __decorate4([
      Event()
    ], CheckBox2.prototype, "created", void 0);
    __decorate4([
      Property(false)
    ], CheckBox2.prototype, "checked", void 0);
    __decorate4([
      Property("")
    ], CheckBox2.prototype, "cssClass", void 0);
    __decorate4([
      Property(false)
    ], CheckBox2.prototype, "disabled", void 0);
    __decorate4([
      Property(false)
    ], CheckBox2.prototype, "indeterminate", void 0);
    __decorate4([
      Property("")
    ], CheckBox2.prototype, "label", void 0);
    __decorate4([
      Property("After")
    ], CheckBox2.prototype, "labelPosition", void 0);
    __decorate4([
      Property("")
    ], CheckBox2.prototype, "name", void 0);
    __decorate4([
      Property("")
    ], CheckBox2.prototype, "value", void 0);
    __decorate4([
      Property(true)
    ], CheckBox2.prototype, "enableHtmlSanitizer", void 0);
    __decorate4([
      Property({})
    ], CheckBox2.prototype, "htmlAttributes", void 0);
    CheckBox2 = __decorate4([
      NotifyPropertyChanges
    ], CheckBox2);
    return CheckBox2;
  }(Component)
);

// node_modules/@syncfusion/ej2-buttons/src/radio-button/radio-button.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LABEL2 = "e-label";
var RIPPLE2 = "e-ripple-container";
var RTL2 = "e-rtl";
var WRAPPER2 = "e-radio-wrapper";
var ATTRIBUTES = ["title", "class", "style", "disabled", "readonly", "name", "value", "id"];
var RadioButton = (
  /** @class */
  function(_super) {
    __extends4(RadioButton2, _super);
    function RadioButton2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isFocused = false;
      return _this;
    }
    RadioButton_1 = RadioButton2;
    RadioButton2.prototype.changeHandler = function(event) {
      this.checked = true;
      this.dataBind();
      var value = this.element.getAttribute("value");
      value = this.isVue && value ? this.element.value : this.value;
      var type = typeof this.value;
      if (this.isVue && type === "boolean") {
        value = value === "true" ? true : false;
      }
      this.trigger("change", { value, event });
      if (this.isAngular) {
        event.stopPropagation();
      }
    };
    RadioButton2.prototype.updateChange = function() {
      var input;
      var instance;
      var radioGrp = this.getRadioGroup();
      for (var i = 0; i < radioGrp.length; i++) {
        input = radioGrp[i];
        if (input !== this.element) {
          instance = getInstance(input, RadioButton_1);
          instance.checked = false;
          if (this.tagName === "EJS-RADIOBUTTON") {
            instance.angularValue = this.value;
          }
        }
      }
    };
    RadioButton2.prototype.destroy = function() {
      var _this = this;
      var radioWrap = this.wrapper;
      _super.prototype.destroy.call(this);
      if (radioWrap) {
        if (!this.disabled) {
          this.unWireEvents();
        }
        if (this.tagName === "INPUT") {
          if (radioWrap.parentNode) {
            radioWrap.parentNode.insertBefore(this.element, radioWrap);
          }
          detach(radioWrap);
          this.element.checked = false;
          ["name", "value", "disabled"].forEach(function(key) {
            _this.element.removeAttribute(key);
          });
        } else {
          ["role", "aria-checked", "class"].forEach(function(key) {
            radioWrap.removeAttribute(key);
          });
          radioWrap.innerHTML = "";
          this.element = this.wrapper;
          if (this.refreshing) {
            ["e-control", "e-radio", "e-lib"].forEach(function(key) {
              _this.element.classList.add(key);
            });
            setValue("ej2_instances", [this], this.element);
          }
        }
      }
    };
    RadioButton2.prototype.focusHandler = function() {
      this.isFocused = true;
    };
    RadioButton2.prototype.focusOutHandler = function() {
      var label = this.getLabel();
      if (label) {
        label.classList.remove("e-focus");
      }
    };
    RadioButton2.prototype.getModuleName = function() {
      return "radio";
    };
    RadioButton2.prototype.getSelectedValue = function() {
      var input;
      var radioGrp = this.getRadioGroup();
      for (var i = 0, len = radioGrp.length; i < len; i++) {
        input = radioGrp[i];
        if (input.checked) {
          return input.value;
        }
      }
      return "";
    };
    RadioButton2.prototype.getRadioGroup = function() {
      return document.querySelectorAll('input.e-radio[name="' + this.element.getAttribute("name") + '"]');
    };
    RadioButton2.prototype.getPersistData = function() {
      return this.addOnPersist(["checked"]);
    };
    RadioButton2.prototype.getWrapper = function() {
      if (this.element.parentElement) {
        return this.element.parentElement;
      } else {
        return null;
      }
    };
    RadioButton2.prototype.getLabel = function() {
      if (this.element.nextElementSibling) {
        return this.element.nextElementSibling;
      } else {
        return null;
      }
    };
    RadioButton2.prototype.initialize = function() {
      if (isNullOrUndefined(this.initialCheckedValue)) {
        this.initialCheckedValue = this.checked;
      }
      this.initWrapper();
      this.updateHtmlAttribute();
      if (this.name) {
        this.element.setAttribute("name", this.name);
      }
      var value = this.element.getAttribute("value");
      var type = typeof this.value;
      if (this.isVue && type === "boolean") {
        value = value === "true" ? true : false;
      }
      if (this.isVue ? this.value && type !== "boolean" && !value : this.value) {
        this.element.setAttribute("value", this.value);
      }
      if (this.checked) {
        this.element.checked = true;
      }
      if (this.disabled) {
        this.setDisabled();
      }
    };
    RadioButton2.prototype.initWrapper = function() {
      var rippleSpan;
      var wrapper = this.element.parentElement;
      if (!wrapper.classList.contains(WRAPPER2)) {
        wrapper = this.createElement("div", { className: WRAPPER2 });
        if (this.element.parentNode) {
          this.element.parentNode.insertBefore(wrapper, this.element);
        }
      }
      var label = this.createElement("label", { attrs: { for: this.element.id } });
      wrapper.appendChild(this.element);
      wrapper.appendChild(label);
      if (isRippleEnabled) {
        rippleSpan = this.createElement("span", { className: RIPPLE2 });
        label.appendChild(rippleSpan);
        rippleEffect(rippleSpan, {
          duration: 400,
          isCenterRipple: true
        });
      }
      wrapper.classList.add("e-wrapper");
      if (this.enableRtl) {
        label.classList.add(RTL2);
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.label) {
        this.setText(this.label);
      }
    };
    RadioButton2.prototype.keyUpHandler = function() {
      if (this.isFocused) {
        this.getLabel().classList.add("e-focus");
      }
    };
    RadioButton2.prototype.labelMouseDownHandler = function(e) {
      var rippleSpan = this.getLabel().getElementsByClassName(RIPPLE2)[0];
      rippleMouseHandler(e, rippleSpan);
    };
    RadioButton2.prototype.labelMouseLeaveHandler = function(e) {
      var rippleSpan = this.getLabel().getElementsByClassName(RIPPLE2)[0];
      if (rippleSpan) {
        var rippleElem = rippleSpan.querySelectorAll(".e-ripple-element");
        for (var i = rippleElem.length - 1; i > 0; i--) {
          rippleSpan.removeChild(rippleSpan.childNodes[i]);
        }
        rippleMouseHandler(e, rippleSpan);
      }
    };
    RadioButton2.prototype.labelMouseUpHandler = function(e) {
      var rippleSpan = this.getLabel().getElementsByClassName(RIPPLE2)[0];
      if (rippleSpan) {
        var rippleElem = rippleSpan.querySelectorAll(".e-ripple-element");
        for (var i = rippleElem.length - 1; i > 0; i--) {
          rippleSpan.removeChild(rippleSpan.childNodes[i]);
        }
        rippleMouseHandler(e, rippleSpan);
      }
    };
    RadioButton2.prototype.formResetHandler = function() {
      this.checked = this.initialCheckedValue;
      if (this.initialCheckedValue) {
        attributes(this.element, { "checked": "true" });
      }
    };
    RadioButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var wrap = this.getWrapper();
      var label = this.getLabel();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "checked":
            if (newProp.checked) {
              this.updateChange();
            }
            this.element.checked = newProp.checked;
            break;
          case "disabled":
            if (newProp.disabled) {
              this.setDisabled();
              this.unWireEvents();
            } else {
              this.element.disabled = false;
              this.wireEvents();
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([wrap], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([wrap], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              label.classList.add(RTL2);
            } else {
              label.classList.remove(RTL2);
            }
            break;
          case "label":
            this.setText(newProp.label);
            break;
          case "labelPosition":
            if (newProp.labelPosition === "Before") {
              label.classList.add("e-right");
            } else {
              label.classList.remove("e-right");
            }
            break;
          case "name":
            this.element.setAttribute("name", newProp.name);
            break;
          case "value":
            var type = typeof this.htmlAttributes.value;
            if (!isNullOrUndefined(this.htmlAttributes) && (this.htmlAttributes.value || type === "boolean" && !this.htmlAttributes.value)) {
              break;
            }
            this.element.setAttribute("value", newProp.value);
            break;
          case "htmlAttributes":
            this.updateHtmlAttribute();
            break;
        }
      }
    };
    RadioButton2.prototype.preRender = function() {
      var element2 = this.element;
      this.formElement = closest(this.element, "form");
      this.tagName = this.element.tagName;
      element2 = wrapperInitialize(this.createElement, "EJS-RADIOBUTTON", "radio", element2, WRAPPER2, "radio");
      this.element = element2;
      if (this.element.getAttribute("type") !== "radio") {
        this.element.setAttribute("type", "radio");
      }
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      if (this.tagName === "EJS-RADIOBUTTON") {
        var formControlName = this.element.getAttribute("formcontrolname");
        if (formControlName) {
          this.setProperties({ "name": formControlName }, true);
          this.element.setAttribute("name", formControlName);
        }
      }
    };
    RadioButton2.prototype.render = function() {
      this.initialize();
      if (!this.disabled) {
        this.wireEvents();
      }
      this.renderComplete();
      this.wrapper = this.getWrapper();
    };
    RadioButton2.prototype.setDisabled = function() {
      this.element.disabled = true;
    };
    RadioButton2.prototype.setText = function(text) {
      var label = this.getLabel();
      var textLabel = label.getElementsByClassName(LABEL2)[0];
      if (textLabel) {
        textLabel.textContent = text;
      } else {
        text = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(text) : text;
        textLabel = this.createElement("span", { className: LABEL2, innerHTML: text });
        label.appendChild(textLabel);
      }
      if (this.labelPosition === "Before") {
        this.getLabel().classList.add("e-right");
      } else {
        this.getLabel().classList.remove("e-right");
      }
    };
    RadioButton2.prototype.updateHtmlAttribute = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          var wrapper = this.element.parentElement;
          if (ATTRIBUTES.indexOf(key) > -1) {
            if (key === "class") {
              addClass([wrapper], this.htmlAttributes["" + key].replace(/\s+/g, " ").trim().split(" "));
            } else if (key === "title" || key === "style") {
              wrapper.setAttribute(key, this.htmlAttributes["" + key]);
            } else {
              this.element.setAttribute(key, this.htmlAttributes["" + key]);
            }
          } else {
            wrapper.setAttribute(key, this.htmlAttributes["" + key]);
          }
        }
      }
    };
    RadioButton2.prototype.unWireEvents = function() {
      var label = this.wrapper;
      EventHandler.remove(this.element, "change", this.changeHandler);
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "focusout", this.focusOutHandler);
      EventHandler.remove(this.element, "keyup", this.keyUpHandler);
      var rippleLabel = label.getElementsByTagName("label")[0];
      if (rippleLabel) {
        EventHandler.remove(rippleLabel, "mousedown", this.labelMouseDownHandler);
        EventHandler.remove(rippleLabel, "mouseup", this.labelMouseUpHandler);
        EventHandler.remove(rippleLabel, "mouseleave", this.labelMouseLeaveHandler);
      }
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    RadioButton2.prototype.wireEvents = function() {
      var label = this.getLabel();
      EventHandler.add(this.element, "change", this.changeHandler, this);
      EventHandler.add(this.element, "keyup", this.keyUpHandler, this);
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "focusout", this.focusOutHandler, this);
      var rippleLabel = label.getElementsByClassName(LABEL2)[0];
      if (rippleLabel) {
        EventHandler.add(rippleLabel, "mousedown", this.labelMouseDownHandler, this);
        EventHandler.add(rippleLabel, "mouseup", this.labelMouseUpHandler, this);
        EventHandler.add(rippleLabel, "mouseleave", this.labelMouseLeaveHandler, this);
      }
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
    };
    RadioButton2.prototype.click = function() {
      this.element.click();
    };
    RadioButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    var RadioButton_1;
    __decorate5([
      Event()
    ], RadioButton2.prototype, "change", void 0);
    __decorate5([
      Event()
    ], RadioButton2.prototype, "created", void 0);
    __decorate5([
      Property(false)
    ], RadioButton2.prototype, "checked", void 0);
    __decorate5([
      Property("")
    ], RadioButton2.prototype, "cssClass", void 0);
    __decorate5([
      Property(false)
    ], RadioButton2.prototype, "disabled", void 0);
    __decorate5([
      Property("")
    ], RadioButton2.prototype, "label", void 0);
    __decorate5([
      Property("After")
    ], RadioButton2.prototype, "labelPosition", void 0);
    __decorate5([
      Property("")
    ], RadioButton2.prototype, "name", void 0);
    __decorate5([
      Property("")
    ], RadioButton2.prototype, "value", void 0);
    __decorate5([
      Property(true)
    ], RadioButton2.prototype, "enableHtmlSanitizer", void 0);
    __decorate5([
      Property({})
    ], RadioButton2.prototype, "htmlAttributes", void 0);
    RadioButton2 = RadioButton_1 = __decorate5([
      NotifyPropertyChanges
    ], RadioButton2);
    return RadioButton2;
  }(Component)
);

// node_modules/@syncfusion/ej2-buttons/src/switch/switch.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DISABLED2 = "e-switch-disabled";
var RIPPLE3 = "e-ripple-container";
var RIPPLE_CHECK = "e-ripple-check";
var RTL3 = "e-rtl";
var WRAPPER3 = "e-switch-wrapper";
var ACTIVE = "e-switch-active";
var ATTRIBUTES2 = ["title", "class", "style", "disabled", "readonly", "name", "value", "aria-label", "id", "role", "tabindex"];
var Switch = (
  /** @class */
  function(_super) {
    __extends5(Switch2, _super);
    function Switch2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isFocused = false;
      _this.isDrag = false;
      _this.isWireEvents = false;
      return _this;
    }
    Switch2.prototype.changeState = function(state) {
      var rippleSpan = null;
      var wrapper = this.getWrapper();
      var bar = wrapper.querySelector(".e-switch-inner");
      var handle = wrapper.querySelector(".e-switch-handle");
      if (isRippleEnabled) {
        rippleSpan = wrapper.getElementsByClassName(RIPPLE3)[0];
      }
      if (state) {
        addClass([bar, handle], ACTIVE);
        this.element.checked = true;
        this.checked = true;
        if (rippleSpan) {
          addClass([rippleSpan], [RIPPLE_CHECK]);
        }
      } else {
        removeClass([bar, handle], ACTIVE);
        this.element.checked = false;
        this.checked = false;
        if (rippleSpan) {
          removeClass([rippleSpan], [RIPPLE_CHECK]);
        }
      }
    };
    Switch2.prototype.clickHandler = function(evt) {
      this.isDrag = false;
      this.focusOutHandler();
      this.changeState(!this.checked);
      this.element.focus();
      var changeEventArgs = { checked: this.element.checked, event: evt };
      this.trigger("change", changeEventArgs);
      if (this.isAngular && evt) {
        evt.stopPropagation();
        evt.preventDefault();
      }
    };
    Switch2.prototype.destroy = function() {
      var _this = this;
      _super.prototype.destroy.call(this);
      if (!this.disabled) {
        this.unWireEvents();
      }
      destroy2(this, this.getWrapper(), this.tagName);
      if (this.refreshing) {
        ["e-control", "e-switch", "e-lib"].forEach(function(key) {
          _this.element.classList.add(key);
        });
        setValue("ej2_instances", [this], this.element);
      }
    };
    Switch2.prototype.focusHandler = function() {
      this.isFocused = true;
    };
    Switch2.prototype.focusOutHandler = function() {
      this.getWrapper().classList.remove("e-focus");
    };
    Switch2.prototype.getModuleName = function() {
      return "switch";
    };
    Switch2.prototype.getPersistData = function() {
      return this.addOnPersist(["checked"]);
    };
    Switch2.prototype.getWrapper = function() {
      if (this.element.parentElement) {
        return this.element.parentElement;
      } else {
        return null;
      }
    };
    Switch2.prototype.initialize = function() {
      this.element.setAttribute("role", "switch");
      if (isNullOrUndefined(this.initialSwitchCheckedValue)) {
        this.initialSwitchCheckedValue = this.checked;
      }
      if (this.name) {
        this.element.setAttribute("name", this.name);
      }
      if (this.value) {
        this.element.setAttribute("value", this.value);
      }
      if (this.checked) {
        this.changeState(true);
      }
      if (this.disabled) {
        this.setDisabled();
      }
      if (this.onLabel || this.offLabel) {
        this.setLabel(this.onLabel, this.offLabel);
      }
    };
    Switch2.prototype.initWrapper = function() {
      var wrapper = this.element.parentElement;
      if (!wrapper.classList.contains(WRAPPER3)) {
        wrapper = this.createElement("div", {
          className: WRAPPER3
        });
        this.element.parentNode.insertBefore(wrapper, this.element);
      }
      var switchInner = this.createElement("span", { className: "e-switch-inner" });
      var onLabel = this.createElement("span", { className: "e-switch-on" });
      var offLabel = this.createElement("span", { className: "e-switch-off" });
      var handle = this.createElement("span", { className: "e-switch-handle" });
      wrapper.appendChild(this.element);
      setHiddenInput(this, wrapper);
      switchInner.appendChild(onLabel);
      switchInner.appendChild(offLabel);
      wrapper.appendChild(switchInner);
      wrapper.appendChild(handle);
      if (isRippleEnabled) {
        var rippleSpan = this.createElement("span", { className: RIPPLE3 });
        handle.appendChild(rippleSpan);
        rippleEffect(rippleSpan, { duration: 400, isCenterRipple: true });
      }
      wrapper.classList.add("e-wrapper");
      if (this.enableRtl) {
        wrapper.classList.add(RTL3);
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
    };
    Switch2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var wrapper = this.getWrapper();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "checked":
            this.changeState(newProp.checked);
            break;
          case "disabled":
            if (newProp.disabled) {
              this.setDisabled();
              this.unWireEvents();
              this.isWireEvents = false;
            } else {
              this.element.disabled = false;
              wrapper.classList.remove(DISABLED2);
              wrapper.setAttribute("aria-disabled", "false");
              if (!this.isWireEvents) {
                this.wireEvents();
                this.isWireEvents = true;
              }
            }
            break;
          case "value":
            this.element.setAttribute("value", newProp.value);
            break;
          case "name":
            this.element.setAttribute("name", newProp.name);
            break;
          case "onLabel":
          case "offLabel":
            this.setLabel(newProp.onLabel, newProp.offLabel);
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              wrapper.classList.add(RTL3);
            } else {
              wrapper.classList.remove(RTL3);
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([wrapper], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([wrapper], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "htmlAttributes":
            this.updateHtmlAttribute();
            break;
        }
      }
    };
    Switch2.prototype.preRender = function() {
      var element2 = this.element;
      this.formElement = closest(this.element, "form");
      this.tagName = this.element.tagName;
      preRender(this, "EJS-SWITCH", WRAPPER3, element2, this.getModuleName());
    };
    Switch2.prototype.render = function() {
      this.initWrapper();
      this.initialize();
      if (!this.disabled) {
        this.wireEvents();
      }
      this.renderComplete();
      this.updateHtmlAttribute();
    };
    Switch2.prototype.rippleHandler = function(e) {
      var rippleSpan = this.getWrapper().getElementsByClassName(RIPPLE3)[0];
      rippleMouseHandler(e, rippleSpan);
      if (e.type === "mousedown" && e.currentTarget.classList.contains("e-switch-wrapper") && e.which === 1) {
        this.isDrag = true;
        this.isFocused = false;
      }
    };
    Switch2.prototype.mouseLeaveHandler = function(e) {
      var rippleSpan = this.element.parentElement.getElementsByClassName(RIPPLE3)[0];
      if (rippleSpan) {
        var rippleElem = rippleSpan.querySelectorAll(".e-ripple-element");
        for (var i = rippleElem.length - 1; i > 0; i--) {
          rippleSpan.removeChild(rippleSpan.childNodes[i]);
        }
        rippleMouseHandler(e, rippleSpan);
      }
    };
    Switch2.prototype.rippleTouchHandler = function(eventType) {
      var rippleSpan = this.getWrapper().getElementsByClassName(RIPPLE3)[0];
      if (rippleSpan) {
        var event_1 = document.createEvent("MouseEvents");
        event_1.initEvent(eventType, false, true);
        rippleSpan.dispatchEvent(event_1);
      }
    };
    Switch2.prototype.setDisabled = function() {
      var wrapper = this.getWrapper();
      this.element.disabled = true;
      wrapper.classList.add(DISABLED2);
      wrapper.setAttribute("aria-disabled", "true");
    };
    Switch2.prototype.setLabel = function(onText, offText) {
      var wrapper = this.getWrapper();
      if (onText) {
        wrapper.querySelector(".e-switch-on").textContent = onText;
      }
      if (offText) {
        wrapper.querySelector(".e-switch-off").textContent = offText;
      }
    };
    Switch2.prototype.updateHtmlAttribute = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          var wrapper = this.getWrapper();
          if (ATTRIBUTES2.indexOf(key) > -1) {
            if (key === "class") {
              addClass([wrapper], this.htmlAttributes["" + key].split(" "));
            } else if (key === "title") {
              wrapper.setAttribute(key, this.htmlAttributes["" + key]);
            } else if (key === "style") {
              wrapper.setAttribute(key, this.htmlAttributes["" + key]);
            } else if (key === "disabled") {
              if (this.htmlAttributes["" + key] === "true") {
                this.setDisabled();
              }
              this.element.setAttribute(key, this.htmlAttributes["" + key]);
            } else {
              this.element.setAttribute(key, this.htmlAttributes["" + key]);
            }
          } else {
            wrapper.setAttribute(key, this.htmlAttributes["" + key]);
          }
        }
      }
    };
    Switch2.prototype.switchFocusHandler = function() {
      if (this.isFocused) {
        this.getWrapper().classList.add("e-focus");
      }
    };
    Switch2.prototype.switchMouseUp = function(e) {
      var aTouchY = 0;
      var yDiff = 0;
      var aTouchX = 0;
      var xDiff = 0;
      var target = e.target;
      if (e.type === "touchmove") {
        e.preventDefault();
        aTouchX = e.changedTouches[0].clientX;
        aTouchY = e.changedTouches[0].clientY;
        xDiff = this.bTouchX - aTouchX;
        yDiff = this.bTouchY - aTouchY;
        if (Math.abs(xDiff) < Math.abs(yDiff)) {
          this.isDrag = false;
          this.rippleTouchHandler("mouseup");
        } else {
          this.isDrag = true;
        }
      }
      if (e.type === "touchstart") {
        this.bTouchX = e.changedTouches[0].clientX;
        this.bTouchY = e.changedTouches[0].clientY;
        this.isDrag = true;
        this.rippleTouchHandler("mousedown");
      }
      if (this.isDrag) {
        if (e.type === "mouseup" && target.className.indexOf("e-switch") < 0 || e.type === "touchend") {
          xDiff = this.bTouchX - e.changedTouches[0].clientX;
          yDiff = this.bTouchY - e.changedTouches[0].clientY;
          if (Math.abs(xDiff) >= Math.abs(yDiff)) {
            this.clickHandler(e);
            this.rippleTouchHandler("mouseup");
            e.preventDefault();
          }
        }
      }
    };
    Switch2.prototype.formResetHandler = function() {
      this.checked = this.initialSwitchCheckedValue;
      this.element.checked = this.initialSwitchCheckedValue;
    };
    Switch2.prototype.toggle = function() {
      this.clickHandler();
    };
    Switch2.prototype.wireEvents = function() {
      var wrapper = this.getWrapper();
      this.delegateMouseUpHandler = this.switchMouseUp.bind(this);
      this.delegateKeyUpHandler = this.switchFocusHandler.bind(this);
      EventHandler.add(wrapper, "click", this.clickHandler, this);
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "focusout", this.focusOutHandler, this);
      EventHandler.add(this.element, "mouseup", this.delegateMouseUpHandler, this);
      EventHandler.add(this.element, "keyup", this.delegateKeyUpHandler, this);
      EventHandler.add(wrapper, "mousedown mouseup", this.rippleHandler, this);
      EventHandler.add(wrapper, "mouseleave", this.mouseLeaveHandler, this);
      EventHandler.add(wrapper, "touchstart touchmove touchend", this.switchMouseUp, this);
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
    };
    Switch2.prototype.unWireEvents = function() {
      var wrapper = this.getWrapper();
      EventHandler.remove(wrapper, "click", this.clickHandler);
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "focusout", this.focusOutHandler);
      EventHandler.remove(this.element, "mouseup", this.delegateMouseUpHandler);
      EventHandler.remove(this.element, "keyup", this.delegateKeyUpHandler);
      EventHandler.remove(wrapper, "mousedown mouseup", this.rippleHandler);
      EventHandler.remove(wrapper, "mouseleave", this.mouseLeaveHandler);
      EventHandler.remove(wrapper, "touchstart touchmove touchend", this.switchMouseUp);
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    Switch2.prototype.click = function() {
      this.element.click();
    };
    Switch2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate6([
      Event()
    ], Switch2.prototype, "change", void 0);
    __decorate6([
      Event()
    ], Switch2.prototype, "created", void 0);
    __decorate6([
      Property(false)
    ], Switch2.prototype, "checked", void 0);
    __decorate6([
      Property("")
    ], Switch2.prototype, "cssClass", void 0);
    __decorate6([
      Property(false)
    ], Switch2.prototype, "disabled", void 0);
    __decorate6([
      Property("")
    ], Switch2.prototype, "name", void 0);
    __decorate6([
      Property("")
    ], Switch2.prototype, "onLabel", void 0);
    __decorate6([
      Property("")
    ], Switch2.prototype, "offLabel", void 0);
    __decorate6([
      Property("")
    ], Switch2.prototype, "value", void 0);
    __decorate6([
      Property({})
    ], Switch2.prototype, "htmlAttributes", void 0);
    Switch2 = __decorate6([
      NotifyPropertyChanges
    ], Switch2);
    return Switch2;
  }(Component)
);

// node_modules/@syncfusion/ej2-buttons/src/chips/chip-list.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var classNames = {
  chipSet: "e-chip-set",
  chip: "e-chip",
  avatar: "e-chip-avatar",
  text: "e-chip-text",
  icon: "e-chip-icon",
  delete: "e-chip-delete",
  deleteIcon: "e-dlt-btn",
  multiSelection: "e-multi-selection",
  singleSelection: "e-selection",
  active: "e-active",
  chipWrapper: "e-chip-avatar-wrap",
  iconWrapper: "e-chip-icon-wrap",
  focused: "e-focused",
  disabled: "e-disabled",
  rtl: "e-rtl"
};
var ChipList = (
  /** @class */
  function(_super) {
    __extends6(ChipList2, _super);
    function ChipList2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.multiSelectedChip = [];
      return _this;
    }
    ChipList2.prototype.preRender = function() {
    };
    ChipList2.prototype.chipType = function() {
      return this.chips && this.chips.length && this.chips.length > 0;
    };
    ChipList2.prototype.render = function() {
      this.type = !isNullOrUndefined(this.chips) && this.chips.length ? "chipset" : this.text || this.element.innerText ? "chip" : "chipset";
      this.setAttributes();
      this.createChip();
      this.setRtl();
      this.select(this.selectedChips);
      this.wireEvent(false);
      this.rippleFunction = rippleEffect(this.element, {
        selector: ".e-chip"
      });
      this.renderComplete();
    };
    ChipList2.prototype.createChip = function() {
      this.innerText = this.element.innerText && this.element.innerText.length !== 0 ? this.element.innerText.trim() : this.element.innerText;
      this.element.innerHTML = "";
      this.chipCreation(this.type === "chip" ? [this.innerText ? this.innerText : this.text] : this.chips);
    };
    ChipList2.prototype.setAttributes = function() {
      if (this.type === "chip") {
        if (this.enabled) {
          this.element.tabIndex = 0;
        }
        this.element.setAttribute("role", "button");
      } else {
        this.element.classList.add(classNames.chipSet);
        this.element.setAttribute("role", "listbox");
        if (this.selection === "Multiple") {
          this.element.classList.add(classNames.multiSelection);
          this.element.setAttribute("aria-multiselectable", "true");
        } else if (this.selection === "Single") {
          this.element.classList.add(classNames.singleSelection);
          this.element.setAttribute("aria-multiselectable", "false");
        } else {
          this.element.setAttribute("aria-multiselectable", "false");
        }
      }
    };
    ChipList2.prototype.setRtl = function() {
      this.element.classList[this.enableRtl ? "add" : "remove"](classNames.rtl);
    };
    ChipList2.prototype.chipCreation = function(data) {
      if (isNullOrUndefined(data)) {
        return;
      }
      var chipListArray = [];
      var attributeArray = [];
      for (var i = 0; i < data.length; i++) {
        var fieldsData = this.getFieldValues(data[i]);
        var attributesValue = fieldsData.htmlAttributes;
        attributeArray.push(attributesValue);
        var chipArray = this.elementCreation(fieldsData);
        var className = (classNames.chip + " " + (fieldsData.enabled ? " " : classNames.disabled) + " " + (fieldsData.avatarIconCss || fieldsData.avatarText ? classNames.chipWrapper : fieldsData.leadingIconCss ? classNames.iconWrapper : " ") + " " + fieldsData.cssClass).split(" ").filter(function(css) {
          return css;
        });
        if (!this.chipType() || this.type === "chip") {
          chipListArray = chipArray;
          addClass([this.element], className);
          this.element.setAttribute("aria-label", fieldsData.text);
          if (fieldsData.value) {
            this.element.setAttribute("data-value", fieldsData.value.toString());
          }
        } else {
          var wrapper = this.createElement("DIV", {
            className: className.join(" "),
            attrs: {
              tabIndex: "0",
              role: "option",
              "aria-label": fieldsData.text,
              "aria-selected": "false"
            }
          });
          if (this.enableDelete) {
            wrapper.setAttribute("aria-keyshortcuts", "Enter to delete");
          }
          if (fieldsData.value) {
            wrapper.setAttribute("data-value", fieldsData.value.toString());
          }
          if (fieldsData.enabled) {
            wrapper.setAttribute("aria-disabled", "false");
          } else {
            wrapper.removeAttribute("tabindex");
            wrapper.setAttribute("aria-disabled", "true");
          }
          if (!isNullOrUndefined(attributeArray[i])) {
            if (attributeArray.length > i && Object.keys(attributeArray[i]).length) {
              var htmlAttr = [];
              htmlAttr = Object.keys(attributeArray[i]);
              for (var j = 0; j < htmlAttr.length; j++) {
                wrapper.setAttribute(htmlAttr[j], attributeArray[i][htmlAttr[j]]);
              }
            }
          }
          append(chipArray, wrapper);
          chipListArray.push(wrapper);
        }
      }
      append(chipListArray, this.element);
    };
    ChipList2.prototype.getFieldValues = function(data) {
      var chipEnabled = !(this.enabled.toString() === "false");
      var fields = {
        text: typeof data === "object" ? data.text ? data.text.toString() : this.text.toString() : !this.chipType() ? this.innerText ? this.innerText : this.text.toString() : data.toString(),
        cssClass: typeof data === "object" ? data.cssClass ? data.cssClass.toString() : this.cssClass.toString() : this.cssClass.toString(),
        leadingIconCss: typeof data === "object" ? data.leadingIconCss ? data.leadingIconCss.toString() : this.leadingIconCss.toString() : this.leadingIconCss.toString(),
        avatarIconCss: typeof data === "object" ? data.avatarIconCss ? data.avatarIconCss.toString() : this.avatarIconCss.toString() : this.avatarIconCss.toString(),
        avatarText: typeof data === "object" ? data.avatarText ? data.avatarText.toString() : this.avatarText.toString() : this.avatarText.toString(),
        trailingIconCss: typeof data === "object" ? data.trailingIconCss ? data.trailingIconCss.toString() : this.trailingIconCss.toString() : this.trailingIconCss.toString(),
        enabled: typeof data === "object" ? data.enabled !== void 0 ? data.enabled.toString() === "false" ? false : true : chipEnabled : chipEnabled,
        value: typeof data === "object" ? data.value ? data.value.toString() : null : null,
        leadingIconUrl: typeof data === "object" ? data.leadingIconUrl ? data.leadingIconUrl.toString() : this.leadingIconUrl : this.leadingIconUrl,
        trailingIconUrl: typeof data === "object" ? data.trailingIconUrl ? data.trailingIconUrl.toString() : this.trailingIconUrl : this.trailingIconUrl,
        htmlAttributes: typeof data === "object" ? data.htmlAttributes ? data.htmlAttributes : this.htmlAttributes : this.htmlAttributes
      };
      return fields;
    };
    ChipList2.prototype.elementCreation = function(fields) {
      var chipArray = [];
      if (fields.avatarText || fields.avatarIconCss) {
        var className = (classNames.avatar + " " + fields.avatarIconCss).trim();
        var chipAvatarElement = this.createElement("span", { className });
        chipAvatarElement.innerText = fields.avatarText;
        chipArray.push(chipAvatarElement);
      } else if (fields.leadingIconCss) {
        var className = (classNames.icon + " " + fields.leadingIconCss).trim();
        var chipIconElement = this.createElement("span", { className });
        chipArray.push(chipIconElement);
      } else if (fields.leadingIconUrl) {
        var className = (classNames.avatar + " image-url").trim();
        var chipIconElement = this.createElement("span", { className });
        chipIconElement.style.backgroundImage = "url(" + fields.leadingIconUrl + ")";
        chipArray.push(chipIconElement);
      }
      var chipTextElement = this.createElement("span", { className: classNames.text });
      chipTextElement.innerText = fields.text;
      chipArray.push(chipTextElement);
      if (fields.trailingIconCss || this.chipType() && this.enableDelete) {
        var className = (classNames.delete + " " + (fields.trailingIconCss ? fields.trailingIconCss : classNames.deleteIcon)).trim();
        var chipdeleteElement = this.createElement("span", { className });
        chipArray.push(chipdeleteElement);
      } else if (fields.trailingIconUrl) {
        var className = "trailing-icon-url".trim();
        var chipIconsElement = this.createElement("span", { className });
        chipIconsElement.style.backgroundImage = "url(" + fields.trailingIconUrl + ")";
        chipArray.push(chipIconsElement);
      }
      return chipArray;
    };
    ChipList2.prototype.find = function(fields) {
      var chipData = { text: "", index: -1, element: this.element, data: "" };
      var chipElement = fields instanceof HTMLElement ? fields : this.element.querySelectorAll("." + classNames.chip)[fields];
      if (chipElement && this.chipType()) {
        chipData.index = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames.chip)).indexOf(chipElement);
        var chip = this.chips[chipData.index];
        if (typeof chip === "object" && chip !== null) {
          var chipModel = chip;
          if (chipModel.text !== void 0) {
            chipData.text = chipModel.text.toString();
          }
        } else if (chip !== void 0) {
          chipData.text = chip.toString();
        }
        chipData.data = chip;
        chipData.element = chipElement;
      }
      return chipData;
    };
    ChipList2.prototype.add = function(chipsData) {
      var _a;
      if (this.type !== "chip") {
        var fieldData = chipsData instanceof Array ? chipsData : [chipsData];
        this.chips = (_a = [].slice.call(this.chips)).concat.apply(_a, fieldData);
        this.chipCreation(fieldData);
      }
    };
    ChipList2.prototype.select = function(fields, selectionType) {
      this.onSelect(fields, false, selectionType);
    };
    ChipList2.prototype.multiSelection = function(newProp) {
      var items = this.element.querySelectorAll(".e-chip");
      for (var j = 0; j < newProp.length; j++) {
        if (typeof newProp[j] === "string") {
          for (var k = 0; k < items.length; k++) {
            if (newProp[j] !== k) {
              if (newProp[j] === items[k].attributes[5].value) {
                this.multiSelectedChip.push(k);
                break;
              }
            }
          }
        } else {
          this.multiSelectedChip.push(newProp[j]);
        }
      }
    };
    ChipList2.prototype.onSelect = function(fields, callFromProperty, selectionType) {
      var index;
      var chipNodes;
      var chipValue = null;
      if (this.chipType() && this.selection !== "None") {
        if (callFromProperty) {
          var chipElements = this.element.querySelectorAll("." + classNames.chip);
          for (var i = 0; i < chipElements.length; i++) {
            chipElements[i].setAttribute("aria-selected", "false");
            chipElements[i].classList.remove(classNames.active);
          }
        }
        var fieldData = fields instanceof Array ? fields : [fields];
        for (var i = 0; i < fieldData.length; i++) {
          var chipElement = fieldData[i] instanceof HTMLElement ? fieldData[i] : this.element.querySelectorAll("." + classNames.chip)[fieldData[i]];
          if (selectionType !== "index") {
            for (var j = 0; j < this.chips.length; j++) {
              chipNodes = this.element.querySelectorAll("." + classNames.chip)[j];
              var fieldsData = this.getFieldValues(this.chips[j]);
              if (selectionType === "value") {
                if (fieldsData.value !== null) {
                  chipValue = chipNodes.dataset.value;
                }
              } else if (selectionType === "text") {
                chipValue = chipNodes.innerText;
              }
              if (chipValue === fieldData[i].toString()) {
                index = j;
                chipElement = this.element.querySelectorAll("." + classNames.chip)[index];
              }
            }
          }
          if (chipElement instanceof HTMLElement) {
            this.selectionHandler(chipElement);
          }
        }
      }
    };
    ChipList2.prototype.remove = function(fields) {
      var _this = this;
      if (this.chipType()) {
        var fieldData = fields instanceof Array ? fields : [fields];
        var chipElements_1 = [];
        var chipCollection_1 = this.element.querySelectorAll("." + classNames.chip);
        fieldData.forEach(function(data) {
          var chipElement = data instanceof HTMLElement ? data : chipCollection_1[data];
          if (chipElement instanceof HTMLElement) {
            chipElements_1.push(chipElement);
          }
        });
        chipElements_1.forEach(function(element2) {
          var chips = _this.element.querySelectorAll("." + classNames.chip);
          var index = Array.prototype.slice.call(chips).indexOf(element2);
          _this.deleteHandler(element2, index);
        });
      }
    };
    ChipList2.prototype.getSelectedChips = function() {
      var selectedChips;
      if (this.chipType() && this.selection !== "None") {
        var selectedItems = { texts: [], Indexes: [], data: [], elements: [] };
        var items = this.element.querySelectorAll("." + classNames.active);
        for (var i = 0; i < items.length; i++) {
          var chip = items[i];
          selectedItems.elements.push(chip);
          var index = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames.chip)).indexOf(chip);
          selectedItems.Indexes.push(index);
          selectedItems.data.push(this.chips[index]);
          var text = typeof this.chips[index] === "object" ? this.chips[index].text ? this.chips[index].text : null : this.chips[index].toString();
          selectedItems.texts.push(text);
        }
        var selectedItem = {
          text: selectedItems.texts[0],
          index: selectedItems.Indexes[0],
          data: selectedItems.data[0],
          element: selectedItems.elements[0]
        };
        selectedChips = !isNullOrUndefined(selectedItem.index) ? this.selection === "Multiple" ? selectedItems : selectedItem : void 0;
      }
      return selectedChips;
    };
    ChipList2.prototype.wireEvent = function(unWireEvent) {
      if (!unWireEvent) {
        EventHandler.add(this.element, "click", this.clickHandler, this);
        EventHandler.add(this.element, "focusout", this.focusOutHandler, this);
        EventHandler.add(this.element, "keydown", this.keyHandler, this);
        EventHandler.add(this.element, "keyup", this.keyHandler, this);
      } else {
        EventHandler.remove(this.element, "click", this.clickHandler);
        EventHandler.remove(this.element, "focusout", this.focusOutHandler);
        EventHandler.remove(this.element, "keydown", this.keyHandler);
        EventHandler.remove(this.element, "keyup", this.keyHandler);
      }
    };
    ChipList2.prototype.keyHandler = function(e) {
      if (e.target.classList.contains(classNames.chip)) {
        if (e.type === "keydown") {
          if (e.keyCode === 13 || e.keyCode === 32) {
            this.clickHandler(e);
          } else if ((e.keyCode === 46 || e.keyCode === 8) && this.enableDelete) {
            this.clickHandler(e, true);
          }
        } else if (e.keyCode === 9) {
          this.focusInHandler(e.target);
        }
      }
    };
    ChipList2.prototype.focusInHandler = function(chipWrapper) {
      if (!chipWrapper.classList.contains(classNames.focused)) {
        chipWrapper.classList.add(classNames.focused);
      }
    };
    ChipList2.prototype.focusOutHandler = function(e) {
      var chipWrapper = closest(e.target, "." + classNames.chip);
      var focusedElement = !this.chipType() ? this.element.classList.contains(classNames.focused) ? this.element : null : this.element.querySelector("." + classNames.focused);
      if (chipWrapper && focusedElement) {
        focusedElement.classList.remove(classNames.focused);
      }
    };
    ChipList2.prototype.clickHandler = function(e, del) {
      var _this = this;
      if (del === void 0) {
        del = false;
      }
      var chipWrapper = closest(e.target, "." + classNames.chip);
      if (chipWrapper) {
        var chipDataArgs = void 0;
        if (this.chipType()) {
          chipDataArgs = this.find(chipWrapper);
        } else {
          var index = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames.chip)).indexOf(chipWrapper);
          chipDataArgs = {
            text: this.innerText ? this.innerText : this.text,
            element: chipWrapper,
            data: this.text,
            index
          };
        }
        chipDataArgs.event = e;
        chipDataArgs.cancel = false;
        this.trigger("beforeClick", chipDataArgs, function(observedArgs) {
          if (!observedArgs.cancel) {
            _this.clickEventHandler(observedArgs.element, e, del);
          }
        });
      }
    };
    ChipList2.prototype.clickEventHandler = function(chipWrapper, e, del) {
      var _this = this;
      if (this.chipType()) {
        var chipData_1 = this.find(chipWrapper);
        chipData_1.event = e;
        var deleteElement = e.target.classList.contains(classNames.deleteIcon) ? e.target : del ? chipWrapper.querySelector("." + classNames.deleteIcon) : void 0;
        if (deleteElement && this.enableDelete) {
          chipData_1.cancel = false;
          var deletedItemArgs = chipData_1;
          this.trigger("delete", deletedItemArgs, function(observedArgs) {
            if (!observedArgs.cancel) {
              _this.deleteHandler(observedArgs.element, observedArgs.index);
              _this.selectionHandler(chipWrapper);
              chipData_1.selected = observedArgs.element.classList.contains(classNames.active);
              var selectedItemArgs2 = chipData_1;
              _this.trigger("click", selectedItemArgs2);
              var chipElement = _this.element.querySelectorAll("." + classNames.chip)[observedArgs.index];
              if (chipElement) {
                chipElement.focus();
                _this.focusInHandler(chipElement);
              }
            }
          });
        } else if (this.selection !== "None") {
          this.selectionHandler(chipWrapper);
          chipData_1.selected = chipWrapper.classList.contains(classNames.active);
          var selectedItemArgs = chipData_1;
          this.trigger("click", selectedItemArgs);
        } else {
          this.focusInHandler(chipWrapper);
          var clickedItemArgs = chipData_1;
          this.trigger("click", clickedItemArgs);
        }
      } else {
        this.focusInHandler(chipWrapper);
        var clickedItemArgs = {
          text: this.innerText ? this.innerText : this.text,
          element: chipWrapper,
          data: this.text,
          event: e
        };
        this.trigger("click", clickedItemArgs);
      }
    };
    ChipList2.prototype.selectionHandler = function(chipWrapper) {
      if (this.selection === "Single") {
        var activeElement = this.element.querySelector("." + classNames.active);
        if (activeElement && activeElement !== chipWrapper) {
          activeElement.classList.remove(classNames.active);
          activeElement.setAttribute("aria-selected", "false");
        }
        this.setProperties({ selectedChips: null }, true);
      } else {
        this.setProperties({ selectedChips: [] }, true);
      }
      if (chipWrapper.classList.contains(classNames.active)) {
        chipWrapper.classList.remove(classNames.active);
        chipWrapper.setAttribute("aria-selected", "false");
      } else {
        chipWrapper.classList.add(classNames.active);
        chipWrapper.setAttribute("aria-selected", "true");
      }
      this.updateSelectedChips();
    };
    ChipList2.prototype.updateSelectedChips = function() {
      var chipListEle = this.element.querySelectorAll(".e-chip");
      var chipCollIndex = [];
      var chipCollValue = [];
      var chip = null;
      var value = null;
      for (var i = 0; i < chipListEle.length; i++) {
        var selectedEle = this.element.querySelectorAll(".e-chip")[i];
        if (selectedEle.getAttribute("aria-selected") === "true") {
          value = selectedEle.getAttribute("data-value");
          if (this.selection === "Single" && selectedEle.classList.contains("e-active")) {
            chip = value ? value : i;
            break;
          } else {
            chip = value ? chipCollValue.push(value) : chipCollIndex.push(i);
          }
        }
      }
      this.setProperties({ selectedChips: this.selection === "Single" ? chip : value ? chipCollValue : chipCollIndex }, true);
    };
    ChipList2.prototype.deleteHandler = function(chipWrapper, index) {
      var deletedChipData = this.find(chipWrapper);
      this.chips.splice(index, 1);
      this.setProperties({ chips: this.chips }, true);
      detach(chipWrapper);
      this.trigger("deleted", deletedChipData);
    };
    ChipList2.prototype.destroy = function() {
      removeClass([this.element], [
        classNames.chipSet,
        classNames.chip,
        classNames.rtl,
        classNames.multiSelection,
        classNames.singleSelection,
        classNames.disabled,
        classNames.chipWrapper,
        classNames.iconWrapper,
        classNames.active,
        classNames.focused
      ].concat(this.cssClass ? this.cssClass.toString().split(" ").filter(function(css) {
        return css;
      }) : []));
      this.removeMultipleAttributes(["tabindex", "role", "aria-label", "aria-multiselectable"], this.element);
      this.wireEvent(true);
      this.rippleFunction();
      _super.prototype.destroy.call(this);
      this.element.innerHTML = "";
      this.element.innerText = this.innerText;
    };
    ChipList2.prototype.removeMultipleAttributes = function(attributes2, element2) {
      attributes2.forEach(function(attr) {
        element2.removeAttribute(attr);
      });
    };
    ChipList2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    ChipList2.prototype.getModuleName = function() {
      return "chip-list";
    };
    ChipList2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "chips":
          case "text":
          case "avatarText":
          case "avatarIconCss":
          case "leadingIconCss":
          case "trailingIconCss":
          case "selection":
          case "enableDelete":
          case "enabled":
            this.refresh();
            break;
          case "cssClass":
            if (!this.chipType()) {
              removeClass([this.element], oldProp.cssClass.toString().split(" ").filter(function(css) {
                return css;
              }));
              addClass([this.element], newProp.cssClass.toString().split(" ").filter(function(css) {
                return css;
              }));
            } else {
              this.refresh();
            }
            break;
          case "selectedChips":
            removeClass(this.element.querySelectorAll(".e-active"), "e-active");
            if (this.selection === "Multiple") {
              this.multiSelectedChip = [];
              this.multiSelection(newProp.selectedChips);
              this.onSelect(this.multiSelectedChip, true);
              this.updateSelectedChips();
            } else {
              this.onSelect(newProp.selectedChips, true);
            }
            break;
          case "enableRtl":
            this.setRtl();
            break;
        }
      }
    };
    __decorate7([
      Property([])
    ], ChipList2.prototype, "chips", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "text", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "avatarText", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "avatarIconCss", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "htmlAttributes", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "leadingIconCss", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "trailingIconCss", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "leadingIconUrl", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "trailingIconUrl", void 0);
    __decorate7([
      Property("")
    ], ChipList2.prototype, "cssClass", void 0);
    __decorate7([
      Property(true)
    ], ChipList2.prototype, "enabled", void 0);
    __decorate7([
      Property([])
    ], ChipList2.prototype, "selectedChips", void 0);
    __decorate7([
      Property("None")
    ], ChipList2.prototype, "selection", void 0);
    __decorate7([
      Property(false)
    ], ChipList2.prototype, "enableDelete", void 0);
    __decorate7([
      Event()
    ], ChipList2.prototype, "created", void 0);
    __decorate7([
      Event()
    ], ChipList2.prototype, "click", void 0);
    __decorate7([
      Event()
    ], ChipList2.prototype, "beforeClick", void 0);
    __decorate7([
      Event()
    ], ChipList2.prototype, "delete", void 0);
    __decorate7([
      Event()
    ], ChipList2.prototype, "deleted", void 0);
    ChipList2 = __decorate7([
      NotifyPropertyChanges
    ], ChipList2);
    return ChipList2;
  }(Component)
);

// node_modules/@syncfusion/ej2-buttons/src/floating-action-button/floating-action-button.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FABHIDDEN = "e-fab-hidden";
var FIXEDFAB = "e-fab-fixed";
var FABTOP = "e-fab-top";
var FABBOTTOM = "e-fab-bottom";
var FABRIGHT = "e-fab-right";
var FABLEFT = "e-fab-left";
var FABMIDDLE = "e-fab-middle";
var FABCENTER = "e-fab-center";
var FabPosition;
(function(FabPosition2) {
  FabPosition2["TopLeft"] = "TopLeft";
  FabPosition2["TopCenter"] = "TopCenter";
  FabPosition2["TopRight"] = "TopRight";
  FabPosition2["MiddleLeft"] = "MiddleLeft";
  FabPosition2["MiddleCenter"] = "MiddleCenter";
  FabPosition2["MiddleRight"] = "MiddleRight";
  FabPosition2["BottomLeft"] = "BottomLeft";
  FabPosition2["BottomCenter"] = "BottomCenter";
  FabPosition2["BottomRight"] = "BottomRight";
})(FabPosition || (FabPosition = {}));
var Fab = (
  /** @class */
  function(_super) {
    __extends7(Fab2, _super);
    function Fab2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    Fab2.prototype.render = function() {
      _super.prototype.render.call(this);
      this.initializeFab();
    };
    Fab2.prototype.preRender = function() {
      _super.prototype.preRender.call(this);
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
    };
    Fab2.prototype.getPersistData = function() {
      _super.prototype.getPersistData.call(this);
      return this.addOnPersist([]);
    };
    Fab2.prototype.getModuleName = function() {
      return "fab";
    };
    Fab2.prototype.initializeFab = function() {
      this.element.classList.add("e-" + _super.prototype.getModuleName.call(this));
      this.checkTarget();
      this.setPosition();
      this.setVisibility();
    };
    Fab2.prototype.checkTarget = function() {
      this.isFixed = true;
      if (this.target) {
        this.targetEle = typeof this.target === "string" ? select(this.target) : this.target;
        if (this.targetEle) {
          this.isFixed = false;
          this.targetEle.appendChild(this.element);
        }
      }
      this.element.classList[this.isFixed ? "add" : "remove"](FIXEDFAB);
    };
    Fab2.prototype.setVisibility = function() {
      this.element.classList[this.visible ? "remove" : "add"](FABHIDDEN);
    };
    Fab2.prototype.setPosition = function() {
      this.element.classList.add(["BottomLeft", "BottomCenter", "BottomRight"].indexOf(this.position) !== -1 ? FABBOTTOM : FABTOP);
      var isRight = ["TopRight", "MiddleRight", "BottomRight"].indexOf(this.position) !== -1;
      this.element.classList.add(!(this.enableRtl || isRight) || this.enableRtl && isRight ? FABLEFT : FABRIGHT);
      if (["MiddleLeft", "MiddleRight", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.element.classList.add(FABMIDDLE);
      }
      if (["TopCenter", "BottomCenter", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.element.classList.add(FABCENTER);
      }
    };
    Fab2.prototype.clearPosition = function() {
      this.element.classList.remove(FABTOP, FABBOTTOM, FABMIDDLE);
      this.element.classList.remove(FABRIGHT, FABLEFT, FABCENTER);
    };
    Fab2.prototype.refreshPosition = function() {
    };
    Fab2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.element.classList.remove("e-" + _super.prototype.getModuleName.call(this), FIXEDFAB);
      this.clearPosition();
    };
    Fab2.prototype.onPropertyChanged = function(newProp, oldProp) {
      _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "enableRtl":
          case "position":
            this.clearPosition();
            this.setPosition();
            break;
          case "visible":
            this.setVisibility();
            break;
          case "target":
            this.checkTarget();
            this.setPosition();
            break;
          case "currencyCode":
            this.refresh();
            break;
        }
      }
    };
    __decorate8([
      Property("BottomRight")
    ], Fab2.prototype, "position", void 0);
    __decorate8([
      Property("")
    ], Fab2.prototype, "target", void 0);
    __decorate8([
      Property(true)
    ], Fab2.prototype, "visible", void 0);
    __decorate8([
      Property(true)
    ], Fab2.prototype, "isPrimary", void 0);
    Fab2 = __decorate8([
      NotifyPropertyChanges
    ], Fab2);
    return Fab2;
  }(Button)
);

// node_modules/@syncfusion/ej2-buttons/src/speed-dial/speed-dial.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var topPosition = ["TopLeft", "TopCenter", "TopRight"];
var bottomPosition = ["BottomLeft", "BottomCenter", "BottomRight"];
var leftPosition = ["TopLeft", "MiddleLeft", "BottomLeft"];
var rightPosition = ["TopRight", "MiddleRight", "BottomRight"];
var SDHIDDEN = "e-speeddial-hidden";
var FIXEDSD = "e-speeddial-fixed";
var SPEEDDIAL = "e-speeddial";
var RTLCLASS = "e-rtl";
var HOVERSD = "e-speeddial-hover-open";
var RADIALSD = "e-speeddial-radial";
var LINEARSD = "e-speeddial-linear";
var TEMPLATESD = "e-speeddial-template";
var SDTEMPLATECONTAINER = "e-speeddial-template-container";
var SDOVERLAY = "e-speeddial-overlay";
var SDPOPUP = "e-speeddial-popup";
var SDUL = "e-speeddial-ul";
var SDLI = "e-speeddial-li";
var SDACTIVELI = "e-speeddial-li-active";
var SDLIICON = "e-speeddial-li-icon";
var SDLITEXT = "e-speeddial-li-text";
var SDLITEXTONLY = "e-speeddial-text-li";
var DISABLED3 = "e-disabled";
var SDVERTICALBOTTOM = "e-speeddial-vert-bottom";
var SDVERTICALRIGHT = "e-speeddial-vert-right";
var SDHORIZONTALTOP = "e-speeddial-horz-top";
var SDHORIZONTALLEFT = "e-speeddial-horz-left";
var SDHORIZONTALRIGHT = "e-speeddial-horz-right";
var SDOVERFLOW = "e-speeddial-overflow";
var SDVERTOVERFLOW = "e-speeddial-vert-overflow";
var SDHORZOVERFLOW = "e-speeddial-horz-overflow";
var SDTOP = "e-speeddial-top";
var SDBOTTOM = "e-speeddial-bottom";
var SDRIGHT = "e-speeddial-right";
var SDLEFT = "e-speeddial-left";
var SDMIDDLE = "e-speeddial-middle";
var SDCENTER = "e-speeddial-center";
var SDTOPLEFT = "e-speeddial-top-left";
var SDBOTTOMRIGHT = "e-speeddial-bottom-right";
var SDTOPRIGHT = "e-speeddial-top-right";
var SDBOTTOMLEFT = "e-speeddial-bottom-left";
var SDVERTDIST = "--speeddialVertDist";
var SDHORZDIST = "--speeddialHorzDist";
var SDRADICALANGLE = "--speeddialRadialAngle";
var SDRADICALOFFSET = "--speeddialRadialOffset";
var SDRADICALMINHEIGHT = "--speeddialRadialMinHeight";
var SDRADICALMINWIDTH = "--speeddialRadialMinWidth";
var SDOVERFLOWLIMIT = "--speeddialOverflowLimit";
var SDRADICALHORZDIST = "--speeddialRadialHorzDist";
var SpeedDialMode;
(function(SpeedDialMode2) {
  SpeedDialMode2["Linear"] = "Linear";
  SpeedDialMode2["Radial"] = "Radial";
})(SpeedDialMode || (SpeedDialMode = {}));
var LinearDirection;
(function(LinearDirection2) {
  LinearDirection2["Up"] = "Up";
  LinearDirection2["Down"] = "Down";
  LinearDirection2["Right"] = "Right";
  LinearDirection2["Left"] = "Left";
  LinearDirection2["Auto"] = "Auto";
})(LinearDirection || (LinearDirection = {}));
var RadialDirection;
(function(RadialDirection2) {
  RadialDirection2["Clockwise"] = "Clockwise";
  RadialDirection2["AntiClockwise"] = "AntiClockwise";
  RadialDirection2["Auto"] = "Auto";
})(RadialDirection || (RadialDirection = {}));
var SpeedDialAnimationEffect;
(function(SpeedDialAnimationEffect2) {
  SpeedDialAnimationEffect2["Fade"] = "Fade";
  SpeedDialAnimationEffect2["FadeZoom"] = "FadeZoom";
  SpeedDialAnimationEffect2["FlipLeftDown"] = "FlipLeftDown";
  SpeedDialAnimationEffect2["FlipLeftUp"] = "FlipLeftUp";
  SpeedDialAnimationEffect2["FlipRightDown"] = "FlipRightDown";
  SpeedDialAnimationEffect2["FlipRightUp"] = "FlipRightUp";
  SpeedDialAnimationEffect2["FlipXDown"] = "FlipXDown";
  SpeedDialAnimationEffect2["FlipXUp"] = "FlipXUp";
  SpeedDialAnimationEffect2["FlipYLeft"] = "FlipYLeft";
  SpeedDialAnimationEffect2["FlipYRight"] = "FlipYRight";
  SpeedDialAnimationEffect2["SlideBottom"] = "SlideBottom";
  SpeedDialAnimationEffect2["SlideLeft"] = "SlideLeft";
  SpeedDialAnimationEffect2["SlideRight"] = "SlideRight";
  SpeedDialAnimationEffect2["SlideTop"] = "SlideTop";
  SpeedDialAnimationEffect2["Zoom"] = "Zoom";
  SpeedDialAnimationEffect2["None"] = "None";
})(SpeedDialAnimationEffect || (SpeedDialAnimationEffect = {}));
var SpeedDialAnimationSettings = (
  /** @class */
  function(_super) {
    __extends8(SpeedDialAnimationSettings2, _super);
    function SpeedDialAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate9([
      Property("Fade")
    ], SpeedDialAnimationSettings2.prototype, "effect", void 0);
    __decorate9([
      Property(400)
    ], SpeedDialAnimationSettings2.prototype, "duration", void 0);
    __decorate9([
      Property(0)
    ], SpeedDialAnimationSettings2.prototype, "delay", void 0);
    return SpeedDialAnimationSettings2;
  }(ChildProperty)
);
var RadialSettings = (
  /** @class */
  function(_super) {
    __extends8(RadialSettings2, _super);
    function RadialSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate9([
      Property("Auto")
    ], RadialSettings2.prototype, "direction", void 0);
    __decorate9([
      Property(-1)
    ], RadialSettings2.prototype, "endAngle", void 0);
    __decorate9([
      Property("100px")
    ], RadialSettings2.prototype, "offset", void 0);
    __decorate9([
      Property(-1)
    ], RadialSettings2.prototype, "startAngle", void 0);
    return RadialSettings2;
  }(ChildProperty)
);
var SpeedDialItem = (
  /** @class */
  function(_super) {
    __extends8(SpeedDialItem2, _super);
    function SpeedDialItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate9([
      Property("")
    ], SpeedDialItem2.prototype, "iconCss", void 0);
    __decorate9([
      Property("")
    ], SpeedDialItem2.prototype, "id", void 0);
    __decorate9([
      Property("")
    ], SpeedDialItem2.prototype, "text", void 0);
    __decorate9([
      Property("")
    ], SpeedDialItem2.prototype, "title", void 0);
    __decorate9([
      Property(false)
    ], SpeedDialItem2.prototype, "disabled", void 0);
    return SpeedDialItem2;
  }(ChildProperty)
);
var SpeedDial = (
  /** @class */
  function(_super) {
    __extends8(SpeedDial2, _super);
    function SpeedDial2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isMenuOpen = false;
      _this.isClock = true;
      _this.isVertical = true;
      _this.isControl = false;
      _this.focusedIndex = -1;
      return _this;
    }
    SpeedDial2.prototype.render = function() {
      this.initialize();
    };
    SpeedDial2.prototype.preRender = function() {
      this.keyConfigs = {
        space: "space",
        enter: "enter",
        end: "end",
        home: "home",
        moveDown: "downarrow",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        esc: "escape"
      };
      this.validateDirection();
    };
    SpeedDial2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    SpeedDial2.prototype.getModuleName = function() {
      return "speed-dial";
    };
    SpeedDial2.prototype.initialize = function() {
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      this.fab = new Fab({
        content: this.content,
        cssClass: this.cssClass ? SPEEDDIAL + " " + this.cssClass : SPEEDDIAL,
        disabled: this.disabled,
        enablePersistence: this.enablePersistence,
        enableRtl: this.enableRtl,
        iconCss: this.openIconCss,
        iconPosition: this.iconPosition,
        position: this.position,
        target: this.target,
        visible: this.visible,
        isPrimary: this.isPrimary
      });
      this.fab.appendTo(this.element);
      if (this.items.length > 0 || this.popupTemplate) {
        this.createPopup();
      }
      this.wireEvents();
    };
    SpeedDial2.prototype.wireEvents = function() {
      EventHandler.add(window, "resize", this.resizeHandler, this);
      EventHandler.add(document.body, "click", this.bodyClickHandler, this);
      if (this.opensOnHover) {
        this.wireFabHover();
      } else {
        this.wireFabClick();
      }
    };
    SpeedDial2.prototype.wirePopupEvents = function() {
      this.removeRippleEffect = rippleEffect(this.popupEle, { selector: "." + SDLIICON });
      this.keyboardModule = new KeyboardEvents(this.element, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
      this.popupKeyboardModule = new KeyboardEvents(this.popupEle, {
        keyAction: this.popupKeyActionHandler.bind(this),
        keyConfigs: { esc: "escape" },
        eventName: "keydown"
      });
      this.documentKeyboardModule = new KeyboardEvents(document.body, {
        keyAction: this.popupKeyActionHandler.bind(this),
        keyConfigs: { enter: "enter", space: "space" },
        eventName: "keydown"
      });
      EventHandler.add(this.popupEle, "click", this.popupClick, this);
      EventHandler.add(this.popupEle, "mouseleave", this.popupMouseLeaveHandle, this);
    };
    SpeedDial2.prototype.wireFabClick = function() {
      EventHandler.add(this.fab.element, "click", this.fabClick, this);
    };
    SpeedDial2.prototype.wireFabHover = function() {
      this.popupEle.classList.add(HOVERSD);
      EventHandler.add(this.fab.element, "mouseover", this.mouseOverHandle, this);
      EventHandler.add(this.element, "mouseleave", this.mouseLeaveHandle, this);
    };
    SpeedDial2.prototype.createPopup = function() {
      var className = SDPOPUP + " " + SDHIDDEN;
      className = this.enableRtl ? className + " " + RTLCLASS : className;
      className = this.cssClass ? className + " " + this.cssClass : className;
      this.popupEle = this.createElement("div", {
        className,
        id: this.element.id + "_popup"
      });
      this.element.insertAdjacentElement("afterend", this.popupEle);
      attributes(this.element, { "aria-expanded": "false", "aria-haspopup": "true", "aria-controls": this.popupEle.id });
      this.setPopupContent();
      if (this.modal) {
        this.createOverlay();
      }
      this.checkTarget();
      this.setPositionProps();
      this.wirePopupEvents();
    };
    SpeedDial2.prototype.createOverlay = function() {
      this.overlayEle = this.createElement("div", {
        id: this.element.id + "_overlay",
        className: (SDOVERLAY + (this.isMenuOpen ? "" : " " + SDHIDDEN) + " " + this.cssClass).trim()
      });
      this.element.insertAdjacentElement("beforebegin", this.overlayEle);
    };
    SpeedDial2.prototype.popupClick = function() {
      this.isControl = true;
    };
    SpeedDial2.prototype.bodyClickHandler = function(e) {
      if (this.isControl) {
        this.isControl = false;
        return;
      }
      if (this.isMenuOpen) {
        this.hidePopupEle(e);
      }
    };
    SpeedDial2.prototype.fabClick = function(e) {
      this.isControl = true;
      if (this.isMenuOpen) {
        this.hidePopupEle(e);
      } else {
        this.showPopupEle(e);
      }
    };
    SpeedDial2.prototype.setPopupContent = function() {
      this.popupEle.classList.remove(RADIALSD, LINEARSD, TEMPLATESD);
      if (!this.popupTemplate) {
        this.popupEle.classList.add(this.mode === "Radial" ? RADIALSD : LINEARSD);
        this.createUl();
        this.createItems();
      } else {
        this.popupEle.classList.add(TEMPLATESD);
        this.appendTemplate();
      }
      this.renderReactTemplates();
    };
    SpeedDial2.prototype.appendTemplate = function() {
      var templateContainer = this.createElement("div", { className: SDTEMPLATECONTAINER });
      append([templateContainer], this.popupEle);
      var templateFunction = this.getTemplateString(this.popupTemplate);
      append(templateFunction({}, this, "fabPopupTemplate", this.element.id + "popupTemplate", this.isStringTemplate), templateContainer);
    };
    SpeedDial2.prototype.getTemplateString = function(template) {
      var stringContent = "";
      try {
        var tempEle = select(template);
        if (typeof template !== "function" && tempEle) {
          stringContent = tempEle.tagName === "SCRIPT" ? tempEle.innerHTML : tempEle.outerHTML;
        } else {
          stringContent = template;
        }
      } catch (e) {
        stringContent = template;
      }
      return compile(stringContent);
    };
    SpeedDial2.prototype.updatePopupTemplate = function() {
      if (this.popupEle) {
        if (this.popupEle.querySelector("." + SDLI)) {
          this.clearItems();
          this.popupEle.classList.remove(RADIALSD, LINEARSD);
          this.popupEle.classList.add(TEMPLATESD);
        }
        while (this.popupEle.firstElementChild) {
          remove(this.popupEle.firstElementChild);
        }
        this.setPopupContent();
        this.updatePositionProperties();
      } else {
        this.createPopup();
      }
    };
    SpeedDial2.prototype.createUl = function() {
      var popupUlEle = this.createElement("ul", {
        className: SDUL,
        id: this.element.id + "_ul",
        attrs: { "role": "menu" }
      });
      this.popupEle.appendChild(popupUlEle);
    };
    SpeedDial2.prototype.createItems = function() {
      var _this = this;
      this.focusedIndex = -1;
      var ul = this.popupEle.querySelector("." + SDUL);
      var _loop_1 = function(index2) {
        var item = this_1.items[parseInt(index2.toString(), 10)];
        var li = this_1.createElement("li", {
          className: SDLI + " " + SDHIDDEN,
          id: item.id ? item.id : this_1.element.id + "_li_" + index2,
          attrs: { "role": "menuitem" }
        });
        if (item.text) {
          li.setAttribute("aria-label", item.text);
        }
        if (this_1.itemTemplate) {
          var templateFunction = this_1.getTemplateString(this_1.itemTemplate);
          append(templateFunction(item, this_1, "fabItemTemplate", this_1.element.id + "itemTemplate", this_1.isStringTemplate), li);
        } else {
          if (item.iconCss) {
            var iconSpan = this_1.createElement("span", {
              className: SDLIICON + " " + item.iconCss
            });
            li.appendChild(iconSpan);
          }
          if (item.text) {
            var textSpan = this_1.createElement("span", {
              className: SDLITEXT
            });
            textSpan.innerText = item.text;
            li.appendChild(textSpan);
            if (!item.iconCss) {
              li.classList.add(SDLITEXTONLY);
            }
          }
        }
        if (item.disabled) {
          li.classList.add(DISABLED3);
          li.setAttribute("aria-disabled", "true");
        } else {
          EventHandler.add(li, "click", function(e) {
            return _this.triggerItemClick(e, item);
          }, this_1);
        }
        if (item.title) {
          li.setAttribute("title", item.title);
        }
        var eventArgs = { element: li, item };
        this_1.trigger("beforeItemRender", eventArgs, function(args) {
          ul.appendChild(args.element);
        });
      };
      var this_1 = this;
      for (var index = 0; index < this.items.length; index++) {
        _loop_1(index);
      }
    };
    SpeedDial2.prototype.setRTL = function() {
      this.popupEle.classList[this.enableRtl ? "add" : "remove"](RTLCLASS);
      this.clearHorizontalPosition();
      if (!(this.popupTemplate || this.mode === "Radial")) {
        this.setLinearHorizontalPosition();
      } else {
        if (!this.popupTemplate && this.mode === "Radial") {
          this.setRadialPosition();
        }
        this.setHorizontalPosition();
      }
    };
    SpeedDial2.prototype.checkTarget = function() {
      this.isFixed = true;
      if (this.target) {
        this.targetEle = typeof this.target === "string" ? select(this.target) : this.target;
        if (this.targetEle) {
          this.targetEle.appendChild(this.element);
          this.isFixed = false;
        }
      }
      if (this.isFixed) {
        if (this.popupEle) {
          this.popupEle.classList.add(FIXEDSD);
        }
        if (this.overlayEle) {
          this.overlayEle.classList.add(FIXEDSD);
        }
      } else {
        if (this.popupEle) {
          this.popupEle.classList.remove(FIXEDSD);
        }
        if (this.overlayEle) {
          this.overlayEle.classList.remove(FIXEDSD);
        }
      }
    };
    SpeedDial2.prototype.setVisibility = function(val) {
      this.setProperties({ visible: val }, true);
      this.fab.setProperties({ visible: val });
    };
    SpeedDial2.prototype.popupMouseLeaveHandle = function(e) {
      var target = e.relatedTarget;
      if (this.opensOnHover && !(target.classList.contains(SPEEDDIAL) || closest(target, "." + SPEEDDIAL))) {
        this.hidePopupEle(e);
      }
    };
    SpeedDial2.prototype.mouseOverHandle = function(e) {
      this.showPopupEle(e);
    };
    SpeedDial2.prototype.mouseLeaveHandle = function(e) {
      var target = e.relatedTarget;
      if (!(target.classList.contains(SDPOPUP) || closest(target, "." + SDPOPUP))) {
        this.hidePopupEle(e);
      }
    };
    SpeedDial2.prototype.popupKeyActionHandler = function(e) {
      switch (e.action) {
        case "esc":
          this.hidePopupEle(e);
          break;
        case "enter":
        case "space":
          if (this.isMenuOpen && e.target !== this.element) {
            this.hidePopupEle(e);
          }
          break;
      }
    };
    SpeedDial2.prototype.keyActionHandler = function(e) {
      e.preventDefault();
      switch (e.action) {
        case "enter":
        case "space":
          if (this.isMenuOpen) {
            if (this.focusedIndex !== -1) {
              this.triggerItemClick(e, this.items[this.focusedIndex]);
            } else {
              this.hidePopupEle(e);
            }
          } else {
            this.showPopupEle(e);
          }
          break;
        case "esc":
          this.hidePopupEle(e);
          break;
        default:
          if (this.popupTemplate || !this.isMenuOpen) {
            break;
          }
          switch (e.action) {
            case "end":
              this.focusLastElement();
              break;
            case "home":
              this.focusFirstElement();
              break;
            case "moveRight":
              if (this.mode === "Radial") {
                this.focusLeftRightElement(false);
              } else {
                this.focusLinearElement(false);
              }
              break;
            case "moveDown":
              if (this.mode === "Radial") {
                this.focusUpDownElement(false);
              } else {
                this.focusLinearElement(false);
              }
              break;
            case "moveLeft":
              if (this.mode === "Radial") {
                this.focusLeftRightElement(true);
              } else {
                this.focusLinearElement(true);
              }
              break;
            case "moveUp":
              if (this.mode === "Radial") {
                this.focusUpDownElement(true);
              } else {
                this.focusLinearElement(true);
              }
              break;
          }
          break;
      }
    };
    SpeedDial2.prototype.focusFirstElement = function() {
      var ele = selectAll("." + SDLI, this.popupEle);
      var index = 0;
      while (ele[parseInt(index.toString(), 10)].classList.contains(DISABLED3)) {
        index++;
        if (index > ele.length - 1) {
          return;
        }
      }
      this.setFocus(index, ele[parseInt(index.toString(), 10)]);
    };
    SpeedDial2.prototype.focusLastElement = function() {
      var ele = selectAll("." + SDLI, this.popupEle);
      var index = ele.length - 1;
      while (ele[parseInt(index.toString(), 10)].classList.contains(DISABLED3)) {
        index--;
        if (index < 0) {
          return;
        }
      }
      this.setFocus(index, ele[parseInt(index.toString(), 10)]);
    };
    SpeedDial2.prototype.focusLinearElement = function(isLeftUp) {
      var isReversed = this.popupEle.classList.contains(SDVERTICALBOTTOM) || this.popupEle.classList.contains(SDHORIZONTALRIGHT);
      if (isReversed !== isLeftUp) {
        this.focusPrevElement();
      } else {
        this.focusNextElement();
      }
    };
    SpeedDial2.prototype.focusLeftRightElement = function(isLeft) {
      var isradialTop = ["TopLeft", "TopCenter", "TopRight", "MiddleLeft"].indexOf(this.position) !== -1;
      if (isradialTop && isLeft !== this.isClock || !isradialTop && isLeft === this.isClock) {
        this.focusPrevElement();
      } else {
        this.focusNextElement();
      }
    };
    SpeedDial2.prototype.focusUpDownElement = function(isUp) {
      var isradialRight = ["TopRight", "MiddleRight", "BottomRight", "BottomCenter"].indexOf(this.position) !== -1;
      if (isradialRight && isUp !== this.isClock || !isradialRight && isUp === this.isClock) {
        this.focusPrevElement();
      } else {
        this.focusNextElement();
      }
    };
    SpeedDial2.prototype.focusPrevElement = function() {
      var ele = selectAll("." + SDLI, this.popupEle);
      var index = this.focusedIndex;
      do {
        index--;
        if (index < 0) {
          this.setFocus(-1);
          return;
        }
      } while (ele[parseInt(index.toString(), 10)].classList.contains(DISABLED3));
      this.setFocus(index, ele[parseInt(index.toString(), 10)]);
    };
    SpeedDial2.prototype.focusNextElement = function() {
      var ele = selectAll("." + SDLI, this.popupEle);
      var index = this.focusedIndex;
      do {
        index++;
        if (index > ele.length - 1) {
          return;
        }
      } while (ele[parseInt(index.toString(), 10)].classList.contains(DISABLED3));
      this.setFocus(index, ele[parseInt(index.toString(), 10)]);
    };
    SpeedDial2.prototype.setFocus = function(index, ele) {
      this.removeFocus();
      if (ele) {
        ele.classList.add(SDACTIVELI);
      }
      this.focusedIndex = index;
    };
    SpeedDial2.prototype.removeFocus = function() {
      var preEle = select("." + SDACTIVELI, this.popupEle);
      if (preEle) {
        preEle.classList.remove(SDACTIVELI);
      }
    };
    SpeedDial2.prototype.updatePositionProperties = function() {
      this.hidePopupEle();
      this.clearPosition();
      this.validateDirection();
      this.setPositionProps();
    };
    SpeedDial2.prototype.setPositionProps = function() {
      if (this.popupTemplate) {
        this.setPosition();
      } else if (this.mode === "Radial") {
        this.setRadialPosition();
        this.setPosition();
      } else {
        this.setLinearPosition();
        this.setMaxSize();
      }
    };
    SpeedDial2.prototype.validateDirection = function() {
      switch (this.direction) {
        case "Up":
          this.actualLinDirection = topPosition.indexOf(this.position) !== -1 ? "Auto" : "Up";
          break;
        case "Down":
          this.actualLinDirection = bottomPosition.indexOf(this.position) !== -1 ? "Auto" : "Down";
          break;
        case "Right":
          this.actualLinDirection = rightPosition.indexOf(this.position) !== -1 ? "Auto" : "Right";
          break;
        case "Left":
          this.actualLinDirection = leftPosition.indexOf(this.position) !== -1 ? "Auto" : "Left";
          break;
        case "Auto":
        default:
          this.actualLinDirection = "Auto";
          break;
      }
      this.isVertical = !(this.actualLinDirection === "Left" || this.actualLinDirection === "Right");
    };
    SpeedDial2.prototype.setMaxSize = function() {
      var top = this.element.offsetTop;
      var left = this.element.offsetLeft;
      var bottom = (this.isFixed ? window.innerHeight : this.targetEle.clientHeight) - this.element.offsetTop - this.element.offsetHeight;
      var right = (this.isFixed ? window.innerWidth : this.targetEle.clientWidth) - this.element.offsetLeft - this.element.offsetWidth;
      var limit = 0;
      var popupUlEle = this.popupEle.querySelector("." + SDUL);
      if (this.isVertical) {
        limit = this.actualLinDirection === "Up" || this.actualLinDirection === "Auto" && topPosition.indexOf(this.position) === -1 ? top : bottom;
        if (limit < popupUlEle.offsetHeight) {
          this.popupEle.classList.add(SDOVERFLOW, SDVERTOVERFLOW);
          popupUlEle.style.setProperty(SDOVERFLOWLIMIT, limit + "px");
        }
      } else {
        limit = this.enableRtl ? this.direction === "Right" ? left : right : this.direction === "Right" ? right : left;
        if (limit < popupUlEle.offsetWidth) {
          this.popupEle.classList.add(SDOVERFLOW, SDHORZOVERFLOW);
          popupUlEle.style.setProperty(SDOVERFLOWLIMIT, limit + "px");
        }
      }
    };
    SpeedDial2.prototype.setLinearPosition = function() {
      var vertDist = 0;
      var isTop = this.actualLinDirection === "Down" || this.actualLinDirection === "Auto" && topPosition.indexOf(this.position) !== -1 || !this.isVertical && bottomPosition.indexOf(this.position) === -1;
      var elementOffSetHeight = this.element.offsetHeight / 2;
      var isMiddle = ["MiddleRight", "MiddleCenter", "MiddleLeft"].indexOf(this.position) !== -1;
      if (isTop) {
        vertDist = this.element.offsetTop + (this.isVertical ? this.element.offsetHeight : 0);
        if (isMiddle) {
          if (this.actualLinDirection === "Right" || this.actualLinDirection === "Left") {
            vertDist = this.element.offsetTop - elementOffSetHeight;
          }
          if (this.actualLinDirection === "Down") {
            vertDist = vertDist - elementOffSetHeight;
          }
        }
        if (!this.isVertical) {
          this.popupEle.classList.add(SDHORIZONTALTOP);
        }
      } else {
        vertDist = this.isFixed ? window.document.documentElement.clientHeight : this.targetEle.clientHeight;
        vertDist = vertDist - this.element.offsetTop - (this.isVertical ? 0 : this.element.offsetHeight);
        if (isMiddle) {
          if (this.actualLinDirection === "Auto" || this.actualLinDirection === "Up") {
            vertDist = vertDist + elementOffSetHeight;
          }
        }
        if (this.isVertical) {
          this.popupEle.classList.add(SDVERTICALBOTTOM);
        }
      }
      this.popupEle.classList.add(isTop ? SDTOP : SDBOTTOM);
      this.popupEle.style.setProperty(SDVERTDIST, vertDist + "px");
      this.setLinearHorizontalPosition();
    };
    SpeedDial2.prototype.setLinearHorizontalPosition = function() {
      if (this.actualLinDirection === "Right" || this.isVertical && rightPosition.indexOf(this.position) === -1) {
        if (this.enableRtl) {
          this.setRight();
        } else {
          this.setLeft();
        }
        if (!this.isVertical) {
          this.popupEle.classList.add(SDHORIZONTALLEFT);
        }
      } else {
        if (this.enableRtl) {
          this.setLeft();
        } else {
          this.setRight();
        }
        this.popupEle.classList.add(this.isVertical ? SDVERTICALRIGHT : SDHORIZONTALRIGHT);
      }
    };
    SpeedDial2.prototype.setLeft = function() {
      var elementOffSetWidth = this.element.offsetWidth / 2;
      var isCenter = ["TopCenter", "MiddleCenter", "BottomCenter"].indexOf(this.position) !== -1;
      var horzDist = this.element.offsetLeft + (this.isVertical ? 0 : this.element.offsetWidth);
      if (isCenter) {
        if (this.actualLinDirection === "Auto" || this.actualLinDirection === "Down" || this.actualLinDirection === "Up") {
          horzDist = this.element.offsetLeft - elementOffSetWidth;
        } else {
          horzDist = this.actualLinDirection === "Right" ? this.element.offsetLeft + elementOffSetWidth : horzDist + elementOffSetWidth;
        }
      }
      this.popupEle.style.setProperty(SDHORZDIST, horzDist + "px");
      this.popupEle.classList.add(SDLEFT);
    };
    SpeedDial2.prototype.setRight = function() {
      var elementOffSetWidth = this.element.offsetWidth / 2;
      var isCenter = ["TopCenter", "MiddleCenter", "BottomCenter"].indexOf(this.position) !== -1;
      var horzDist = this.isFixed ? window.document.documentElement.clientWidth : this.targetEle.clientWidth;
      horzDist = horzDist - this.element.offsetLeft - (this.isVertical ? this.element.offsetWidth : 0);
      if (isCenter && this.actualLinDirection === "Left") {
        horzDist = horzDist + elementOffSetWidth;
      }
      if (this.popupEle.classList.contains("e-rtl") && isCenter) {
        horzDist = horzDist - elementOffSetWidth;
      }
      this.popupEle.style.setProperty(SDHORZDIST, horzDist + "px");
      this.popupEle.classList.add(SDRIGHT);
    };
    SpeedDial2.prototype.setPosition = function() {
      if (["MiddleLeft", "MiddleRight", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(SDMIDDLE);
        var yoffset = ((this.isFixed ? window.innerHeight : this.targetEle.clientHeight) - this.popupEle.offsetHeight) / 2;
        this.popupEle.style.setProperty(SDVERTDIST, yoffset + "px");
      }
      this.popupEle.classList.add(bottomPosition.indexOf(this.position) === -1 ? SDTOP : SDBOTTOM);
      this.setHorizontalPosition();
    };
    SpeedDial2.prototype.setHorizontalPosition = function() {
      if (["TopCenter", "BottomCenter", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(SDCENTER);
        var xoffset = ((this.isFixed ? window.innerWidth : this.targetEle.clientWidth) - this.popupEle.offsetWidth) / 2;
        this.popupEle.style.setProperty(SDHORZDIST, xoffset + "px");
      }
      var isRight = rightPosition.indexOf(this.position) !== -1;
      this.popupEle.classList.add(!(this.enableRtl || isRight) || this.enableRtl && isRight ? SDLEFT : SDRIGHT);
    };
    SpeedDial2.prototype.setCustomRadialPosition = function() {
      var viewportWidth = document.documentElement.clientWidth;
      var viewportHeight = document.documentElement.clientHeight;
      if (["TopLeft", "BottomLeft", "MiddleLeft"].indexOf(this.position) !== -1) {
        var horzDist = void 0;
        if (this.enableRtl) {
          if (this.isFixed) {
            horzDist = viewportWidth - (this.element.offsetLeft + this.element.offsetWidth);
          } else {
            horzDist = this.targetEle.clientWidth - (this.element.offsetLeft + this.element.offsetWidth);
          }
        } else {
          horzDist = this.element.offsetLeft;
        }
        this.popupEle.style.setProperty(SDRADICALHORZDIST, horzDist + "px");
      }
      if (["TopLeft", "TopCenter", "TopRight"].indexOf(this.position) !== -1) {
        this.popupEle.style.top = this.element.offsetTop + "px";
      }
      if (["TopRight", "BottomRight", "MiddleRight"].indexOf(this.position) !== -1) {
        var horzDist = void 0;
        if (this.enableRtl) {
          horzDist = this.element.offsetLeft;
        } else {
          if (this.isFixed) {
            horzDist = viewportWidth - (this.element.offsetLeft + this.element.offsetWidth);
          } else {
            horzDist = this.targetEle.clientWidth - (this.element.offsetLeft + this.element.offsetWidth);
          }
        }
        this.popupEle.style.setProperty(SDRADICALHORZDIST, horzDist + "px");
      }
      if (["BottomLeft", "BottomCenter", "BottomRight"].indexOf(this.position) !== -1) {
        if (this.isFixed) {
          this.popupEle.style.bottom = viewportHeight - (this.element.offsetTop + this.element.offsetHeight) + "px";
        } else {
          this.popupEle.style.bottom = this.targetEle.clientHeight - (this.element.offsetTop + this.element.offsetHeight) + "px";
        }
      }
      if (["TopCenter", "MiddleCenter", "BottomCenter"].indexOf(this.position) !== -1) {
        var horzDist = void 0;
        if (this.enableRtl) {
          if (this.isFixed) {
            horzDist = viewportWidth - (this.element.offsetLeft + this.element.offsetWidth) - this.popupEle.offsetWidth / 2;
          } else {
            var targetEleWidth = this.targetEle.clientWidth;
            var popupEleWidth = this.popupEle.offsetWidth;
            horzDist = targetEleWidth - (this.element.offsetLeft + this.element.offsetWidth) - popupEleWidth / 2;
          }
        } else {
          horzDist = this.element.offsetLeft - this.popupEle.offsetWidth / 2;
        }
        this.popupEle.style.setProperty(SDRADICALHORZDIST, horzDist + "px");
      }
      if (["MiddleLeft", "MiddleCenter", "MiddleRight"].indexOf(this.position) !== -1) {
        this.popupEle.style.top = this.element.offsetTop - this.popupEle.offsetHeight / 2 + "px";
      }
    };
    SpeedDial2.prototype.setRadialPosition = function() {
      this.setRadialCorner();
      var range = this.getActualRange();
      this.isClock = range.direction === "Clockwise";
      var offset = formatUnit(range.offset);
      var li = selectAll("." + SDLI, this.popupEle);
      this.popupEle.style.setProperty(SDRADICALOFFSET, offset);
      this.popupEle.style.setProperty(SDRADICALMINHEIGHT, li[0].offsetHeight + "px");
      this.popupEle.style.setProperty(SDRADICALMINWIDTH, li[0].offsetWidth + "px");
      var availableAngle = Math.abs(range.endAngle - range.startAngle);
      var gaps = availableAngle === 360 || availableAngle === 0 ? li.length : li.length - 1;
      var perAngle = availableAngle / gaps;
      for (var i = 0; i < li.length; i++) {
        var ele = li[parseInt(i.toString(), 10)];
        var startAngle = range.startAngle;
        var angle = this.isClock ? startAngle + perAngle * i : startAngle - perAngle * i;
        angle = angle % 360;
        ele.style.setProperty(SDRADICALANGLE, angle + "deg");
      }
    };
    SpeedDial2.prototype.setRadialCorner = function() {
      if (["TopLeft", "TopCenter", "MiddleLeft", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(this.enableRtl ? SDTOPRIGHT : SDTOPLEFT);
      }
      if (["TopRight", "TopCenter", "MiddleRight", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(this.enableRtl ? SDTOPLEFT : SDTOPRIGHT);
      }
      if (["BottomLeft", "BottomCenter", "MiddleLeft", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(this.enableRtl ? SDBOTTOMRIGHT : SDBOTTOMLEFT);
      }
      if (["BottomRight", "BottomCenter", "MiddleRight", "MiddleCenter"].indexOf(this.position) !== -1) {
        this.popupEle.classList.add(this.enableRtl ? SDBOTTOMLEFT : SDBOTTOMRIGHT);
      }
    };
    SpeedDial2.prototype.getActualRange = function() {
      var range = { offset: this.radialSettings.offset };
      var start = this.radialSettings.startAngle;
      var end = this.radialSettings.endAngle;
      var isClockwise = false;
      switch (this.position) {
        case "TopLeft":
        case "TopRight":
          if ("TopLeft" === this.position !== this.enableRtl) {
            isClockwise = this.radialSettings.direction === "Clockwise";
            this.checkAngleRange(start, end, range, isClockwise, 0, 90, false);
          } else {
            isClockwise = this.radialSettings.direction !== "AntiClockwise";
            this.checkAngleRange(start, end, range, isClockwise, 90, 180, false);
          }
          break;
        case "TopCenter":
          isClockwise = this.radialSettings.direction === "Clockwise";
          this.checkAngleRange(start, end, range, isClockwise, 0, 180, false);
          break;
        case "MiddleLeft":
        case "MiddleRight":
          if ("MiddleLeft" === this.position !== this.enableRtl) {
            isClockwise = this.radialSettings.direction === "Clockwise";
            start = isNullOrUndefined(start) || start < 0 || start > 360 || start > 90 && start < 270 ? isClockwise ? 270 : 90 : start;
            end = isNullOrUndefined(end) || end < 0 || end > 360 || end > 90 && end < 270 ? isClockwise ? 90 : 270 : end;
            start = start < 91 ? start + 360 : start;
            end = end < 91 ? end + 360 : end;
            var switchVal = isClockwise && end < start || !isClockwise && end > start;
            range.startAngle = switchVal ? end : start;
            range.endAngle = switchVal ? start : end;
          } else {
            isClockwise = this.radialSettings.direction !== "AntiClockwise";
            this.checkAngleRange(start, end, range, isClockwise, 90, 270, false);
          }
          break;
        case "MiddleCenter":
          isClockwise = this.radialSettings.direction !== "AntiClockwise";
          start = isNullOrUndefined(start) || start < 0 || start > 360 ? isClockwise ? 0 : 360 : start;
          end = isNullOrUndefined(end) || end < 0 || end > 360 ? isClockwise ? 360 : 0 : end;
          range.startAngle = !isClockwise && start <= end ? start + 360 : start;
          range.endAngle = isClockwise && end <= start ? end + 360 : end;
          break;
        case "BottomLeft":
        case "BottomRight":
          if ("BottomLeft" === this.position !== this.enableRtl) {
            isClockwise = this.radialSettings.direction === "Clockwise";
            this.checkAngleRange(start, end, range, isClockwise, 270, 360, true);
          } else {
            isClockwise = this.radialSettings.direction !== "AntiClockwise";
            this.checkAngleRange(start, end, range, isClockwise, 180, 270, true);
          }
          break;
        case "BottomCenter":
          isClockwise = this.radialSettings.direction !== "AntiClockwise";
          this.checkAngleRange(start, end, range, isClockwise, 180, 360, true);
          break;
      }
      range.direction = isClockwise ? "Clockwise" : "AntiClockwise";
      return range;
    };
    SpeedDial2.prototype.checkAngleRange = function(start, end, range, isClockwise, min, max, check0) {
      start = this.checkAngle(start, isClockwise, min, max, check0);
      end = this.checkAngle(end, !isClockwise, min, max, check0);
      var switchVal = isClockwise && end < start || !isClockwise && end > start;
      range.startAngle = switchVal ? end : start;
      range.endAngle = switchVal ? start : end;
    };
    SpeedDial2.prototype.checkAngle = function(val, isStart, min, max, check0) {
      if (isNullOrUndefined(val) || val < 0 || val > 360) {
        return isStart ? min : max;
      } else {
        val = check0 ? val === 0 ? 360 : val : val === 360 ? 0 : val;
        return val >= min && val <= max ? val : isStart ? min : max;
      }
    };
    SpeedDial2.prototype.clearPosition = function() {
      this.popupEle.style.removeProperty(SDRADICALOFFSET);
      this.popupEle.style.removeProperty(SDRADICALMINHEIGHT);
      this.popupEle.style.removeProperty(SDRADICALMINWIDTH);
      this.popupEle.classList.remove(SDTOPLEFT, SDTOPRIGHT, SDBOTTOMLEFT, SDBOTTOMRIGHT);
      this.popupEle.classList.remove(SDTOP, SDBOTTOM, SDMIDDLE);
      this.popupEle.classList.remove(SDHORIZONTALTOP, SDVERTICALBOTTOM);
      this.popupEle.style.removeProperty(SDVERTDIST);
      this.clearHorizontalPosition();
      this.clearOverflow();
    };
    SpeedDial2.prototype.clearHorizontalPosition = function() {
      this.popupEle.style.removeProperty(SDHORZDIST);
      this.popupEle.style.removeProperty(SDRADICALHORZDIST);
      this.popupEle.style.removeProperty("top");
      this.popupEle.style.removeProperty("bottom");
      this.popupEle.classList.remove(SDRIGHT, SDLEFT, SDCENTER);
      this.popupEle.classList.remove(SDVERTICALRIGHT, SDHORIZONTALLEFT, SDHORIZONTALRIGHT);
    };
    SpeedDial2.prototype.clearOverflow = function() {
      this.popupEle.classList.remove(SDOVERFLOW, SDVERTOVERFLOW, SDHORZOVERFLOW);
      this.popupEle.style.removeProperty(SDOVERFLOWLIMIT);
    };
    SpeedDial2.prototype.hidePopupEle = function(e) {
      var _this = this;
      if (!this.popupEle || !this.isMenuOpen) {
        return;
      }
      var eventArgs = { element: this.popupEle, event: e, cancel: false };
      this.trigger("beforeClose", eventArgs, function(args) {
        if (args.cancel) {
          return;
        }
        if (_this.animation.effect !== "None") {
          var closeAnimation_1 = {
            name: _this.animation.effect + "Out",
            timingFunction: "easeOut"
          };
          var eleArray_1 = _this.popupTemplate ? [_this.popupEle.firstElementChild] : selectAll("." + SDLI, _this.popupEle);
          var timeOutInterval_1 = _this.animation.duration / (eleArray_1.length + 1);
          closeAnimation_1.duration = 2 * timeOutInterval_1;
          var animateElement_1 = function(curIndex) {
            var ele2 = eleArray_1[parseInt(curIndex.toString(), 10)];
            closeAnimation_1.delay = curIndex === eleArray_1.length - 1 ? _this.animation.delay : 0;
            closeAnimation_1.begin = function() {
              if (curIndex === eleArray_1.length - 1) {
                _this.startHide();
              }
            };
            closeAnimation_1.end = function() {
              ele2.classList.add(SDHIDDEN);
              if (curIndex === 0) {
                _this.endHide();
              }
            };
            new Animation(closeAnimation_1).animate(ele2);
            if (curIndex !== 0) {
              var index_1 = curIndex - 1;
              setTimeout(function() {
                animateElement_1(index_1);
              }, timeOutInterval_1);
            }
          };
          animateElement_1(eleArray_1.length - 1);
        } else {
          _this.startHide();
          if (!_this.popupTemplate) {
            var ele = selectAll("." + SDLI, _this.popupEle);
            ele.forEach(function(element2) {
              element2.classList.add(SDHIDDEN);
            });
          }
          _this.endHide();
        }
      });
    };
    SpeedDial2.prototype.startHide = function() {
      this.element.setAttribute("aria-expanded", "false");
      this.removeFocus();
      this.isMenuOpen = false;
    };
    SpeedDial2.prototype.endHide = function() {
      this.fab.setProperties({ iconCss: this.openIconCss });
      this.popupEle.classList.add(SDHIDDEN);
      if (this.popupTemplate) {
        this.setVisibility(true);
      }
      this.toggleOverlay();
      if (this.popupTemplate) {
        this.popupEle.removeAttribute("tabindex");
      }
      this.trigger("onClose", { element: this.popupEle });
    };
    SpeedDial2.prototype.showPopupEle = function(e) {
      var _this = this;
      if (!this.popupEle || this.isMenuOpen) {
        return;
      }
      if (this.popupTemplate || this.mode === "Radial") {
        this.setCustomRadialPosition();
      } else {
        this.setLinearPosition();
      }
      var eventArgs = { element: this.popupEle, event: e, cancel: false };
      this.trigger("beforeOpen", eventArgs, function(args) {
        if (args.cancel) {
          return;
        }
        if (_this.animation.effect !== "None" || animationMode === "Enable" && _this.animation.effect === "None") {
          if (animationMode === "Enable" && _this.animation.effect === "None") {
            _this.animation.effect = "Fade";
          }
          if (animationMode === "Enable" && _this.animation.duration === 0) {
            _this.animation.duration = 400;
          }
          var openAnimation_1 = {
            name: _this.animation.effect + "In",
            timingFunction: "easeIn"
          };
          var eleArray_2 = _this.popupTemplate ? [_this.popupEle.firstElementChild] : selectAll("." + SDLI, _this.popupEle);
          var timeOutInterval_2 = _this.animation.duration / (eleArray_2.length + 1);
          openAnimation_1.duration = 2 * timeOutInterval_2;
          var animateElement_2 = function(curIndex) {
            var ele2 = eleArray_2[parseInt(curIndex.toString(), 10)];
            openAnimation_1.delay = curIndex === 0 ? _this.animation.delay : 0;
            openAnimation_1.begin = function() {
              if (curIndex === 0) {
                _this.startShow();
              }
              ele2.classList.remove(SDHIDDEN);
            };
            openAnimation_1.end = function() {
              if (curIndex === eleArray_2.length - 1) {
                _this.endShow();
              }
            };
            new Animation(openAnimation_1).animate(ele2);
            if (curIndex !== eleArray_2.length - 1) {
              var index_2 = curIndex + 1;
              setTimeout(function() {
                animateElement_2(index_2);
              }, timeOutInterval_2);
            }
          };
          animateElement_2(0);
        } else {
          _this.startShow();
          if (!_this.popupTemplate) {
            var ele = selectAll("." + SDLI, _this.popupEle);
            ele.forEach(function(element2) {
              element2.classList.remove(SDHIDDEN);
            });
          }
          _this.endShow();
        }
      });
    };
    SpeedDial2.prototype.startShow = function() {
      this.element.setAttribute("aria-expanded", "true");
      this.isMenuOpen = true;
      this.toggleOverlay();
      this.popupEle.classList.remove(SDHIDDEN);
      if (this.popupTemplate) {
        this.setVisibility(false);
      }
    };
    SpeedDial2.prototype.endShow = function() {
      if (this.closeIconCss) {
        this.fab.setProperties({ iconCss: this.closeIconCss });
      }
      if (this.popupTemplate) {
        this.popupEle.setAttribute("tabindex", "1");
        this.popupEle.focus();
      }
      this.trigger("onOpen", { element: this.popupEle });
    };
    SpeedDial2.prototype.toggleOverlay = function() {
      if (!this.overlayEle) {
        return;
      }
      this.overlayEle.classList[this.isMenuOpen ? "remove" : "add"](SDHIDDEN);
    };
    SpeedDial2.prototype.removeOverlayEle = function() {
      if (!this.overlayEle) {
        return;
      }
      remove(this.overlayEle);
      this.overlayEle = void 0;
    };
    SpeedDial2.prototype.updatePopupItems = function() {
      if (this.popupEle) {
        this.hidePopupEle();
        this.clearItems();
        this.createItems();
        this.updatePositionProperties();
      } else {
        this.createPopup();
      }
    };
    SpeedDial2.prototype.handleResize = function(e) {
      if (!this.popupEle) {
        return;
      }
      this.hidePopupEle(e);
      this.clearOverflow();
      this.setPositionProps();
    };
    SpeedDial2.prototype.triggerItemClick = function(e, item) {
      var target = e.target;
      target = target.classList.contains(SDLI) ? target : closest(target, "." + SDLI);
      var eventArgs = { element: target, item, event: e };
      this.trigger("clicked", eventArgs);
      this.hidePopupEle(e);
    };
    SpeedDial2.prototype.show = function() {
      this.showPopupEle();
    };
    SpeedDial2.prototype.hide = function() {
      this.hidePopupEle();
    };
    SpeedDial2.prototype.refreshPosition = function() {
      this.resizeHandler();
    };
    SpeedDial2.prototype.resizeHandler = function(e) {
      this.handleResize(e);
    };
    SpeedDial2.prototype.clearItems = function() {
      var liList = selectAll("." + SDLI, this.popupEle);
      liList.forEach(function(element2) {
        remove(element2);
      });
    };
    SpeedDial2.prototype.unwireEvents = function() {
      EventHandler.remove(window, "resize", this.resizeHandler);
      EventHandler.remove(document.body, "click", this.bodyClickHandler);
      if (this.opensOnHover) {
        this.unwireFabHover();
      } else {
        this.unwireFabClick();
      }
    };
    SpeedDial2.prototype.unwireFabClick = function() {
      EventHandler.remove(this.fab.element, "click", this.fabClick);
    };
    SpeedDial2.prototype.unwireFabHover = function() {
      this.popupEle.classList.remove(HOVERSD);
      EventHandler.remove(this.fab.element, "mouseover", this.mouseOverHandle);
      EventHandler.remove(this.element, "mouseleave", this.mouseLeaveHandle);
    };
    SpeedDial2.prototype.unwirePopupEvents = function() {
      if (isRippleEnabled) {
        this.removeRippleEffect();
      }
      this.removeRippleEffect = null;
      this.keyboardModule.destroy();
      this.popupKeyboardModule.destroy();
      this.documentKeyboardModule.destroy();
      this.keyboardModule = null;
      this.popupKeyboardModule = null;
      this.documentKeyboardModule = null;
      EventHandler.remove(this.popupEle, "click", this.popupClick);
      EventHandler.remove(this.popupEle, "mouseleave", this.popupMouseLeaveHandle);
    };
    SpeedDial2.prototype.destroy = function() {
      var _this = this;
      _super.prototype.destroy.call(this);
      this.unwireEvents();
      ["aria-expanded", "aria-haspopup", "aria-controls"].forEach(function(attr) {
        _this.element.removeAttribute(attr);
      });
      if (this.popupEle) {
        this.unwirePopupEvents();
        remove(this.popupEle);
        this.popupEle = void 0;
      }
      this.removeOverlayEle();
      this.fab.destroy();
      this.fab = void 0;
    };
    SpeedDial2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var fabProplist = ["content", "cssClass", "disabled", "enablePersistence", "enableRtl", "iconPosition", "position", "target", "template", "title", "visible", "isPrimary"];
      var fabModel = extend({}, newProp);
      for (var _i = 0, _a = Object.keys(fabModel); _i < _a.length; _i++) {
        var prop = _a[_i];
        if (fabProplist.indexOf(prop) < 0) {
          deleteObject(fabModel, prop);
        }
      }
      this.fab.setProperties(fabModel);
      for (var _b = 0, _c = Object.keys(newProp); _b < _c.length; _b++) {
        var prop = _c[_b];
        switch (prop) {
          case "cssClass":
            if (!this.popupEle) {
              break;
            }
            if (oldProp.cssClass) {
              removeClass(this.overlayEle ? [this.popupEle, this.overlayEle] : [this.popupEle], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass(this.overlayEle ? [this.popupEle, this.overlayEle] : [this.popupEle], newProp.cssClass.split(" "));
            }
            break;
          case "visible":
          case "disabled":
            this.hide();
            break;
          case "enableRtl":
            if (!this.popupEle) {
              break;
            }
            this.setRTL();
            break;
          case "openIconCss":
            if (!this.isMenuOpen) {
              this.fab.setProperties({ iconCss: this.openIconCss });
            }
            break;
          case "closeIconCss":
            if (this.isMenuOpen) {
              this.fab.setProperties({ iconCss: this.closeIconCss });
            }
            break;
          case "position":
            if (!this.popupEle) {
              break;
            }
            this.updatePositionProperties();
            break;
          case "direction":
            if (!this.popupEle || this.popupTemplate) {
              break;
            }
            this.updatePositionProperties();
            break;
          case "popupTemplate":
            this.updatePopupTemplate();
            break;
          case "target":
            this.hidePopupEle();
            this.checkTarget();
            if (this.overlayEle) {
              this.element.insertAdjacentElement("beforebegin", this.overlayEle);
            }
            if (!this.popupEle) {
              break;
            }
            this.element.insertAdjacentElement("afterend", this.popupEle);
            this.updatePositionProperties();
            break;
          case "items":
          case "itemTemplate":
            if (this.popupTemplate) {
              break;
            }
            this.updatePopupItems();
            break;
          case "modal":
            if (newProp.modal) {
              this.createOverlay();
            } else {
              this.removeOverlayEle();
            }
            break;
          case "mode":
            if (!this.popupEle || this.popupTemplate) {
              break;
            }
            this.popupEle.classList.remove(RADIALSD, LINEARSD);
            this.popupEle.classList.add(this.mode === "Radial" ? RADIALSD : LINEARSD);
            this.updatePositionProperties();
            break;
          case "radialSettings":
            if (this.popupEle && this.mode === "Radial" && !this.popupTemplate) {
              this.setRadialPosition();
            }
            break;
          case "opensOnHover":
            if (this.opensOnHover) {
              this.unwireFabClick();
              this.wireFabHover();
            } else {
              this.unwireFabHover();
              this.wireFabClick();
            }
            break;
        }
      }
    };
    __decorate9([
      Complex({}, SpeedDialAnimationSettings)
    ], SpeedDial2.prototype, "animation", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "content", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "closeIconCss", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "cssClass", void 0);
    __decorate9([
      Property("Auto")
    ], SpeedDial2.prototype, "direction", void 0);
    __decorate9([
      Property(false)
    ], SpeedDial2.prototype, "disabled", void 0);
    __decorate9([
      Property("Left")
    ], SpeedDial2.prototype, "iconPosition", void 0);
    __decorate9([
      Collection([], SpeedDialItem)
    ], SpeedDial2.prototype, "items", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "itemTemplate", void 0);
    __decorate9([
      Property("Linear")
    ], SpeedDial2.prototype, "mode", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "openIconCss", void 0);
    __decorate9([
      Property(false)
    ], SpeedDial2.prototype, "opensOnHover", void 0);
    __decorate9([
      Property("BottomRight")
    ], SpeedDial2.prototype, "position", void 0);
    __decorate9([
      Property(false)
    ], SpeedDial2.prototype, "modal", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "popupTemplate", void 0);
    __decorate9([
      Complex({}, RadialSettings)
    ], SpeedDial2.prototype, "radialSettings", void 0);
    __decorate9([
      Property("")
    ], SpeedDial2.prototype, "target", void 0);
    __decorate9([
      Property(true)
    ], SpeedDial2.prototype, "visible", void 0);
    __decorate9([
      Property(true)
    ], SpeedDial2.prototype, "isPrimary", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "beforeClose", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "beforeItemRender", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "beforeOpen", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "created", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "clicked", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "onClose", void 0);
    __decorate9([
      Event()
    ], SpeedDial2.prototype, "onOpen", void 0);
    SpeedDial2 = __decorate9([
      NotifyPropertyChanges
    ], SpeedDial2);
    return SpeedDial2;
  }(Component)
);

// node_modules/@syncfusion/ej2-popups/src/common/resize.js
var elementClass = ["north-west", "north", "north-east", "west", "east", "south-west", "south", "south-east"];
var RESIZE_HANDLER = "e-resize-handle";
var FOCUSED_HANDLER = "e-focused-handle";
var DIALOG_RESIZABLE = "e-dlg-resizable";
var RESTRICT_LEFT = ["e-restrict-left"];
var RESIZE_WITHIN_VIEWPORT = "e-resize-viewport";
var dialogBorderResize = ["north", "west", "east", "south"];
var targetElement;
var selectedHandler;
var originalWidth = 0;
var originalHeight = 0;
var originalX = 0;
var originalY = 0;
var originalMouseX = 0;
var originalMouseY = 0;
var minHeight;
var maxHeight;
var minWidth;
var maxWidth;
var containerElement;
var resizeStart = null;
var resize = null;
var resizeEnd = null;
var resizeWestWidth;
var setLeft = true;
var previousWidth = 0;
var setWidth = true;
function createResize(args) {
  resizeStart = args.resizeBegin;
  resize = args.resizing;
  resizeEnd = args.resizeComplete;
  targetElement = getDOMElement(args.element);
  containerElement = getDOMElement(args.boundary);
  var directions = args.direction.split(" ");
  for (var i = 0; i < directions.length; i++) {
    if (dialogBorderResize.indexOf(directions[i]) >= 0 && directions[i]) {
      setBorderResizeElm(directions[i]);
    } else if (directions[i].trim() !== "") {
      var resizeHandler = createElement("div", { className: "e-icons " + RESIZE_HANDLER + " e-" + directions[i] });
      targetElement.appendChild(resizeHandler);
    }
  }
  minHeight = args.minHeight;
  minWidth = args.minWidth;
  maxWidth = args.maxWidth;
  maxHeight = args.maxHeight;
  if (args.proxy && args.proxy.element && args.proxy.element.classList.contains("e-dialog")) {
    wireEvents(args.proxy);
  } else {
    wireEvents();
  }
}
function setBorderResizeElm(direction) {
  calculateValues();
  var borderBottom = createElement("span", {
    attrs: {
      "unselectable": "on",
      "contenteditable": "false"
    }
  });
  borderBottom.setAttribute("class", "e-dialog-border-resize e-" + direction);
  if (direction === "south") {
    borderBottom.style.height = "2px";
    borderBottom.style.width = "100%";
    borderBottom.style.bottom = "0px";
    borderBottom.style.left = "0px";
  }
  if (direction === "north") {
    borderBottom.style.height = "2px";
    borderBottom.style.width = "100%";
    borderBottom.style.top = "0px";
    borderBottom.style.left = "0px";
  }
  if (direction === "east") {
    borderBottom.style.height = "100%";
    borderBottom.style.width = "2px";
    borderBottom.style.right = "0px";
    borderBottom.style.top = "0px";
  }
  if (direction === "west") {
    borderBottom.style.height = "100%";
    borderBottom.style.width = "2px";
    borderBottom.style.left = "0px";
    borderBottom.style.top = "0px";
  }
  targetElement.appendChild(borderBottom);
}
function getDOMElement(element2) {
  var domElement;
  if (!isNullOrUndefined(element2)) {
    if (typeof element2 === "string") {
      domElement = document.querySelector(element2);
    } else {
      domElement = element2;
    }
  }
  return domElement;
}
function wireEvents(args) {
  var context = args || this;
  var resizers = targetElement.querySelectorAll("." + RESIZE_HANDLER);
  for (var i = 0; i < resizers.length; i++) {
    selectedHandler = resizers[i];
    EventHandler.add(selectedHandler, "mousedown", onMouseDown, context);
    var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
    EventHandler.add(selectedHandler, eventName, onTouchStart, context);
  }
  var borderResizers = targetElement.querySelectorAll(".e-dialog-border-resize");
  if (!isNullOrUndefined(borderResizers)) {
    for (var i = 0; i < borderResizers.length; i++) {
      selectedHandler = borderResizers[i];
      EventHandler.add(selectedHandler, "mousedown", onMouseDown, context);
      var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
      EventHandler.add(selectedHandler, eventName, onTouchStart, context);
    }
  }
}
function getEventType(e) {
  return e.indexOf("mouse") > -1 ? "mouse" : "touch";
}
function onMouseDown(e) {
  e.preventDefault();
  targetElement = e.target.parentElement;
  calculateValues();
  originalMouseX = e.pageX;
  originalMouseY = e.pageY;
  e.target.classList.add(FOCUSED_HANDLER);
  if (!isNullOrUndefined(resizeStart)) {
    var proxy_1 = this;
    if (resizeStart(e, proxy_1) === true) {
      return;
    }
  }
  if (this.targetEle && targetElement && targetElement.querySelector("." + DIALOG_RESIZABLE)) {
    containerElement = this.target === "body" ? null : this.targetEle;
    maxWidth = this.targetEle.clientWidth;
    maxHeight = this.targetEle.clientHeight;
  }
  var target = isNullOrUndefined(containerElement) ? document : containerElement;
  EventHandler.add(target, "mousemove", onMouseMove, this);
  EventHandler.add(document, "mouseup", onMouseUp, this);
  for (var i = 0; i < RESTRICT_LEFT.length; i++) {
    if (targetElement.classList.contains(RESTRICT_LEFT[i])) {
      setLeft = false;
    } else {
      setLeft = true;
    }
  }
}
function onMouseUp(e) {
  var touchMoveEvent = Browser.info.name === "msie" ? "pointermove" : "touchmove";
  var touchEndEvent = Browser.info.name === "msie" ? "pointerup" : "touchend";
  var target = isNullOrUndefined(containerElement) ? document : containerElement;
  var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
  EventHandler.remove(target, "mousemove", onMouseMove);
  EventHandler.remove(target, touchMoveEvent, onMouseMove);
  EventHandler.remove(target, eventName, onMouseMove);
  if (!isNullOrUndefined(document.body.querySelector("." + FOCUSED_HANDLER))) {
    document.body.querySelector("." + FOCUSED_HANDLER).classList.remove(FOCUSED_HANDLER);
  }
  if (!isNullOrUndefined(resizeEnd)) {
    var proxy_2 = this;
    resizeEnd(e, proxy_2);
  }
  EventHandler.remove(document, "mouseup", onMouseUp);
  EventHandler.remove(document, touchEndEvent, onMouseUp);
}
function calculateValues() {
  originalWidth = parseFloat(getComputedStyle(targetElement, null).getPropertyValue("width").replace("px", ""));
  originalHeight = parseFloat(getComputedStyle(targetElement, null).getPropertyValue("height").replace("px", ""));
  originalX = targetElement.getBoundingClientRect().left;
  originalY = targetElement.getBoundingClientRect().top;
}
function onTouchStart(e) {
  targetElement = e.target.parentElement;
  calculateValues();
  var dialogResizeElement = targetElement.classList.contains("e-dialog");
  if ((e.target.classList.contains(RESIZE_HANDLER) || e.target.classList.contains("e-dialog-border-resize")) && dialogResizeElement) {
    e.target.classList.add(FOCUSED_HANDLER);
  }
  var coordinates = e.touches ? e.changedTouches[0] : e;
  originalMouseX = coordinates.pageX;
  originalMouseY = coordinates.pageY;
  if (!isNullOrUndefined(resizeStart)) {
    var proxy_3 = this;
    if (resizeStart(e, proxy_3) === true) {
      return;
    }
  }
  var touchMoveEvent = Browser.info.name === "msie" ? "pointermove" : "touchmove";
  var touchEndEvent = Browser.info.name === "msie" ? "pointerup" : "touchend";
  var target = isNullOrUndefined(containerElement) ? document : containerElement;
  EventHandler.add(target, touchMoveEvent, onMouseMove, this);
  EventHandler.add(document, touchEndEvent, onMouseUp, this);
}
function onMouseMove(e) {
  if (e.target.classList.contains(RESIZE_HANDLER) && e.target.classList.contains(FOCUSED_HANDLER)) {
    selectedHandler = e.target;
  } else if (!isNullOrUndefined(document.body.querySelector("." + FOCUSED_HANDLER))) {
    selectedHandler = document.body.querySelector("." + FOCUSED_HANDLER);
  }
  if (!isNullOrUndefined(selectedHandler)) {
    var resizeTowards = "";
    for (var i = 0; i < elementClass.length; i++) {
      if (selectedHandler.classList.contains("e-" + elementClass[i])) {
        resizeTowards = elementClass[i];
      }
    }
    if (!isNullOrUndefined(resize)) {
      var proxy_4 = this;
      resize(e, proxy_4);
    }
    switch (resizeTowards) {
      case "south":
        resizeSouth(e);
        break;
      case "north":
        resizeNorth(e);
        break;
      case "west":
        resizeWest(e);
        break;
      case "east":
        resizeEast(e);
        break;
      case "south-east":
        resizeSouth(e);
        resizeEast(e);
        break;
      case "south-west":
        resizeSouth(e);
        resizeWest(e);
        break;
      case "north-east":
        resizeNorth(e);
        resizeEast(e);
        break;
      case "north-west":
        resizeNorth(e);
        resizeWest(e);
        break;
      default:
        break;
    }
  }
}
function getClientRectValues(element2) {
  return element2.getBoundingClientRect();
}
function resizeSouth(e) {
  var documentHeight = document.documentElement.clientHeight;
  var calculateValue = false;
  var coordinates = e.touches ? e.changedTouches[0] : e;
  var currentpageY = coordinates.pageY;
  var targetRectValues = getClientRectValues(targetElement);
  var containerRectValues;
  if (!isNullOrUndefined(containerElement)) {
    containerRectValues = getClientRectValues(containerElement);
  }
  if (!isNullOrUndefined(containerElement)) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && (documentHeight - currentpageY >= 0 || targetRectValues.top < 0)) {
    calculateValue = true;
  }
  var calculatedHeight = originalHeight + (currentpageY - originalMouseY);
  calculatedHeight = calculatedHeight > minHeight ? calculatedHeight : minHeight;
  var containerTop = 0;
  if (!isNullOrUndefined(containerElement)) {
    containerTop = containerRectValues.top;
  }
  var borderValue = isNullOrUndefined(containerElement) ? 0 : containerElement.offsetHeight - containerElement.clientHeight;
  var topWithoutborder = targetRectValues.top - containerTop - borderValue / 2;
  topWithoutborder = topWithoutborder < 0 ? 0 : topWithoutborder;
  if (targetRectValues.top > 0 && topWithoutborder + calculatedHeight > maxHeight) {
    calculateValue = false;
    if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
      return;
    }
    targetElement.style.height = maxHeight - parseInt(topWithoutborder.toString(), 10) + "px";
    return;
  }
  var targetTop = 0;
  if (calculateValue) {
    if (targetRectValues.top < 0 && documentHeight + (targetRectValues.height + targetRectValues.top) > 0) {
      targetTop = targetRectValues.top;
      if (calculatedHeight + targetTop <= 30) {
        calculatedHeight = targetRectValues.height - (targetRectValues.height + targetRectValues.top) + 30;
      }
    }
    if (calculatedHeight + targetRectValues.top >= maxHeight) {
      targetElement.style.height = targetRectValues.height + (documentHeight - (targetRectValues.height + targetRectValues.top)) + "px";
    }
    var calculatedTop = isNullOrUndefined(containerElement) ? targetTop : topWithoutborder;
    if (calculatedHeight >= minHeight && calculatedHeight + calculatedTop <= maxHeight) {
      targetElement.style.height = calculatedHeight + "px";
    }
  }
}
function resizeNorth(e) {
  var calculateValue = false;
  var boundaryRectValues;
  var pageY = getEventType(e.type) === "mouse" ? e.pageY : e.touches[0].pageY;
  var targetRectValues = getClientRectValues(targetElement);
  if (!isNullOrUndefined(containerElement)) {
    boundaryRectValues = getClientRectValues(containerElement);
  }
  if (!isNullOrUndefined(containerElement) && targetRectValues.top - boundaryRectValues.top > 0) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && pageY > 0) {
    calculateValue = true;
  }
  var currentHeight = originalHeight - (pageY - originalMouseY);
  if (calculateValue) {
    if (currentHeight >= minHeight && currentHeight <= maxHeight) {
      var containerTop = 0;
      if (!isNullOrUndefined(containerElement)) {
        containerTop = boundaryRectValues.top;
      }
      var top_1 = originalY - containerTop + (pageY - originalMouseY);
      top_1 = top_1 > 0 ? top_1 : 1;
      targetElement.style.height = currentHeight + "px";
      targetElement.style.top = top_1 + "px";
    }
  }
}
function resizeWest(e) {
  var documentWidth = document.documentElement.clientWidth;
  var calculateValue = false;
  var rectValues;
  if (!isNullOrUndefined(containerElement)) {
    rectValues = getClientRectValues(containerElement);
  }
  var pageX = getEventType(e.type) === "mouse" ? e.pageX : e.touches[0].pageX;
  var targetRectValues = getClientRectValues(targetElement);
  var borderValue = isNullOrUndefined(containerElement) ? 0 : containerElement.offsetWidth - containerElement.clientWidth;
  var left = isNullOrUndefined(containerElement) ? 0 : rectValues.left;
  var containerWidth = isNullOrUndefined(containerElement) ? 0 : rectValues.width;
  if (isNullOrUndefined(resizeWestWidth)) {
    if (!isNullOrUndefined(containerElement)) {
      resizeWestWidth = targetRectValues.left - left - borderValue / 2 + targetRectValues.width;
      resizeWestWidth = resizeWestWidth + (containerWidth - borderValue - resizeWestWidth);
    } else {
      resizeWestWidth = documentWidth;
    }
  }
  if (!isNullOrUndefined(containerElement) && Math.floor(targetRectValues.left - rectValues.left + targetRectValues.width + (rectValues.right - targetRectValues.right)) - borderValue <= maxWidth) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && pageX >= 0) {
    calculateValue = true;
  }
  var calculatedWidth = originalWidth - (pageX - originalMouseX);
  if (setLeft) {
    calculatedWidth = calculatedWidth > resizeWestWidth ? resizeWestWidth : calculatedWidth;
  }
  if (calculateValue) {
    if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
      var containerLeft = 0;
      if (!isNullOrUndefined(containerElement)) {
        containerLeft = rectValues.left;
      }
      var left_1 = originalX - containerLeft + (pageX - originalMouseX);
      left_1 = left_1 > 0 ? left_1 : 1;
      if (calculatedWidth !== previousWidth && setWidth) {
        targetElement.style.width = calculatedWidth + "px";
      }
      if (setLeft) {
        targetElement.style.left = left_1 + "px";
        if (left_1 === 1) {
          setWidth = false;
        } else {
          setWidth = true;
        }
      }
    }
  }
  previousWidth = calculatedWidth;
}
function resizeEast(e) {
  var documentWidth = document.documentElement.clientWidth;
  var calculateValue = false;
  var containerRectValues;
  if (!isNullOrUndefined(containerElement)) {
    containerRectValues = getClientRectValues(containerElement);
  }
  var coordinates = e.touches ? e.changedTouches[0] : e;
  var pageX = coordinates.pageX;
  var targetRectValues = getClientRectValues(targetElement);
  if (!isNullOrUndefined(containerElement) && (targetRectValues.left - containerRectValues.left + targetRectValues.width <= maxWidth || targetRectValues.right - containerRectValues.left >= targetRectValues.width)) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && documentWidth - pageX > 0) {
    calculateValue = true;
  }
  var calculatedWidth = originalWidth + (pageX - originalMouseX);
  var containerLeft = 0;
  if (!isNullOrUndefined(containerElement)) {
    containerLeft = containerRectValues.left;
  }
  if (targetRectValues.left - containerLeft + calculatedWidth > maxWidth) {
    calculateValue = false;
    if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
      return;
    }
    targetElement.style.width = maxWidth - (targetRectValues.left - containerLeft) + "px";
  }
  if (calculateValue) {
    if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
      targetElement.style.width = calculatedWidth + "px";
    }
  }
}
function setMinHeight(minimumHeight) {
  minHeight = minimumHeight;
}
function setMaxWidth(value) {
  maxWidth = value;
}
function setMaxHeight(value) {
  maxHeight = value;
}
function removeResize() {
  var handlers = targetElement.querySelectorAll("." + RESIZE_HANDLER);
  for (var i = 0; i < handlers.length; i++) {
    detach(handlers[i]);
  }
  var borderResizers = targetElement.querySelectorAll(".e-dialog-border-resize");
  if (!isNullOrUndefined(borderResizers)) {
    for (var i = 0; i < borderResizers.length; i++) {
      detach(borderResizers[i]);
    }
  }
}

// node_modules/@syncfusion/ej2-popups/src/dialog/dialog.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ButtonProps = (
  /** @class */
  function(_super) {
    __extends9(ButtonProps2, _super);
    function ButtonProps2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate10([
      Property(true)
    ], ButtonProps2.prototype, "isFlat", void 0);
    __decorate10([
      Property()
    ], ButtonProps2.prototype, "buttonModel", void 0);
    __decorate10([
      Property("Button")
    ], ButtonProps2.prototype, "type", void 0);
    __decorate10([
      Event()
    ], ButtonProps2.prototype, "click", void 0);
    return ButtonProps2;
  }(ChildProperty)
);
var AnimationSettings = (
  /** @class */
  function(_super) {
    __extends9(AnimationSettings3, _super);
    function AnimationSettings3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate10([
      Property("Fade")
    ], AnimationSettings3.prototype, "effect", void 0);
    __decorate10([
      Property(400)
    ], AnimationSettings3.prototype, "duration", void 0);
    __decorate10([
      Property(0)
    ], AnimationSettings3.prototype, "delay", void 0);
    return AnimationSettings3;
  }(ChildProperty)
);
var ROOT = "e-dialog";
var RTL4 = "e-rtl";
var DLG_HEADER_CONTENT = "e-dlg-header-content";
var DLG_HEADER = "e-dlg-header";
var DLG_FOOTER_CONTENT = "e-footer-content";
var MODAL_DLG = "e-dlg-modal";
var DLG_CONTENT = "e-dlg-content";
var DLG_CLOSE_ICON = "e-icon-dlg-close";
var DLG_OVERLAY = "e-dlg-overlay";
var DLG_TARGET = "e-dlg-target";
var DLG_CONTAINER = "e-dlg-container";
var SCROLL_DISABLED = "e-scroll-disabled";
var DLG_PRIMARY_BUTTON = "e-primary";
var ICON = "e-icons";
var POPUP_ROOT = "e-popup";
var DEVICE = "e-device";
var FULLSCREEN = "e-dlg-fullscreen";
var DLG_CLOSE_ICON_BTN = "e-dlg-closeicon-btn";
var DLG_HIDE = "e-popup-close";
var DLG_SHOW = "e-popup-open";
var DLG_UTIL_DEFAULT_TITLE = "Information";
var DLG_UTIL_ROOT = "e-scroll-disabled";
var DLG_UTIL_ALERT = "e-alert-dialog";
var DLG_UTIL_CONFIRM = "e-confirm-dialog";
var DLG_RESIZABLE = "e-dlg-resizable";
var DLG_RESTRICT_LEFT_VALUE = "e-restrict-left";
var DLG_RESTRICT_WIDTH_VALUE = "e-resize-viewport";
var DLG_REF_ELEMENT = "e-dlg-ref-element";
var DLG_USER_ACTION_CLOSED = "user action";
var DLG_CLOSE_ICON_CLOSED = "close icon";
var DLG_ESCAPE_CLOSED = "escape";
var DLG_OVERLAYCLICK_CLOSED = "overlayClick";
var DLG_DRAG = "e-draggable";
var Dialog = (
  /** @class */
  function(_super) {
    __extends9(Dialog2, _super);
    function Dialog2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.needsID = true;
      return _this;
    }
    Dialog2.prototype.render = function() {
      this.initialize();
      this.initRender();
      this.wireEvents();
      if (this.width === "100%") {
        this.element.style.width = "";
      }
      if (this.minHeight !== "") {
        this.element.style.minHeight = formatUnit(this.minHeight);
      }
      if (this.enableResize) {
        this.setResize();
        if (this.animationSettings.effect === "None") {
          this.getMinHeight();
        }
      }
      this.renderComplete();
    };
    Dialog2.prototype.initializeValue = function() {
      this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
    };
    Dialog2.prototype.preRender = function() {
      var _this = this;
      this.initializeValue();
      this.headerContent = null;
      this.allowMaxHeight = true;
      this.preventVisibility = true;
      this.clonedEle = this.element.cloneNode(true);
      this.closeIconClickEventHandler = function(event) {
        _this.dlgClosedBy = DLG_CLOSE_ICON_CLOSED;
        _this.hide(event);
      };
      this.dlgOverlayClickEventHandler = function(event) {
        _this.dlgClosedBy = DLG_OVERLAYCLICK_CLOSED;
        event.preventFocus = false;
        _this.trigger("overlayClick", event, function(overlayClickEventArgs) {
          if (!overlayClickEventArgs.preventFocus) {
            _this.focusContent();
          }
          _this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
        });
      };
      var localeText = { close: "Close" };
      this.l10n = new L10n("dialog", localeText, this.locale);
      this.checkPositionData();
      if (isNullOrUndefined(this.target)) {
        var prevOnChange = this.isProtectedOnChange;
        this.isProtectedOnChange = true;
        this.target = document.body;
        this.isProtectedOnChange = prevOnChange;
      }
    };
    Dialog2.prototype.updatePersistData = function() {
      if (this.enablePersistence) {
        this.setProperties({
          width: parseFloat(this.element.style.width),
          height: parseFloat(this.element.style.height),
          position: { X: parseFloat(this.dragObj.element.style.left), Y: parseFloat(this.dragObj.element.style.top) }
        }, true);
      }
    };
    Dialog2.prototype.isNumberValue = function(value) {
      var isNumber = /^[-+]?\d*\.?\d+$/.test(value);
      return isNumber;
    };
    Dialog2.prototype.checkPositionData = function() {
      if (!isNullOrUndefined(this.position)) {
        if (!isNullOrUndefined(this.position.X) && typeof this.position.X !== "number") {
          var isNumber = this.isNumberValue(this.position.X);
          if (isNumber) {
            var prevOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            this.position.X = parseFloat(this.position.X);
            this.isProtectedOnChange = prevOnChange;
          }
        }
        if (!isNullOrUndefined(this.position.Y) && typeof this.position.Y !== "number") {
          var isNumber = this.isNumberValue(this.position.Y);
          if (isNumber) {
            var prevOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            this.position.Y = parseFloat(this.position.Y);
            this.isProtectedOnChange = prevOnChange;
          }
        }
      }
    };
    Dialog2.prototype.getEle = function(list, selector) {
      var element2 = void 0;
      for (var i = 0; i < list.length; i++) {
        if (list[i].classList.contains(selector)) {
          element2 = list[i];
          break;
        }
      }
      return element2;
    };
    Dialog2.prototype.getMinHeight = function() {
      var computedHeaderHeight = "0px";
      var computedFooterHeight = "0px";
      if (!isNullOrUndefined(this.element.querySelector("." + DLG_HEADER_CONTENT))) {
        computedHeaderHeight = getComputedStyle(this.headerContent).height;
      }
      var footerEle = this.getEle(this.element.children, DLG_FOOTER_CONTENT);
      if (!isNullOrUndefined(footerEle)) {
        computedFooterHeight = getComputedStyle(footerEle).height;
      }
      var headerHeight = parseInt(computedHeaderHeight.slice(0, computedHeaderHeight.indexOf("p")), 10);
      var footerHeight = parseInt(computedFooterHeight.slice(0, computedFooterHeight.indexOf("p")), 10);
      setMinHeight(headerHeight + 30 + (isNaN(footerHeight) ? 0 : footerHeight));
      return headerHeight + 30 + footerHeight;
    };
    Dialog2.prototype.onResizeStart = function(args, dialogObj) {
      dialogObj.trigger("resizeStart", args);
      return args.cancel;
    };
    Dialog2.prototype.onResizing = function(args, dialogObj) {
      dialogObj.trigger("resizing", args);
    };
    Dialog2.prototype.onResizeComplete = function(args, dialogObj) {
      dialogObj.trigger("resizeStop", args);
      this.updatePersistData();
    };
    Dialog2.prototype.setResize = function() {
      if (this.enableResize) {
        if (this.isBlazorServerRender() && !isNullOrUndefined(this.element.querySelector(".e-icons.e-resize-handle"))) {
          return;
        }
        this.element.classList.add(DLG_RESIZABLE);
        var computedHeight = getComputedStyle(this.element).minHeight;
        var computedWidth = getComputedStyle(this.element).minWidth;
        var direction = "";
        for (var i = 0; i < this.resizeHandles.length; i++) {
          if (this.resizeHandles[i] === "All") {
            direction = "south north east west north-east north-west south-east south-west";
            break;
          } else {
            var directionValue = "";
            switch (this.resizeHandles[i].toString()) {
              case "SouthEast":
                directionValue = "south-east";
                break;
              case "SouthWest":
                directionValue = "south-west";
                break;
              case "NorthEast":
                directionValue = "north-east";
                break;
              case "NorthWest":
                directionValue = "north-west";
                break;
              default:
                directionValue = this.resizeHandles[i].toString();
                break;
            }
            direction += directionValue.toLocaleLowerCase() + " ";
          }
        }
        if (this.enableRtl && direction.trim() === "south-east") {
          direction = "south-west";
        } else if (this.enableRtl && direction.trim() === "south-west") {
          direction = "south-east";
        }
        if (this.isModal && this.enableRtl) {
          this.element.classList.add(DLG_RESTRICT_LEFT_VALUE);
        } else if (this.isModal && this.target === document.body) {
          this.element.classList.add(DLG_RESTRICT_WIDTH_VALUE);
        }
        createResize({
          element: this.element,
          direction,
          minHeight: parseInt(computedHeight.slice(0, computedWidth.indexOf("p")), 10),
          maxHeight: this.targetEle.clientHeight,
          minWidth: parseInt(computedWidth.slice(0, computedWidth.indexOf("p")), 10),
          maxWidth: this.targetEle.clientWidth,
          boundary: this.target === document.body ? null : this.targetEle,
          resizeBegin: this.onResizeStart.bind(this),
          resizeComplete: this.onResizeComplete.bind(this),
          resizing: this.onResizing.bind(this),
          proxy: this
        });
        this.wireWindowResizeEvent();
      } else {
        removeResize();
        this.unWireWindowResizeEvent();
        if (this.isModal) {
          this.element.classList.remove(DLG_RESTRICT_LEFT_VALUE);
        } else {
          this.element.classList.remove(DLG_RESTRICT_WIDTH_VALUE);
        }
        this.element.classList.remove(DLG_RESIZABLE);
      }
    };
    Dialog2.prototype.getFocusElement = function(target) {
      var value = 'input,select,textarea,button:enabled,a,[contenteditable="true"],[tabindex]';
      var items = target.querySelectorAll(value);
      return { element: items[items.length - 1] };
    };
    Dialog2.prototype.keyDown = function(event) {
      var _this = this;
      if (event.keyCode === 9) {
        if (this.isModal) {
          var buttonObj = void 0;
          if (!isNullOrUndefined(this.btnObj)) {
            buttonObj = this.btnObj[this.btnObj.length - 1];
          }
          if (isNullOrUndefined(this.btnObj) && !isNullOrUndefined(this.ftrTemplateContent)) {
            buttonObj = this.getFocusElement(this.ftrTemplateContent);
          }
          if (isNullOrUndefined(this.btnObj) && isNullOrUndefined(this.ftrTemplateContent) && !isNullOrUndefined(this.contentEle)) {
            buttonObj = this.getFocusElement(this.contentEle);
          }
          if (!isNullOrUndefined(buttonObj) && document.activeElement === buttonObj.element && !event.shiftKey) {
            event.preventDefault();
            this.focusableElements(this.element).focus();
          }
          if (document.activeElement === this.focusableElements(this.element) && event.shiftKey) {
            event.preventDefault();
            if (!isNullOrUndefined(buttonObj)) {
              buttonObj.element.focus();
            }
          }
        }
      }
      var element2 = document.activeElement;
      var isTagName = ["input", "textarea"].indexOf(element2.tagName.toLowerCase()) > -1;
      var isContentEdit = false;
      if (!isTagName) {
        isContentEdit = element2.hasAttribute("contenteditable") && element2.getAttribute("contenteditable") === "true";
      }
      if (event.keyCode === 27 && this.closeOnEscape) {
        this.dlgClosedBy = DLG_ESCAPE_CLOSED;
        var query = document.querySelector(".e-popup-open:not(.e-dialog)");
        if (!(!isNullOrUndefined(query) && !query.classList.contains("e-toolbar-pop"))) {
          this.hide(event);
        }
      }
      if (event.keyCode === 13 && !event.ctrlKey && element2.tagName.toLowerCase() !== "textarea" && isTagName && !isNullOrUndefined(this.primaryButtonEle) || event.keyCode === 13 && event.ctrlKey && (element2.tagName.toLowerCase() === "textarea" || isContentEdit) && !isNullOrUndefined(this.primaryButtonEle)) {
        var buttonIndex_1;
        var firstPrimary = this.buttons.some(function(data, index) {
          buttonIndex_1 = index;
          var buttonModel = data.buttonModel;
          return !isNullOrUndefined(buttonModel) && buttonModel.isPrimary === true;
        });
        if (firstPrimary && typeof this.buttons[buttonIndex_1].click === "function") {
          setTimeout(function() {
            _this.buttons[buttonIndex_1].click.call(_this, event);
          });
        }
      }
    };
    Dialog2.prototype.initialize = function() {
      if (!isNullOrUndefined(this.target)) {
        this.targetEle = typeof this.target === "string" ? document.querySelector(this.target) : this.target;
      }
      if (!this.isBlazorServerRender()) {
        addClass([this.element], ROOT);
      }
      if (Browser.isDevice) {
        addClass([this.element], DEVICE);
      }
      if (!this.isBlazorServerRender()) {
        this.setCSSClass();
      }
      this.setMaxHeight();
    };
    Dialog2.prototype.initRender = function() {
      var _this = this;
      this.initialRender = true;
      if (!this.isBlazorServerRender()) {
        attributes(this.element, { role: "dialog" });
      }
      if (this.zIndex === 1e3) {
        this.setzIndex(this.element, false);
        this.calculatezIndex = true;
      } else {
        this.calculatezIndex = false;
      }
      if (this.isBlazorServerRender() && isNullOrUndefined(this.headerContent)) {
        this.headerContent = this.element.getElementsByClassName("e-dlg-header-content")[0];
      }
      if (this.isBlazorServerRender() && isNullOrUndefined(this.contentEle)) {
        this.contentEle = this.element.querySelector("#" + this.element.id + "_dialog-content");
      }
      if (!this.isBlazorServerRender()) {
        this.setTargetContent();
        if (this.header !== "" && !isNullOrUndefined(this.header)) {
          this.setHeader();
        }
        this.renderCloseIcon();
        this.setContent();
        if (this.footerTemplate !== "" && !isNullOrUndefined(this.footerTemplate)) {
          this.setFooterTemplate();
        } else if (!isNullOrUndefined(this.buttons[0].buttonModel)) {
          this.setButton();
        }
      }
      if (this.isBlazorServerRender()) {
        if (!isNullOrUndefined(this.buttons[0].buttonModel) && this.footerTemplate === "") {
          this.setButton();
        }
      }
      if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
        this.setAllowDragging();
      }
      if (!this.isBlazorServerRender()) {
        attributes(this.element, { "aria-modal": this.isModal ? "true" : "false" });
        if (this.isModal) {
          this.setIsModal();
        }
      }
      if (this.isBlazorServerRender() && isNullOrUndefined(this.dlgContainer)) {
        this.dlgContainer = this.element.parentElement;
        for (var i = 0, childNodes = this.dlgContainer.children; i < childNodes.length; i++) {
          if (childNodes[i].classList.contains("e-dlg-overlay")) {
            this.dlgOverlay = childNodes[i];
          }
        }
      }
      if (this.element.classList.contains(DLG_UTIL_ALERT) !== true && this.element.classList.contains(DLG_UTIL_CONFIRM) !== true && !isNullOrUndefined(this.element.parentElement)) {
        var parentEle = this.isModal ? this.dlgContainer.parentElement : this.element.parentElement;
        this.refElement = this.createElement("div", { className: DLG_REF_ELEMENT });
        parentEle.insertBefore(this.refElement, this.isModal ? this.dlgContainer : this.element);
      }
      if (!isNullOrUndefined(this.targetEle)) {
        if (this.isModal) {
          this.targetEle.appendChild(this.dlgContainer);
        } else {
          this.targetEle.appendChild(this.element);
        }
      }
      this.popupObj = new Popup(this.element, {
        height: this.height,
        width: this.width,
        zIndex: this.zIndex,
        relateTo: this.target,
        actionOnScroll: "none",
        enableRtl: this.enableRtl,
        // eslint-disable-next-line
        open: function(event) {
          var eventArgs = {
            container: _this.isModal ? _this.dlgContainer : _this.element,
            element: _this.element,
            target: _this.target,
            preventFocus: false
          };
          if (_this.enableResize) {
            _this.resetResizeIcon();
          }
          _this.trigger("open", eventArgs, function(openEventArgs) {
            if (!openEventArgs.preventFocus) {
              _this.focusContent();
            }
          });
        },
        // eslint-disable-next-line
        close: function(event) {
          if (_this.isModal) {
            addClass([_this.dlgOverlay], "e-fade");
          }
          _this.unBindEvent(_this.element);
          if (_this.isModal) {
            _this.dlgContainer.style.display = "none";
          }
          _this.trigger("close", _this.closeArgs);
          var activeEle = document.activeElement;
          if (!isNullOrUndefined(activeEle) && !isNullOrUndefined(activeEle.blur)) {
            activeEle.blur();
          }
          if (!isNullOrUndefined(_this.storeActiveElement) && !isNullOrUndefined(_this.storeActiveElement.focus)) {
            _this.storeActiveElement.focus();
          }
        }
      });
      this.positionChange();
      this.setEnableRTL();
      if (!this.isBlazorServerRender()) {
        addClass([this.element], DLG_HIDE);
        if (this.isModal) {
          this.setOverlayZindex();
        }
      }
      if (this.visible) {
        this.show();
        if (this.isModal) {
          var targetType = this.getTargetContainer(this.target);
          if (targetType instanceof Element) {
            var computedStyle = window.getComputedStyle(targetType);
            if (computedStyle.getPropertyValue("direction") === "rtl") {
              this.setPopupPosition();
            }
          }
        }
      } else {
        if (this.isModal) {
          this.dlgOverlay.style.display = "none";
        }
      }
      this.initialRender = false;
    };
    Dialog2.prototype.getTargetContainer = function(targetValue) {
      var targetElement2 = null;
      if (typeof targetValue === "string") {
        if (targetValue.startsWith("#")) {
          targetElement2 = document.getElementById(targetValue.substring(1));
        } else if (targetValue.startsWith(".")) {
          var elements = document.getElementsByClassName(targetValue.substring(1));
          targetElement2 = elements.length > 0 ? elements[0] : null;
        } else {
          if (!(targetValue instanceof HTMLElement) && targetValue !== document.body) {
            targetElement2 = document.querySelector(targetValue);
          }
        }
      } else if (targetValue instanceof HTMLElement) {
        targetElement2 = targetValue;
      }
      return targetElement2;
    };
    Dialog2.prototype.resetResizeIcon = function() {
      var dialogConHeight = this.getMinHeight();
      if (this.targetEle.offsetHeight < dialogConHeight) {
        var className = this.enableRtl ? "e-south-west" : "e-south-east";
        var resizeIcon = this.element.querySelector("." + className);
        if (!isNullOrUndefined(resizeIcon)) {
          resizeIcon.style.bottom = "-" + dialogConHeight.toString() + "px";
        }
      }
    };
    Dialog2.prototype.setOverlayZindex = function(zIndexValue) {
      var zIndex;
      if (isNullOrUndefined(zIndexValue)) {
        zIndex = parseInt(this.element.style.zIndex, 10) ? parseInt(this.element.style.zIndex, 10) : this.zIndex;
      } else {
        zIndex = zIndexValue;
      }
      this.dlgOverlay.style.zIndex = (zIndex - 1).toString();
      this.dlgContainer.style.zIndex = zIndex.toString();
    };
    Dialog2.prototype.positionChange = function() {
      if (this.isModal) {
        if (!isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else if (!isNaN(parseFloat(this.position.X)) && isNaN(parseFloat(this.position.Y)) || isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else {
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          this.dlgContainer.classList.add("e-dlg-" + this.position.X + "-" + this.position.Y);
        }
      } else {
        this.setPopupPosition();
      }
    };
    Dialog2.prototype.setPopupPosition = function() {
      this.popupObj.setProperties({
        position: {
          X: this.position.X,
          Y: this.position.Y
        }
      });
    };
    Dialog2.prototype.setAllowDragging = function() {
      var _this = this;
      var handleContent = "." + DLG_HEADER_CONTENT;
      if (!this.element.classList.contains(DLG_DRAG)) {
        this.dragObj = new Draggable(this.element, {
          clone: false,
          isDragScroll: true,
          abort: ".e-dlg-closeicon-btn",
          handle: handleContent,
          dragStart: function(event) {
            _this.trigger("dragStart", event, function(dragEventArgs) {
              if (isBlazor()) {
                dragEventArgs.bindEvents(event.dragElement);
              }
            });
          },
          dragStop: function(event) {
            if (_this.isModal) {
              _this.IsDragStop = true;
              if (!isNullOrUndefined(_this.position)) {
                _this.dlgContainer.classList.remove("e-dlg-" + _this.position.X + "-" + _this.position.Y);
              }
              var targetType = _this.getTargetContainer(_this.target);
              if (targetType instanceof Element) {
                var computedStyle = window.getComputedStyle(targetType);
                if (computedStyle.getPropertyValue("direction") === "rtl") {
                  _this.element.style.position = "absolute";
                } else {
                  _this.element.style.position = "relative";
                }
              } else {
                _this.element.style.position = "relative";
              }
            }
            _this.trigger("dragStop", event);
            _this.element.classList.remove(DLG_RESTRICT_LEFT_VALUE);
            _this.updatePersistData();
          },
          drag: function(event) {
            _this.trigger("drag", event);
          }
        });
        if (!isNullOrUndefined(this.targetEle)) {
          this.dragObj.dragArea = this.targetEle;
        }
      }
    };
    Dialog2.prototype.setButton = function() {
      if (!this.isBlazorServerRender()) {
        this.buttonContent = [];
        this.btnObj = [];
        for (var i = 0; i < this.buttons.length; i++) {
          var buttonType = !isNullOrUndefined(this.buttons[i].type) ? this.buttons[i].type.toLowerCase() : "button";
          var btn = this.createElement("button", { className: this.cssClass, attrs: { type: buttonType } });
          this.buttonContent.push(btn.outerHTML);
        }
        this.setFooterTemplate();
      }
      var footerBtn;
      for (var i = 0, childNodes = this.element.children; i < childNodes.length; i++) {
        if (childNodes[i].classList.contains(DLG_FOOTER_CONTENT)) {
          footerBtn = childNodes[i].querySelectorAll("button");
        }
      }
      for (var i = 0; i < this.buttons.length; i++) {
        if (!this.isBlazorServerRender()) {
          this.btnObj[i] = new Button(this.buttons[i].buttonModel);
        }
        if (this.isBlazorServerRender()) {
          this.ftrTemplateContent = this.element.querySelector("." + DLG_FOOTER_CONTENT);
        }
        if (!isNullOrUndefined(this.ftrTemplateContent) && footerBtn.length > 0) {
          if (typeof this.buttons[i].click === "function") {
            EventHandler.add(footerBtn[i], "click", this.buttons[i].click, this);
          }
          if (typeof this.buttons[i].click === "object") {
            EventHandler.add(footerBtn[i], "click", this.buttonClickHandler.bind(this, i), this);
          }
        }
        if (!this.isBlazorServerRender() && !isNullOrUndefined(this.ftrTemplateContent)) {
          this.btnObj[i].appendTo(this.ftrTemplateContent.children[i]);
          if (this.buttons[i].isFlat) {
            this.btnObj[i].element.classList.add("e-flat");
          }
          this.primaryButtonEle = this.element.getElementsByClassName("e-primary")[0];
        }
      }
    };
    Dialog2.prototype.buttonClickHandler = function(index) {
      this.trigger("buttons[" + index + "].click", {});
    };
    Dialog2.prototype.setContent = function() {
      this.contentEle = this.createElement("div", { className: DLG_CONTENT, id: this.element.id + "_dialog-content" });
      if (this.headerEle) {
        attributes(this.element, { "aria-describedby": this.element.id + "_title " + this.element.id + "_dialog-content" });
      } else {
        attributes(this.element, { "aria-describedby": this.element.id + "_dialog-content" });
      }
      if (this.innerContentElement) {
        this.contentEle.appendChild(this.innerContentElement);
      } else if (!isNullOrUndefined(this.content) && this.content !== "" || !this.initialRender) {
        if (typeof this.content === "string" && !isBlazor()) {
          this.setTemplate(this.content, this.contentEle, "content");
        } else if (this.content instanceof HTMLElement) {
          this.contentEle.appendChild(this.content);
        } else {
          this.setTemplate(this.content, this.contentEle, "content");
        }
      }
      if (!isNullOrUndefined(this.headerContent)) {
        this.element.insertBefore(this.contentEle, this.element.children[1]);
      } else {
        this.element.insertBefore(this.contentEle, this.element.children[0]);
      }
      if (this.height === "auto") {
        if (!this.isBlazorServerRender() && Browser.isIE && this.element.style.width === "" && !isNullOrUndefined(this.width)) {
          this.element.style.width = formatUnit(this.width);
        }
        this.setMaxHeight();
      }
    };
    Dialog2.prototype.setTemplate = function(template, toElement, prop) {
      var templateFn;
      var templateProps;
      if (toElement.classList.contains(DLG_HEADER)) {
        templateProps = this.element.id + "header";
      } else if (toElement.classList.contains(DLG_FOOTER_CONTENT)) {
        templateProps = this.element.id + "footerTemplate";
      } else {
        templateProps = this.element.id + "content";
      }
      var templateValue;
      if (!isNullOrUndefined(template.outerHTML)) {
        toElement.appendChild(template);
      } else if (typeof template === "string" || typeof template !== "string" || isBlazor() && !this.isStringTemplate) {
        if (typeof template === "string") {
          template = this.sanitizeHelper(template);
        }
        if (this.isVue || typeof template !== "string") {
          templateFn = compile(template);
          templateValue = template;
        } else {
          toElement.innerHTML = template;
        }
      }
      var fromElements = [];
      if (!isNullOrUndefined(templateFn)) {
        var isString = isBlazor() && !this.isStringTemplate && templateValue.indexOf("<div>Blazor") === 0 ? this.isStringTemplate : true;
        for (var _i = 0, _a = templateFn({}, this, prop, templateProps, isString); _i < _a.length; _i++) {
          var item = _a[_i];
          fromElements.push(item);
        }
        append([].slice.call(fromElements), toElement);
      }
    };
    Dialog2.prototype.sanitizeHelper = function(value) {
      if (this.enableHtmlSanitizer) {
        var dialogItem = SanitizeHtmlHelper.beforeSanitize();
        var beforeEvent = {
          cancel: false,
          helper: null
        };
        extend(dialogItem, dialogItem, beforeEvent);
        this.trigger("beforeSanitizeHtml", dialogItem);
        if (dialogItem.cancel && !isNullOrUndefined(dialogItem.helper)) {
          value = dialogItem.helper(value);
        } else if (!dialogItem.cancel) {
          value = SanitizeHtmlHelper.serializeValue(dialogItem, value);
        }
      }
      return value;
    };
    Dialog2.prototype.setMaxHeight = function() {
      if (!this.allowMaxHeight) {
        return;
      }
      var display = this.element.style.display;
      this.element.style.display = "none";
      this.element.style.maxHeight = !isNullOrUndefined(this.target) && this.targetEle.offsetHeight < window.innerHeight ? this.targetEle.offsetHeight - 20 + "px" : window.innerHeight - 20 + "px";
      this.element.style.display = display;
      if (Browser.isIE && this.height === "auto" && !isNullOrUndefined(this.contentEle) && this.element.offsetHeight < this.contentEle.offsetHeight) {
        this.element.style.height = "inherit";
      }
    };
    Dialog2.prototype.setEnableRTL = function() {
      if (!this.isBlazorServerRender()) {
        if (this.enableRtl) {
          addClass([this.element], RTL4);
        } else {
          removeClass([this.element], RTL4);
        }
      }
      if (!isNullOrUndefined(this.element.querySelector(".e-resize-handle"))) {
        removeResize();
        this.setResize();
      }
    };
    Dialog2.prototype.setTargetContent = function() {
      var _this = this;
      if (isNullOrUndefined(this.content) || this.content === "") {
        var isContent = this.element.innerHTML.replace(/\s|<(\/?|\/?)(!--!--)>/g, "") !== "";
        if (this.element.children.length > 0 || isContent) {
          this.innerContentElement = document.createDocumentFragment();
          [].slice.call(this.element.childNodes).forEach(function(el) {
            if (el.nodeType !== 8) {
              _this.innerContentElement.appendChild(el);
            }
          });
        }
      }
    };
    Dialog2.prototype.setHeader = function() {
      if (this.headerEle) {
        this.headerEle.innerHTML = "";
      } else {
        this.headerEle = this.createElement("div", { id: this.element.id + "_title", className: DLG_HEADER });
      }
      this.createHeaderContent();
      this.headerContent.appendChild(this.headerEle);
      this.setTemplate(this.header, this.headerEle, "header");
      attributes(this.element, { "aria-describedby": this.element.id + "_title" });
      attributes(this.element, { "aria-label": "dialog" });
      this.element.insertBefore(this.headerContent, this.element.children[0]);
      if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
        this.setAllowDragging();
      }
    };
    Dialog2.prototype.setFooterTemplate = function() {
      if (this.ftrTemplateContent) {
        this.ftrTemplateContent.innerHTML = "";
      } else {
        this.ftrTemplateContent = this.createElement("div", {
          className: DLG_FOOTER_CONTENT
        });
      }
      if (this.footerTemplate !== "" && !isNullOrUndefined(this.footerTemplate)) {
        this.setTemplate(this.footerTemplate, this.ftrTemplateContent, "footerTemplate");
      } else {
        this.ftrTemplateContent.innerHTML = this.buttonContent.join("");
      }
      this.element.appendChild(this.ftrTemplateContent);
    };
    Dialog2.prototype.createHeaderContent = function() {
      if (isNullOrUndefined(this.headerContent)) {
        this.headerContent = this.createElement("div", { id: this.element.id + "_dialog-header", className: DLG_HEADER_CONTENT });
      }
    };
    Dialog2.prototype.renderCloseIcon = function() {
      if (this.showCloseIcon) {
        this.closeIcon = this.createElement("button", { className: DLG_CLOSE_ICON_BTN, attrs: { type: "button" } });
        this.closeIconBtnObj = new Button({ cssClass: "e-flat", iconCss: DLG_CLOSE_ICON + " " + ICON });
        this.closeIconTitle();
        if (!isNullOrUndefined(this.headerContent)) {
          prepend([this.closeIcon], this.headerContent);
        } else {
          this.createHeaderContent();
          prepend([this.closeIcon], this.headerContent);
          this.element.insertBefore(this.headerContent, this.element.children[0]);
        }
        this.closeIconBtnObj.appendTo(this.closeIcon);
      }
    };
    Dialog2.prototype.closeIconTitle = function() {
      this.l10n.setLocale(this.locale);
      var closeIconTitle = this.l10n.getConstant("close");
      this.closeIcon.setAttribute("title", closeIconTitle);
      this.closeIcon.setAttribute("aria-label", closeIconTitle);
    };
    Dialog2.prototype.setCSSClass = function(oldCSSClass) {
      if (oldCSSClass) {
        removeClass([this.element], oldCSSClass.split(" "));
        if (this.isModal && !isNullOrUndefined(this.dlgContainer)) {
          removeClass([this.dlgContainer], oldCSSClass.split(" "));
        }
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
        if (this.isModal && !isNullOrUndefined(this.dlgContainer)) {
          addClass([this.dlgContainer], this.cssClass.split(" "));
        }
      }
    };
    Dialog2.prototype.setIsModal = function() {
      this.dlgContainer = this.createElement("div", { className: DLG_CONTAINER });
      this.setCSSClass();
      this.element.classList.remove(DLG_SHOW);
      this.element.parentNode.insertBefore(this.dlgContainer, this.element);
      this.dlgContainer.appendChild(this.element);
      addClass([this.element], MODAL_DLG);
      this.dlgOverlay = this.createElement("div", { className: DLG_OVERLAY });
      this.dlgOverlay.style.zIndex = (this.zIndex - 1).toString();
      this.dlgContainer.appendChild(this.dlgOverlay);
    };
    Dialog2.prototype.getValidFocusNode = function(items) {
      var node;
      for (var u = 0; u < items.length; u++) {
        node = items[u];
        if ((node.clientHeight > 0 || node.tagName.toLowerCase() === "a" && node.hasAttribute("href")) && node.tabIndex > -1 && !node.disabled && !this.disableElement(node, '[disabled],[aria-disabled="true"],[type="hidden"]')) {
          return node;
        } else {
          node = null;
        }
      }
      return node;
    };
    Dialog2.prototype.focusableElements = function(content) {
      if (!isNullOrUndefined(content)) {
        var value = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
        var items = content.querySelectorAll(value);
        return this.getValidFocusNode(items);
      }
      return null;
    };
    Dialog2.prototype.getAutoFocusNode = function(container) {
      var node = container.querySelector("." + DLG_CLOSE_ICON_BTN);
      var value = "[autofocus]";
      var items = container.querySelectorAll(value);
      var validNode = this.getValidFocusNode(items);
      if (isBlazor()) {
        this.primaryButtonEle = this.element.getElementsByClassName("e-primary")[0];
      }
      if (!isNullOrUndefined(validNode)) {
        node = validNode;
      } else {
        validNode = this.focusableElements(this.contentEle);
        if (!isNullOrUndefined(validNode)) {
          return node = validNode;
        } else if (!isNullOrUndefined(this.primaryButtonEle)) {
          return this.element.querySelector("." + DLG_PRIMARY_BUTTON);
        }
      }
      return node;
    };
    Dialog2.prototype.disableElement = function(element2, t) {
      var elementMatch = element2 ? element2.matches || element2.webkitMatchesSelector || element2.msGetRegionContent : null;
      if (elementMatch) {
        for (; element2; element2 = element2.parentNode) {
          if (element2 instanceof Element && elementMatch.call(element2, t)) {
            return element2;
          }
        }
      }
      return null;
    };
    Dialog2.prototype.focusContent = function() {
      var element2 = this.getAutoFocusNode(this.element);
      var node = !isNullOrUndefined(element2) ? element2 : this.element;
      var userAgent = Browser.userAgent;
      if (userAgent.indexOf("MSIE ") > 0 || userAgent.indexOf("Trident/") > 0) {
        this.element.focus();
      }
      node.focus();
      this.unBindEvent(this.element);
      this.bindEvent(this.element);
    };
    Dialog2.prototype.bindEvent = function(element2) {
      EventHandler.add(element2, "keydown", this.keyDown, this);
    };
    Dialog2.prototype.unBindEvent = function(element2) {
      EventHandler.remove(element2, "keydown", this.keyDown);
    };
    Dialog2.prototype.updateSanitizeContent = function() {
      if (!this.isBlazorServerRender()) {
        this.contentEle.innerHTML = this.sanitizeHelper(this.content);
      }
    };
    Dialog2.prototype.isBlazorServerRender = function() {
      return isBlazor() && this.isServerRendered;
    };
    Dialog2.prototype.getModuleName = function() {
      return "dialog";
    };
    Dialog2.prototype.onPropertyChanged = function(newProp, oldProp) {
      if (!this.element.classList.contains(ROOT)) {
        return;
      }
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "content":
            if (!isNullOrUndefined(this.content) && this.content !== "") {
              if (this.isBlazorServerRender()) {
                this.contentEle = this.element.querySelector(".e-dlg-content");
              }
              if (!isNullOrUndefined(this.contentEle) && this.contentEle.getAttribute("role") !== "dialog") {
                if (!this.isBlazorServerRender()) {
                  this.contentEle.innerHTML = "";
                }
                if (typeof this.content === "function") {
                  this.clearTemplate(["content"]);
                  detach(this.contentEle);
                  this.contentEle = null;
                  this.setContent();
                } else {
                  if (typeof this.content === "string") {
                    if (this.isBlazorServerRender() && this.contentEle.innerText === "") {
                      this.contentEle.insertAdjacentHTML("beforeend", this.sanitizeHelper(this.content));
                    } else {
                      this.updateSanitizeContent();
                    }
                  } else {
                    this.contentEle.appendChild(this.content);
                  }
                }
                this.setMaxHeight();
              } else {
                if (!this.isBlazorServerRender() || isNullOrUndefined(this.element.querySelector(".e-dlg-content"))) {
                  this.setContent();
                }
              }
            } else if (!isNullOrUndefined(this.contentEle)) {
              detach(this.contentEle);
              this.contentEle = null;
            }
            break;
          case "header":
            if (this.header === "" || isNullOrUndefined(this.header)) {
              if (this.headerEle) {
                detach(this.headerEle);
                this.headerEle = null;
              }
            } else {
              if (!this.isBlazorServerRender() || isNullOrUndefined(this.element.querySelector(".e-dlg-header-content"))) {
                this.setHeader();
              }
            }
            break;
          case "footerTemplate":
            if (this.footerTemplate === "" || isNullOrUndefined(this.footerTemplate)) {
              if (!this.ftrTemplateContent) {
                return;
              }
              detach(this.ftrTemplateContent);
              this.ftrTemplateContent = null;
              this.buttons = [{}];
            } else {
              if (!this.isBlazorServerRender() || isNullOrUndefined(this.element.querySelector(".e-footer-content"))) {
                this.setFooterTemplate();
              }
              this.buttons = [{}];
            }
            break;
          case "showCloseIcon":
            if (this.element.getElementsByClassName(DLG_CLOSE_ICON).length > 0) {
              if (!this.showCloseIcon && (this.header === "" || isNullOrUndefined(this.header))) {
                detach(this.headerContent);
                this.headerContent = null;
              } else if (!this.showCloseIcon) {
                detach(this.closeIcon);
              } else {
                if (this.isBlazorServerRender()) {
                  this.wireEvents();
                }
              }
            } else {
              if (!this.isBlazorServerRender()) {
                this.renderCloseIcon();
              }
              this.wireEvents();
            }
            break;
          case "locale":
            if (this.showCloseIcon) {
              this.closeIconTitle();
            }
            break;
          case "visible":
            if (this.visible) {
              this.show();
            } else {
              this.hide();
            }
            break;
          case "isModal":
            this.updateIsModal();
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            this.updatePersistData();
            break;
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(newProp.width) });
            this.updatePersistData();
            break;
          case "zIndex":
            this.popupObj.zIndex = this.zIndex;
            if (this.isModal) {
              this.setOverlayZindex(this.zIndex);
            }
            if (this.element.style.zIndex !== this.zIndex.toString()) {
              this.calculatezIndex = false;
            }
            break;
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
          case "buttons": {
            var buttonCount = this.buttons.length;
            if (!isNullOrUndefined(this.ftrTemplateContent) && !this.isBlazorServerRender()) {
              detach(this.ftrTemplateContent);
              this.ftrTemplateContent = null;
            }
            for (var i = 0; i < buttonCount; i++) {
              if (!isNullOrUndefined(this.buttons[i].buttonModel)) {
                this.footerTemplate = "";
                this.setButton();
              }
            }
            break;
          }
          case "allowDragging":
            if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
              this.setAllowDragging();
            } else {
              this.dragObj.destroy();
            }
            break;
          case "target":
            this.setTarget(newProp.target);
            break;
          case "position":
            this.checkPositionData();
            if (this.isModal) {
              var positionX = this.position.X;
              var positionY = this.position.Y;
              if (!isNullOrUndefined(oldProp.position)) {
                if (!isNullOrUndefined(oldProp.position.X)) {
                  positionX = oldProp.position.X;
                }
                if (!isNullOrUndefined(oldProp.position.Y)) {
                  positionY = oldProp.position.Y;
                }
              }
              if (this.dlgContainer.classList.contains("e-dlg-" + positionX + "-" + positionY)) {
                this.dlgContainer.classList.remove("e-dlg-" + positionX + "-" + positionY);
              }
            }
            this.positionChange();
            this.updatePersistData();
            break;
          case "enableRtl":
            this.setEnableRTL();
            break;
          case "enableResize":
            this.setResize();
            break;
          case "minHeight":
            if (this.minHeight !== "") {
              this.element.style.minHeight = formatUnit(this.minHeight);
            }
            break;
        }
      }
    };
    Dialog2.prototype.setTarget = function(target) {
      this.popupObj.relateTo = target;
      this.target = target;
      this.targetEle = typeof this.target === "string" ? document.querySelector(this.target) : this.target;
      if (this.dragObj) {
        this.dragObj.dragArea = this.targetEle;
      }
      this.setMaxHeight();
      if (this.isModal) {
        this.updateIsModal();
      }
      if (this.enableResize) {
        this.setResize();
      }
    };
    Dialog2.prototype.updateIsModal = function() {
      this.element.setAttribute("aria-modal", this.isModal ? "true" : "false");
      if (this.isModal) {
        if (isNullOrUndefined(this.dlgOverlay)) {
          this.setIsModal();
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          if (!isNullOrUndefined(this.targetEle)) {
            this.targetEle.appendChild(this.dlgContainer);
          }
        }
      } else {
        removeClass([this.element], MODAL_DLG);
        removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
        detach(this.dlgOverlay);
        while (this.dlgContainer.firstChild) {
          this.dlgContainer.parentElement.insertBefore(this.dlgContainer.firstChild, this.dlgContainer);
        }
        this.dlgContainer.parentElement.removeChild(this.dlgContainer);
      }
      if (this.visible) {
        this.show();
      }
      this.positionChange();
      if (this.isModal && this.dlgOverlay) {
        EventHandler.add(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler, this);
      }
    };
    Dialog2.prototype.setzIndex = function(zIndexElement, setPopupZindex) {
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      var currentzIndex = getZindexPartial(zIndexElement);
      this.zIndex = currentzIndex > this.zIndex ? currentzIndex : this.zIndex;
      this.isProtectedOnChange = prevOnChange;
      if (setPopupZindex) {
        this.popupObj.zIndex = this.zIndex;
      }
    };
    Dialog2.prototype.windowResizeHandler = function() {
      setMaxWidth(this.targetEle.clientWidth);
      setMaxHeight(this.targetEle.clientHeight);
      this.setMaxHeight();
    };
    Dialog2.prototype.getPersistData = function() {
      return this.addOnPersist(["width", "height", "position"]);
    };
    Dialog2.prototype.removeAllChildren = function(element2) {
      while (element2.children[0]) {
        this.removeAllChildren(element2.children[0]);
        element2.removeChild(element2.children[0]);
      }
    };
    Dialog2.prototype.destroy = function() {
      if (this.isDestroyed) {
        return;
      }
      var classArray = [RTL4, MODAL_DLG, DLG_RESIZABLE, DLG_RESTRICT_LEFT_VALUE, FULLSCREEN, DEVICE];
      var attrs = ["role", "aria-modal", "aria-labelledby", "aria-describedby", "aria-grabbed", "tabindex", "style"];
      removeClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
      if (!isNullOrUndefined(this.element) && this.element.classList.contains(FULLSCREEN)) {
        removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
      }
      if (this.isModal) {
        removeClass([!isNullOrUndefined(this.targetEle) ? this.targetEle : document.body], SCROLL_DISABLED);
      }
      this.unWireEvents();
      if (!isNullOrUndefined(this.btnObj)) {
        for (var i = 0; i < this.btnObj.length; i++) {
          this.btnObj[i].destroy();
        }
      }
      if (!isNullOrUndefined(this.closeIconBtnObj)) {
        this.closeIconBtnObj.destroy();
      }
      if (!isNullOrUndefined(this.dragObj)) {
        this.dragObj.destroy();
      }
      if (!isNullOrUndefined(this.popupObj.element) && this.popupObj.element.classList.contains(POPUP_ROOT)) {
        this.popupObj.destroy();
      }
      removeClass([this.element], classArray);
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        removeClass([this.element], this.cssClass.split(" "));
      }
      if (!isNullOrUndefined(this.refElement) && !isNullOrUndefined(this.refElement.parentElement)) {
        this.refElement.parentElement.insertBefore(this.isModal ? this.dlgContainer : this.element, this.refElement);
        detach(this.refElement);
        this.refElement = void 0;
      }
      if (this.isModal && !this.isBlazorServerRender()) {
        detach(this.dlgOverlay);
        this.dlgContainer.parentNode.insertBefore(this.element, this.dlgContainer);
        detach(this.dlgContainer);
      }
      if (!this.isBlazorServerRender()) {
        this.element.innerHTML = this.clonedEle.innerHTML;
      }
      if (this.isBlazorServerRender()) {
        if (!isNullOrUndefined(this.element.children)) {
          for (var i = 0; i <= this.element.children.length; i++) {
            i = i - i;
            detach(this.element.children[i]);
          }
        }
      }
      for (var i = 0; i < attrs.length; i++) {
        this.element.removeAttribute(attrs[i]);
      }
      this.ftrTemplateContent = null;
      this.headerContent = null;
      if (!this.isReact && !this.isVue && !isNullOrUndefined(this.contentEle)) {
        this.removeAllChildren(this.contentEle);
      }
      this.contentEle = null;
      if (!this.isBlazorServerRender()) {
        _super.prototype.destroy.call(this);
      } else {
        this.isDestroyed = true;
      }
      if (this.isReact) {
        this.clearTemplate();
      }
    };
    Dialog2.prototype.wireWindowResizeEvent = function() {
      this.boundWindowResizeHandler = this.windowResizeHandler.bind(this);
      window.addEventListener("resize", this.boundWindowResizeHandler);
    };
    Dialog2.prototype.unWireWindowResizeEvent = function() {
      window.removeEventListener("resize", this.boundWindowResizeHandler);
      this.boundWindowResizeHandler = null;
    };
    Dialog2.prototype.wireEvents = function() {
      if (this.isBlazorServerRender() && this.showCloseIcon) {
        this.closeIcon = this.element.getElementsByClassName("e-dlg-closeicon-btn")[0];
      }
      if (this.showCloseIcon) {
        EventHandler.add(this.closeIcon, "click", this.closeIconClickEventHandler, this);
      }
      if (this.isModal && this.dlgOverlay) {
        EventHandler.add(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler, this);
      }
    };
    Dialog2.prototype.unWireEvents = function() {
      if (this.showCloseIcon) {
        EventHandler.remove(this.closeIcon, "click", this.closeIconClickEventHandler);
      }
      if (this.isModal) {
        EventHandler.remove(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler);
      }
      if (this.buttons.length > 0 && !isNullOrUndefined(this.buttons[0].buttonModel) && this.footerTemplate === "") {
        for (var i = 0; i < this.buttons.length; i++) {
          if (typeof this.buttons[i].click === "function") {
            EventHandler.remove(this.ftrTemplateContent.children[i], "click", this.buttons[i].click);
          }
        }
      }
    };
    Dialog2.prototype.refreshPosition = function() {
      this.popupObj.refreshPosition();
      if (this.element.classList.contains(MODAL_DLG)) {
        this.positionChange();
      }
    };
    Dialog2.prototype.getDimension = function() {
      var dialogWidth = this.element.offsetWidth;
      var dialogHeight = this.element.offsetHeight;
      return { width: dialogWidth, height: dialogHeight };
    };
    Dialog2.prototype.show = function(isFullScreen) {
      var _this = this;
      if (!this.element.classList.contains(ROOT)) {
        return;
      }
      if (!this.element.classList.contains(DLG_SHOW) || !isNullOrUndefined(isFullScreen)) {
        if (!isNullOrUndefined(isFullScreen)) {
          this.fullScreen(isFullScreen);
        }
        var eventArgs_1 = isBlazor() ? {
          cancel: false,
          element: this.element,
          container: this.isModal ? this.dlgContainer : this.element,
          maxHeight: this.element.style.maxHeight
        } : {
          cancel: false,
          element: this.element,
          container: this.isModal ? this.dlgContainer : this.element,
          target: this.target,
          maxHeight: this.element.style.maxHeight
        };
        this.trigger("beforeOpen", eventArgs_1, function(beforeOpenArgs) {
          if (!beforeOpenArgs.cancel) {
            if (_this.element.style.maxHeight !== eventArgs_1.maxHeight) {
              _this.allowMaxHeight = false;
              _this.element.style.maxHeight = eventArgs_1.maxHeight;
            }
            if (_this.enableResize && _this.boundWindowResizeHandler == null && !_this.initialRender) {
              _this.wireWindowResizeEvent();
            }
            _this.storeActiveElement = document.activeElement;
            _this.element.tabIndex = -1;
            if (_this.isModal && !isNullOrUndefined(_this.dlgOverlay)) {
              _this.dlgOverlay.style.display = "block";
              _this.dlgContainer.style.display = "flex";
              removeClass([_this.dlgOverlay], "e-fade");
              if (!isNullOrUndefined(_this.targetEle)) {
                if (_this.targetEle === document.body) {
                  _this.dlgContainer.style.position = "fixed";
                } else {
                  _this.dlgContainer.style.position = "absolute";
                }
                _this.dlgOverlay.style.position = "absolute";
                var targetType = _this.getTargetContainer(_this.target);
                if (targetType instanceof Element) {
                  var computedStyle = window.getComputedStyle(targetType);
                  if (computedStyle.getPropertyValue("direction") === "rtl") {
                    _this.element.style.position = "absolute";
                  } else {
                    _this.element.style.position = "relative";
                  }
                } else {
                  _this.element.style.position = "relative";
                }
                addClass([_this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
              } else {
                addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
              }
            }
            var openAnimation = {
              name: _this.animationSettings.effect === "None" && animationMode === "Enable" ? "ZoomIn" : _this.animationSettings.effect + "In",
              duration: _this.animationSettings.duration,
              delay: _this.animationSettings.delay
            };
            var zIndexElement = _this.isModal ? _this.element.parentElement : _this.element;
            if (_this.calculatezIndex) {
              _this.setzIndex(zIndexElement, true);
              setStyleAttribute(_this.element, { "zIndex": _this.zIndex });
              if (_this.isModal) {
                _this.setOverlayZindex(_this.zIndex);
              }
            }
            _this.animationSettings.effect === "None" && animationMode === "Enable" ? _this.popupObj.show(openAnimation) : _this.animationSettings.effect === "None" ? _this.popupObj.show() : _this.popupObj.show(openAnimation);
            if (_this.isModal) {
              var targetType = _this.getTargetContainer(_this.target);
              if (targetType instanceof Element) {
                var computedStyle = window.getComputedStyle(targetType);
                if (computedStyle.getPropertyValue("direction") === "rtl" && !_this.IsDragStop) {
                  _this.setPopupPosition();
                }
              }
            }
            _this.dialogOpen = true;
            var prevOnChange = _this.isProtectedOnChange;
            _this.isProtectedOnChange = true;
            _this.visible = true;
            _this.preventVisibility = true;
            _this.isProtectedOnChange = prevOnChange;
          }
        });
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Dialog2.prototype.hide = function(event) {
      var _this = this;
      if (!this.element.classList.contains(ROOT)) {
        return;
      }
      if (this.preventVisibility) {
        var eventArgs = isBlazor() ? {
          cancel: false,
          isInteracted: event ? true : false,
          element: this.element,
          container: this.isModal ? this.dlgContainer : this.element,
          event
        } : {
          cancel: false,
          isInteracted: event ? true : false,
          element: this.element,
          target: this.target,
          container: this.isModal ? this.dlgContainer : this.element,
          event,
          closedBy: this.dlgClosedBy
        };
        this.closeArgs = eventArgs;
        this.trigger("beforeClose", eventArgs, function(beforeCloseArgs) {
          if (!beforeCloseArgs.cancel) {
            if (_this.isModal) {
              if (!isNullOrUndefined(_this.targetEle)) {
                removeClass([_this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
              }
            }
            if (_this.enableResize) {
              _this.unWireWindowResizeEvent();
            }
            if (document.body.classList.contains(DLG_TARGET) && document.body.classList.contains(SCROLL_DISABLED)) {
              removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
            }
            var closeAnimation = {
              name: _this.animationSettings.effect === "None" && animationMode === "Enable" ? "ZoomOut" : _this.animationSettings.effect + "Out",
              duration: _this.animationSettings.duration,
              delay: _this.animationSettings.delay
            };
            if (_this.animationSettings.effect === "None" && animationMode === "Enable") {
              _this.popupObj.hide(closeAnimation);
            } else if (_this.animationSettings.effect === "None") {
              _this.popupObj.hide();
            } else {
              _this.popupObj.hide(closeAnimation);
            }
            _this.dialogOpen = false;
            var prevOnChange = _this.isProtectedOnChange;
            _this.isProtectedOnChange = true;
            _this.visible = false;
            _this.preventVisibility = false;
            _this.isProtectedOnChange = prevOnChange;
          }
          _this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
        });
      }
    };
    Dialog2.prototype.fullScreen = function(args) {
      var top = this.element.offsetTop;
      var left = this.element.offsetLeft;
      if (args) {
        if (!this.isModal) {
          this.element.style.top = document.scrollingElement.scrollTop + "px";
        }
        addClass([this.element], FULLSCREEN);
        var display = this.element.style.display;
        this.element.style.display = "none";
        this.element.style.maxHeight = !isNullOrUndefined(this.target) ? this.targetEle.offsetHeight + "px" : window.innerHeight + "px";
        this.element.style.display = display;
        addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
        if (this.allowDragging && !isNullOrUndefined(this.dragObj)) {
          this.dragObj.destroy();
        }
      } else {
        removeClass([this.element], FULLSCREEN);
        removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
        if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
          this.setAllowDragging();
        }
      }
      return args;
    };
    Dialog2.prototype.getButtons = function(index) {
      if (!isNullOrUndefined(index)) {
        return this.btnObj[index];
      }
      return this.btnObj;
    };
    __decorate10([
      Property("")
    ], Dialog2.prototype, "content", void 0);
    __decorate10([
      Property(true)
    ], Dialog2.prototype, "enableHtmlSanitizer", void 0);
    __decorate10([
      Property(false)
    ], Dialog2.prototype, "enablePersistence", void 0);
    __decorate10([
      Property(false)
    ], Dialog2.prototype, "showCloseIcon", void 0);
    __decorate10([
      Property(false)
    ], Dialog2.prototype, "isModal", void 0);
    __decorate10([
      Property("")
    ], Dialog2.prototype, "header", void 0);
    __decorate10([
      Property(true)
    ], Dialog2.prototype, "visible", void 0);
    __decorate10([
      Property(false)
    ], Dialog2.prototype, "enableResize", void 0);
    __decorate10([
      Property(["South-East"])
    ], Dialog2.prototype, "resizeHandles", void 0);
    __decorate10([
      Property("auto")
    ], Dialog2.prototype, "height", void 0);
    __decorate10([
      Property("")
    ], Dialog2.prototype, "minHeight", void 0);
    __decorate10([
      Property("100%")
    ], Dialog2.prototype, "width", void 0);
    __decorate10([
      Property("")
    ], Dialog2.prototype, "cssClass", void 0);
    __decorate10([
      Property(1e3)
    ], Dialog2.prototype, "zIndex", void 0);
    __decorate10([
      Property(null)
    ], Dialog2.prototype, "target", void 0);
    __decorate10([
      Property("")
    ], Dialog2.prototype, "footerTemplate", void 0);
    __decorate10([
      Property(false)
    ], Dialog2.prototype, "allowDragging", void 0);
    __decorate10([
      Collection([{}], ButtonProps)
    ], Dialog2.prototype, "buttons", void 0);
    __decorate10([
      Property(true)
    ], Dialog2.prototype, "closeOnEscape", void 0);
    __decorate10([
      Complex({}, AnimationSettings)
    ], Dialog2.prototype, "animationSettings", void 0);
    __decorate10([
      Complex({ X: "center", Y: "center" }, PositionData)
    ], Dialog2.prototype, "position", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "created", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "open", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "beforeSanitizeHtml", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "beforeOpen", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "close", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "beforeClose", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "dragStart", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "dragStop", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "drag", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "overlayClick", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "resizeStart", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "resizing", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "resizeStop", void 0);
    __decorate10([
      Event()
    ], Dialog2.prototype, "destroyed", void 0);
    Dialog2 = __decorate10([
      NotifyPropertyChanges
    ], Dialog2);
    return Dialog2;
  }(Component)
);
var DialogUtility;
(function(DialogUtility2) {
  function alert(args) {
    var dialogElement = createElement("div", { "className": DLG_UTIL_ALERT });
    document.body.appendChild(dialogElement);
    var alertDialogObj;
    var okButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }];
    if (typeof args === "string") {
      alertDialogObj = createDialog({
        content: args,
        position: { X: "center", Y: "top" },
        isModal: true,
        header: DLG_UTIL_DEFAULT_TITLE,
        buttons: okButtonModel
      }, dialogElement);
    } else {
      alertDialogObj = createDialog(alertOptions(args), dialogElement);
    }
    alertDialogObj.close = function() {
      if (args && args.close) {
        args.close.apply(alertDialogObj);
      }
      alertDialogObj.destroy();
      if (alertDialogObj.element.classList.contains("e-dlg-modal")) {
        alertDialogObj.element.parentElement.remove();
        alertDialogObj.target.classList.remove(DLG_UTIL_ROOT);
      } else {
        alertDialogObj.element.remove();
      }
    };
    return alertDialogObj;
  }
  DialogUtility2.alert = alert;
  function confirm(args) {
    var dialogElement = createElement("div", { "className": DLG_UTIL_CONFIRM });
    document.body.appendChild(dialogElement);
    var confirmDialogObj;
    var okCancelButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }, {
      buttonModel: { content: "Cancel" },
      click: function() {
        this.hide();
      }
    }];
    if (typeof args === "string") {
      confirmDialogObj = createDialog({
        position: { X: "center", Y: "top" },
        content: args,
        isModal: true,
        header: DLG_UTIL_DEFAULT_TITLE,
        buttons: okCancelButtonModel
      }, dialogElement);
    } else {
      confirmDialogObj = createDialog(confirmOptions(args), dialogElement);
    }
    confirmDialogObj.close = function() {
      if (args && args.close) {
        args.close.apply(confirmDialogObj);
      }
      confirmDialogObj.destroy();
      if (confirmDialogObj.element.classList.contains("e-dlg-modal")) {
        confirmDialogObj.element.parentElement.remove();
        confirmDialogObj.target.classList.remove(DLG_UTIL_ROOT);
      } else {
        confirmDialogObj.element.remove();
      }
    };
    return confirmDialogObj;
  }
  DialogUtility2.confirm = confirm;
  function createDialog(options, element2) {
    var dialogObject = new Dialog(options);
    dialogObject.appendTo(element2);
    return dialogObject;
  }
  function alertOptions(option) {
    var options = {};
    options.buttons = [];
    options = formOptions(options, option);
    options = setAlertButtonModel(options, option);
    return options;
  }
  function confirmOptions(option) {
    var options = {};
    options.buttons = [];
    options = formOptions(options, option);
    options = setConfirmButtonModel(options, option);
    return options;
  }
  function formOptions(options, option) {
    options.header = !isNullOrUndefined(option.title) ? option.title : null;
    options.content = !isNullOrUndefined(option.content) ? option.content : "";
    options.isModal = !isNullOrUndefined(option.isModal) ? option.isModal : true;
    options.showCloseIcon = !isNullOrUndefined(option.showCloseIcon) ? option.showCloseIcon : false;
    options.allowDragging = !isNullOrUndefined(option.isDraggable) ? option.isDraggable : false;
    options.closeOnEscape = !isNullOrUndefined(option.closeOnEscape) ? option.closeOnEscape : false;
    options.position = !isNullOrUndefined(option.position) ? option.position : { X: "center", Y: "top" };
    options.animationSettings = !isNullOrUndefined(option.animationSettings) ? option.animationSettings : { effect: "Fade", duration: 400, delay: 0 };
    options.cssClass = !isNullOrUndefined(option.cssClass) ? option.cssClass : "";
    options.zIndex = !isNullOrUndefined(option.zIndex) ? option.zIndex : 1e3;
    options.open = !isNullOrUndefined(option.open) ? option.open : null;
    options.width = !isNullOrUndefined(option.width) ? option.width : "auto";
    options.height = !isNullOrUndefined(option.height) ? option.height : "auto";
    return options;
  }
  function setAlertButtonModel(options, option) {
    var alertButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }];
    if (!isNullOrUndefined(option.okButton)) {
      options.buttons[0] = formButtonModel(options.buttons[0], option.okButton, alertButtonModel[0]);
    } else {
      options.buttons = alertButtonModel;
    }
    return options;
  }
  function setConfirmButtonModel(options, option) {
    var okButtonModel = {
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    };
    var cancelButtonModel = {
      buttonModel: { content: "Cancel" },
      click: function() {
        this.hide();
      }
    };
    if (!isNullOrUndefined(option.okButton)) {
      options.buttons[0] = formButtonModel(options.buttons[0], option.okButton, okButtonModel);
    } else {
      options.buttons[0] = okButtonModel;
    }
    if (!isNullOrUndefined(option.cancelButton)) {
      options.buttons[1] = formButtonModel(options.buttons[1], option.cancelButton, cancelButtonModel);
    } else {
      options.buttons[1] = cancelButtonModel;
    }
    return options;
  }
  function formButtonModel(buttonModel, option, buttonPropModel) {
    var buttonProps = buttonPropModel;
    if (!isNullOrUndefined(option.text)) {
      buttonProps.buttonModel.content = option.text;
    }
    if (!isNullOrUndefined(option.icon)) {
      buttonProps.buttonModel.iconCss = option.icon;
    }
    if (!isNullOrUndefined(option.cssClass)) {
      buttonProps.buttonModel.cssClass = option.cssClass;
    }
    if (!isNullOrUndefined(option.click)) {
      buttonProps.click = option.click;
    }
    if (!isNullOrUndefined(option.isFlat)) {
      buttonProps.isFlat = option.isFlat;
    }
    return buttonProps;
  }
})(DialogUtility || (DialogUtility = {}));

// node_modules/@syncfusion/ej2-popups/src/tooltip/tooltip.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TOUCHEND_HIDE_DELAY = 1500;
var TAPHOLD_THRESHOLD = 500;
var SHOW_POINTER_TIP_GAP = 0;
var HIDE_POINTER_TIP_GAP = 8;
var MOUSE_TRAIL_GAP = 2;
var POINTER_ADJUST = 2;
var ROOT2 = "e-tooltip";
var RTL5 = "e-rtl";
var DEVICE2 = "e-bigger";
var ICON2 = "e-icons";
var CLOSE = "e-tooltip-close";
var TOOLTIP_WRAP = "e-tooltip-wrap";
var CONTENT = "e-tip-content";
var ARROW_TIP = "e-arrow-tip";
var ARROW_TIP_OUTER = "e-arrow-tip-outer";
var ARROW_TIP_INNER = "e-arrow-tip-inner";
var TIP_BOTTOM = "e-tip-bottom";
var TIP_TOP = "e-tip-top";
var TIP_LEFT = "e-tip-left";
var TIP_RIGHT = "e-tip-right";
var POPUP_ROOT2 = "e-popup";
var POPUP_OPEN = "e-popup-open";
var POPUP_CLOSE = "e-popup-close";
var POPUP_LIB = "e-lib";
var HIDE_POPUP = "e-hidden";
var POPUP_CONTAINER = "e-tooltip-popup-container";
var Animation2 = (
  /** @class */
  function(_super) {
    __extends10(Animation3, _super);
    function Animation3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate11([
      Property({ effect: "FadeIn", duration: 150, delay: 0 })
    ], Animation3.prototype, "open", void 0);
    __decorate11([
      Property({ effect: "FadeOut", duration: 150, delay: 0 })
    ], Animation3.prototype, "close", void 0);
    return Animation3;
  }(ChildProperty)
);
var Tooltip = (
  /** @class */
  function(_super) {
    __extends10(Tooltip2, _super);
    function Tooltip2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.mouseMoveEvent = null;
      _this.mouseMoveTarget = null;
      _this.containerElement = null;
      _this.isBodyContainer = true;
      return _this;
    }
    Tooltip2.prototype.initialize = function() {
      this.formatPosition();
      addClass([this.element], ROOT2);
    };
    Tooltip2.prototype.formatPosition = function() {
      var _a, _b;
      if (!this.position)
        return;
      if (this.position.indexOf("Top") === 0 || this.position.indexOf("Bottom") === 0) {
        _a = this.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];
      } else {
        _b = this.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];
      }
    };
    Tooltip2.prototype.renderArrow = function() {
      this.setTipClass(this.position);
      var tip = this.createElement("div", { className: ARROW_TIP + " " + this.tipClass });
      tip.appendChild(this.createElement("div", { className: ARROW_TIP_OUTER + " " + this.tipClass }));
      tip.appendChild(this.createElement("div", { className: ARROW_TIP_INNER + " " + this.tipClass }));
      this.tooltipEle.appendChild(tip);
    };
    Tooltip2.prototype.setTipClass = function(position) {
      if (position.indexOf("Right") === 0) {
        this.tipClass = TIP_LEFT;
      } else if (position.indexOf("Bottom") === 0) {
        this.tipClass = TIP_TOP;
      } else if (position.indexOf("Left") === 0) {
        this.tipClass = TIP_RIGHT;
      } else {
        this.tipClass = TIP_BOTTOM;
      }
    };
    Tooltip2.prototype.renderPopup = function(target) {
      var elePos = this.mouseTrail ? { top: 0, left: 0 } : this.getTooltipPosition(target);
      this.tooltipEle.classList.remove(POPUP_LIB);
      this.popupObj = new Popup(this.tooltipEle, {
        height: this.height,
        width: this.width,
        position: { X: elePos.left, Y: elePos.top },
        enableRtl: this.enableRtl,
        open: this.openPopupHandler.bind(this),
        close: this.closePopupHandler.bind(this)
      });
    };
    Tooltip2.prototype.getScalingFactor = function(target) {
      if (!target) {
        return { x: 1, y: 1 };
      }
      var scalingFactors = { x: 1, y: 1 };
      var elementsWithTransform = target.closest('[style*="transform: scale"]');
      if (elementsWithTransform && elementsWithTransform !== this.tooltipEle && elementsWithTransform.contains(this.tooltipEle)) {
        var computedStyle = window.getComputedStyle(elementsWithTransform);
        var transformValue = computedStyle.getPropertyValue("transform");
        var matrixValues = transformValue.match(/matrix\(([^)]+)\)/)[1].split(",").map(parseFloat);
        scalingFactors.x = matrixValues[0];
        scalingFactors.y = matrixValues[3];
      }
      return scalingFactors;
    };
    Tooltip2.prototype.getTooltipPosition = function(target) {
      this.tooltipEle.style.display = "block";
      var parentWithZoomStyle = this.element.closest('[style*="zoom"]');
      if (parentWithZoomStyle) {
        if (!parentWithZoomStyle.contains(this.tooltipEle)) {
          this.tooltipEle.style.zoom = getComputedStyle(parentWithZoomStyle).zoom;
        }
      }
      var pos = calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY, !this.isBodyContainer, this.isBodyContainer ? null : this.containerElement.getBoundingClientRect());
      var scalingFactors = this.getScalingFactor(target);
      var offsetPos = this.calculateTooltipOffset(this.position, scalingFactors.x, scalingFactors.y);
      var collisionPosition = this.calculateElementPosition(pos, offsetPos);
      var collisionLeft = collisionPosition[0];
      var collisionTop = collisionPosition[1];
      var elePos = this.collisionFlipFit(target, collisionLeft, collisionTop);
      elePos.left = elePos.left / scalingFactors.x;
      elePos.top = elePos.top / scalingFactors.y;
      this.tooltipEle.style.display = "";
      return elePos;
    };
    Tooltip2.prototype.windowResize = function() {
      this.reposition(this.findTarget());
    };
    Tooltip2.prototype.reposition = function(target) {
      if (this.popupObj && target) {
        var elePos = this.getTooltipPosition(target);
        this.popupObj.position = { X: elePos.left, Y: elePos.top };
        this.popupObj.dataBind();
      }
    };
    Tooltip2.prototype.openPopupHandler = function() {
      if (!this.mouseTrail && this.needTemplateReposition()) {
        this.reposition(this.findTarget());
      }
      this.trigger("afterOpen", this.tooltipEventArgs);
      this.tooltipEventArgs = null;
    };
    Tooltip2.prototype.closePopupHandler = function() {
      if (this.isReact && !(this.opensOn === "Click" && typeof this.content === "function")) {
        this.clearTemplate(["content"]);
      }
      this.clear();
      var tooltipAfterCloseEventArgs = {
        type: this.tooltipEventArgs.event ? this.tooltipEventArgs.event.type : null,
        cancel: false,
        target: this.tooltipEventArgs.target,
        event: this.tooltipEventArgs.event ? this.tooltipEventArgs.event : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(this.tooltipEventArgs.event)
      };
      this.trigger("afterClose", tooltipAfterCloseEventArgs);
      tooltipAfterCloseEventArgs = null;
    };
    Tooltip2.prototype.calculateTooltipOffset = function(position, xScalingFactor, yScalingFactor) {
      if (xScalingFactor === void 0) {
        xScalingFactor = 1;
      }
      if (yScalingFactor === void 0) {
        yScalingFactor = 1;
      }
      var pos = { top: 0, left: 0 };
      var tipWidth;
      var tipHeight;
      var tooltipEleWidth;
      var tooltipEleHeight;
      var arrowEle;
      var tipAdjust;
      var tipHeightAdjust;
      var tipWidthAdjust;
      if (xScalingFactor !== 1 || yScalingFactor !== 1) {
        var tooltipEleRect = this.tooltipEle.getBoundingClientRect();
        var arrowEleRect = void 0;
        tooltipEleWidth = Math.round(tooltipEleRect.width);
        tooltipEleHeight = Math.round(tooltipEleRect.height);
        arrowEle = select("." + ARROW_TIP, this.tooltipEle);
        if (arrowEle) {
          arrowEleRect = arrowEle.getBoundingClientRect();
        }
        tipWidth = arrowEle ? Math.round(arrowEleRect.width) : 0;
        tipHeight = arrowEle ? Math.round(arrowEleRect.height) : 0;
        tipAdjust = this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;
        tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (tooltipEleHeight - this.tooltipEle.clientHeight * yScalingFactor);
        tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (tooltipEleWidth - this.tooltipEle.clientWidth * xScalingFactor);
      } else {
        tooltipEleWidth = this.tooltipEle.offsetWidth;
        tooltipEleHeight = this.tooltipEle.offsetHeight;
        arrowEle = select("." + ARROW_TIP, this.tooltipEle);
        tipWidth = arrowEle ? arrowEle.offsetWidth : 0;
        tipHeight = arrowEle ? arrowEle.offsetHeight : 0;
        tipAdjust = this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;
        tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);
        tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);
      }
      if (this.mouseTrail) {
        tipAdjust += MOUSE_TRAIL_GAP;
      }
      switch (position) {
        case "RightTop":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;
        case "RightCenter":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;
        case "RightBottom":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;
        case "BottomRight":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;
        case "BottomCenter":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;
        case "BottomLeft":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;
        case "LeftBottom":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;
        case "LeftCenter":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;
        case "LeftTop":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;
        case "TopLeft":
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;
        case "TopRight":
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;
        default:
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;
      }
      pos.left += this.offsetX;
      pos.top += this.offsetY;
      return pos;
    };
    Tooltip2.prototype.updateTipPosition = function(position) {
      var selEle = selectAll("." + ARROW_TIP + ",." + ARROW_TIP_OUTER + ",." + ARROW_TIP_INNER, this.tooltipEle);
      var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];
      removeClass(selEle, removeList);
      this.setTipClass(position);
      addClass(selEle, this.tipClass);
    };
    Tooltip2.prototype.adjustArrow = function(target, position, tooltipPositionX, tooltipPositionY) {
      var arrowEle = select("." + ARROW_TIP, this.tooltipEle);
      if (this.showTipPointer === false || arrowEle === null) {
        return;
      }
      this.updateTipPosition(position);
      var leftValue;
      var topValue;
      this.tooltipEle.style.display = "block";
      var tooltipWidth = this.tooltipEle.clientWidth;
      var tooltipHeight = this.tooltipEle.clientHeight;
      var arrowInnerELe = select("." + ARROW_TIP_INNER, this.tooltipEle);
      var tipWidth = arrowEle.offsetWidth;
      var tipHeight = arrowEle.offsetHeight;
      this.tooltipEle.style.display = "";
      if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {
        if (this.tipClass === TIP_BOTTOM) {
          topValue = "99.9%";
          arrowInnerELe.style.top = "-" + (tipHeight - 2) + "px";
        } else {
          topValue = -(tipHeight - 1) + "px";
          arrowInnerELe.style.top = "-" + (tipHeight - 6) + "px";
        }
        if (target) {
          var tipPosExclude = tooltipPositionX !== "Center" || tooltipWidth > target.offsetWidth || this.mouseTrail;
          if (tipPosExclude && tooltipPositionX === "Left" || !tipPosExclude && this.tipPointerPosition === "End") {
            leftValue = tooltipWidth - tipWidth - POINTER_ADJUST + "px";
          } else if (tipPosExclude && tooltipPositionX === "Right" || !tipPosExclude && this.tipPointerPosition === "Start") {
            leftValue = POINTER_ADJUST + "px";
          } else if (tipPosExclude && (this.tipPointerPosition === "End" || this.tipPointerPosition === "Start")) {
            leftValue = this.tipPointerPosition === "End" ? target.offsetWidth + (this.tooltipEle.offsetWidth - target.offsetWidth) / 2 - tipWidth / 2 - POINTER_ADJUST + "px" : (this.tooltipEle.offsetWidth - target.offsetWidth) / 2 - tipWidth / 2 + POINTER_ADJUST + "px";
          } else {
            leftValue = tooltipWidth / 2 - tipWidth / 2 + "px";
          }
        }
      } else {
        if (this.tipClass === TIP_RIGHT) {
          leftValue = "99.9%";
          arrowInnerELe.style.left = "-" + (tipWidth - 2) + "px";
        } else {
          leftValue = -(tipWidth - 1) + "px";
          arrowInnerELe.style.left = -tipWidth + (tipWidth - 2) + "px";
        }
        var tipPosExclude = tooltipPositionY !== "Center" || tooltipHeight > target.offsetHeight || this.mouseTrail;
        if (tipPosExclude && tooltipPositionY === "Top" || !tipPosExclude && this.tipPointerPosition === "End") {
          topValue = tooltipHeight - tipHeight - POINTER_ADJUST + "px";
        } else if (tipPosExclude && tooltipPositionY === "Bottom" || !tipPosExclude && this.tipPointerPosition === "Start") {
          topValue = POINTER_ADJUST + "px";
        } else {
          topValue = tooltipHeight / 2 - tipHeight / 2 + "px";
        }
      }
      arrowEle.style.top = topValue;
      arrowEle.style.left = leftValue;
    };
    Tooltip2.prototype.renderContent = function(target) {
      var tooltipContent = select("." + CONTENT, this.tooltipEle);
      if (this.cssClass) {
        addClass([this.tooltipEle], this.cssClass.split(" "));
      }
      if (target && !isNullOrUndefined(target.getAttribute("title"))) {
        target.setAttribute("data-content", target.getAttribute("title"));
        target.removeAttribute("title");
      }
      if (!isNullOrUndefined(this.content)) {
        tooltipContent.innerHTML = "";
        if (this.content instanceof HTMLElement) {
          tooltipContent.appendChild(this.content);
        } else if (typeof this.content === "string") {
          if (this.isAngular) {
            this.setProperties({ content: SanitizeHtmlHelper.sanitize(this.content) }, true);
          } else {
            this.content = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(this.content) : this.content;
          }
          if (this.enableHtmlParse) {
            var tempFunction = compile(this.content);
            var tempArr = tempFunction({}, this, "content", this.element.id + "content", void 0, void 0, tooltipContent, this.root);
            if (tempArr) {
              append(tempArr, tooltipContent);
            }
          } else {
            tooltipContent["textContent"] = this.content;
          }
        } else {
          var templateFunction = compile(this.content);
          var tempArr = templateFunction({}, this, "content", this.element.id + "content", void 0, void 0, tooltipContent);
          if (tempArr) {
            append(tempArr, tooltipContent);
          }
          this.renderReactTemplates();
        }
      } else {
        if (target && !isNullOrUndefined(target.getAttribute("data-content"))) {
          tooltipContent.innerHTML = target.getAttribute("data-content");
        }
      }
    };
    Tooltip2.prototype.renderCloseIcon = function() {
      if (!this.isSticky) {
        var existingCloseIcon = this.tooltipEle.querySelector("." + ICON2 + "." + CLOSE);
        if (existingCloseIcon) {
          remove(existingCloseIcon);
        }
        return;
      }
      var tipClose = this.createElement("div", { className: ICON2 + " " + CLOSE });
      this.tooltipEle.appendChild(tipClose);
      EventHandler.add(tipClose, Browser.touchStartEvent, this.onStickyClose, this);
    };
    Tooltip2.prototype.addDescribedBy = function(target, id) {
      var describedby = (target.getAttribute("aria-describedby") || "").split(/\s+/);
      if (describedby.indexOf(id) < 0) {
        describedby.push(id);
      }
      attributes(target, { "aria-describedby": describedby.join(" ").trim(), "data-tooltip-id": id });
    };
    Tooltip2.prototype.removeDescribedBy = function(target) {
      var id = target.getAttribute("data-tooltip-id");
      var describedby = (target.getAttribute("aria-describedby") || "").split(/\s+/);
      var index = describedby.indexOf(id);
      if (index !== -1) {
        describedby.splice(index, 1);
      }
      target.removeAttribute("data-tooltip-id");
      var orgdescribedby = describedby.join(" ").trim();
      if (orgdescribedby) {
        target.setAttribute("aria-describedby", orgdescribedby);
      } else {
        target.removeAttribute("aria-describedby");
      }
    };
    Tooltip2.prototype.tapHoldHandler = function(evt) {
      clearTimeout(this.autoCloseTimer);
      this.targetHover(evt.originalEvent);
    };
    Tooltip2.prototype.touchEndHandler = function() {
      var _this = this;
      if (this.isSticky) {
        return;
      }
      var close = function() {
        _this.close();
      };
      this.autoCloseTimer = setTimeout(close, TOUCHEND_HIDE_DELAY);
    };
    Tooltip2.prototype.targetClick = function(e) {
      var target;
      if (this.target) {
        target = closest(e.target, this.target);
      } else {
        target = this.element;
      }
      if (isNullOrUndefined(target)) {
        return;
      }
      if (target.getAttribute("data-tooltip-id") === null) {
        this.targetHover(e);
      } else if (!this.isSticky) {
        this.hideTooltip(this.animation.close, e, target);
      }
    };
    Tooltip2.prototype.targetHover = function(e) {
      var target;
      if (this.target) {
        target = closest(e.target, this.target);
      } else {
        target = this.element;
      }
      if (isNullOrUndefined(target) || target.getAttribute("data-tooltip-id") !== null && this.closeDelay === 0) {
        return;
      }
      var targetList = [].slice.call(selectAll('[data-tooltip-id= "' + this.ctrlId + '_content"]', document));
      for (var _i = 0, targetList_1 = targetList; _i < targetList_1.length; _i++) {
        var target_1 = targetList_1[_i];
        this.restoreElement(target_1);
      }
      this.showTooltip(target, this.animation.open, e);
    };
    Tooltip2.prototype.mouseMoveBeforeOpen = function(e) {
      this.mouseMoveEvent = e;
    };
    Tooltip2.prototype.mouseMoveBeforeRemove = function() {
      if (this.mouseMoveTarget) {
        EventHandler.remove(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen);
      }
    };
    Tooltip2.prototype.showTooltip = function(target, showAnimation, e) {
      var _this = this;
      clearTimeout(this.showTimer);
      clearTimeout(this.hideTimer);
      if (this.openDelay && this.mouseTrail) {
        this.mouseMoveBeforeRemove();
        this.mouseMoveTarget = target;
        EventHandler.add(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen, this);
      }
      this.tooltipEventArgs = {
        type: e ? e.type : null,
        cancel: false,
        target,
        event: e ? e : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(e)
      };
      var observeCallback = function(beforeRenderArgs) {
        _this.beforeRenderCallback(beforeRenderArgs, target, e, showAnimation);
      };
      this.trigger("beforeRender", this.tooltipEventArgs, observeCallback.bind(this));
    };
    Tooltip2.prototype.beforeRenderCallback = function(beforeRenderArgs, target, e, showAnimation) {
      if (beforeRenderArgs.cancel) {
        this.isHidden = true;
        this.clear();
        this.mouseMoveBeforeRemove();
      } else {
        this.isHidden = false;
        if (isNullOrUndefined(this.tooltipEle)) {
          this.ctrlId = this.element.getAttribute("id") ? getUniqueID(this.element.getAttribute("id")) : getUniqueID("tooltip");
          this.tooltipEle = this.createElement("div", {
            className: TOOLTIP_WRAP + " " + POPUP_ROOT2 + " " + POPUP_LIB,
            attrs: {
              role: "tooltip",
              "aria-hidden": "false",
              "id": this.ctrlId + "_content"
            },
            styles: "width:" + formatUnit(this.width) + ";height:" + formatUnit(this.height) + ";position:absolute;"
          });
          this.tooltipBeforeRender(target, this);
          this.tooltipAfterRender(target, e, showAnimation, this);
        } else {
          if (target) {
            this.adjustArrow(target, this.position, this.tooltipPositionX, this.tooltipPositionY);
            this.addDescribedBy(target, this.ctrlId + "_content");
            this.renderContent(target);
            Animation.stop(this.tooltipEle);
            this.reposition(target);
            this.tooltipAfterRender(target, e, showAnimation, this);
          }
        }
      }
    };
    Tooltip2.prototype.appendContainer = function(ctrlObj) {
      if (typeof this.container == "string") {
        if (this.container === "body") {
          this.containerElement = document.body;
        } else {
          this.isBodyContainer = false;
          this.containerElement = select(this.container, document);
        }
      } else if (this.container instanceof HTMLElement) {
        this.containerElement = this.container;
        this.isBodyContainer = this.containerElement.tagName === "BODY";
      }
      if (!this.isBodyContainer) {
        addClass([this.containerElement], POPUP_CONTAINER);
      }
      this.containerElement.appendChild(ctrlObj.tooltipEle);
    };
    Tooltip2.prototype.tooltipBeforeRender = function(target, ctrlObj) {
      if (target) {
        if (Browser.isDevice) {
          addClass([ctrlObj.tooltipEle], DEVICE2);
        }
        if (ctrlObj.width !== "auto") {
          ctrlObj.tooltipEle.style.maxWidth = formatUnit(ctrlObj.width);
        }
        ctrlObj.tooltipEle.appendChild(ctrlObj.createElement("div", { className: CONTENT }));
        this.appendContainer(ctrlObj);
        removeClass([ctrlObj.tooltipEle], HIDE_POPUP);
        ctrlObj.addDescribedBy(target, ctrlObj.ctrlId + "_content");
        ctrlObj.renderContent(target);
        addClass([ctrlObj.tooltipEle], POPUP_OPEN);
        if (ctrlObj.showTipPointer) {
          ctrlObj.renderArrow();
        }
        ctrlObj.renderCloseIcon();
        ctrlObj.renderPopup(target);
        ctrlObj.adjustArrow(target, ctrlObj.position, ctrlObj.tooltipPositionX, ctrlObj.tooltipPositionY);
        Animation.stop(ctrlObj.tooltipEle);
        ctrlObj.reposition(target);
      }
    };
    Tooltip2.prototype.tooltipAfterRender = function(target, e, showAnimation, ctrlObj) {
      if (target) {
        removeClass([ctrlObj.tooltipEle], POPUP_OPEN);
        addClass([ctrlObj.tooltipEle], POPUP_CLOSE);
        ctrlObj.tooltipEventArgs = {
          type: e ? e.type : null,
          cancel: false,
          target,
          event: e ? e : null,
          element: ctrlObj.tooltipEle,
          isInteracted: !isNullOrUndefined(e)
        };
        if (ctrlObj.needTemplateReposition() && !ctrlObj.mouseTrail && (showAnimation.effect === "None" || showAnimation.effect == "FadeIn" || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.isReact && typeof ctrlObj.content != "string")) {
          ctrlObj.tooltipEle.style.display = "none";
        }
        var observeCallback = function(observedArgs) {
          ctrlObj.beforeOpenCallback(observedArgs, target, showAnimation, e);
        };
        ctrlObj.trigger("beforeOpen", ctrlObj.tooltipEventArgs, observeCallback.bind(ctrlObj));
      }
    };
    Tooltip2.prototype.beforeOpenCallback = function(observedArgs, target, showAnimation, e) {
      var _this = this;
      if (observedArgs.cancel) {
        this.isHidden = true;
        this.clear();
        this.mouseMoveBeforeRemove();
        this.restoreElement(target);
      } else {
        var openAnimation_1 = {
          name: showAnimation.effect === "None" && animationMode === "Enable" ? "FadeIn" : this.animation.open.effect,
          duration: showAnimation.duration,
          delay: showAnimation.delay,
          timingFunction: "easeOut"
        };
        if (showAnimation.effect === "None") {
          openAnimation_1 = void 0;
        }
        if (this.openDelay > 0) {
          var show = function() {
            if (_this.mouseTrail) {
              EventHandler.add(target, "mousemove touchstart mouseenter", _this.onMouseMove, _this);
            }
            if (_this.popupObj) {
              _this.popupObj.show(openAnimation_1, target);
              if (_this.mouseMoveEvent && _this.mouseTrail) {
                _this.onMouseMove(_this.mouseMoveEvent);
              }
            }
          };
          this.showTimer = setTimeout(show, this.openDelay);
        } else {
          if (this.popupObj) {
            this.popupObj.show(openAnimation_1, target);
          }
        }
      }
      if (e) {
        this.wireMouseEvents(e, target);
      }
    };
    Tooltip2.prototype.needTemplateReposition = function() {
      var tooltip = this;
      return !isNullOrUndefined(tooltip.viewContainerRef) && typeof tooltip.viewContainerRef !== "string" || this.isReact;
    };
    Tooltip2.prototype.checkCollision = function(target, x, y) {
      var elePos = {
        left: x,
        top: y,
        position: this.position,
        horizontal: this.tooltipPositionX,
        vertical: this.tooltipPositionY
      };
      var affectedPos = isCollide(this.tooltipEle, this.checkCollideTarget(), x, y);
      if (affectedPos.length > 0) {
        elePos.horizontal = affectedPos.indexOf("left") >= 0 ? "Right" : affectedPos.indexOf("right") >= 0 ? "Left" : this.tooltipPositionX;
        elePos.vertical = affectedPos.indexOf("top") >= 0 ? "Bottom" : affectedPos.indexOf("bottom") >= 0 ? "Top" : this.tooltipPositionY;
      }
      return elePos;
    };
    Tooltip2.prototype.calculateElementPosition = function(pos, offsetPos) {
      return [
        this.isBodyContainer ? pos.left + offsetPos.left : pos.left - this.containerElement.getBoundingClientRect().left + offsetPos.left + window.pageXOffset + this.containerElement.scrollLeft,
        this.isBodyContainer ? pos.top + offsetPos.top : pos.top - this.containerElement.getBoundingClientRect().top + offsetPos.top + window.pageYOffset + this.containerElement.scrollTop
      ];
    };
    Tooltip2.prototype.collisionFlipFit = function(target, x, y) {
      var elePos = this.checkCollision(target, x, y);
      var newpos = elePos.position;
      if (this.tooltipPositionY !== elePos.vertical) {
        newpos = this.position.indexOf("Bottom") === 0 || this.position.indexOf("Top") === 0 ? elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical;
      }
      if (this.tooltipPositionX !== elePos.horizontal) {
        if (newpos.indexOf("Left") === 0) {
          elePos.vertical = newpos === "LeftTop" || newpos === "LeftCenter" ? "Top" : "Bottom";
          newpos = elePos.vertical + "Left";
        }
        if (newpos.indexOf("Right") === 0) {
          elePos.vertical = newpos === "RightTop" || newpos === "RightCenter" ? "Top" : "Bottom";
          newpos = elePos.vertical + "Right";
        }
        elePos.horizontal = this.tooltipPositionX;
      }
      this.tooltipEventArgs = {
        type: null,
        cancel: false,
        target,
        event: null,
        element: this.tooltipEle,
        collidedPosition: newpos
      };
      this.trigger("beforeCollision", this.tooltipEventArgs);
      if (this.tooltipEventArgs.cancel) {
        newpos = this.position;
      } else {
        var elePosVertical = elePos.vertical;
        var elePosHorizontal = elePos.horizontal;
        if (elePos.position !== newpos) {
          var pos = calculatePosition(target, elePosHorizontal, elePosVertical, !this.isBodyContainer, this.isBodyContainer ? null : this.containerElement.getBoundingClientRect());
          this.adjustArrow(target, newpos, elePosHorizontal, elePosVertical);
          var scalingFactors = this.getScalingFactor(target);
          var offsetPos = this.calculateTooltipOffset(newpos, scalingFactors.x, scalingFactors.y);
          offsetPos.top -= this.getOffSetPosition("TopBottom", newpos, this.offsetY);
          offsetPos.left -= this.getOffSetPosition("RightLeft", newpos, this.offsetX);
          elePos.position = newpos;
          var elePosition = this.calculateElementPosition(pos, offsetPos);
          elePos.left = elePosition[0];
          elePos.top = elePosition[1];
        } else {
          this.adjustArrow(target, newpos, elePosHorizontal, elePosVertical);
        }
      }
      var eleOffset = { left: elePos.left, top: elePos.top };
      var position = this.isBodyContainer ? fit(this.tooltipEle, this.checkCollideTarget(), { X: true, Y: this.windowCollision }, eleOffset) : eleOffset;
      this.tooltipEle.style.display = "block";
      var arrowEle = select("." + ARROW_TIP, this.tooltipEle);
      if (this.showTipPointer && arrowEle != null && (newpos.indexOf("Bottom") === 0 || newpos.indexOf("Top") === 0)) {
        var arrowleft = parseInt(arrowEle.style.left, 10) - (position.left - elePos.left);
        if (arrowleft < 0) {
          arrowleft = 0;
        } else if (arrowleft + arrowEle.offsetWidth > this.tooltipEle.clientWidth) {
          arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;
        }
        arrowEle.style.left = arrowleft.toString() + "px";
      }
      this.tooltipEle.style.display = "";
      eleOffset.left = position.left;
      eleOffset.top = position.top;
      return eleOffset;
    };
    Tooltip2.prototype.getOffSetPosition = function(positionString, newPos, offsetType) {
      return positionString.indexOf(this.position.split(/(?=[A-Z])/)[0]) !== -1 && positionString.indexOf(newPos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * offsetType : 0;
    };
    Tooltip2.prototype.checkCollideTarget = function() {
      return !this.windowCollision && this.target ? this.element : null;
    };
    Tooltip2.prototype.hideTooltip = function(hideAnimation, e, targetElement2) {
      var _this = this;
      if (this.closeDelay > 0) {
        clearTimeout(this.hideTimer);
        clearTimeout(this.showTimer);
        var hide = function() {
          if (_this.closeDelay && _this.tooltipEle && _this.isTooltipOpen) {
            return;
          }
          _this.tooltipHide(hideAnimation, e, targetElement2);
        };
        this.hideTimer = setTimeout(hide, this.closeDelay);
      } else {
        this.tooltipHide(hideAnimation, e, targetElement2);
      }
    };
    Tooltip2.prototype.tooltipHide = function(hideAnimation, e, targetElement2) {
      var _this = this;
      var target;
      if (e) {
        target = this.target ? targetElement2 || e.target : this.element;
      } else {
        target = select('[data-tooltip-id= "' + this.ctrlId + '_content"]', document);
      }
      this.tooltipEventArgs = {
        type: e ? e.type : null,
        cancel: false,
        target,
        event: e ? e : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(e)
      };
      this.trigger("beforeClose", this.tooltipEventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          _this.mouseMoveBeforeRemove();
          _this.popupHide(hideAnimation, target, e);
        } else {
          _this.isHidden = false;
        }
      });
    };
    Tooltip2.prototype.popupHide = function(hideAnimation, target, e) {
      if (target && e) {
        this.restoreElement(target);
      }
      this.isHidden = true;
      var closeAnimation = {
        name: hideAnimation.effect === "None" && animationMode === "Enable" ? "FadeOut" : this.animation.close.effect,
        duration: hideAnimation.duration,
        delay: hideAnimation.delay,
        timingFunction: "easeIn"
      };
      if (hideAnimation.effect === "None") {
        closeAnimation = void 0;
      }
      if (this.popupObj) {
        this.popupObj.hide(closeAnimation);
      }
    };
    Tooltip2.prototype.restoreElement = function(target) {
      this.unwireMouseEvents(target);
      if (!isNullOrUndefined(target.getAttribute("data-content"))) {
        target.setAttribute("title", target.getAttribute("data-content"));
        target.removeAttribute("data-content");
      }
      this.removeDescribedBy(target);
    };
    Tooltip2.prototype.clear = function() {
      var target = this.findTarget();
      if (target) {
        this.restoreElement(target);
      }
      if (this.tooltipEle) {
        removeClass([this.tooltipEle], POPUP_CLOSE);
        addClass([this.tooltipEle], POPUP_OPEN);
      }
      if (this.isHidden) {
        if (this.popupObj) {
          this.popupObj.destroy();
        }
        if (this.tooltipEle) {
          remove(this.tooltipEle);
        }
        this.tooltipEle = null;
        this.popupObj = null;
      }
    };
    Tooltip2.prototype.tooltipHover = function() {
      if (this.tooltipEle) {
        this.isTooltipOpen = true;
      }
    };
    Tooltip2.prototype.tooltipMouseOut = function(e) {
      this.isTooltipOpen = false;
      this.hideTooltip(this.animation.close, e, this.findTarget());
    };
    Tooltip2.prototype.onMouseOut = function(e) {
      var enteredElement = e.relatedTarget;
      if (enteredElement && !this.mouseTrail) {
        var checkForTooltipElement = closest(enteredElement, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT2);
        if (checkForTooltipElement) {
          EventHandler.add(checkForTooltipElement, "mouseleave", this.tooltipElementMouseOut, this);
        } else {
          this.hideTooltip(this.animation.close, e, this.findTarget());
          if (this.closeDelay === 0 && (this.animation.close.effect === "None" || this.isReact && typeof this.content != "string")) {
            this.clear();
          }
        }
      } else {
        this.hideTooltip(this.animation.close, e, this.findTarget());
        this.clear();
      }
    };
    Tooltip2.prototype.tooltipElementMouseOut = function(e) {
      this.hideTooltip(this.animation.close, e, this.findTarget());
      EventHandler.remove(this.element, "mouseleave", this.tooltipElementMouseOut);
      this.clear();
    };
    Tooltip2.prototype.onStickyClose = function() {
      this.close();
    };
    Tooltip2.prototype.onMouseMove = function(event) {
      var eventPageX = 0;
      var eventPageY = 0;
      if (event.type.indexOf("touch") > -1) {
        event.preventDefault();
        eventPageX = event.touches[0].pageX;
        eventPageY = event.touches[0].pageY;
      } else {
        eventPageX = event.pageX;
        eventPageY = event.pageY;
      }
      Animation.stop(this.tooltipEle);
      removeClass([this.tooltipEle], POPUP_CLOSE);
      addClass([this.tooltipEle], POPUP_OPEN);
      this.adjustArrow(event.target, this.position, this.tooltipPositionX, this.tooltipPositionY);
      var scalingFactors = this.getScalingFactor(event.target);
      var pos = this.calculateTooltipOffset(this.position, scalingFactors.x, scalingFactors.y);
      var x = eventPageX + pos.left + this.offsetX;
      var y = eventPageY + pos.top + this.offsetY;
      var elePos = this.checkCollision(event.target, x, y);
      if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {
        var newpos = this.position.indexOf("Bottom") === 0 || this.position.indexOf("Top") === 0 ? elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;
        elePos.position = newpos;
        this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);
        var colpos = this.calculateTooltipOffset(elePos.position, scalingFactors.x, scalingFactors.y);
        elePos.left = eventPageX + colpos.left - this.offsetX;
        elePos.top = eventPageY + colpos.top - this.offsetY;
      }
      this.tooltipEle.style.left = elePos.left + "px";
      this.tooltipEle.style.top = elePos.top + "px";
    };
    Tooltip2.prototype.keyDown = function(event) {
      if (this.tooltipEle && event.keyCode === 27) {
        this.close();
      }
    };
    Tooltip2.prototype.touchEnd = function(e) {
      if (this.tooltipEle && closest(e.target, "." + ROOT2) === null && !this.isSticky) {
        this.close();
      }
    };
    Tooltip2.prototype.scrollHandler = function(e) {
      if (this.tooltipEle && !this.isSticky) {
        if (!closest(e.target, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT2) && !this.isSticky) {
          this.close();
        }
      }
    };
    Tooltip2.prototype.render = function() {
      this.initialize();
      this.wireEvents(this.opensOn);
      this.renderComplete();
    };
    Tooltip2.prototype.preRender = function() {
      this.tipClass = TIP_BOTTOM;
      this.tooltipPositionX = "Center";
      this.tooltipPositionY = "Top";
      this.isHidden = true;
    };
    Tooltip2.prototype.wireEvents = function(trigger) {
      var triggerList = this.getTriggerList(trigger);
      for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {
        var opensOn = triggerList_1[_i];
        if (opensOn === "Custom") {
          return;
        }
        if (opensOn === "Focus") {
          this.wireFocusEvents();
        }
        if (opensOn === "Click") {
          EventHandler.add(this.element, Browser.touchStartEvent, this.targetClick, this);
        }
        if (opensOn === "Hover") {
          if (Browser.isDevice) {
            this.touchModule = new Touch(this.element, {
              tapHoldThreshold: TAPHOLD_THRESHOLD,
              tapHold: this.tapHoldHandler.bind(this)
            });
            EventHandler.add(this.element, Browser.touchEndEvent, this.touchEndHandler, this);
          } else {
            EventHandler.add(this.element, "mouseover", this.targetHover, this);
          }
        }
      }
      EventHandler.add(document, "touchend", this.touchEnd, this);
      EventHandler.add(document, "scroll wheel", this.scrollHandler, this);
      EventHandler.add(window, "resize", this.windowResize, this);
      EventHandler.add(document, "keydown", this.keyDown, this);
    };
    Tooltip2.prototype.getTriggerList = function(trigger) {
      if (!trigger)
        return [];
      if (trigger === "Auto") {
        trigger = Browser.isDevice ? "Hover" : "Hover Focus";
      }
      return trigger.split(" ");
    };
    Tooltip2.prototype.wireFocusEvents = function() {
      if (!isNullOrUndefined(this.target)) {
        var targetList = [].slice.call(selectAll(this.target, this.element));
        this.targetsList = targetList;
        if (!isNullOrUndefined(this.targetsList) && this.targetsList.length > 0) {
          for (var _i = 0, targetList_2 = targetList; _i < targetList_2.length; _i++) {
            var target = targetList_2[_i];
            EventHandler.add(target, "focus", this.targetHover, this);
          }
        } else {
          EventHandler.add(this.element, "focusin", this.targetHover, this);
        }
      } else {
        EventHandler.add(this.element, "focusin", this.targetHover, this);
      }
    };
    Tooltip2.prototype.wireMouseEvents = function(e, target) {
      if (this.tooltipEle) {
        if (!this.isSticky) {
          if (e.type === "focus") {
            EventHandler.add(target, "blur", this.onMouseOut, this);
          }
          if (e.type === "focusin") {
            EventHandler.add(target, "focusout", this.onMouseOut, this);
          }
          if (e.type === "mouseover") {
            EventHandler.add(target, "mouseleave", this.onMouseOut, this);
          }
          if (this.closeDelay) {
            EventHandler.add(this.tooltipEle, "mouseenter", this.tooltipHover, this);
            EventHandler.add(this.tooltipEle, "mouseleave", this.tooltipMouseOut, this);
          }
        }
        if (this.mouseTrail && this.openDelay === 0) {
          EventHandler.add(target, "mousemove touchstart mouseenter", this.onMouseMove, this);
        }
      }
    };
    Tooltip2.prototype.unwireEvents = function(trigger) {
      var triggerList = this.getTriggerList(trigger);
      for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {
        var opensOn = triggerList_2[_i];
        if (opensOn === "Custom") {
          return;
        }
        if (opensOn === "Focus") {
          this.unwireFocusEvents();
        }
        if (opensOn === "Click") {
          EventHandler.remove(this.element, Browser.touchStartEvent, this.targetClick);
        }
        if (opensOn === "Hover") {
          if (Browser.isDevice) {
            if (this.touchModule) {
              this.touchModule.destroy();
            }
            EventHandler.remove(this.element, Browser.touchEndEvent, this.touchEndHandler);
          } else {
            EventHandler.remove(this.element, "mouseover", this.targetHover);
          }
        }
      }
      EventHandler.remove(document, "touchend", this.touchEnd);
      EventHandler.remove(document, "scroll wheel", this.scrollHandler);
      EventHandler.remove(window, "resize", this.windowResize);
      EventHandler.remove(document, "keydown", this.keyDown);
    };
    Tooltip2.prototype.unwireFocusEvents = function() {
      if (!isNullOrUndefined(this.target)) {
        var targetList = [].slice.call(selectAll(this.target, this.element));
        if (!isNullOrUndefined(this.targetsList) && this.targetsList.length > 0) {
          for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {
            var target = targetList_3[_i];
            EventHandler.remove(target, "focus", this.targetHover);
          }
        } else {
          EventHandler.remove(this.element, "focusin", this.targetHover);
        }
      } else {
        EventHandler.remove(this.element, "focusin", this.targetHover);
      }
    };
    Tooltip2.prototype.unwireMouseEvents = function(target) {
      if (!this.isSticky) {
        var triggerList = this.getTriggerList(this.opensOn);
        for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {
          var opensOn = triggerList_3[_i];
          if (opensOn === "Focus") {
            EventHandler.remove(target, "blur", this.onMouseOut);
            EventHandler.remove(target, "focusout", this.onMouseOut);
          }
          if (opensOn === "Hover" && !Browser.isDevice) {
            EventHandler.remove(target, "mouseleave", this.onMouseOut);
          }
        }
        if (this.closeDelay) {
          EventHandler.remove(target, "mouseenter", this.tooltipHover);
          EventHandler.remove(target, "mouseleave", this.tooltipMouseOut);
        }
      }
      if (this.mouseTrail) {
        EventHandler.remove(target, "mousemove touchstart mouseenter", this.onMouseMove);
      }
    };
    Tooltip2.prototype.findTarget = function() {
      var target = select('[data-tooltip-id= "' + this.ctrlId + '_content"]', document);
      return target;
    };
    Tooltip2.prototype.getModuleName = function() {
      return "tooltip";
    };
    Tooltip2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Tooltip2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var targetElement2 = this.findTarget();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            if (this.tooltipEle && targetElement2) {
              this.tooltipEle.style.width = this.tooltipEle.style.maxWidth = formatUnit(newProp.width);
              this.reposition(targetElement2);
            }
            break;
          case "height":
            if (this.tooltipEle && targetElement2) {
              this.tooltipEle.style.height = formatUnit(newProp.height);
              this.reposition(targetElement2);
            }
            break;
          case "content":
            if (this.tooltipEle) {
              this.renderContent();
            }
            break;
          case "opensOn":
            this.unwireEvents(oldProp.opensOn);
            this.wireEvents(newProp.opensOn);
            break;
          case "position":
            this.formatPosition();
            if (this.tooltipEle && targetElement2) {
              var arrowInnerELe = select("." + ARROW_TIP_INNER, this.tooltipEle);
              if (arrowInnerELe) {
                arrowInnerELe.style.top = arrowInnerELe.style.left = null;
              }
              this.reposition(targetElement2);
            }
            break;
          case "tipPointerPosition":
            if (this.tooltipEle && targetElement2) {
              this.reposition(targetElement2);
            }
            break;
          case "offsetX":
            if (this.tooltipEle) {
              var x = newProp.offsetX - oldProp.offsetX;
              this.tooltipEle.style.left = (parseInt(this.tooltipEle.style.left, 10) + x).toString() + "px";
            }
            break;
          case "offsetY":
            if (this.tooltipEle) {
              var y = newProp.offsetY - oldProp.offsetY;
              this.tooltipEle.style.top = (parseInt(this.tooltipEle.style.top, 10) + y).toString() + "px";
            }
            break;
          case "cssClass":
            if (this.tooltipEle) {
              if (oldProp.cssClass) {
                removeClass([this.tooltipEle], oldProp.cssClass.split(" "));
              }
              if (newProp.cssClass) {
                addClass([this.tooltipEle], newProp.cssClass.split(" "));
              }
            }
            break;
          case "enableRtl":
            if (this.tooltipEle) {
              if (this.enableRtl) {
                addClass([this.tooltipEle], RTL5);
              } else {
                removeClass([this.tooltipEle], RTL5);
              }
            }
            break;
          case "isSticky":
            if (this.tooltipEle && targetElement2) {
              this.renderCloseIcon();
              this.reposition(targetElement2);
            }
            break;
          case "container":
            if (!isNullOrUndefined(this.containerElement)) {
              removeClass([this.containerElement], POPUP_CONTAINER);
            }
            this.container = newProp.container;
            if (this.tooltipEle && targetElement2) {
              this.appendContainer(this);
              this.reposition(targetElement2);
            }
        }
      }
    };
    Tooltip2.prototype.open = function(element2, animation) {
      if (isNullOrUndefined(animation)) {
        animation = this.animation.open;
      }
      if (isNullOrUndefined(element2)) {
        element2 = this.element;
      }
      if (element2.style.display === "none") {
        return;
      }
      this.showTooltip(element2, animation);
    };
    Tooltip2.prototype.close = function(animation) {
      if (!animation) {
        animation = this.animation.close;
      }
      this.hideTooltip(animation);
    };
    Tooltip2.prototype.refresh = function(target) {
      if (this.tooltipEle) {
        this.renderContent(target);
      }
      if (this.popupObj && target) {
        this.reposition(target);
      }
      if (!isNullOrUndefined(this.targetsList) && !isNullOrUndefined(this.target)) {
        var target_2 = selectAll(this.target, this.element);
        if (target_2.length !== this.targetsList.length) {
          this.unwireEvents(this.opensOn);
          this.wireEvents(this.opensOn);
        }
      }
    };
    Tooltip2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.tooltipEle) {
        remove(this.tooltipEle);
      }
      if (this.popupObj) {
        this.popupObj.destroy();
      }
      destroy();
      removeClass([this.element], ROOT2);
      this.unwireEvents(this.opensOn);
      this.unwireMouseEvents(this.element);
      this.tooltipEle = null;
      this.popupObj = null;
      var currentTarget = selectAll('[data-tooltip-id= "' + this.ctrlId + '_content"]', this.element);
      for (var _i = 0, currentTarget_1 = currentTarget; _i < currentTarget_1.length; _i++) {
        var target = currentTarget_1[_i];
        this.restoreElement(target);
      }
      this.containerElement = null;
      this.tipClass = null;
      this.tooltipPositionX = null;
      this.tooltipPositionY = null;
      this.ctrlId = null;
      this.tooltipEventArgs = null;
      this.touchModule = null;
      this.mouseMoveEvent = null;
      this.mouseMoveTarget = null;
      this.containerElement = null;
      this.targetsList = null;
    };
    __decorate11([
      Property("auto")
    ], Tooltip2.prototype, "width", void 0);
    __decorate11([
      Property("auto")
    ], Tooltip2.prototype, "height", void 0);
    __decorate11([
      Property()
    ], Tooltip2.prototype, "content", void 0);
    __decorate11([
      Property("body")
    ], Tooltip2.prototype, "container", void 0);
    __decorate11([
      Property()
    ], Tooltip2.prototype, "target", void 0);
    __decorate11([
      Property("TopCenter")
    ], Tooltip2.prototype, "position", void 0);
    __decorate11([
      Property(0)
    ], Tooltip2.prototype, "offsetX", void 0);
    __decorate11([
      Property(0)
    ], Tooltip2.prototype, "offsetY", void 0);
    __decorate11([
      Property(true)
    ], Tooltip2.prototype, "showTipPointer", void 0);
    __decorate11([
      Property(true)
    ], Tooltip2.prototype, "enableHtmlParse", void 0);
    __decorate11([
      Property(false)
    ], Tooltip2.prototype, "windowCollision", void 0);
    __decorate11([
      Property("Auto")
    ], Tooltip2.prototype, "tipPointerPosition", void 0);
    __decorate11([
      Property("Auto")
    ], Tooltip2.prototype, "opensOn", void 0);
    __decorate11([
      Property(false)
    ], Tooltip2.prototype, "mouseTrail", void 0);
    __decorate11([
      Property(false)
    ], Tooltip2.prototype, "isSticky", void 0);
    __decorate11([
      Complex({}, Animation2)
    ], Tooltip2.prototype, "animation", void 0);
    __decorate11([
      Property(0)
    ], Tooltip2.prototype, "openDelay", void 0);
    __decorate11([
      Property(0)
    ], Tooltip2.prototype, "closeDelay", void 0);
    __decorate11([
      Property()
    ], Tooltip2.prototype, "cssClass", void 0);
    __decorate11([
      Property(true)
    ], Tooltip2.prototype, "enableHtmlSanitizer", void 0);
    __decorate11([
      Property("")
    ], Tooltip2.prototype, "htmlAttributes", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "beforeRender", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "beforeOpen", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "afterOpen", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "beforeClose", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "afterClose", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "beforeCollision", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "created", void 0);
    __decorate11([
      Event()
    ], Tooltip2.prototype, "destroyed", void 0);
    Tooltip2 = __decorate11([
      NotifyPropertyChanges
    ], Tooltip2);
    return Tooltip2;
  }(Component)
);

// node_modules/@syncfusion/ej2-popups/src/spinner/spinner.js
var globalTimeOut = {};
var DEFT_MAT_WIDTH = 30;
var DEFT_MAT3_WIDTH = 30;
var DEFT_FAB_WIDTH = 30;
var DEFT_FLUENT_WIDTH = 30;
var DEFT_FLUENT2_WIDTH = 30;
var DEFT_BOOT_WIDTH = 30;
var DEFT_BOOT4_WIDTH = 36;
var DEFT_BOOT5_WIDTH = 36;
var CLS_SHOWSPIN = "e-spin-show";
var CLS_HIDESPIN = "e-spin-hide";
var CLS_MATERIALSPIN = "e-spin-material";
var CLS_MATERIAL3SPIN = "e-spin-material3";
var CLS_FABRICSPIN = "e-spin-fabric";
var CLS_FLUENTSPIN = "e-spin-fluent";
var CLS_FLUENT2SPIN = "e-spin-fluent2";
var CLS_TAILWINDSPIN = "e-spin-tailwind";
var CLS_BOOTSPIN = "e-spin-bootstrap";
var CLS_BOOT4SPIN = "e-spin-bootstrap4";
var CLS_BOOT5SPIN = "e-spin-bootstrap5";
var CLS_HIGHCONTRASTSPIN = "e-spin-high-contrast";
var CLS_SPINWRAP = "e-spinner-pane";
var CLS_SPININWRAP = "e-spinner-inner";
var CLS_SPINCIRCLE = "e-path-circle";
var CLS_SPINARC = "e-path-arc";
var CLS_SPINLABEL = "e-spin-label";
var CLS_SPINTEMPLATE = "e-spin-template";
var spinTemplate = null;
var spinCSSClass = null;
function createSpinner(args, internalCreateElement) {
  var _a;
  if (!args.target) {
    return;
  }
  var radius;
  var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
  var container = create_spinner_container(args.target, makeElement);
  if (!isNullOrUndefined(args.cssClass)) {
    var classNames5 = args.cssClass.split(" ").filter(function(className) {
      return className.trim() !== "";
    });
    (_a = container.wrap.classList).add.apply(_a, classNames5);
  }
  if (!isNullOrUndefined(args.template) || !isNullOrUndefined(spinTemplate)) {
    var template = !isNullOrUndefined(args.template) ? args.template : spinTemplate;
    container.wrap.classList.add(CLS_SPINTEMPLATE);
    replaceContent(container.wrap, template, spinCSSClass);
  } else {
    var theme = !isNullOrUndefined(args.type) ? args.type : getTheme(container.wrap);
    var width = !isNullOrUndefined(args.width) ? args.width : void 0;
    radius = calculateRadius(width, theme);
    setTheme(theme, container.wrap, radius, makeElement);
    if (!isNullOrUndefined(args.label)) {
      createLabel(container.inner_wrap, args.label, makeElement);
    }
  }
  container.wrap.classList.add(CLS_HIDESPIN);
  container = null;
}
function createLabel(container, label, makeElement) {
  var labelEle = makeElement("div", {});
  labelEle.classList.add(CLS_SPINLABEL);
  labelEle.innerHTML = label;
  container.appendChild(labelEle);
  return labelEle;
}
function createMaterialSpinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Material", radius };
  create_material_element(container, uniqueID, makeElement, CLS_MATERIALSPIN);
  mat_calculate_attributes(radius, container, "Material", CLS_MATERIALSPIN);
}
function createMaterial3Spinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Material3", radius };
  create_material_element(container, uniqueID, makeElement, CLS_MATERIAL3SPIN);
  mat_calculate_attributes(radius, container, "Material3", CLS_MATERIAL3SPIN);
}
function createBootstrap4Spinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Bootstrap4", radius };
  create_material_element(container, uniqueID, makeElement, CLS_BOOT4SPIN);
  mat_calculate_attributes(radius, container, "Bootstrap4", CLS_BOOT4SPIN);
}
function createBootstrap5Spinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Bootstrap5", radius };
  create_material_element(container, uniqueID, makeElement, CLS_BOOT5SPIN);
  mat_calculate_attributes(radius, container, "Bootstrap5", CLS_BOOT5SPIN);
}
function startMatAnimate(container, uniqueID, radius) {
  var globalObject = {};
  var timeOutVar = 0;
  globalTimeOut["" + uniqueID].timeOut = 0;
  globalObject["" + uniqueID] = globalVariables(uniqueID, radius, 0, 0);
  var spinnerInfo = { uniqueID, container, globalInfo: globalObject, timeOutVar };
  animateMaterial(spinnerInfo);
}
function createFabricSpinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Fabric", radius };
  create_fabric_element(container, uniqueID, CLS_FABRICSPIN, makeElement);
  fb_calculate_attributes(radius, container, CLS_FABRICSPIN);
}
function createFluentSpinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Fluent", radius };
  create_fabric_element(container, uniqueID, CLS_FLUENTSPIN, makeElement);
  fb_calculate_attributes(radius, container, CLS_FLUENTSPIN);
}
function createFluent2Spinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Fluent2", radius };
  create_fabric_element(container, uniqueID, CLS_FLUENT2SPIN, makeElement);
  fb_calculate_attributes(radius, container, CLS_FLUENT2SPIN);
}
function createTailwindSpinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Tailwind", radius };
  create_fabric_element(container, uniqueID, CLS_TAILWINDSPIN, makeElement);
  fb_calculate_attributes(radius, container, CLS_TAILWINDSPIN);
}
function createHighContrastSpinner(container, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "HighContrast", radius };
  create_fabric_element(container, uniqueID, CLS_HIGHCONTRASTSPIN, makeElement);
  fb_calculate_attributes(radius, container, CLS_HIGHCONTRASTSPIN);
}
function getTheme(container) {
  var theme = window.getComputedStyle(container, ":after").getPropertyValue("content");
  return theme.replace(/['"]+/g, "");
}
function setTheme(theme, container, radius, makeElement) {
  var innerContainer = container.querySelector("." + CLS_SPININWRAP);
  var svg = innerContainer.querySelector("svg");
  if (!isNullOrUndefined(svg)) {
    innerContainer.removeChild(svg);
  }
  switch (theme) {
    case "Material":
      createMaterialSpinner(innerContainer, radius, makeElement);
      break;
    case "Material3":
      createMaterial3Spinner(innerContainer, radius, makeElement);
      break;
    case "Fabric":
      createFabricSpinner(innerContainer, radius, makeElement);
      break;
    case "Fluent":
      createFluentSpinner(innerContainer, radius, makeElement);
      break;
    case "Fluent2":
      createFluent2Spinner(innerContainer, radius, makeElement);
      break;
    case "Bootstrap":
      createBootstrapSpinner(innerContainer, radius, makeElement);
      break;
    case "HighContrast":
      createHighContrastSpinner(innerContainer, radius, makeElement);
      break;
    case "Bootstrap4":
      createBootstrap4Spinner(innerContainer, radius, makeElement);
      break;
    case "Bootstrap5":
      createBootstrap5Spinner(innerContainer, radius, makeElement);
      break;
    case "Tailwind":
    case "Tailwind-dark":
      createTailwindSpinner(innerContainer, radius, makeElement);
      break;
  }
}
function createBootstrapSpinner(innerContainer, radius, makeElement) {
  var uniqueID = random_generator();
  globalTimeOut["" + uniqueID] = { timeOut: 0, type: "Bootstrap", radius };
  create_bootstrap_element(innerContainer, uniqueID, makeElement);
  boot_calculate_attributes(innerContainer, radius);
}
function create_bootstrap_element(innerContainer, uniqueID, makeElement) {
  var svgBoot = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  var viewBoxValue = 64;
  var trans = 32;
  var defaultRadius = 2;
  svgBoot.setAttribute("id", uniqueID);
  svgBoot.setAttribute("class", CLS_BOOTSPIN);
  svgBoot.setAttribute("viewBox", "0 0 " + viewBoxValue + " " + viewBoxValue);
  innerContainer.insertBefore(svgBoot, innerContainer.firstChild);
  for (var item = 0; item <= 7; item++) {
    var bootCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    bootCircle.setAttribute("class", CLS_SPINCIRCLE + "_" + item);
    bootCircle.setAttribute("r", defaultRadius + "");
    bootCircle.setAttribute("transform", "translate(" + trans + "," + trans + ")");
    svgBoot.appendChild(bootCircle);
  }
}
function boot_calculate_attributes(innerContainer, radius) {
  var svg = innerContainer.querySelector("svg.e-spin-bootstrap");
  var x = 0;
  var y = 0;
  var rad = 24;
  svg.style.width = svg.style.height = radius + "px";
  var startArc = 90;
  for (var item = 0; item <= 7; item++) {
    var start = defineArcPoints(x, y, rad, startArc);
    var circleEle = svg.querySelector("." + CLS_SPINCIRCLE + "_" + item);
    circleEle.setAttribute("cx", start.x + "");
    circleEle.setAttribute("cy", start.y + "");
    startArc = startArc >= 360 ? 0 : startArc;
    startArc = startArc + 45;
  }
}
function generateSeries(begin, stop) {
  var series = [];
  var start = begin;
  var end = stop;
  var increment = false;
  var count = 1;
  formSeries(start);
  function formSeries(i) {
    series.push(i);
    if (i !== end || count === 1) {
      if (i <= start && i > 1 && !increment) {
        i = parseFloat((i - 0.2).toFixed(2));
      } else if (i === 1) {
        i = 7;
        i = parseFloat((i + 0.2).toFixed(2));
        increment = true;
      } else if (i < 8 && increment) {
        i = parseFloat((i + 0.2).toFixed(2));
        if (i === 8) {
          increment = false;
        }
      } else if (i <= 8 && !increment) {
        i = parseFloat((i - 0.2).toFixed(2));
      }
      ++count;
      formSeries(i);
    }
  }
  return series;
}
function animateBootstrap(innerContainer) {
  var svg = innerContainer.querySelector("svg.e-spin-bootstrap");
  var id = svg.getAttribute("id");
  for (var i = 1; i <= 8; i++) {
    var circleEle = innerContainer.getElementsByClassName("e-path-circle_" + (i === 8 ? 0 : i))[0];
    rotation(circleEle, i, i, generateSeries(i, i), id);
  }
  function rotation(circle, start, end, series, id2) {
    var count = 0;
    boot_animate(start);
    function boot_animate(radius) {
      if (globalTimeOut["" + id2].isAnimate) {
        ++count;
        circle.setAttribute("r", radius + "");
        if (count >= series.length) {
          count = 0;
        }
        globalTimeOut[id2].timeOut = setTimeout(boot_animate.bind(null, series[count]), 18);
      }
    }
  }
}
function replaceContent(container, template, cssClass2) {
  if (!isNullOrUndefined(cssClass2)) {
    container.classList.add(cssClass2);
  }
  var inner = container.querySelector(".e-spinner-inner");
  inner.innerHTML = template;
}
function calculateRadius(width, theme) {
  var defaultSize;
  switch (theme) {
    case "Material":
      defaultSize = DEFT_MAT_WIDTH;
      break;
    case "Material3":
      defaultSize = DEFT_MAT3_WIDTH;
      break;
    case "Fabric":
      defaultSize = DEFT_FAB_WIDTH;
      break;
    case "Tailwind":
    case "Tailwind-dark":
      defaultSize = DEFT_FAB_WIDTH;
      break;
    case "Fluent":
      defaultSize = DEFT_FLUENT_WIDTH;
      break;
    case "Fluent2":
      defaultSize = DEFT_FLUENT2_WIDTH;
      break;
    case "Bootstrap4":
      defaultSize = DEFT_BOOT4_WIDTH;
      break;
    case "Bootstrap5":
      defaultSize = DEFT_BOOT5_WIDTH;
      break;
    default:
      defaultSize = DEFT_BOOT_WIDTH;
  }
  width = width ? parseFloat(width + "") : defaultSize;
  return theme === "Bootstrap" ? width : width / 2;
}
function globalVariables(id, radius, count, previousId) {
  return {
    radius,
    count,
    previousId
  };
}
function random_generator() {
  var random = "";
  var combine = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (var i = 0; i < 5; i++) {
    random += combine.charAt(Math.floor(Math.random() * combine.length));
  }
  return random;
}
function create_fabric_element(innerCon, uniqueID, themeClass, makeElement) {
  var svgFabric = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svgFabric.setAttribute("id", uniqueID);
  svgFabric.setAttribute("class", themeClass);
  var fabricCirclePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  fabricCirclePath.setAttribute("class", CLS_SPINCIRCLE);
  var fabricCircleArc = document.createElementNS("http://www.w3.org/2000/svg", "path");
  fabricCircleArc.setAttribute("class", CLS_SPINARC);
  innerCon.insertBefore(svgFabric, innerCon.firstChild);
  svgFabric.appendChild(fabricCirclePath);
  svgFabric.appendChild(fabricCircleArc);
}
function create_material_element(innerContainer, uniqueID, makeElement, cls) {
  var svgMaterial = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  var matCirclePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  svgMaterial.setAttribute("class", cls);
  svgMaterial.setAttribute("id", uniqueID);
  matCirclePath.setAttribute("class", CLS_SPINCIRCLE);
  innerContainer.insertBefore(svgMaterial, innerContainer.firstChild);
  svgMaterial.appendChild(matCirclePath);
}
function create_spinner_container(target, makeElement) {
  var spinnerContainer = makeElement("div", {});
  var spinnerInnerContainer = makeElement("div", {});
  spinnerContainer.classList.add(CLS_SPINWRAP);
  spinnerInnerContainer.classList.add(CLS_SPININWRAP);
  spinnerInnerContainer.setAttribute("aria-disabled", "true");
  target.appendChild(spinnerContainer);
  spinnerContainer.appendChild(spinnerInnerContainer);
  return { wrap: spinnerContainer, inner_wrap: spinnerInnerContainer };
}
function animateMaterial(spinnerInfo) {
  var start = 1;
  var end = 149;
  var duration = 1333;
  var max = 75;
  createCircle(start, end, easeAnimation, duration, spinnerInfo.globalInfo[spinnerInfo.uniqueID].count, max, spinnerInfo);
  spinnerInfo.globalInfo[spinnerInfo.uniqueID].count = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].count % 4;
}
function createCircle(start, end, easing, duration, count, max, spinnerInfo) {
  var id = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId;
  var startTime = (/* @__PURE__ */ new Date()).getTime();
  var change = end - start;
  var diameter = getSize(spinnerInfo.globalInfo[spinnerInfo.uniqueID].radius * 2 + "");
  var strokeSize = getStrokeSize(diameter);
  var rotate = -90 * (spinnerInfo.globalInfo[spinnerInfo.uniqueID].count || 0);
  mat_animation(spinnerInfo);
  function mat_animation(spinnerInfo2) {
    var currentTime = Math.max(0, Math.min((/* @__PURE__ */ new Date()).getTime() - startTime, duration));
    updatePath(easing(currentTime, start, change, duration), spinnerInfo2.container);
    if (id === spinnerInfo2.globalInfo[spinnerInfo2.uniqueID].previousId && currentTime < duration) {
      globalTimeOut[spinnerInfo2.uniqueID].timeOut = setTimeout(mat_animation.bind(null, spinnerInfo2), 1);
    } else {
      animateMaterial(spinnerInfo2);
    }
  }
  function updatePath(value, container) {
    if (!isNullOrUndefined(container.querySelector("svg.e-spin-material")) || !isNullOrUndefined(container.querySelector("svg.e-spin-material3"))) {
      var svg = void 0;
      if (!isNullOrUndefined(container.querySelector("svg.e-spin-material")) && !isNullOrUndefined(container.querySelector("svg.e-spin-material").querySelector("path.e-path-circle"))) {
        svg = container.querySelector("svg.e-spin-material");
      } else if (!isNullOrUndefined(container.querySelector("svg.e-spin-material3")) && !isNullOrUndefined(container.querySelector("svg.e-spin-material3").querySelector("path.e-path-circle"))) {
        svg = container.querySelector("svg.e-spin-material3");
      }
      if (!isNullOrUndefined(svg)) {
        var path = svg.querySelector("path.e-path-circle");
        path.setAttribute("stroke-dashoffset", getDashOffset(diameter, strokeSize, value, max) + "");
        path.setAttribute("transform", "rotate(" + rotate + " " + diameter / 2 + " " + diameter / 2 + ")");
      }
    }
  }
}
function mat_calculate_attributes(radius, container, type, cls) {
  var diameter = radius * 2;
  var svg = container.querySelector("svg." + cls);
  var path = svg.querySelector("path.e-path-circle");
  var strokeSize = getStrokeSize(diameter);
  var transformOrigin = diameter / 2 + "px";
  svg.setAttribute("viewBox", "0 0 " + diameter + " " + diameter);
  svg.style.width = svg.style.height = diameter + "px";
  svg.style.transformOrigin = transformOrigin + " " + transformOrigin + " " + transformOrigin;
  path.setAttribute("d", drawArc(diameter, strokeSize));
  if (type === "Material" || type === "Material3" || type === "Fluent2") {
    path.setAttribute("stroke-width", strokeSize + "");
    path.setAttribute("stroke-dasharray", (diameter - strokeSize) * Math.PI * 0.75 + "");
    path.setAttribute("stroke-dashoffset", getDashOffset(diameter, strokeSize, 1, 75) + "");
  }
}
function getSize(value) {
  var parsed = parseFloat(value);
  return parsed;
}
function drawArc(diameter, strokeSize) {
  var radius = diameter / 2;
  var offset = strokeSize / 2;
  return "M" + radius + "," + offset + "A" + (radius - offset) + "," + (radius - offset) + " 0 1 1 " + offset + "," + radius;
}
function getStrokeSize(diameter) {
  return 10 / 100 * diameter;
}
function getDashOffset(diameter, strokeSize, value, max) {
  return (diameter - strokeSize) * Math.PI * (3 * max / 100 - value / 100);
}
function easeAnimation(current, start, change, duration) {
  var timestamp = (current /= duration) * current;
  var timecount = timestamp * current;
  return start + change * (6 * timecount * timestamp + -15 * timestamp * timestamp + 10 * timecount);
}
function fb_calculate_attributes(radius, innerConainer, trgClass) {
  var centerX = radius;
  var centerY = radius;
  var diameter = radius * 2;
  var startArc = 315;
  var endArc = 45;
  var svg = innerConainer.querySelector("." + trgClass);
  var circle = svg.querySelector(".e-path-circle");
  var path = svg.querySelector(".e-path-arc");
  var transformOrigin = diameter / 2 + "px";
  circle.setAttribute("d", defineCircle(centerX, centerY, radius));
  path.setAttribute("d", defineArc(centerX, centerY, radius, startArc, endArc));
  svg.setAttribute("viewBox", "0 0 " + diameter + " " + diameter);
  svg.style.transformOrigin = transformOrigin + " " + transformOrigin + " " + transformOrigin;
  svg.style.width = svg.style.height = diameter + "px";
}
function defineArcPoints(centerX, centerY, radius, angle) {
  var radians = (angle - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(radians),
    y: centerY + radius * Math.sin(radians)
  };
}
function defineArc(x, y, radius, startArc, endArc) {
  var start = defineArcPoints(x, y, radius, endArc);
  var end = defineArcPoints(x, y, radius, startArc);
  var d = [
    "M",
    start.x,
    start.y,
    "A",
    radius,
    radius,
    0,
    0,
    0,
    end.x,
    end.y
  ].join(" ");
  return d;
}
function defineCircle(x, y, radius) {
  var d = [
    "M",
    x,
    y,
    "m",
    -radius,
    0,
    "a",
    radius,
    radius,
    0,
    1,
    0,
    radius * 2,
    0,
    "a",
    radius,
    radius,
    0,
    1,
    0,
    -radius * 2,
    0
  ].join(" ");
  return d;
}
function showSpinner(container) {
  showHideSpinner(container, false);
  container = null;
}
function showHideSpinner(container, isHide) {
  var spinnerWrap;
  if (container) {
    if (container.classList.contains(CLS_SPINWRAP)) {
      spinnerWrap = container;
    } else {
      var spinWrapCollection = container.querySelectorAll("." + CLS_SPINWRAP);
      if (Browser.isIE) {
        for (var i = 0; i < spinWrapCollection.length; i++) {
          if (spinWrapCollection[i].parentElement && spinWrapCollection[i].parentElement === container) {
            spinnerWrap = spinWrapCollection[i];
            break;
          }
        }
      } else {
        spinnerWrap = Array.from(spinWrapCollection).find(function(wrap) {
          return wrap.parentElement === container;
        }) || null;
      }
    }
  }
  if (container && spinnerWrap) {
    var inner = spinnerWrap.querySelector("." + CLS_SPININWRAP);
    var spinCheck = isHide ? !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_HIDESPIN) : !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_SHOWSPIN);
    if (spinCheck) {
      var svgEle = spinnerWrap.querySelector("svg");
      if (isNullOrUndefined(svgEle)) {
        return;
      }
      var id = svgEle.getAttribute("id");
      globalTimeOut["" + id].isAnimate = !isHide;
      switch (globalTimeOut["" + id].type) {
        case "Material":
        case "Material3":
          if (isHide) {
            clearTimeout(globalTimeOut[id].timeOut);
          } else {
            startMatAnimate(inner, id, globalTimeOut[id].radius);
          }
          break;
        case "Bootstrap":
          if (isHide) {
            clearTimeout(globalTimeOut[id].timeOut);
          } else {
            animateBootstrap(inner);
          }
          break;
      }
    }
    if (isHide) {
      classList(spinnerWrap, [CLS_HIDESPIN], [CLS_SHOWSPIN]);
    } else {
      classList(spinnerWrap, [CLS_SHOWSPIN], [CLS_HIDESPIN]);
    }
    container = null;
  }
}
function hideSpinner(container) {
  showHideSpinner(container, true);
  container = null;
}

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/draw.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Draw = (
  /** @class */
  function() {
    function Draw2(parent) {
      this.isInitialLoading = false;
      this.fileName = "";
      this.isErrorImage = false;
      this.isShapeTextInserted = false;
      this.isRotateZoom = false;
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
      this.tempTextSettings = { text: "Enter Text", fontFamily: "", fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.tempAdjValue = "";
      this.tempFilter = "";
      this.tempUndoRedoStep = 0;
      this.tempFreehandCounter = 0;
      this.tempCurrFhdIndex = 0;
      this.tempZoomFactor = null;
      this.isCancelAction = false;
      this.rotatedFlipCropSel = false;
      this.zoomCrop = { width: 0, height: 0 };
      this.isImageEdited = false;
      this.isFileChanged = false;
      this.isNewPath = false;
      this.isResizeSelect = false;
      this.arrowDimension = {
        bar: { width: 10, height: 32, ratioX: null, ratioY: null },
        arrow: { width: 24, height: 24, ratioX: null, ratioY: null },
        arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
        circle: { width: 10, height: 10, ratioX: null, ratioY: null },
        square: { width: 20, height: 20, ratioX: null, ratioY: null }
      };
      this.origDim = { width: 0, height: 0 };
      this.isImageApply = false;
      this.imgCanvasPoints = [];
      this.isCropSelect = false;
      this.isDownScale = false;
      this.preventStraightening = false;
      this.tempObjColl = [];
      this.tempPointColl = {};
      this.parent = parent;
      this.addEventListener();
    }
    Draw2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Draw2.prototype.addEventListener = function() {
      this.parent.on("draw", this.draw, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Draw2.prototype.removeEventListener = function() {
      this.parent.off("draw", this.draw);
      this.parent.off("destroyed", this.destroy);
    };
    Draw2.prototype.draw = function(args) {
      this.updatePrivateVariables();
      switch (args.prop) {
        case "drawObject":
          this.drawObject(args.value["canvas"], args.value["obj"], args.value["isCropRatio"], args.value["points"], args.value["isPreventDrag"], args.value["saveContext"], args.value["isPreventSelection"]);
          break;
        case "updateActiveObject":
          this.updateActiveObject(args.value["actPoint"], args.value["obj"], args.value["isMouseMove"], args.value["x"], args.value["y"]);
          break;
        case "clearOuterCanvas":
          this.clearOuterCanvas(args.value["context"]);
          break;
        case "setDestPoints":
          this.setDestPoints();
          break;
        case "updateCurrTransState":
          this.updateCurrTransState(args.value["type"], args.value["isPreventDestination"], args.value["isRotatePan"]);
          break;
        case "currTransState":
          this.currTransState(args.value["type"], args.value["isPreventDestination"], args.value["context"], args.value["isPreventCircleCrop"]);
          break;
        case "setTransform":
          this.setTransform(args.value["context"], args.value["value"], args.value["isReverse"]);
          break;
        case "render-image":
          this.renderImage(args.value["isMouseWheel"], args.value["isPreventClearRect"], args.value["isFrame"], args.value["isStraighten"]);
          break;
        case "draw-image-to-canvas":
          this.drawImgToCanvas(args.value["dimension"]);
          break;
        case "update-canvas":
          this.updateCanvas();
          break;
        case "performCancel":
          this.performCancel(args.value["isContextualToolbar"], args.value["isUndoRedo"], args.value["isFinalCancel"]);
          break;
        case "updateFlipPan":
          this.updateFlipPan(args.value["tempSelectionObj"]);
          break;
        case "select":
          this.select(args.value["type"], args.value["startX"], args.value["startY"], args.value["width"], args.value["height"]);
          break;
        case "callUpdateCurrTransState":
          this.callUpdateCurrTransState();
          break;
        case "resetPanPoints":
          this.resetPanPoints();
          break;
        case "setClientTransDim":
          this.setClientTransDim(args.value["isPreventDimension"]);
          break;
        case "redrawImgWithObj":
          this.redrawImgWithObj();
          break;
        case "setCurrentObj":
          this.setCurrentObj(args.value["obj"], args.value["isUndoRedo"]);
          break;
        case "performPointZoom":
          this.performPointZoom(args.value["x"], args.value["y"], args.value["type"], args.value["isResize"]);
          break;
        case "open":
          this.open(args.value["data"]);
          break;
        case "isInitialLoading":
          this.isInitialLoading = args.value["isInitialLoading"];
          break;
        case "isInitialLoaded":
          this.getInitialLoaded(args.value["object"]);
          break;
        case "fileSelect":
          this.fileSelect(args.value["inputElement"], args.value["args"]);
          break;
        case "getFileName":
          args.value["obj"]["fileName"] = this.fileName;
          args.value["obj"]["fileType"] = this.fileType;
          break;
        case "getErrorImage":
          args.value["obj"]["isErrorImage"] = this.isErrorImage;
          break;
        case "getInitialZoomValue":
          args.value["obj"]["initialZoomValue"] = this.initZoomValue;
          break;
        case "setShapeTextInsert":
          this.isShapeTextInserted = args.value["bool"];
          break;
        case "resetCurrentSelectionPoint":
          this.currSelPoint = null;
          break;
        case "setRotateZoom":
          this.isRotateZoom = args.value["isRotateZoom"];
          break;
        case "setTempStrokeSettings":
          this.tempStrokeSettings = args.value["tempStrokeSettings"];
          break;
        case "setTempTextSettings":
          this.tempTextSettings = args.value["tempTextSettings"];
          break;
        case "setTempAdjustmentValue":
          this.tempAdjValue = args.value["tempAdjustmentValue"];
          break;
        case "getTempAdjustmentValue":
          args.value["obj"]["value"] = this.tempAdjValue;
          break;
        case "setTempFilter":
          this.tempFilter = args.value["tempFilter"];
          break;
        case "setTempUndoRedoStep":
          this.tempUndoRedoStep = args.value["tempUndoRedoStep"];
          break;
        case "setTempFreehandCounter":
          this.tempFreehandCounter = args.value["tempFreehandCounter"];
          break;
        case "setTempCurrentFreehandDrawIndex":
          this.tempCurrFhdIndex = args.value["tempCurrentFreehandDrawIndex"];
          break;
        case "setTempZoomFactor":
          this.tempZoomFactor = args.value["tempZoomFactor"];
          break;
        case "setCancelAction":
          this.isCancelAction = args.value["bool"];
          break;
        case "getRotatedFlipCropSelection":
          args.value["bool"]["isSelected"] = this.rotatedFlipCropSel;
          break;
        case "getPrevActObj":
          args.value["obj"]["prevActObj"] = this.prevActObj;
          break;
        case "setPrevActObj":
          this.prevActObj = args.value["prevActObj"];
          break;
        case "setZoomCropWidth":
          this.zoomCrop.width = args.value["width"];
          this.zoomCrop.height = args.value["height"];
          break;
        case "setImageEdited":
          this.isImageEdited = true;
          break;
        case "reset":
          this.reset();
          break;
        case "setNewPath":
          this.isNewPath = args.value["bool"];
          break;
        case "getNewPath":
          args.value["obj"]["isNewPath"] = this.isNewPath;
          break;
        case "getArrowDimension":
          args.value["obj"]["arrowDimension"] = extend({}, this.arrowDimension, {}, true);
          break;
        case "setArrowDimension":
          this.arrowDimension = args.value["arrowDimension"];
          break;
        case "moveToSelectionRange":
          this.moveToSelectionRange(args.value["type"], args.value["activeObj"]);
          break;
        case "setResizeSelect":
          this.isResizeSelect = args.value["bool"];
          break;
        case "applyFrame":
          this.applyFrame(args.value["ctx"], args.value["frame"], args.value["preventImg"]);
          break;
        case "drawImage":
          this.drawImage();
          break;
        case "downScaleImgCanvas":
          this.downScaleImgCanvas(args.value["ctx"], args.value["isImgAnnotation"], args.value["isHFlip"], args.value["isVFlip"]);
          break;
        case "downScale":
          this.downScale(args.value["canvas"], args.value["width"], args.value["height"]);
          break;
        case "resetFrameZoom":
          this.resetFrameZoom(args.value["isOk"]);
          break;
        case "triggerFrameChange":
          args.value["obj"]["frameChangeEventArgs"] = this.triggerFrameChange(args.value["prevFrameSettings"]);
          break;
        case "setImageApply":
          this.isImageApply = args.value["bool"];
          break;
        case "zoomToSel":
          this.zoomToSel(args.value["activeObj"], args.value["isToolbar"]);
          break;
        case "getStraightenActObj":
          args.value["obj"]["activeObj"] = this.straightenActObj;
          break;
        case "setStraightenActObj":
          this.straightenActObj = args.value["activeObj"];
          break;
        case "updateImgCanvasPoints":
          this.updateImgCanvasPoints();
          break;
        case "isLinesIntersect":
          args.value["obj"]["isIntersect"] = this.isLinesIntersect(args.value["obj"]);
          break;
        case "getImageCanvasPoints":
          args.value["obj"]["points"] = this.imgCanvasPoints;
          break;
        case "setDestForStraighten":
          this.setDestForStraighten();
          break;
        case "setTempDestForStraighten":
          this.tempStraightenDestPoints = extend({}, this.straightenDestPoints, {}, true);
          break;
        case "getStraightenInitZoom":
          args.value["obj"]["zoomFactor"] = this.straightenInitZoom;
          break;
        case "setStraightenInitZoom":
          this.straightenInitZoom = args.value["zoomFactor"];
          break;
        case "isPointsInsideImg":
          args.value["obj"]["bool"] = this.checkPointPosition(args.value["x"], args.value["y"], this.imgCanvasPoints[0].x, this.imgCanvasPoints[0].y, this.imgCanvasPoints[1].x, this.imgCanvasPoints[1].y, this.imgCanvasPoints[2].x, this.imgCanvasPoints[2].y, this.imgCanvasPoints[3].x, this.imgCanvasPoints[3].y) !== "inside";
          break;
        case "setIsCropSelect":
          this.isCropSelect = args.value["bool"];
          break;
        case "updateCropSelection":
          this.updateCropSelection();
          break;
        case "updateCropSelObj":
          this.updateCropSelObj();
          break;
        case "redrawDownScale":
          this.redrawDownScale();
          break;
        case "updateFinetune":
          this.updateFinetune();
          break;
        case "isSelOutsideImg":
          args.value["obj"]["bool"] = this.isSelOutsideImg();
          break;
        case "resetStraightenDestPoints":
          this.straightenDestPoints = null;
          break;
        case "checkPointPosition":
          args.value["obj"]["position"] = this.checkPointPosition(args.value["obj"]["x"], args.value["obj"]["y"], args.value["obj"]["x1"], args.value["obj"]["y1"], args.value["obj"]["x2"], args.value["obj"]["y2"], args.value["obj"]["x3"], args.value["obj"]["y3"], args.value["obj"]["x4"], args.value["obj"]["y4"]);
          break;
        case "updateTempObjColl":
          this.tempObjColl = extend([], this.parent.objColl, [], true);
          break;
        case "resetTempObjColl":
          this.tempObjColl = null;
          break;
        case "updateTempPointColl":
          this.tempPointColl = extend({}, this.parent.pointColl, {}, true);
          break;
        case "resetTempPointColl":
          this.tempPointColl = {};
          break;
      }
    };
    Draw2.prototype.getModuleName = function() {
      return "draw";
    };
    Draw2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (isNullOrUndefined(this.tempZoomFactor)) {
        this.tempZoomFactor = parent.transform.zoomFactor;
      }
      if (this.tempTextSettings.fontFamily === "") {
        this.tempTextSettings.fontFamily = parent.fontFamily.default;
      }
    };
    Draw2.prototype.reset = function() {
      this.isInitialLoading = this.isErrorImage = this.isNewPath = this.isResizeSelect = false;
      this.isShapeTextInserted = false;
      this.isImageApply = false;
      this.initZoomValue = null;
      this.tempFilter = "";
      this.origDim = { width: 0, height: 0 };
      this.currSelPoint = null;
      this.isRotateZoom = false;
      this.tempAdjValue = "";
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
      this.tempTextSettings = { text: "Enter Text", fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.tempUndoRedoStep = this.tempFreehandCounter = this.tempCurrFhdIndex = 0;
      this.tempZoomFactor = null;
      this.isCancelAction = false;
      this.rotatedFlipCropSel = false;
      this.prevActObj = null;
      this.tempStraightenDestPoints = null;
      this.arrowDimension = {
        bar: { width: 10, height: 32, ratioX: null, ratioY: null },
        arrow: { width: 24, height: 24, ratioX: null, ratioY: null },
        arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
        circle: { width: 10, height: 10, ratioX: null, ratioY: null },
        square: { width: 20, height: 20, ratioX: null, ratioY: null }
      };
      this.straightenActObj = null;
      this.imgCanvasPoints = [];
      this.straightenInitZoom = null;
      this.tempObjColl = [];
      this.tempPointColl = {};
      this.straightenDestPoints = null;
      this.isCropSelect = this.isDownScale = this.preventStraightening = false;
    };
    Draw2.prototype.redrawDownScale = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.isDownScale = true;
        this.renderImage();
        this.isDownScale = false;
        if (activeObj.shape) {
          this.drawObject("duplicate", activeObj);
        }
      }
    };
    Draw2.prototype.updateFinetune = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
        var filter = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("draw", { prop: "redrawDownScale" });
        var inMemoryContext = parent.inMemoryCanvas.getContext("2d");
        var ctx = this.lowerContext;
        var imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        parent.inMemoryCanvas.width = imageData.width;
        parent.inMemoryCanvas.height = imageData.height;
        inMemoryContext.putImageData(imageData, 0, 0);
        this.lowerContext.filter = filter;
        parent.notify("draw", { prop: "redrawDownScale" });
      }
    };
    Draw2.prototype.drawImage = function() {
      this.applyFrame(this.lowerContext, this.parent.frameObj.type);
    };
    Draw2.prototype.drawObject = function(canvas, obj, isCropRatio, points, isPreventDrag, saveContext, isPreventSelection) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var actPoint = parent.activeObj.activePoint;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      var canvasDraw;
      canvas = canvas.toLowerCase();
      if (canvas === "original") {
        canvasDraw = this.lowerContext;
      } else if (canvas === "duplicate") {
        canvasDraw = this.upperContext;
      } else if (saveContext) {
        canvasDraw = saveContext;
      }
      if (!isPreventDrag && actObj.shape) {
        this.setDragLimit();
      }
      if (parent.currObjType.shape) {
        var splitWords = parent.currObjType.shape.split("-");
        if (splitWords[0].toLowerCase() === "crop" && isCropRatio) {
          this.drawCropRatio();
        }
      }
      actObj = parent.activeObj;
      actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(actObj.strokeSettings)) {
        var obj_1 = { strokeSettings: {} };
        parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj: obj_1 } });
        actObj.strokeSettings = obj_1["strokeSettings"];
      }
      if (isNullOrUndefined(actObj.strokeSettings.strokeWidth)) {
        actObj.strokeSettings.strokeWidth = 2;
      }
      if (obj) {
        parent.activeObj = extend({}, obj, {}, true);
      }
      if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
        actPoint.startX = points.startX;
        actPoint.startY = points.startY;
        actPoint.endX = points.endX;
        actPoint.endY = points.endY;
        actPoint.width = points.width;
        actPoint.height = points.height;
      }
      this.updateActiveObject();
      actObj = parent.activeObj;
      actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(actPoint.startX) && isNullOrUndefined(actPoint.startY)) {
        return;
      }
      if (parent.currObjType.isText) {
        var obj_2 = { keyHistory: "" };
        parent.notify("shape", { prop: "getKeyHistory", onPropertyChange: false, value: { obj: obj_2 } });
        actObj.keyHistory = obj_2["keyHistory"];
      }
      var isCrop = false;
      if (canvas !== "original") {
        var splitWords = void 0;
        if (actObj.shape) {
          splitWords = actObj.shape.split("-");
          if (splitWords[0] === "crop") {
            isCrop = true;
          }
        }
        if (isCrop) {
          if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
            actPoint.startX = points.startX;
            actPoint.startY = points.startY;
            actPoint.endX = points.endX;
            actPoint.endY = points.endY;
            actPoint.width = points.width;
            actPoint.height = points.height;
          } else {
            actPoint = actObj.activePoint;
          }
          this.upperContext.fillStyle = "rgb(0, 0, 0, 0.25)";
          this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
          this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
        }
        if (isNullOrUndefined(isPreventSelection) && (canvasDraw === this.lowerContext || canvasDraw === this.upperContext)) {
          this.rotateContext("initial", canvasDraw);
          this.drawOuterSelection(canvasDraw);
          this.rotateContext("reverse", canvasDraw);
        }
      }
      parent.currObjType.isActiveObj = true;
      var object = { keyHistory: "" };
      parent.notify("shape", { prop: "getKeyHistory", onPropertyChange: false, value: { obj: object } });
      if (obj) {
        this.drawShapeObj(canvas, obj.shape, saveContext, isPreventSelection);
      } else if (object["keyHistory"] !== "" && parent.currObjType.isText) {
        this.drawShapeObj(canvas, "text", saveContext, isPreventSelection);
      } else if (actObj.shape) {
        this.drawShapeObj(canvas, actObj.shape, saveContext, isPreventSelection);
      } else {
        this.drawShapeObj(canvas, void 0, saveContext, isPreventSelection);
      }
      if (canvas === "duplicate" && isCrop && actObj.shape !== "crop-circle" && parent.frameObj.type !== "none") {
        this.applyFrame(this.upperContext, parent.frameObj.type);
        this.drawCornerCircles(this.upperContext);
      }
    };
    Draw2.prototype.rotateContext = function(type, ctx) {
      var parent = this.parent;
      var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
      var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
      var _c = parent.activeObj.activePoint, startX = _c.startX, startY = _c.startY, width = _c.width, height = _c.height;
      if (shape === "line" || shape === "arrow") {
        return;
      }
      var rotationAngle = type === "initial" ? rotatedAngle : -rotatedAngle;
      var translateX;
      var translateY;
      if (parent.transform.straighten === 0 && !parent.isCropTab) {
        translateX = startX + width / 2;
        translateY = startY + height / 2;
      } else {
        translateX = destLeft + destWidth / 2;
        translateY = destTop + destHeight / 2;
      }
      ctx.translate(translateX, translateY);
      ctx.rotate(rotationAngle);
      ctx.translate(-translateX, -translateY);
    };
    Draw2.prototype.setDragLimit = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
      if (actPoint && shape !== "image" && shape !== "line" && rotatedAngle === 0) {
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        if (actPoint.startX < destLeft) {
          actPoint.startX = destLeft;
          actPoint.endX = Math.min(actPoint.startX + actPoint.width, destLeft + destWidth);
        } else if (actPoint.endX > destLeft + destWidth) {
          actPoint.endX = destLeft + destWidth;
          actPoint.startX = Math.max(actPoint.endX - actPoint.width, destLeft);
        }
        if (actPoint.startY < destTop) {
          actPoint.startY = destTop;
        } else if (actPoint.endY > destTop + destHeight) {
          actPoint.endY = destTop + destHeight;
          actPoint.startY = Math.max(actPoint.endY - actPoint.height, destTop);
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
      }
    };
    Draw2.prototype.drawCropRatio = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var x;
      var y;
      var width;
      var height;
      var canvasWidth = parent.lowerCanvas.clientWidth;
      var canvasHeight = parent.lowerCanvas.clientHeight + 1;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.transform.zoomFactor > 0 && this.currSelPoint) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        this.drawCustomSelection("crop-custom", null, null, null, null);
        if (parent.transform.straighten !== 0) {
          actPoint = parent.activeObj.activePoint;
        }
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
          width = actPoint.width < actPoint.height ? actPoint.width : actPoint.height;
          height = width;
        } else {
          if (destLeft + destLeft + destWidth <= canvasWidth) {
            width = actPoint.width;
          } else {
            width = parent.transform.straighten === 0 ? canvasWidth - destLeft : actPoint.width;
          }
          if (destTop + destTop + destHeight <= canvasHeight) {
            height = actPoint.height;
          } else {
            height = parent.transform.straighten === 0 ? canvasHeight - destTop : actPoint.height;
          }
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.activeObj = activeObj;
        parent.currObjType.shape = activeObj.shape;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.isCustomCrop = false;
      } else {
        width = destWidth;
        height = destHeight;
        if (destLeft < 0) {
          width += destLeft;
        }
        if (destTop < 0) {
          height += destTop;
        }
        if (destLeft + destWidth > parent.lowerCanvas.width) {
          width -= destLeft + destWidth - parent.lowerCanvas.width;
        }
        if (destTop + destHeight > parent.lowerCanvas.height) {
          height -= destTop + destHeight - parent.lowerCanvas.height;
        }
      }
      switch (parent.currObjType.shape.toLowerCase()) {
        case "crop-square":
        case "crop-circle":
          parent.notify("selection", { prop: "setDragDirection", onPropertyChange: false, value: { width, height } });
          actPoint = parent.activeObj.activePoint;
          if (parent.lowerCanvas.width < actPoint.endX - actPoint.startX) {
            actPoint.startX = 7.5;
            actPoint.endX = parent.lowerCanvas.width - 7.5;
          }
          if (parent.lowerCanvas.height < actPoint.endY - actPoint.startY) {
            actPoint.startY = 7.5;
            actPoint.endY = parent.lowerCanvas.height - 7.5;
          }
          if (width === destWidth && height === destHeight) {
            actPoint.startX += destLeft;
            actPoint.startY += destTop;
            actPoint.endX += destLeft;
            actPoint.endY += destTop;
          }
          if (parent.lowerCanvas.width > parent.lowerCanvas.height) {
            actPoint.height = actPoint.endY - actPoint.startY;
            actPoint.width = actPoint.height;
            actPoint.endX = actPoint.startX + actPoint.width;
          } else {
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.width;
            actPoint.endY = actPoint.startY + actPoint.height;
          }
          break;
        case "crop-3:2":
          x = 3;
          y = 2;
          break;
        case "crop-4:3":
          x = 4;
          y = 3;
          break;
        case "crop-5:4":
          x = 5;
          y = 4;
          break;
        case "crop-7:5":
          x = 7;
          y = 5;
          break;
        case "crop-16:9":
          x = 16;
          y = 9;
          break;
        case "crop-2:3":
          x = 2;
          y = 3;
          break;
        case "crop-3:4":
          x = 3;
          y = 4;
          break;
        case "crop-4:5":
          x = 4;
          y = 5;
          break;
        case "crop-5:7":
          x = 5;
          y = 7;
          break;
        case "crop-9:16":
          x = 9;
          y = 16;
          break;
        default:
          x = parseInt(parent.currObjType.shape.toLowerCase().split("crop-")[1].split(":")[0]);
          y = parseInt(parent.currObjType.shape.toLowerCase().split("crop-")[1].split(":")[1]);
          break;
      }
      if (x !== void 0 && y !== void 0) {
        parent.notify("selection", {
          prop: "calcShapeRatio",
          onPropertyChange: false,
          value: { x, y, imgWidth: width, imgHeight: height }
        });
        if (width === destWidth && height === destHeight) {
          this.updatePoints();
        }
        actPoint = parent.activeObj.activePoint;
      }
      if (actPoint.startX < destLeft) {
        var diff = destLeft - actPoint.startX + 7.5;
        actPoint.startX += diff;
        actPoint.endX += diff;
      }
      if (actPoint.startY < destTop) {
        var diff = destTop - actPoint.startY + 7.5;
        actPoint.startY += diff;
        actPoint.endY += diff;
      }
      parent.activeObj = this.updateWidthHeight(parent.activeObj);
      this.adjToCenter();
      this.enlargeToImg();
      if (parent.transform.straighten !== 0) {
        this.adjToStraighten();
        this.updateActiveObject(parent.activeObj.activePoint, parent.activeObj);
      }
      var object = { isIntersect: null, arr: null };
      var count = 0;
      actPoint = parent.activeObj.activePoint;
      if (parent.transform.straighten !== 0) {
        while (this.isLinesIntersect(object) && count < 100) {
          count++;
          var diff = actPoint.width * 1 / 100;
          actPoint.startX += diff;
          actPoint.endX -= diff;
          diff = actPoint.height * 1 / 100;
          actPoint.startY += diff;
          actPoint.endY -= diff;
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.updateActiveObject(actPoint, parent.activeObj);
        }
      }
      this.straightenInitZoom = parent.transform.zoomFactor;
      this.straightenActObj = extend({}, parent.activeObj, {}, true);
      parent.notify("draw", { prop: "resetStraightenDestPoints" });
      parent.notify("draw", { prop: "setDestForStraighten" });
    };
    Draw2.prototype.adjToCenter = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var diffX = parent.lowerCanvas.width / 2 - (actPoint.endX - actPoint.width / 2);
      var diffY = parent.lowerCanvas.height / 2 - (actPoint.endY - actPoint.height / 2);
      actPoint.startX += diffX;
      actPoint.endX += diffX;
      actPoint.startY += diffY;
      actPoint.endY += diffY;
      if (actPoint.startX < (destLeft >= 7.5 ? destLeft : 7.5)) {
        var diff = (destLeft >= 7.5 ? destLeft : 0) - actPoint.startX;
        actPoint.startX += diff;
        actPoint.endX += diff;
      } else if (actPoint.endX > destLeft + destWidth) {
        var diff = actPoint.endX - (destLeft + destWidth);
        actPoint.startX -= diff;
        actPoint.endX -= diff;
      }
      if (actPoint.startY < (destTop >= 7.5 ? destTop : 7.5)) {
        var diff = (destTop >= 7.5 ? destTop : 0) - actPoint.startY;
        actPoint.startY += diff;
        actPoint.endY += diff;
      } else if (actPoint.endY > destTop + destHeight) {
        var diff = actPoint.endY - (destTop + destHeight);
        actPoint.startY -= diff;
        actPoint.endY -= diff;
      }
    };
    Draw2.prototype.enlargeToImg = function() {
      var parent = this.parent;
      if (parent.transform.straighten === 0) {
        return;
      }
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        var actPoint = parent.activeObj.activePoint;
        var tempActPoint = extend({}, actPoint, {}, true);
        var count = 0;
        while (true) {
          count++;
          var diff = actPoint.width * 5 / 100;
          actPoint.startX -= diff;
          actPoint.endX += diff;
          diff = actPoint.height * 5 / 100;
          actPoint.startY -= diff;
          actPoint.endY += diff;
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.updateActiveObject(actPoint, parent.activeObj);
          var object = { isIntersect: null, arr: null };
          this.updateImgCanvasPoints();
          this.isLinesIntersect(object);
          if (object["arr"][0] || object["arr"][1] || object["arr"][2] || object["arr"][3] || actPoint.startX < 7.5 || actPoint.startY < 7.5 || count === 100) {
            actPoint = extend({}, tempActPoint, {}, true);
            diff = actPoint.width * 1 / 100;
            actPoint.startX += diff;
            actPoint.endX -= diff;
            diff = actPoint.height * 1 / 100;
            actPoint.startY += diff;
            actPoint.endY -= diff;
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            this.updateActiveObject(actPoint, parent.activeObj);
            break;
          }
          tempActPoint = extend({}, actPoint, {}, true);
        }
      }
    };
    Draw2.prototype.updateActiveObject = function(actPoint, obj, isMouseMove, x, y) {
      var parent = this.parent;
      actPoint = actPoint ? actPoint : extend({}, parent.activeObj.activePoint, {}, true);
      obj = obj ? obj : extend({}, parent.activeObj, {}, true);
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      var startX = actPoint.startX, startY = actPoint.startY, endX = actPoint.endX, endY = actPoint.endY, width = actPoint.width, height = actPoint.height;
      x = x ? x : 0;
      y = y ? y : 0;
      var horCircleWidth = width / 2;
      var verCircleHeight = height / 2;
      var radius = 7.5;
      obj.horTopLine = {
        startX: startX + x,
        startY: startY - y,
        endX: endX + x,
        endY: endY + y
      };
      obj.horBottomLine = {
        startX: startX - x,
        startY: endY - y,
        endX: endX - x,
        endY: endY + y
      };
      obj.verLeftLine = {
        startX: startX + x,
        startY: startY - y,
        endX: startX - y,
        endY: endY - y
      };
      obj.verRightLine = {
        startX: endX + x,
        startY: startY + y,
        endX: endX - x,
        endY: endY + y
      };
      obj.topLeftCircle = {
        startX,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.topCenterCircle = {
        startX: startX + horCircleWidth,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.topRightCircle = {
        startX: endX,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.centerLeftCircle = {
        startX,
        startY: startY + verCircleHeight,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.centerRightCircle = {
        startX: endX,
        startY: startY + verCircleHeight,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomLeftCircle = {
        startX,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomCenterCircle = {
        startX: startX + horCircleWidth,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomRightCircle = {
        startX: endX,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      if (obj.rotatedAngle === 0) {
        obj.rotationCirclePoint = {
          x: obj.bottomCenterCircle.startX,
          y: obj.bottomCenterCircle.startY + 25
        };
        obj.rotationCirclePoint.ratioX = (obj.rotationCirclePoint.x - parent.img.destLeft) / parent.img.destWidth;
        obj.rotationCirclePoint.ratioY = (obj.rotationCirclePoint.y - parent.img.destTop) / parent.img.destHeight;
      }
      obj.activePoint = actPoint;
      if (isNullOrUndefined(isMouseMove)) {
        parent.activeObj = extend({}, obj, {}, true);
      }
    };
    Draw2.prototype.drawOuterSelection = function(canvasDraw, isCropCircle) {
      var splitWords;
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      canvasDraw.lineWidth = 0.5;
      var tempObj = extend({}, actObj, {}, true);
      if (actObj.shape) {
        splitWords = actObj.shape.split("-");
      }
      if ((splitWords && splitWords[0] === "crop" || actObj.shape === void 0) && !isCropCircle) {
        this.upperContext.fillStyle = "rgb(0, 0, 0, 0.25)";
        this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
      }
      canvasDraw.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      canvasDraw.fillStyle = parent.themeColl[parent.theme]["secondaryColor"];
      var degree;
      if (tempObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - tempObj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (actObj.shape === "arrow" || actObj.shape === "line") {
        canvasDraw.beginPath();
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.lineTo(actPoint.endX, actPoint.endY);
        canvasDraw.stroke();
      } else if (actObj.shape === "path") {
        canvasDraw.beginPath();
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (activeObj.pointColl[0]) {
          canvasDraw.moveTo(activeObj.pointColl[0].x, activeObj.pointColl[0].y);
          if (activeObj.pointColl.length > 1) {
            for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
              actPoint.endX = activeObj.pointColl[i].x;
              actPoint.endY = activeObj.pointColl[i].y;
              canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            }
          }
        }
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          parent.activeObj = actObj = activeObj;
        }
        canvasDraw.lineTo(actPoint.endX, actPoint.endY);
        canvasDraw.stroke();
      } else {
        this.drawCornerCircles(canvasDraw);
      }
      if (parent.selectionSettings.showCircle && (splitWords === void 0 || splitWords[0] !== "crop")) {
        var strokeColor = canvasDraw.strokeStyle;
        var fillColor = canvasDraw.fillStyle;
        canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
        canvasDraw.fillStyle = parent.selectionSettings.fillColor;
        if (actObj.shape === "text") {
          canvasDraw.lineWidth *= 2;
          canvasDraw.beginPath();
          this.drawRotationArcLine(canvasDraw);
          canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
          canvasDraw.stroke();
          canvasDraw.fill();
          canvasDraw.closePath();
          canvasDraw.beginPath();
          canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
          canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
          canvasDraw.stroke();
          canvasDraw.fill();
          canvasDraw.closePath();
          canvasDraw.lineWidth /= 2;
        } else {
          this.drawCenterCircles(canvasDraw);
        }
        canvasDraw.strokeStyle = strokeColor;
        canvasDraw.fillStyle = fillColor;
      }
      tempObj.rotationCircleLine = actObj.rotationCircleLine;
      parent.activeObj = extend({}, tempObj, {}, true);
    };
    Draw2.prototype.drawArrowHead = function(canvasDraw, isStartHead) {
      var headType = isStartHead ? this.parent.activeObj.start : this.parent.activeObj.end;
      switch (headType) {
        case "arrowSolid":
          isStartHead ? this.arrowSolid(canvasDraw, true) : this.arrowSolid(canvasDraw, false);
          break;
        case "arrow":
          isStartHead ? this.arrow(canvasDraw, true) : this.arrow(canvasDraw, false);
          break;
        case "circleSolid":
          isStartHead ? this.arrowCircleSolid(canvasDraw, true) : this.arrowCircleSolid(canvasDraw, false);
          break;
        case "circle":
          isStartHead ? this.arrowCircle(canvasDraw, true) : this.arrowCircle(canvasDraw, false);
          break;
        case "bar":
          isStartHead ? this.arrowBar(canvasDraw, true) : this.arrowBar(canvasDraw, false);
          break;
        case "square":
        case "squareSolid":
          isStartHead ? this.arrowSquareStart(canvasDraw) : this.arrowSquareEnd(canvasDraw);
          break;
      }
    };
    Draw2.prototype.drawShapeObj = function(canvas, shape, saveContext, isPreventSelection) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      var _a = actObj.strokeSettings, strokeColor = _a.strokeColor, fillColor = _a.fillColor, strokeWidth = _a.strokeWidth;
      var currentShape = shape !== void 0 ? shape : parent.currObjType.shape;
      parent.currObjType.shape = currentShape;
      var canvasDraw;
      if (canvas.toLowerCase() === "original") {
        canvasDraw = this.lowerContext;
      } else if (canvas.toLowerCase() === "duplicate") {
        canvasDraw = this.upperContext;
      } else if (saveContext) {
        canvasDraw = saveContext;
      }
      var shapeType = parent.currObjType.shape.toLowerCase();
      var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "image"];
      if (shapeColl.indexOf(shapeType) !== -1) {
        actObj.shape = parent.currObjType.shape;
      }
      canvasDraw.strokeStyle = strokeColor;
      if (shape === "text" || shape === "freehanddraw") {
        canvasDraw.fillStyle = strokeColor;
      } else {
        canvasDraw.fillStyle = fillColor;
      }
      var horLineWidth = actPoint.width / 3;
      var verLineHeight = actPoint.height / 3;
      var selectionWidth = actPoint.endX - actPoint.startX;
      var selectionHeight = actPoint.endY - actPoint.startY;
      this.rotateContext("initial", canvasDraw);
      var degree;
      var tempFillStyle = canvasDraw.fillStyle;
      var activeObj;
      switch (parent.currObjType.shape.toLowerCase()) {
        case "rectangle":
          this.drawSquareLines(canvasDraw);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "ellipse":
          selectionWidth = Math.abs(selectionWidth);
          selectionHeight = Math.abs(selectionHeight);
          canvasDraw.beginPath();
          canvasDraw.ellipse(actPoint.startX + selectionWidth / 2, actPoint.startY + selectionHeight / 2, selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
          if (fillColor !== "") {
            canvasDraw.fillStyle = fillColor;
            canvasDraw.fill();
          }
          canvasDraw.ellipse(actPoint.startX + selectionWidth / 2, actPoint.startY + selectionHeight / 2, Math.abs(selectionWidth / 2 - strokeWidth), Math.abs(selectionHeight / 2 - strokeWidth), 0, 0, 2 * Math.PI, false);
          canvasDraw.fillStyle = strokeColor;
          canvasDraw.fill("evenodd");
          canvasDraw.closePath();
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "crop-circle":
          if (canvasDraw === this.lowerContext) {
            canvasDraw = this.upperContext;
          }
          this.shapeCircle(canvasDraw, selectionWidth, selectionHeight);
          break;
        case "line":
          this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "arrow":
          if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
          } else {
            degree = parent.transform.degree - actObj.shapeDegree;
          }
          if (degree < 0) {
            degree = 360 + degree;
          }
          canvasDraw.fillStyle = canvasDraw.strokeStyle;
          if (isNullOrUndefined(actObj.triangleDirection)) {
            actObj.triangleDirection = "right";
          }
          if (isNullOrUndefined(actObj.start)) {
            actObj.start = "none";
          }
          if (isNullOrUndefined(actObj.end)) {
            actObj.end = "arrowSolid";
          }
          this.drawArrowHead(canvasDraw, true);
          this.drawArrowHead(canvasDraw, false);
          if (actObj.end === "none") {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          }
          canvasDraw.fillStyle = tempFillStyle;
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "path":
          activeObj = extend({}, parent.activeObj, {}, true);
          if (activeObj.pointColl.length > 1) {
            var obj = { shape: null };
            parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
            if (obj["shape"] === "path") {
              var nextPoint = { x: 0, y: 0 };
              for (var i = 0, len = activeObj.pointColl.length; i < len; i++) {
                if (isNullOrUndefined(activeObj.pointColl[i + 1])) {
                  nextPoint.x = activeObj.activePoint.endX;
                  nextPoint.y = activeObj.activePoint.endY;
                } else {
                  nextPoint.x = activeObj.pointColl[i + 1].x;
                  nextPoint.y = activeObj.pointColl[i + 1].y;
                }
                actPoint.startX = activeObj.pointColl[i].x;
                actPoint.startY = activeObj.pointColl[i].y;
                actPoint.endX = nextPoint.x;
                actPoint.endY = nextPoint.y;
                parent.activeObj = this.updateWidthHeight(parent.activeObj);
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
              }
            } else {
              for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
                actPoint.startX = activeObj.pointColl[i - 1].x;
                actPoint.startY = activeObj.pointColl[i - 1].y;
                actPoint.endX = activeObj.pointColl[i].x;
                actPoint.endY = activeObj.pointColl[i].y;
                parent.activeObj = this.updateWidthHeight(parent.activeObj);
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
              }
            }
            parent.activeObj = actObj = activeObj;
          } else {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          }
          if (canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "text":
          this.shapeText(canvasDraw);
          break;
        case "image":
          this.shapeImage(canvasDraw);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "crop-square":
        case "crop-3:4":
        case "crop-4:3":
        case "crop-6:9":
        case "crop-9:6":
        case "crop-9:16":
        case "crop-16:9":
          if (canvasDraw === this.lowerContext) {
            canvasDraw = this.upperContext;
          }
          this.drawSelection(horLineWidth, verLineHeight);
          parent.currObjType.shape = "";
          break;
        default:
          this.drawSelection(horLineWidth, verLineHeight);
          break;
      }
      this.rotateContext("reverse", canvasDraw);
    };
    Draw2.prototype.updatePoints = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
      actPoint.startX += destLeft;
      actPoint.startY += destTop;
      actPoint.endX += destLeft;
      actPoint.endY += destTop;
      parent.activeObj = this.updateWidthHeight(parent.activeObj);
    };
    Draw2.prototype.updateWidthHeight = function(obj) {
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      obj.activePoint.width = endX - startX;
      obj.activePoint.height = endY - startY;
      return obj;
    };
    Draw2.prototype.drawCornerCircles = function(canvasDraw) {
      var parent = this.parent;
      var tempObj = parent.activeObj;
      canvasDraw.beginPath();
      canvasDraw.rect(tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height);
      canvasDraw.stroke();
      canvasDraw.closePath();
      if (parent.selectionSettings.showCircle) {
        var strokeColor = canvasDraw.strokeStyle;
        var fillColor = canvasDraw.fillStyle;
        canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
        canvasDraw.fillStyle = parent.selectionSettings.fillColor;
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        canvasDraw.moveTo(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY);
        canvasDraw.arc(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY, tempObj.topLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY);
        canvasDraw.arc(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY, tempObj.topRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY);
        canvasDraw.arc(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY, tempObj.bottomLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY);
        canvasDraw.arc(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY, tempObj.bottomRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        canvasDraw.lineWidth /= 2;
        canvasDraw.strokeStyle = strokeColor;
        canvasDraw.fillStyle = fillColor;
      }
    };
    Draw2.prototype.drawCenterCircles = function(canvasDraw) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      canvasDraw.lineWidth *= 2;
      canvasDraw.beginPath();
      if (actObj.shape === "arrow" || actObj.shape === "line") {
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(actPoint.endX, actPoint.endY);
        canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
      } else if (actObj.shape === "path") {
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (activeObj.pointColl.length > 1) {
          for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
            actPoint.startX = activeObj.pointColl[i - 1].x;
            actPoint.startY = activeObj.pointColl[i - 1].y;
            actPoint.endX = activeObj.pointColl[i].x;
            actPoint.endY = activeObj.pointColl[i].y;
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
          }
        }
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          parent.activeObj = actObj = activeObj;
        }
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(actPoint.endX, actPoint.endY);
        canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
      } else {
        this.drawRotationArcLine(canvasDraw);
        canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
      }
      canvasDraw.stroke();
      canvasDraw.fill();
      canvasDraw.closePath();
      if (actObj.shape !== "arrow" && actObj.shape !== "line" && actObj.shape !== "path") {
        canvasDraw.beginPath();
        canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
        canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
      }
      canvasDraw.lineWidth /= 2;
    };
    Draw2.prototype.drawRotationArcLine = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      if (isNullOrUndefined(actObj.rotationCircleLine)) {
        actObj.rotationCircleLine = 22.5;
      }
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (actObj.flipObjColl) {
        for (var i = 0, len = actObj.flipObjColl.length; i < len; i++) {
          var flipStr = actObj.flipObjColl[i].toLowerCase();
          if (flipStr === "horizontal") {
            isHorizontalflip = true;
          } else if (flipStr === "vertical") {
            isVerticalflip = true;
          }
        }
      }
      switch (degree) {
        case 0:
        case 360:
          if (isVerticalflip) {
            actObj.rotationCirclePoint = {
              x: actObj.topCenterCircle.startX,
              y: actObj.topCenterCircle.startY - actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
          } else {
            actObj.rotationCirclePoint = {
              x: actObj.bottomCenterCircle.startX,
              y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
          }
          break;
        case 90:
        case -270:
          if (isHorizontalflip) {
            actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX + actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          } else {
            actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX - actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          }
          break;
        case 180:
        case -180:
          if (isVerticalflip) {
            actObj.rotationCirclePoint = {
              x: actObj.bottomCenterCircle.startX,
              y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
          } else {
            actObj.rotationCirclePoint = {
              x: actObj.topCenterCircle.startX,
              y: actObj.topCenterCircle.startY - actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
          }
          break;
        case 270:
        case -90:
          if (isHorizontalflip) {
            actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX - actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          } else {
            actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX + actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          }
          break;
      }
    };
    Draw2.prototype.drawSquareLines = function(canvasDraw) {
      var splitWords;
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var _b = actObj.strokeSettings, fillColor = _b.fillColor, strokeColor = _b.strokeColor, strokeWidth = _b.strokeWidth;
      if (actObj.shape) {
        splitWords = actObj.shape.split("-");
      }
      if (splitWords[0] === "crop") {
        canvasDraw.strokeStyle = "#fff";
      } else {
        canvasDraw.strokeStyle = strokeColor;
      }
      canvasDraw.beginPath();
      canvasDraw.rect(startX, startY, width, height);
      if (fillColor !== "") {
        canvasDraw.fillStyle = fillColor;
        canvasDraw.fill();
      }
      canvasDraw.rect(startX + strokeWidth, startY + strokeWidth, width - 2 * strokeWidth, height - 2 * strokeWidth);
      canvasDraw.fillStyle = strokeColor;
      canvasDraw.fill("evenodd");
      canvasDraw.closePath();
    };
    Draw2.prototype.drawSelection = function(horLineWidth, verLineHeight) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      this.upperContext.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      this.upperContext.beginPath();
      actObj.horTopInnerLine = { startX, startY: startY + verLineHeight, endX, endY: endY + verLineHeight };
      actObj.horBottomInnerLine = { startX, startY: startY + 2 * verLineHeight, endX, endY: endY + 2 * verLineHeight };
      actObj.verLeftInnerLine = {
        startX: startX + horLineWidth,
        startY,
        endX: startX + horLineWidth,
        endY
      };
      actObj.verRightInnerLine = {
        startX: startX + 2 * horLineWidth,
        startY,
        endX: startX + 2 * horLineWidth,
        endY
      };
      this.upperContext.moveTo(actObj.horTopInnerLine.startX, actObj.horTopInnerLine.startY);
      this.upperContext.lineTo(actObj.horTopInnerLine.endX, actObj.horTopInnerLine.startY);
      this.upperContext.moveTo(actObj.horBottomInnerLine.startX, actObj.horBottomInnerLine.startY);
      this.upperContext.lineTo(actObj.horBottomInnerLine.endX, actObj.horBottomInnerLine.startY);
      this.upperContext.moveTo(actObj.verLeftInnerLine.startX, actObj.verLeftInnerLine.startY);
      this.upperContext.lineTo(actObj.verLeftInnerLine.endX, actObj.verLeftInnerLine.endY);
      this.upperContext.moveTo(actObj.verRightInnerLine.startX, actObj.verRightInnerLine.startY);
      this.upperContext.lineTo(actObj.verRightInnerLine.endX, actObj.verRightInnerLine.endY);
      this.upperContext.stroke();
      this.upperContext.closePath();
    };
    Draw2.prototype.shapeCircle = function(canvasDraw, selectionWidth, selectionHeight) {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width;
      canvasDraw.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      canvasDraw.fillStyle = "rgb(0, 0, 0, 0.25)";
      canvasDraw.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var tempWidth = canvasDraw.lineWidth;
      canvasDraw.lineWidth = 2;
      canvasDraw.beginPath();
      canvasDraw.ellipse(parent.activeObj.horTopLine.startX + selectionWidth / 2, parent.activeObj.horTopLine.startY + selectionHeight / 2, selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
      canvasDraw.stroke();
      canvasDraw.closePath();
      canvasDraw.save();
      canvasDraw.beginPath();
      canvasDraw.arc((endX - startX) / 2 + startX, (endY - startY) / 2 + startY, width / 2, 0, Math.PI * 2);
      canvasDraw.closePath();
      canvasDraw.clip();
      canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      canvasDraw.restore();
      canvasDraw.lineWidth = tempWidth;
      this.drawOuterSelection(canvasDraw, true);
      parent.currObjType.shape = "";
    };
    Draw2.prototype.shapeLine = function(canvasDraw, x1, y1, x2, y2) {
      var tempLineWidth = canvasDraw.lineWidth;
      canvasDraw.lineWidth = this.parent.activeObj.strokeSettings.strokeWidth;
      canvasDraw.beginPath();
      canvasDraw.moveTo(x1, y1);
      canvasDraw.lineTo(x2, y2);
      canvasDraw.stroke();
      canvasDraw.lineWidth = tempLineWidth;
    };
    Draw2.prototype.manipulateSaveCtx = function(canvasDraw, x, y) {
      if (canvasDraw !== this.lowerContext && canvasDraw !== this.upperContext) {
        var obj = { width: 0, height: 0 };
        this.parent.notify("crop", {
          prop: "calcRatio",
          onPropertyChange: false,
          value: { obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } }
        });
        var ratio = obj;
        if (x) {
          x *= ratio.width;
        }
        if (y) {
          y *= ratio.height;
        }
      }
      return { x, y };
    };
    Draw2.prototype.arrow = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      canvasDraw.lineWidth = strWidth;
      var x = this.arrowDimension["arrow"]["width"];
      var y = this.arrowDimension["arrow"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
      var angle = Math.atan2(this.dy, this.dx);
      var isStartArrow = actObj.start === "arrow";
      var isEndArrow = actObj.end === "arrow";
      var isEndCircleOrSquare = actObj.end === "circle" || actObj.end === "square";
      if ((start && actObj.triangleDirection === "left" || actObj.triangleDirection === "right") && (isStartArrow && actObj.end === "none" || isStartArrow && !isEndCircleOrSquare) || !start && (isEndArrow && actObj.start === "none" || !isStartArrow && !isEndCircleOrSquare)) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        this.shapeLine(canvasDraw, 0, 0, -x, y / 2);
        this.shapeLine(canvasDraw, 0, 0, -x, -y / 2);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        this.shapeLine(canvasDraw, 0, 0, x, y / 2);
        this.shapeLine(canvasDraw, 0, 0, x, -y / 2);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
      }
    };
    Draw2.prototype.arrowSolid = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var x = this.arrowDimension["arrowSolid"]["width"];
      var y = this.arrowDimension["arrowSolid"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      var isStartArrowSolid = actObj.start === "arrowSolid";
      var isEndArrowSolid = actObj.end === "arrowSolid";
      var isEndCircleOrSquare = actObj.end === "circle" || actObj.end === "square";
      if (start && (isStartArrowSolid && actObj.end === "none") || isStartArrowSolid && !isEndCircleOrSquare || !start && (isEndArrowSolid && actObj.start === "none" || !isStartArrowSolid && !isEndCircleOrSquare)) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        canvasDraw.beginPath();
        canvasDraw.moveTo(strWidth, 0);
        canvasDraw.lineTo(-x + y / 2, y / 2);
        canvasDraw.lineTo(-x + y / 2, -y / 2);
        canvasDraw.closePath();
        canvasDraw.fill();
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        canvasDraw.beginPath();
        canvasDraw.moveTo(0 - strWidth, 0);
        canvasDraw.lineTo(x - y / 2, y / 2);
        canvasDraw.lineTo(x - y / 2, -y / 2);
        canvasDraw.closePath();
        canvasDraw.fill();
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.arrowSquareStart = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var isStartSquare = actObj.start === "square";
      var isEndCircle = actObj.end === "circle";
      var isStartSquareSolid = actObj.start === "squareSolid";
      var isEndCircleSolid = actObj.end === "circleSolid";
      if (isStartSquare && actObj.end === "none" || isStartSquare && !isEndCircle && actObj.start !== "square" || isStartSquareSolid && isEndCircleSolid) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      canvasDraw.lineWidth = strWidth;
      canvasDraw.beginPath();
      canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
      var x = this.arrowDimension["square"]["width"];
      var y = this.arrowDimension["square"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      if (actObj.triangleDirection === "left") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        if (actObj.start === "squareSolid") {
          canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
        }
        canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        this.squareStartIntersectX1 = endX - y / 2 * Math.cos(angle);
        this.squareStartIntersectY1 = endY - y / 2 * Math.sin(angle);
        if (actObj.start === "square" && actObj.end !== "square" && actObj.end !== "circle") {
          this.shapeLine(canvasDraw, startX, startY, this.squareStartIntersectX1, this.squareStartIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "circle") {
          this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        } else if (actObj.start === "squareSolid" && actObj.end === "squareSolid") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
      } else if (actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (actObj.start === "squareSolid" && actObj.end === "squareSolid") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        if (actObj.start === "squareSolid") {
          canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
        }
        canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
        this.squareStartIntersectX1 = startX + y / 2 * Math.cos(angle);
        this.squareStartIntersectY1 = startY + y / 2 * Math.sin(angle);
        if (actObj.start === "square" && actObj.end !== "square" && actObj.end !== "circle") {
          this.shapeLine(canvasDraw, endX, endY, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
        if (actObj.start === "square" && actObj.end === "circle") {
          this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
      }
    };
    Draw2.prototype.arrowSquareEnd = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var x = this.arrowDimension["square"]["width"];
      var y = this.arrowDimension["square"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      canvasDraw.lineWidth = strWidth;
      if (actObj.triangleDirection === "right") {
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (actObj.end === "squareSolid" && actObj.start === "none") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        if (actObj.end === "squareSolid") {
          canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
        }
        canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
        this.squareEndIntersectX1 = endX - y / 2 * Math.cos(angle);
        this.squareEndIntersectY1 = endY - y / 2 * Math.sin(angle);
        if (actObj.end === "square" && actObj.start !== "square" && actObj.start !== "circle") {
          this.shapeLine(canvasDraw, startX, startY, this.squareEndIntersectX1, this.squareEndIntersectY1);
        } else if (actObj.start === "circle" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
      } else if (actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        if (actObj.end === "squareSolid") {
          canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
        }
        canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
        this.squareEndIntersectX1 = startX + y / 2 * Math.cos(angle);
        this.squareEndIntersectY1 = startY + y / 2 * Math.sin(angle);
        if (actObj.end === "square" && actObj.start !== "square" && actObj.start !== "circle") {
          this.shapeLine(canvasDraw, endX, endY, this.squareEndIntersectX1, this.squareEndIntersectY1);
        } else if (actObj.start === "circle" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
      }
    };
    Draw2.prototype.arrowCircle = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        canvasDraw.beginPath();
        canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.closePath();
        this.dx = endX - startX;
        this.dy = endY - startY;
        var a = this.dx * this.dx + this.dy * this.dy;
        var b = 2 * (this.dx * (startX - endX) + this.dy * (startY - endY));
        var c = (startX - endX) * (startX - endX) + (startY - endY) * (startY - endY) - circleRadius * circleRadius;
        var intersect = b * b - 4 * a * c;
        if (intersect >= 0) {
          canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
          var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
          var intersectionX1 = startX + this.dx * t2;
          var intersectionY1 = startY + this.dy * t2;
          if (start) {
            this.startCircleIntersectX1 = intersectionX1;
            this.startCircleIntersectY1 = intersectionY1;
            this.endCircleIntersectX1 = endX - this.dx * t2;
            this.endCircleIntersectY1 = endY - this.dy * t2;
            canvasDraw.beginPath();
            canvasDraw.fill();
            canvasDraw.beginPath();
            if (actObj.start === "circle" && actObj.end === "circle") {
              this.shapeLine(canvasDraw, this.startCircleIntersectX1, this.startCircleIntersectY1, this.endCircleIntersectX1, this.endCircleIntersectY1);
            } else if (actObj.start === "circle" && actObj.end !== "circle" && actObj.end !== "square") {
              this.shapeLine(canvasDraw, startX, startY, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            canvasDraw.stroke();
            canvasDraw.closePath();
          } else {
            this.endCircleIntersectX1 = intersectionX1;
            this.endCircleIntersectY1 = intersectionY1;
            if (actObj.end === "circle" && (actObj.start !== "circle" && actObj.start !== "square")) {
              this.shapeLine(canvasDraw, startX, startY, this.endCircleIntersectX1, this.endCircleIntersectY1);
            }
          }
        }
        var angle = Math.atan2(this.dy, this.dx);
        parent.activeObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        canvasDraw.beginPath();
        canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.closePath();
        this.dx = startX - endX;
        this.dy = startY - endY;
        var a = this.dx * this.dx + this.dy * this.dy;
        var b = 2 * (this.dx * (endX - startX) + this.dy * (endY - startY));
        var c = (endX - startX) * (endX - startX) + (endY - startY) * (endY - startY) - circleRadius * circleRadius;
        var intersect = b * b - 4 * a * c;
        if (intersect >= 0) {
          canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
          var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
          var intersectionX1 = endX + this.dx * t2;
          var intersectionY1 = endY + this.dy * t2;
          if (start) {
            this.startCircleIntersectX1 = intersectionX1;
            this.startCircleIntersectY1 = intersectionY1;
            this.endCircleIntersectX1 = startX - this.dx * t2;
            this.endCircleIntersectY1 = startY - this.dy * t2;
            if (actObj.start === "circle" && actObj.end === "circle") {
              this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            } else if (actObj.start === "circle" && actObj.end !== "circle" && actObj.end !== "square") {
              this.shapeLine(canvasDraw, endX, endY, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
          } else {
            this.endCircleIntersectX1 = intersectionX1;
            this.endCircleIntersectY1 = intersectionY1;
            canvasDraw.beginPath();
            canvasDraw.fill();
            canvasDraw.beginPath();
            if (actObj.end === "circle" && (actObj.start !== "circle" && actObj.start !== "square")) {
              this.shapeLine(canvasDraw, endX, endY, this.endCircleIntersectX1, this.endCircleIntersectY1);
            }
          }
        }
        var angle = Math.atan2(this.dy, this.dx);
        parent.activeObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.arrowCircleSolid = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var isStartCircleSolid = actObj.start === "circleSolid";
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (isStartCircleSolid && actObj.end === "none") || isStartCircleSolid && actObj.end !== "circle" && actObj.end !== "square" || !start && (actObj.end === "circleSolid" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (isStartCircleSolid && actObj.end === "none") || isStartCircleSolid && actObj.end !== "circle" && actObj.end !== "square" || !start && (actObj.end === "circleSolid" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
      }
    };
    Draw2.prototype.arrowBar = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (actObj.start === "bar" && actObj.end === "none") || actObj.start === "bar" && (actObj.end !== "circle" && actObj.end !== "square") || !start && (actObj.end === "bar" && actObj.start === "none" || actObj.end === "bar" && (actObj.start !== "circle" && actObj.start !== "square"))) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var x = this.arrowDimension["bar"]["width"];
        var y = this.arrowDimension["bar"]["height"];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        canvasDraw.fillRect(-x + y / 4, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (actObj.start === "bar" && actObj.end === "none") || actObj.start === "bar" && (actObj.end !== "circle" && actObj.end !== "square") || !start && (actObj.end === "bar" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var x = this.arrowDimension["bar"]["width"];
        var y = this.arrowDimension["bar"]["height"];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        canvasDraw.fillRect(y / 4 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        parent.activeObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.shapeImage = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var ctx = actObj.imageCanvas.getContext("2d");
      if (canvasDraw === this.lowerContext && this.isImageApply) {
        var dimObj = { width: 0, height: 0 };
        parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: { width: actObj.imageElement.width, height: actObj.imageElement.height, obj: dimObj, isImgShape: null } });
        if (width < dimObj["width"] / 5 || height < dimObj["height"] / 5) {
          ctx.clearRect(0, 0, actObj.imageCanvas.width, actObj.imageCanvas.height);
          parent.notify("selection", { prop: "applyTransformToImg", onPropertyChange: false, value: { ctx } });
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("selection", { prop: "setImageClarity", onPropertyChange: false, value: { bool: false } });
          this.isImageApply = false;
        }
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = width;
      imgPoint.height = height;
      if (actObj.flipObjColl.length === 4) {
        actObj.flipObjColl = [];
        actObj.shapeFlip = "";
      }
      imgPoint.startX = (width - imgPoint.width) / 2 + startX;
      imgPoint.startY = (height - imgPoint.height) / 2 + startY;
      var temp = canvasDraw.globalAlpha;
      canvasDraw.globalAlpha = actObj.opacity;
      if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
        this.rotateImage(canvasDraw);
      } else {
        canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
      }
      canvasDraw.globalAlpha = temp;
      parent.currObjType.isText = false;
    };
    Draw2.prototype.shapeText = function(canvasDraw) {
      var parent = this.parent;
      var filter = canvasDraw.filter;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var rows = actObj.keyHistory.split("\n");
      var _b = actObj.textSettings, fontFamily = _b.fontFamily, bold = _b.bold, italic = _b.italic;
      var fontSize = actObj.textSettings.fontSize;
      var lHeight = fontSize + fontSize * 0.25;
      var lineHeight = (lHeight * rows.length - fontSize * rows.length) / rows.length;
      canvasDraw.filter = "none";
      for (var i = 0; i < rows.length; i++) {
        var text = rows[i];
        var yPoint = (i + 1) * fontSize * 0.85 + i * lineHeight;
        if (parent.transform.degree === -360) {
          parent.transform.degree = 0;
        }
        if (parent.transform.degree === 0 || parent.transform.degree === 180) {
          if (fontSize > height) {
            fontSize = actObj.textSettings.fontSize = height - height * 0.1;
          }
        } else {
          if (fontSize > width) {
            fontSize = actObj.textSettings.fontSize = width - width * 0.1;
          }
        }
        canvasDraw.strokeStyle = actObj.strokeSettings.strokeColor;
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        var textStyle = "";
        if (bold) {
          textStyle = "bold ";
        }
        if (italic) {
          textStyle = "italic ";
        }
        if (bold && italic) {
          textStyle = "italic bold ";
        }
        canvasDraw.font = textStyle + fontSize + "px " + fontFamily;
        if (actObj.flipObjColl.length === 4) {
          actObj.flipObjColl = [];
          actObj.shapeFlip = "";
        }
        if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
          this.rotateText(canvasDraw);
        } else {
          canvasDraw.fillText(text, startX + fontSize * 0.1, startY + yPoint);
        }
      }
      canvasDraw.filter = filter;
      parent.currObjType.isText = false;
    };
    Draw2.prototype.updateActPoint = function(degree, canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var actPoint = actObj.activePoint;
      if (degree.toLowerCase() === "horizontal") {
        if (actPoint.startX <= canvasDraw.canvas.width / 2) {
          actPoint.startX = canvasDraw.canvas.width / 2 + (canvasDraw.canvas.width / 2 - actPoint.endX);
          actPoint.endX = actPoint.startX + actPoint.width;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        } else if (actPoint.startX >= canvasDraw.canvas.width / 2) {
          actPoint.startX = canvasDraw.canvas.width - actPoint.endX;
          actPoint.endX = actPoint.startX + actPoint.width;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        }
      } else if (degree.toLowerCase() === "vertical") {
        if (actPoint.startY <= canvasDraw.canvas.height / 2) {
          actPoint.startY = canvasDraw.canvas.height / 2 + (canvasDraw.canvas.height / 2 - actPoint.endY);
          actPoint.endY = actPoint.startY + actPoint.height;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        } else if (actPoint.startY >= canvasDraw.canvas.height / 2) {
          actPoint.startY = canvasDraw.canvas.height - actPoint.endY;
          actPoint.endY = actPoint.startY + actPoint.height;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        }
      }
      return actPoint;
    };
    Draw2.prototype.rotateImage = function(canvasDraw) {
      var parent = this.parent;
      var degree;
      var actObj = parent.activeObj;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree === -450) {
        degree = -90;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
      imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.width : actObj.activePoint.height;
      imgPoint.startX = actObj.activePoint.startX;
      imgPoint.startY = actObj.activePoint.startY;
      var startX = imgPoint.startX;
      var startY = imgPoint.startY;
      var tempDegree;
      var tempColl = [];
      canvasDraw.save();
      for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
        var coll = actObj.rotateFlipColl[i];
        tempColl.push(coll);
        if (typeof coll === "number") {
          if (actObj.shapeDegree === 0) {
            tempDegree = coll;
          } else {
            tempDegree = coll - actObj.shapeDegree;
          }
          if (tempDegree === -450) {
            tempDegree = -90;
          }
          if (tempDegree < 0) {
            tempDegree = 360 + tempDegree;
          }
          imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
          imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.width : actObj.activePoint.height;
          canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
          canvasDraw.rotate(Math.PI / 180 * coll);
          canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
          if (tempDegree % 90 === 0 && tempDegree % 270 !== 0 || tempDegree === 0) {
            startY = canvasDraw.canvas.width - (actObj.activePoint.startX + actObj.activePoint.width);
            startY += (actObj.activePoint.width - imgPoint.height) / 2;
            startX = imgPoint.startY;
          } else if (tempDegree % 270 === 0) {
            startX = canvasDraw.canvas.height - (actObj.activePoint.startY + actObj.activePoint.height);
            startX += (actObj.activePoint.height - imgPoint.width) / 2;
            startY = imgPoint.startX;
          }
          imgPoint.startX = startX;
          imgPoint.startY = startY;
          actObj.activePoint.startX = startX;
          actObj.activePoint.startY = startY;
          actObj.activePoint.endX = actObj.activePoint.startX + imgPoint.width;
          actObj.activePoint.endY = actObj.activePoint.startY + imgPoint.height;
          actObj = this.updateWidthHeight(actObj);
        } else {
          if (coll === "horizontal" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "vertical";
          } else if (coll === "vertical" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "horizontal";
          }
          if (coll === "horizontal") {
            canvasDraw.translate(canvasDraw.canvas.width, 0);
            canvasDraw.scale(-1, 1);
            actObj.activePoint = this.updateActPoint("horizontal", canvasDraw);
          } else if (coll === "vertical") {
            canvasDraw.translate(0, canvasDraw.canvas.height);
            canvasDraw.scale(1, -1);
            actObj.activePoint = this.updateActPoint("vertical", canvasDraw);
          }
          imgPoint.startX = actObj.activePoint.startX;
          imgPoint.startY = actObj.activePoint.startY;
        }
        imgPoint.startX = actObj.activePoint.startX;
        imgPoint.startY = actObj.activePoint.startY;
        startX = imgPoint.startX;
        startY = imgPoint.startY;
      }
      if (actObj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj: actObj } });
      }
      canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
      canvasDraw.restore();
      parent.activeObj = tempActiveObj;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Draw2.prototype.rotateText = function(canvasDraw) {
      var parent = this.parent;
      var degree;
      var actObj = parent.activeObj;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      var actPoint = parent.activeObj.activePoint;
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree === -450) {
        degree = -90;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.height : actPoint.width;
      imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.width : actPoint.height;
      imgPoint.startX = actPoint.startX;
      imgPoint.startY = actPoint.startY;
      var startX = imgPoint.startX;
      var startY = imgPoint.startY;
      var tempDegree;
      var tempColl = [];
      canvasDraw.save();
      for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
        var coll = actObj.rotateFlipColl[i];
        tempColl.push(coll);
        if (typeof coll === "number") {
          if (actObj.shapeDegree === 0) {
            tempDegree = coll;
          } else {
            tempDegree = coll - actObj.shapeDegree;
          }
          if (tempDegree === -450) {
            tempDegree = -90;
          }
          if (tempDegree < 0) {
            tempDegree = 360 + tempDegree;
          }
          imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.height : actPoint.width;
          imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.width : actPoint.height;
          canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
          canvasDraw.rotate(Math.PI / 180 * coll);
          canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
          if (tempDegree % 90 === 0 && tempDegree % 270 !== 0 || tempDegree === 0) {
            startY = canvasDraw.canvas.width - actPoint.endX;
            startX = actPoint.startY;
          } else if (tempDegree % 270 === 0) {
            startX = canvasDraw.canvas.height - actPoint.endY;
            startY = actPoint.startX;
          }
          imgPoint.startX = startX;
          imgPoint.startY = startY;
          actPoint.startX = startX;
          actPoint.startY = startY;
          actPoint.endX = actPoint.startX + imgPoint.width;
          actPoint.endY = actPoint.startY + imgPoint.height;
          actObj = this.updateWidthHeight(actObj);
        } else {
          if (coll === "horizontal" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "vertical";
          } else if (coll === "vertical" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "horizontal";
          }
          if (coll === "horizontal") {
            canvasDraw.translate(canvasDraw.canvas.width, 0);
            canvasDraw.scale(-1, 1);
          } else if (coll === "vertical") {
            canvasDraw.translate(0, canvasDraw.canvas.height);
            canvasDraw.scale(1, -1);
          }
          actObj.activePoint = actPoint = this.updateActPoint(coll, canvasDraw);
          imgPoint.startX = actPoint.startX;
          imgPoint.startY = actPoint.startY;
        }
        imgPoint.startX = actPoint.startX;
        imgPoint.startY = actPoint.startY;
        startX = imgPoint.startX;
        startY = imgPoint.startY;
      }
      if (actObj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj: actObj } });
      }
      startY += actObj.textSettings.fontSize * 0.4;
      this.textFlipDegree(canvasDraw, startX, startY);
      canvasDraw.restore();
      parent.activeObj = tempActiveObj;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Draw2.prototype.textFlipDegree = function(canvasDraw, startX, startY) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var rows = actObj.keyHistory.split("\n");
      var fontSize = actObj.textSettings.fontSize;
      var lineHeight = (fontSize * rows.length - fontSize * rows.length) / rows.length;
      var yPoint = fontSize * 0.85 + lineHeight;
      for (var i = 0, len = rows.length; i < len; i++) {
        var text = rows[i];
        if (i > 0) {
          if (i === 1) {
            yPoint -= fontSize * 0.85;
          }
          yPoint += fontSize + fontSize * 0.15;
        }
        canvasDraw.fillText(text, startX + fontSize * 0.15, startY + yPoint + (i > 0 ? fontSize * 0.25 : -fontSize * 0.35));
      }
    };
    Draw2.prototype.clearOuterCanvas = function(context) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var left = destLeft > 0 ? destLeft : 0;
      var top = destTop > 0 ? destTop : 0;
      context.clearRect(0, 0, left, parent.lowerCanvas.height);
      context.clearRect(destLeft + destWidth, 0, parent.lowerCanvas.width - (destLeft + destWidth), parent.lowerCanvas.height);
      context.clearRect(0, 0, parent.lowerCanvas.width, top);
      context.clearRect(0, destTop + destHeight, parent.lowerCanvas.width, parent.lowerCanvas.height - (destTop + destHeight));
      if (parent.transform.currFlipState !== "") {
        parent.img.destLeft = destLeft;
        parent.img.destTop = destTop;
      }
    };
    Draw2.prototype.setDestPoints = function() {
      var maxDimension;
      var parent = this.parent;
      var _a = parent.transform, degree = _a.degree, zoomFactor = _a.zoomFactor;
      if (degree % 90 === 0 && degree % 180 !== 0) {
        var obj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: parent.img.srcHeight, height: parent.img.srcWidth, obj, isImgShape: null }
        });
        maxDimension = obj;
        if (this.isRotateZoom) {
          maxDimension.width += maxDimension.width * zoomFactor;
          maxDimension.height += maxDimension.height * zoomFactor;
          parent.img.destWidth = maxDimension.height;
          parent.img.destHeight = maxDimension.width;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.height) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.width) / 2;
        parent.img.destWidth = maxDimension.height;
        parent.img.destHeight = maxDimension.width;
      } else {
        var obj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
        });
        maxDimension = obj;
        if (this.isRotateZoom) {
          maxDimension.width += maxDimension.width * zoomFactor;
          maxDimension.height += maxDimension.height * zoomFactor;
          parent.img.destWidth = maxDimension.width;
          parent.img.destHeight = maxDimension.height;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        if (degree === 0) {
          parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        } else {
          parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
        }
        parent.img.destWidth = maxDimension.width;
        parent.img.destHeight = maxDimension.height;
      }
    };
    Draw2.prototype.updateCurrTransState = function(type, isPreventDestination, isRotatePan, isStraighten) {
      var parent = this.parent;
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      if (type === "initial") {
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        if (isNullOrUndefined(isPreventDestination)) {
          this.setDestPoints();
        }
      }
      if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
        this.currTransState(type, true, null, isRotatePan);
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "" && parent.transform.straighten === 0 && isNullOrUndefined(isStraighten)) {
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
        }
        if (isRotatePan) {
          parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
        }
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
        if (isRotatePan) {
          parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
          parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
        }
      } else {
        this.currTransState(type, null, null, isRotatePan);
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "" && parent.transform.straighten === 0 && isNullOrUndefined(isStraighten)) {
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
        }
      }
    };
    Draw2.prototype.currTransState = function(type, isPreventDimension, context, isPreventCircleCrop) {
      var parent = this.parent;
      context = context ? context : this.lowerContext;
      if (type === "initial") {
        this.setTransformColl(context, type);
      } else if (type === "reverse") {
        this.setTransformColl(context, type);
        this.setClientTransDim(isPreventDimension);
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" && isNullOrUndefined(isPreventCircleCrop)) {
          if (isPreventCircleCrop) {
            parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
          }
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
          if (isPreventCircleCrop) {
            parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
            parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
          }
        }
      }
    };
    Draw2.prototype.setTransformColl = function(context, type) {
      var parent = this.parent;
      if (type === "initial") {
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          this.setTransform(context, parent.rotateFlipColl[i]);
        }
      } else if (type === "reverse") {
        for (var i = parent.rotateFlipColl.length - 1; i >= 0; i--) {
          this.setTransform(context, parent.rotateFlipColl[i], true);
        }
      }
    };
    Draw2.prototype.setTransform = function(context, value, isReverse) {
      var parent = this.parent;
      if (isReverse && value === 90) {
        value = -90;
      } else if (isReverse && value === -90) {
        value = 90;
      }
      if (value === "horizontal" && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        value = "vertical";
      } else if (value === "vertical" && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        value = "horizontal";
      }
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: true } });
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: true } });
      if (isNullOrUndefined(isReverse)) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      }
      switch (value) {
        case 90:
        case -90:
          context.translate(context.canvas.width / 2, context.canvas.height / 2);
          context.rotate(Math.PI / 180 * value);
          context.translate(-context.canvas.width / 2, -context.canvas.height / 2);
          break;
        case "horizontal":
          context.translate(context.canvas.width, 0);
          context.scale(-1, 1);
          break;
        case "vertical":
          context.translate(0, context.canvas.height);
          context.scale(1, -1);
          break;
      }
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: false } });
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: false } });
    };
    Draw2.prototype.drawImgToCanvas = function(maxDimension) {
      var parent = this.parent;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.img.destWidth = maxDimension.width;
      parent.img.destHeight = maxDimension.height;
      if (this.isInitialLoading) {
        parent.notify("filter", { prop: "initFilter", onPropertyChange: false });
        this.isInitialLoading = false;
      }
      var temp = this.lowerContext.filter;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.drawImage();
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      this.lowerContext.filter = temp;
    };
    Draw2.prototype.renderImage = function(isMouseWheel, isPreventClearRect, isFrame, isStraighten) {
      var parent = this.parent;
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      if (isNullOrUndefined(isPreventClearRect)) {
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      }
      if (isMouseWheel) {
        this.setTransformColl(this.lowerContext, "initial");
      } else {
        if (parent.transform.zoomFactor !== 0) {
          this.isRotateZoom = true;
        }
        this.updateCurrTransState("initial", null, null, isStraighten);
      }
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      this.drawImage();
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      if (isMouseWheel) {
        this.setTransformColl(this.lowerContext, "reverse");
      } else {
        this.updateCurrTransState("reverse", null, null, isStraighten);
        this.isRotateZoom = false;
      }
      if (isFrame) {
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      } else {
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
      }
      this.clearOuterCanvas(this.lowerContext);
      if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
    };
    Draw2.prototype.imageOnLoad = function(src) {
      var _this = this;
      var parent = this.parent;
      var proxy = this;
      parent.baseImg.src = src;
      parent.baseImg.onload = function() {
        parent.imgSrc = src;
        parent.notify("filter", { prop: "update-finetunes", onPropertyChange: false });
        proxy.lowerContext.drawImage(parent.baseImg, 0, 0, proxy.parent.lowerCanvas.width, proxy.parent.lowerCanvas.height);
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
        proxy.updateBaseImgCanvas();
        var fileOpened = { fileName: _this.fileName, fileType: _this.fileType, isValidImage: true };
        proxy.updateCanvas();
        if (parent.currObjType.isUndoZoom) {
          parent.currObjType.isUndoZoom = false;
          proxy.parent.lowerCanvas.style.display = "block";
        }
        parent.isUndoRedo = _this.isErrorImage = false;
        if (Browser.isDevice) {
          parent.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "destroy-bottom-toolbar", onPropertyChange: false });
          var eventargs = {
            isApplyBtn: false,
            isDevice: Browser.isDevice,
            isOkBtn: null,
            isResize: null,
            isFrame: null,
            isMainToolbar: true
          };
          parent.notify("toolbar", { prop: "init-main-toolbar", onPropertyChange: false, value: eventargs });
          parent.notify("toolbar", { prop: "create-bottom-toolbar", onPropertyChange: false });
        } else {
          parent.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
          var eventargs = { isApplyBtn: false, isDevice: false, isOkBtn: null };
          parent.notify("toolbar", { prop: "init-main-toolbar", onPropertyChange: false, value: eventargs });
        }
        if (parent.isImageLoaded && parent.element.style.opacity !== "0.5") {
          parent.trigger("fileOpened", fileOpened);
        }
      };
      parent.baseImg.onerror = function() {
        hideSpinner(parent.element);
        proxy.isErrorImage = true;
        proxy.errorLoading();
      };
    };
    Draw2.prototype.errorLoading = function() {
      var parent = this.parent;
      var fileOpened = { fileName: null, fileType: null, isValidImage: false };
      parent.trigger("fileOpened", fileOpened);
    };
    Draw2.prototype.updateBaseImgCanvas = function() {
      var parent = this.parent;
      parent.baseImgCanvas.width = parent.baseImg.width;
      parent.baseImgCanvas.height = parent.baseImg.height;
      parent.baseImgCanvas.getContext("2d").drawImage(parent.baseImg, 0, 0);
    };
    Draw2.prototype.updateCanvas = function() {
      var parent = this.parent;
      parent.img.srcWidth = parent.baseImgCanvas.width;
      parent.img.srcHeight = parent.baseImgCanvas.height;
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
      parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
      this.drawImgToCanvas(maxDimension);
      this.origDim.width = parent.img.destWidth;
      this.origDim.height = parent.img.destHeight;
      this.zoomCrop.width = parent.img.destWidth;
      this.zoomCrop.height = parent.img.destHeight;
      parent.notify("transform", {
        prop: "setCropDimension",
        onPropertyChange: false,
        value: { width: parent.img.destWidth, height: parent.img.destHeight }
      });
      var point = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("crop", { prop: "setCropDestPoints", onPropertyChange: false, value: { point } });
      var temp = this.lowerContext.filter;
      this.lowerContext.filter = "none";
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = temp;
      if (parent.img.destWidth > 0 && parent.img.destHeight > 0) {
        parent.isImageLoaded = true;
      }
      if (parent.isUndoRedo) {
        if (parent.transform.currFlipState !== "") {
          parent.notify("transform", {
            prop: "flipImage",
            onPropertyChange: false,
            value: { direction: parent.toPascalCase(parent.transform.currFlipState) }
          });
        }
      }
      if (parent.disabled) {
        parent.element.setAttribute("class", "e-disabled");
      }
      if (parent.zoomSettings.zoomFactor !== 1 || parent.zoomSettings.zoomPoint) {
        parent.zoom(parent.zoomSettings.zoomFactor, parent.zoomSettings.zoomPoint);
      }
      if (isNullOrUndefined(this.initZoomValue)) {
        this.initZoomValue = parent.zoomSettings.zoomFactor;
      }
      this.isImageEdited = false;
    };
    Draw2.prototype.resetFrameZoom = function(isOk) {
      var parent = this.parent;
      if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
        var temp = parent.tempFrameZoomLevel;
        parent.tempFrameZoomLevel = null;
        parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: temp, zoomPoint: null, isResize: true }
        });
        var obj = parent.cancelCropSelection;
        if (isOk && obj) {
          obj.previousObj.frameObj = extend({}, parent.frameObj, null, true);
          obj.currentObj.frameObj = extend({}, parent.frameObj, null, true);
          obj.previousObj.frame = obj.currentObj.frame = parent.frameObj.type;
        }
        this.updateCropSelObj();
        parent.cancelCropSelection = null;
      }
    };
    Draw2.prototype.performCancel = function(isContextualToolbar, isUndoRedo, isFinalCancel) {
      var parent = this.parent;
      if (isFinalCancel) {
        parent.noPushUndo = false;
      }
      var straightenObj = { bool: parent.isStraightening };
      isContextualToolbar = isContextualToolbar ? isContextualToolbar : false;
      var obj = { bool: false };
      parent.allowDownScale = true;
      parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (isNullOrUndefined(isUndoRedo) && JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
        extend(parent.frameObj, parent.tempFrameObj);
        this.renderImage(null, null, true);
      }
      this.resetFrameZoom(false);
      if (obj["bool"]) {
        parent.notify("freehand-draw", { prop: "cancelFhd", onPropertyChange: false });
        parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      } else if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        parent.textArea.style.display = "none";
        parent.textArea.value = "";
        parent.textArea.style.transform = "";
        if (this.prevActObj) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
        } else {
          parent.activeObj.strokeSettings = this.tempStrokeSettings;
          parent.activeObj.textSettings = this.tempTextSettings;
        }
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
        if (this.isShapeTextInserted) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("selection", { prop: "setTempActObj", onPropertyChange: false, value: { obj: parent.activeObj } });
        if (parent.drawingShape) {
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        }
      } else if ((!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) && document.querySelector("#" + parent.element.id + "_sliderWrapper") || parent.currObjType.isFiltered) {
        this.lowerContext.filter = this.tempAdjValue;
        parent.canvasFilter = this.tempAdjValue;
        parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.tempAdjValue } });
        parent.initialAdjustmentValue = this.tempAdjValue;
        if (this.lowerContext.filter.split(" ").length > 1 && this.lowerContext.filter.split(" ")[0].split("(")[1].split(")")[0] === "1") {
          parent.notify("filter", { prop: "setBrightnessAdjusted", onPropertyChange: false, value: { isBrightnessAdjusted: false } });
        }
        parent.currentFilter = this.tempFilter;
        parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.redrawImgWithObj();
        parent.currObjType.isFiltered = false;
        var obj_3 = { tempAdjustmentLevel: null };
        parent.notify("filter", { prop: "getTempAdjustmentLevel", onPropertyChange: false, value: { obj: obj_3 } });
        parent.notify("filter", {
          prop: "setAdjustmentLevel",
          onPropertyChange: false,
          value: { adjustmentLevel: extend({}, obj_3["tempAdjustmentLevel"], {}, true) }
        });
        parent.notify("undo-redo", { prop: "setUndoRedoStep", onPropertyChange: false, value: { step: this.tempUndoRedoStep } });
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        parent.currObjType.isCustomCrop = false;
        this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
        this.clearOuterCanvas(this.lowerContext);
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        var eventargs = { type: "main", isApplyBtn: null, isCropping: null, isZooming: null };
        parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
        if (parent.activeObj.shape && parent.activeObj.shape === "image") {
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else {
        if (isContextualToolbar && (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"])) {
          var eventargs = { type: "main", isApplyBtn: null, isCropping: null, isZooming: null };
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
        } else {
          this.cancelItems();
          if (parent.transform.zoomFactor > 0) {
            parent.togglePan = true;
            parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
          } else {
            parent.togglePan = false;
            parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
          }
        }
      }
      this.isShapeTextInserted = false;
      this.isNewPath = false;
      parent.notify("toolbar", { prop: "refresh-dropdown-btn", value: { isDisabled: false } });
      parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
      if (isFinalCancel) {
        parent.noPushUndo = false;
      }
      parent.drawingShape = null;
      parent.notify("draw", { prop: "resetTempObjColl" });
      parent.notify("draw", { prop: "resetTempPointColl" });
    };
    Draw2.prototype.cancelItems = function() {
      var parent = this.parent;
      var isCropSelection = false;
      var id = parent.element.id;
      var ascpectIcon = parent.element.querySelector("#" + id + "_aspectratio");
      var nonAspectIcon = parent.element.querySelector("#" + id + "_nonaspectratio");
      var splitWords;
      var shapes = ["rectangle", "ellipse", "line", "arrow", "path", "image"];
      if (parent.activeObj.shape !== void 0) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== void 0 && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection && parent.isCropTab) {
        parent.isCropTab = false;
        parent.transform.zoomFactor = parent.transform.defaultZoomFactor;
      }
      if (parent.isResize) {
        if (ascpectIcon || nonAspectIcon || parent.currentToolbar === "resize-toolbar") {
          var obj = { width: null, height: null };
          parent.notify("selection", { prop: "getNumTextValue", onPropertyChange: false, value: { obj } });
          var point = { x: obj["width"], y: obj["height"] };
          var aspectRatioElement = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
          var blrAspRatElem = parent.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
          if (point && point.x && point.y && !isNullOrUndefined(parent.aspectWidth)) {
            if (aspectRatioElement || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
              parent.notify("transform", { prop: "resizeImage", value: { width: parent.aspectWidth, height: parent.aspectHeight } });
            } else {
              var bool = parent.currObjType.isUndoAction;
              parent.currObjType.isUndoAction = false;
              parent.notify("transform", { prop: "resizeCrop", value: { width: parent.aspectWidth, height: parent.aspectHeight } });
              parent.currObjType.isUndoAction = bool;
            }
          }
          var obj1 = { prevCropObj: parent.prevCropObj };
          var obj2 = { prevObj: parent.prevObj };
          parent.notify("toolbar", { prop: "getPrevCropObj", onPropertyChange: false, value: { obj: obj1 } });
          parent.notify("toolbar", { prop: "getPrevObj", onPropertyChange: false, value: { obj: obj2 } });
          if (obj1["prevCropObj"] && obj2["prevObj"]) {
            parent.objColl = [];
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.cropObj = extend({}, obj1["prevCropObj"], {}, true);
            this.setCurrentObj(obj2["prevObj"]);
            parent.objColl = obj2["prevObj"]["objColl"];
            parent.pointColl = obj2["prevObj"]["pointColl"];
            parent.freehandCounter = parent.pointColl.length;
            parent.transform.straighten = 0;
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
            });
            var currObj = parent.currSelectionPoint ? extend({}, parent.currSelectionPoint, {}, true) : null;
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: true }
            });
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: obj2["prevObj"]["defaultZoom"], zoomPoint: null, isResize: true }
            });
            parent.currSelectionPoint = currObj;
            if (obj2["prevObj"].zoomFactor) {
              parent.setProperties({ zoomSettings: { zoomFactor: obj2["prevObj"].zoomFactor } }, true);
            }
            parent.notify("transform", {
              prop: "setPreviousZoomValue",
              onPropertyChange: false,
              value: { previousZoomValue: parent.zoomSettings.zoomFactor }
            });
          }
          parent.isResize = false;
          parent.notify("transform", { prop: "setResizedImgAngle", onPropertyChange: false, value: { angle: null } });
          var temp = parent.isCropTab;
          parent.isCropTab = false;
          this.updateCropSelObj();
          parent.cancelCropSelection = null;
          parent.isCropTab = temp;
        }
      }
      switch (true) {
        case parent.togglePen:
          this.cancelPen();
          break;
        case parent.activeObj.shape === "text":
          this.cancelText();
          break;
        case shapes.indexOf(parent.activeObj.shape) !== -1:
          this.cancelShape();
          break;
        case isCropSelection:
          this.cancelSelection();
          break;
        default:
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
          break;
      }
      parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      parent.currObjType.isCustomCrop = false;
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
      var eventargs = { type: "main", isApplyBtn: null, isCropping: false, isZooming: null };
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
    };
    Draw2.prototype.cancelPen = function() {
      var parent = this.parent;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.togglePen = false;
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var tempPointsColl = extend([], parent.pointColl, [], true);
      parent.pointColl = {};
      for (var i = 0; i < this.tempFreehandCounter; i++) {
        parent.pointColl[i] = tempPointsColl[i];
      }
      parent.freehandCounter = this.tempFreehandCounter;
      parent.notify("freehand-draw", { prop: "setCurrentFreehandDrawIndex", value: { value: this.tempCurrFhdIndex } });
      parent.activeObj.strokeSettings = this.tempStrokeSettings;
      parent.notify("shape", {
        prop: "setStrokeSettings",
        value: { strokeSettings: parent.activeObj.strokeSettings, strokeColor: null, fillColor: null, strokeWidth: null }
      });
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
      parent.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      parent.freehandCounter = parent.pointColl.length;
      this.tempPointColl = {};
      this.renderImage();
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelText = function() {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "setTextSettings",
        onPropertyChange: false,
        value: { textSettings: this.tempTextSettings, fontFamily: null, fontSize: null }
      });
      parent.notify("shape", {
        prop: "setStrokeSettings",
        value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var len = object["appliedUndoRedoColl"].length;
        var appliedColl = object["appliedUndoRedoColl"][len - 1];
        if (this.prevActObj && appliedColl && appliedColl.currentObjColl.length && appliedColl.currentObjColl[appliedColl.currentObjColl.length - 1].currIndex === this.prevActObj.currIndex) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
        } else {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      this.tempTextSettings = {
        text: "Enter Text",
        fontFamily: parent.fontFamily.default,
        fontSize: null,
        fontRatio: null,
        bold: false,
        italic: false,
        underline: false
      };
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      this.renderImage();
      this.tempObjColl = [];
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelShape = function() {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "setStrokeSettings",
        value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else if (this.isNewPath) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.renderImage();
      } else {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var obj = void 0;
        for (var i = 0, iLen = object["appliedUndoRedoColl"].length; i < iLen; i++) {
          var currObjColl = object["appliedUndoRedoColl"][i].currentObjColl;
          for (var j = 0, jLen = currObjColl.length; j < jLen; j++) {
            if (this.prevActObj && this.prevActObj.currIndex && currObjColl[j].currIndex === this.prevActObj.currIndex) {
              obj = currObjColl[0];
              break;
            }
          }
        }
        if (this.prevActObj && obj) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
          parent.notify("selection", { prop: "redrawShape", onPropertyChange: false, value: { obj: parent.activeObj } });
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
          parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
        } else {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        var undoRedoObj = { undoRedoStep: null };
        parent.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
        if (object["appliedUndoRedoColl"][undoRedoObj["undoRedoStep"] - 1]) {
          parent.objColl = extend([], object["appliedUndoRedoColl"][undoRedoObj["undoRedoStep"] - 1].currentObjColl, [], true);
        } else {
          parent.objColl = [];
        }
        this.renderImage();
      }
      parent.currObjType.isDragging = false;
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      this.renderImage();
      this.tempObjColl = [];
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelSelection = function() {
      var parent = this.parent;
      if (parent.cancelCropSelection) {
        var obj = { value: parent.tempStraighten };
        parent.transform.straighten = obj["value"];
        parent.straightenBaseImageCanvas();
        parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: parent.activeObj } });
        parent.notify("crop", { prop: "resizeWrapper" });
        this.updateCropSelObj();
        if (this.tempStraightenDestPoints && JSON.stringify(this.tempStraightenDestPoints) !== JSON.stringify(this.straightenDestPoints)) {
          this.straightenDestPoints = extend({}, this.tempStraightenDestPoints, {}, true);
        }
      }
    };
    Draw2.prototype.updateCropSelObj = function() {
      var parent = this.parent;
      if (parent.cancelCropSelection) {
        parent.cropObj = extend({}, parent.cancelCropSelection.previousCropObj, {}, true);
        parent.afterCropActions = parent.cancelCropSelection.previousObj.afterCropActions;
        parent.notify("undo-redo", { prop: "undoDefault", onPropertyChange: false, value: { obj: parent.cancelCropSelection } });
        parent.currSelectionPoint = extend({}, parent.cancelCropSelection.previousCropObj.activeObj, true);
        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
          parent.currSelectionPoint = null;
        }
        this.clearOuterCanvas(this.lowerContext);
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
      }
    };
    Draw2.prototype.updateCropSelection = function() {
      var parent = this.parent;
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var currentObj = object["currObj"];
      currentObj.objColl = extend([], parent.objColl, [], true);
      currentObj.pointColl = extend([], parent.pointColl, [], true);
      currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      parent.cancelCropSelection = {
        operation: "cropTransform",
        previousObj: currentObj,
        currentObj,
        previousObjColl: currentObj.objColl,
        currentObjColl: currentObj.objColl,
        previousPointColl: currentObj.pointColl,
        currentPointColl: currentObj.pointColl,
        previousSelPointColl: currentObj.selPointColl,
        currentSelPointColl: currentObj.selPointColl,
        previousCropObj: extend({}, parent.cropObj, {}, true),
        currentCropObj: extend({}, parent.cropObj, {}, true),
        previousText: null,
        currentText: null,
        filter: null,
        isCircleCrop: parent.isCircleCrop
      };
    };
    Draw2.prototype.updateFlipPan = function(tempSelectionObj) {
      var parent = this.parent;
      if (parent.transform.currFlipState !== "") {
        var temp = this.lowerContext.filter;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("transform", { prop: "rotatedFlip", onPropertyChange: false });
        this.lowerContext.filter = "none";
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
        this.lowerContext.filter = temp;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (tempSelectionObj) {
          this.drawObject("duplicate", tempSelectionObj);
        }
      }
    };
    Draw2.prototype.select = function(type, startX, startY, width, height) {
      var parent = this.parent;
      type = type.toLowerCase();
      if (!parent.disabled && parent.isImageLoaded) {
        parent.allowDownScale = false;
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var previousObj = object["currObj"];
        previousObj.objColl = extend([], parent.objColl, [], true);
        previousObj.pointColl = extend([], parent.pointColl, [], true);
        previousObj.afterCropActions = parent.afterCropActions;
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        previousObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.notify("crop", { prop: "setPreviousCropCurrentObj", onPropertyChange: false, value: { obj: previousObj } });
        if (parent.transform.zoomFactor > 0 && parent.activeObj.shape && parent.activeObj.shape.split("-")[0] === "crop" && isNullOrUndefined(this.currSelPoint)) {
          this.currSelPoint = extend({}, parent.activeObj, {}, true);
        }
        var isPrevent = false;
        var splitWords = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
          isPrevent = true;
        } else if (splitWords !== void 0 && splitWords[0] === "crop") {
          isPrevent = true;
        }
        var obj = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: obj } });
        var prevObj = obj["currObj"];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("shape", { prop: "setKeyHistory", onPropertyChange: false, value: { keyHistory: "" } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.upperCanvas.style.display = "block";
        if (parent.currSelectionPoint || parent.transform.defaultZoomFactor !== 0 || parent.transform.degree !== 0 && parent.panPoint.totalPannedInternalPoint.x !== 0 && parent.panPoint.totalPannedInternalPoint.y !== 0 && !isPrevent) {
          parent.isCircleCrop = false;
          if (parent.transform.defaultZoomFactor !== 0 && !this.isResizeSelect) {
            var isCropTab = parent.isCropTab;
            parent.isCropTab = false;
            parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
            parent.isCropTab = isCropTab;
            this.resetPanPoints();
          }
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
          parent.isCropTab = true;
          parent.isCircleCrop = false;
          if (!this.isResizeSelect) {
            parent.notify("crop", { prop: "setCurrSelPoints", onPropertyChange: false, value: { isSetDimension: true } });
          }
          parent.transform.zoomFactor = parent.transform.cropZoomFactor;
          if (isNullOrUndefined(parent.cropObj.activeObj.shape)) {
            parent.currObjType.shape = "crop-" + type;
            this.drawNewSelection(type, startX, startY, width, height);
          }
        } else {
          if (!this.isCropSelect) {
            parent.notify("crop", {
              prop: "adjustStraightenForShapes",
              onPropertyChange: false,
              value: { type: "reverse", isInitialRotated: true }
            });
            parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
            this.renderImage();
          } else {
            this.isCropSelect = false;
          }
          if (type === "custom") {
            parent.currObjType.shape = "";
          }
          this.drawNewSelection(type, startX, startY, width, height);
        }
      }
    };
    Draw2.prototype.drawNewSelection = function(type, startX, startY, width, height) {
      var parent = this.parent;
      var points;
      var cropShape = "crop-" + type.toLowerCase();
      if (cropShape === "crop-custom") {
        if (parent.currObjType.shape === "" || parent.currObjType.shape === "crop-custom") {
          this.drawCustomSelection("crop-custom", startX, startY, width, height);
          this.adjToStraighten();
          this.updateSelectionInsert();
          if (parent.isStraightening) {
            this.straightenActObj = extend({}, parent.activeObj, {}, true);
            this.straightenInitZoom = parent.transform.zoomFactor;
          }
        }
      } else if (cropShape === "crop-canvas") {
        parent.upperCanvas.style.display = "block";
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      } else {
        parent.currObjType.isCustomCrop = false;
        parent.currObjType.shape = cropShape;
        if (width && height) {
          points = {
            startX,
            startY,
            endX: startX + width,
            endY: startY + height,
            width,
            height
          };
        } else if (width && cropShape === "crop-circle") {
          points = {
            startX,
            startY,
            endX: startX + width,
            endY: startY + width,
            width,
            height: width
          };
        }
        parent.activeObj.shape = cropShape;
        this.updateSelectionInsert(points);
      }
    };
    Draw2.prototype.updateSelectionInsert = function(points) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var selectionSettings = {
        type: parent.getSelectionType(obj["shapeSettingsObj"]["type"]),
        startX: obj["shapeSettingsObj"]["startX"],
        startY: obj["shapeSettingsObj"]["startY"],
        width: obj["shapeSettingsObj"]["width"],
        height: obj["shapeSettingsObj"]["height"]
      };
      var selectionChangingArgs = {
        action: "insert",
        previousSelectionSettings: selectionSettings,
        currentSelectionSettings: selectionSettings
      };
      parent.trigger("selectionChanging", selectionChangingArgs);
      parent.notify("shape", {
        prop: "updSelChangeEventArgs",
        onPropertyChange: false,
        value: { selectionSettings: selectionChangingArgs.currentSelectionSettings }
      });
      if (selectionChangingArgs.currentSelectionSettings.type === "Custom") {
        this.drawObject("duplicate", parent.activeObj, null, null, true);
      } else {
        if (actPoint.startX !== 0 || actPoint.startY !== 0 || actPoint.width !== 0 || actPoint.height !== 0) {
          points = {
            startX: actPoint.startX,
            startY: actPoint.startY,
            endX: actPoint.endX,
            endY: actPoint.endY,
            width: actPoint.width,
            height: actPoint.height
          };
        }
        this.drawObject("duplicate", null, true, points);
      }
    };
    Draw2.prototype.drawCustomSelection = function(cropShape, startX, startY, width, height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      parent.currObjType.isCustomCrop = true;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.currObjType.shape = parent.activeObj.shape = cropShape.toLowerCase();
      if (!isNullOrUndefined(startX) && !isNullOrUndefined(startY) && !isNullOrUndefined(width) && !isNullOrUndefined(height)) {
        actPoint.startX = startX;
        actPoint.startY = startY;
        actPoint.endX = startX + width;
        actPoint.endY = startY + height;
        actPoint.width = width;
        actPoint.height = height;
      } else if (width && height) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        actPoint.width = width;
        actPoint.height = height;
        actPoint.startX = destLeft + (destWidth / 2 - width / 2);
        actPoint.startY = destTop + (destHeight / 2 - height / 2);
      } else {
        if (isNullOrUndefined(parent.transform.zoomFactor) || parent.transform.zoomFactor === 0) {
          var _b = parent.img, destLeft_1 = _b.destLeft, destTop_1 = _b.destTop, destWidth_1 = _b.destWidth, destHeight_1 = _b.destHeight;
          var lowerCanvasWidth_1 = parent.lowerCanvas.width;
          var lowerCanvasHeight_1 = parent.lowerCanvas.height;
          var activePoint_1 = actPoint;
          if (destLeft_1 >= 0 && destTop_1 >= 0) {
            activePoint_1.startX = destLeft_1;
            activePoint_1.startY = destTop_1;
            activePoint_1.endX = destLeft_1 + destWidth_1;
            activePoint_1.endY = destTop_1 + destHeight_1;
          } else if (destLeft_1 >= 0) {
            activePoint_1.startX = destLeft_1;
            activePoint_1.startY = 7.5;
            activePoint_1.endX = destLeft_1 + destWidth_1;
            activePoint_1.endY = lowerCanvasHeight_1 - 15;
          } else if (destTop_1 >= 0) {
            activePoint_1.startX = 7.5;
            activePoint_1.startY = destTop_1;
            activePoint_1.endX = lowerCanvasWidth_1 - 15;
            activePoint_1.endY = destTop_1 + destHeight_1;
          } else {
            activePoint_1.startX = 7.5;
            activePoint_1.startY = 7.5;
            activePoint_1.endX = lowerCanvasWidth_1 - 15;
            activePoint_1.endY = lowerCanvasHeight_1 - 15;
          }
        } else {
          var _c = parent.img, destLeft_2 = _c.destLeft, destTop_2 = _c.destTop, destWidth_2 = _c.destWidth, destHeight_2 = _c.destHeight;
          var lowerCanvasWidth_2 = parent.lowerCanvas.width;
          var lowerCanvasHeight_2 = parent.lowerCanvas.height;
          var activePoint_2 = actPoint;
          activePoint_2.startX = Math.max(destLeft_2 > 0 ? destLeft_2 : 7.5, destLeft_2);
          activePoint_2.startY = Math.max(destTop_2 > 0 ? destTop_2 : 7.5, destTop_2);
          activePoint_2.endX = Math.min(destLeft_2 + destWidth_2 + 15 < lowerCanvasWidth_2 ? destLeft_2 + destWidth_2 - 15 : lowerCanvasWidth_2 - 15, destLeft_2 + destWidth_2);
          activePoint_2.endY = Math.min(destTop_2 + destHeight_2 + 15 < lowerCanvasHeight_2 ? destTop_2 + destHeight_2 - 15 : lowerCanvasHeight_2 - 15, destTop_2 + destHeight_2);
        }
        var _d = parent.img, destLeft = _d.destLeft, destTop = _d.destTop, destWidth = _d.destWidth, destHeight = _d.destHeight;
        var lowerCanvasWidth = parent.lowerCanvas.clientWidth;
        var lowerCanvasHeight = parent.lowerCanvas.clientHeight;
        var activePoint = actPoint;
        activePoint.startX = Math.max(activePoint.startX, destLeft);
        activePoint.startY = Math.max(activePoint.startY, destTop);
        activePoint.endX = Math.min(activePoint.endX, destLeft + destWidth);
        activePoint.endY = Math.min(activePoint.endY, destTop + destHeight);
        if (parent.transform.straighten > 0) {
          if (this.imgCanvasPoints[0].x > activePoint.startX) {
            activePoint.startX = this.imgCanvasPoints[0].x;
          }
          if (this.imgCanvasPoints[0].y > activePoint.startY) {
            activePoint.startY = this.imgCanvasPoints[0].y;
          }
          if (this.imgCanvasPoints[2].x < activePoint.endX) {
            activePoint.endX = this.imgCanvasPoints[2].x;
          }
          if (this.imgCanvasPoints[2].y < activePoint.endY) {
            activePoint.endY = this.imgCanvasPoints[2].x;
          }
        } else if (parent.transform.straighten < 0) {
          if (this.imgCanvasPoints[3].x > activePoint.startX) {
            activePoint.startX = this.imgCanvasPoints[3].x;
          }
          if (this.imgCanvasPoints[3].y < activePoint.startY) {
            activePoint.startY = this.imgCanvasPoints[3].y;
          }
          if (this.imgCanvasPoints[1].x < activePoint.endX) {
            activePoint.endX = this.imgCanvasPoints[1].x;
          }
          if (this.imgCanvasPoints[1].y > activePoint.endY) {
            activePoint.endY = this.imgCanvasPoints[1].x;
          }
        }
        if (activePoint.startX === destLeft && destLeft + destWidth > lowerCanvasWidth) {
          activePoint.endX = lowerCanvasWidth - 15;
        }
        if (activePoint.startY === destTop && destTop + destHeight > lowerCanvasHeight) {
          activePoint.endY = lowerCanvasHeight - 15;
        }
        if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
          var temp = parent.activeObj.activePoint.startX;
          parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
          parent.activeObj.activePoint.endX = temp;
        }
        if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
          var temp = parent.activeObj.activePoint.startY;
          parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
          parent.activeObj.activePoint.endY = temp;
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
        this.updateActiveObject(actPoint, parent.activeObj);
        this.adjActObj();
      }
      this.updateSelectionInsert();
    };
    Draw2.prototype.adjToStraighten = function() {
      var parent = this.parent;
      if (parent.transform.straighten !== 0 && parent.isStraightening) {
        var actPoint = parent.activeObj.activePoint;
        actPoint.startX += 7.5;
        actPoint.startY += 7.5;
        actPoint.endX -= 7.5;
        actPoint.endY -= 7.5;
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
      }
    };
    Draw2.prototype.adjActObj = function() {
      var parent = this.parent;
      if (parent.transform.straighten === 0) {
        return;
      }
      var actPoint = parent.activeObj.activePoint;
      var tempActPoint = extend({}, actPoint, {}, true);
      var count = 0;
      while (true) {
        count++;
        var object = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
        if (object["arr"][0] || object["arr"][1] || object["arr"][2] || object["arr"][3] || count === 100) {
          actPoint = extend({}, tempActPoint, {}, true);
          break;
        }
        tempActPoint = extend({}, actPoint, {}, true);
        actPoint.startX -= 5;
        actPoint.endX += 5;
        actPoint.width = actPoint.endX - actPoint.startX;
        this.updateActiveObject(actPoint, parent.activeObj);
      }
    };
    Draw2.prototype.callUpdateCurrTransState = function() {
      var parent = this.parent;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.isRotateZoom = true;
      this.updateCurrTransState("initial");
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
        parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedPoint.y;
      }
      parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      var temp = this.lowerContext.filter;
      if (parent.transform.degree === 0) {
        parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      }
      this.drawImage();
      this.updateCurrTransState("reverse");
      if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
        parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedPoint.y;
      }
      this.isRotateZoom = false;
      parent.objColl = tempObjColl;
      var tempTogglePen = parent.togglePen;
      parent.togglePen = false;
      this.lowerContext.filter = "none";
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
      });
      parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      parent.img.destLeft -= parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop -= parent.panPoint.totalPannedInternalPoint.y;
      parent.togglePen = tempTogglePen;
      this.lowerContext.filter = temp;
      parent.activeObj = tempActiveObj;
    };
    Draw2.prototype.resetPanPoints = function() {
      this.parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
      this.parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
      this.parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
    };
    Draw2.prototype.setClientTransDim = function(isPreventDimension) {
      var parent = this.parent;
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destHeight) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destWidth + 1) / 2;
        var temp = parent.img.destWidth;
        parent.img.destWidth = parent.img.destHeight;
        parent.img.destHeight = temp;
      } else {
        if (isNullOrUndefined(isPreventDimension)) {
          parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destWidth) / 2;
          parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destHeight + 1) / 2;
        }
      }
    };
    Draw2.prototype.redrawImgWithObj = function() {
      var parent = this.parent;
      var obj = { canvasFilter: parent.canvasFilter };
      this.lowerContext.filter = obj["canvasFilter"];
      if (parent.rotateFlipColl.length !== 0) {
        var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        this.callUpdateCurrTransState();
        parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
      } else {
        this.callUpdateCurrTransState();
      }
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
    };
    Draw2.prototype.setCurrentObj = function(obj, isUndoRedo) {
      var parent = this.parent;
      var isObj = obj ? true : false;
      if (!isObj) {
        parent.cropObj.aspectWidth = parent.aspectWidth;
        parent.cropObj.aspectHeight = parent.aspectHeight;
        parent.cropObj.frame = parent.frameObj.type;
      }
      obj = obj ? obj : parent.cropObj;
      parent.transform.cropZoomFactor = obj.cropZoom;
      parent.transform.defaultZoomFactor = obj.defaultZoom;
      this.straightenInitZoom = obj.straightenZoom;
      if (!isObj) {
        parent.transform.zoomFactor = obj.cropZoom;
      } else {
        if (obj.activeObj.shape && obj.activeObj.shape.split("-")[0] === "crop") {
          parent.transform.zoomFactor = obj.cropZoom;
        } else {
          parent.transform.zoomFactor = obj.defaultZoom;
        }
      }
      parent.setProperties({ zoomSettings: { zoomFactor: obj.zoomFactor } }, true);
      parent.notify("transform", { prop: "setPreviousZoomValue", onPropertyChange: false, value: { previousZoomValue: obj.previousZoomValue } });
      parent.panPoint.totalPannedPoint = extend({}, obj.totalPannedPoint, {}, true);
      parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
      parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
      var point = extend({}, obj.tempFlipPanPoint, {}, true);
      parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point } });
      parent.rotateFlipColl = extend([], obj.rotateFlipColl, [], true);
      parent.transform.degree = obj.degree;
      parent.frameObj.type = obj.frame;
      parent.transform.currFlipState = obj.currFlipState;
      parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.adjustmentLevel } });
      parent.notify("filter", { prop: "setTempAdjVal" });
      parent.currentFilter = obj.currentFilter;
      parent.notify("filter", { prop: "setTempFilVal" });
      if (parent.transform.straighten !== obj.straighten || isUndoRedo) {
        parent.transform.straighten = obj.straighten;
        parent.straightenBaseImageCanvas();
      }
      parent.img = {
        destLeft: obj.destPoints.startX,
        destTop: obj.destPoints.startY,
        destWidth: obj.destPoints.width,
        destHeight: obj.destPoints.height,
        srcLeft: obj.srcPoints.startX,
        srcTop: obj.srcPoints.startY,
        srcWidth: obj.srcPoints.width,
        srcHeight: obj.srcPoints.height
      };
      parent.aspectWidth = obj.aspectWidth;
      parent.aspectHeight = obj.aspectHeight;
      if (obj.afterCropActions) {
        parent.afterCropActions = obj.afterCropActions;
      }
      this.lowerContext.filter = obj.filter;
      parent.notify("filter", { prop: "setBrightnessAdjusted", onPropertyChange: false, value: { isBrightnessAdjusted: obj.isBrightAdjust } });
      var isCircleCrop = parent.isCircleCrop;
      var currSelectionPoint;
      if (isNullOrUndefined(parent.currSelectionPoint)) {
        currSelectionPoint = null;
      } else {
        currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
        parent.currSelectionPoint = null;
      }
      parent.isCircleCrop = false;
      this.drawCropSelectionImage(obj, false);
      if (parent.transform.degree !== 0) {
        if (parent.transform.currFlipState === "") {
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
        } else {
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
        }
        parent.img.destLeft = obj.destPoints.startX;
        parent.img.destTop = obj.destPoints.startY;
        parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
        parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
      }
      parent.activeObj = extend({}, obj.activeObj, {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
        this.drawObject("duplicate", null, null, null, true);
      }
      var activeObj = extend({}, obj.activeObj, {}, true);
      var isAfterCropAction = false;
      if (parent.afterCropActions.length > 0) {
        var object = { collection: parent.afterCropActions };
        parent.notify("shape", {
          prop: "alignRotateFlipColl",
          onPropertyChange: false,
          value: { collection: parent.afterCropActions, isRotateFlipCollection: null, obj: object }
        });
        parent.afterCropActions = object["collection"];
      }
      var afterCropActions = extend([], parent.afterCropActions, [], true);
      if (!isObj && afterCropActions.length > 0) {
        isAfterCropAction = true;
        for (var i = 0, len = afterCropActions.length; i < len; i++) {
          if (afterCropActions[i] === "horizontalflip" || afterCropActions[i] === "verticalflip") {
            parent.activeObj = extend({}, currSelectionPoint, {}, true);
            this.rotatedFlipCropSel = true;
          }
          parent.notify("transform", { prop: "updateTransform", onPropertyChange: false, value: { text: afterCropActions[i] } });
        }
        activeObj = extend({}, parent.activeObj, {}, true);
        this.resetPanPoints();
        parent.activeObj = activeObj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
          this.drawObject("duplicate", null, null, null, true);
        }
        if (obj.degree !== parent.transform.degree) {
          parent.transform.cropZoomFactor = null;
          parent.transform.zoomFactor = 0;
        }
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        if (this.rotatedFlipCropSel) {
          this.rotatedFlipCropSel = false;
        }
      }
      parent.afterCropActions = afterCropActions;
      if (!this.isCancelAction && !isAfterCropAction) {
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.img.destLeft = obj.destPoints.startX;
        parent.img.destTop = obj.destPoints.startY;
      }
      parent.activeObj = activeObj;
      parent.isCircleCrop = isCircleCrop;
      if (isNullOrUndefined(currSelectionPoint)) {
        parent.currSelectionPoint = null;
      } else {
        parent.currSelectionPoint = extend({}, currSelectionPoint, {}, true);
        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
          parent.currSelectionPoint = null;
        }
      }
    };
    Draw2.prototype.drawCropSelectionImage = function(obj, isObj) {
      var parent = this.parent;
      var temp = this.lowerContext.filter;
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
      if (isObj) {
        this.updateCurrTransState("initial");
      } else {
        this.setTransformColl(this.lowerContext, "initial");
      }
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      this.drawImage();
      if (isObj) {
        this.updateCurrTransState("reverse");
      } else {
        this.setTransformColl(this.lowerContext, "reverse");
      }
      parent.img.destLeft = parent.cropObj.destPoints.startX;
      parent.img.destTop = parent.cropObj.destPoints.startY;
      var activeObj = extend({}, obj.activeObj, {}, true);
      this.lowerContext.filter = "none";
      parent.img = {
        destLeft: obj.destPoints.startX,
        destTop: obj.destPoints.startY,
        destWidth: obj.destPoints.width,
        destHeight: obj.destPoints.height,
        srcLeft: obj.srcPoints.startX,
        srcTop: obj.srcPoints.startY,
        srcWidth: obj.srcPoints.width,
        srcHeight: obj.srcPoints.height
      };
      if (obj.activeObj.activePoint.width !== 0 && obj.activeObj.activePoint.height !== 0) {
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.img.destLeft = obj.activeObj.activePoint.startX;
        parent.img.destTop = obj.activeObj.activePoint.startY;
        parent.img.destWidth = obj.activeObj.activePoint.width;
        parent.img.destHeight = obj.activeObj.activePoint.height;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
      }
      parent.activeObj = activeObj;
      this.lowerContext.filter = temp;
    };
    Draw2.prototype.performPointZoom = function(x, y, type, isResize, value) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var ratioX = (x - destLeft) / destWidth;
      var ratioY = (y - destTop) / destHeight;
      var isUndoRedo = parent.isUndoRedo;
      parent.isUndoRedo = true;
      parent.setProperties({ zoomSettings: { zoomPoint: { x, y } } }, true);
      var zoomValue = value ? value : type === "zoomIn" ? 0.1 : -0.1;
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: zoomValue, zoomPoint: null, isResize }
      });
      parent.isUndoRedo = isUndoRedo;
      this.panToPoint(x, y, ratioX, ratioY);
    };
    Draw2.prototype.panToPoint = function(x, y, ratioX, ratioY) {
      var parent = this.parent;
      if (parent.transform.zoomFactor > 0) {
        var destLeft = parent.img.destLeft;
        var destTop = parent.img.destTop;
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (parent.transform.degree === 0) {
          parent.img.destLeft = x - ratioX * parent.img.destWidth;
          parent.img.destTop = y - ratioY * parent.img.destHeight;
          this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
        } else {
          var isCropTab = parent.isCropTab;
          parent.isCropTab = true;
          var objColl = extend([], parent.objColl, [], true);
          var pointColl = extend([], parent.pointColl, [], true);
          var straightenObj = { straightenPoint: null };
          parent.notify("freehand-draw", {
            prop: "getStraightenPoint",
            onPropertyChange: false,
            value: { obj: straightenObj }
          });
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          parent.notify("freehand-draw", {
            prop: "setStraightenPoint",
            onPropertyChange: false,
            value: { x: null, y: null, ratioX: null, ratioY: null }
          });
          var object = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: object }
          });
          var cropSelPointColl = object["selPointColl"];
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.panPoint.currentPannedPoint = {
            x: x - ratioX * parent.img.destWidth - destLeft,
            y: y - ratioY * parent.img.destHeight - destTop
          };
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
          parent.isCropTab = isCropTab;
          parent.objColl = objColl;
          parent.pointColl = pointColl;
          parent.freehandCounter = parent.pointColl.length;
          if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
            parent.notify("freehand-draw", {
              prop: "setStraightenPoint",
              onPropertyChange: false,
              value: {
                x: straightenObj["straightenPoint"]["x"],
                y: straightenObj["straightenPoint"]["y"],
                ratioX: straightenObj["straightenPoint"]["ratioX"],
                ratioY: straightenObj["straightenPoint"]["ratioY"]
              }
            });
          }
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } }
          });
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: {
              ctx: this.lowerContext,
              shape: "pan",
              pen: "pan",
              x: parent.panPoint.currentPannedPoint.x,
              y: parent.panPoint.currentPannedPoint.y,
              panRegion: ""
            }
          });
        }
        this.adjustPanning(activeObj);
        parent.activeObj = activeObj;
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
          this.drawObject("duplicate", null, null, null, true);
        }
      }
    };
    Draw2.prototype.adjustPanning = function(activeObj) {
      var parent = this.parent;
      var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      if (width !== 0 && height !== 0) {
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        var point = { x: 0, y: 0 };
        if (destLeft > startX) {
          point.x = destLeft - startX;
        } else if (destLeft + destWidth < startX + width) {
          point.x = destLeft + destWidth - (startX + width);
        }
        if (destTop > startY) {
          point.y = destTop - startY;
        } else if (destTop + destHeight < startY + height) {
          point.y = destTop + destHeight - (startY + height);
        }
        if (parent.transform.degree === 0) {
          parent.img.destLeft -= point.x;
          parent.img.destTop -= point.y;
          this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
        } else {
          var isCropTab = parent.isCropTab;
          parent.isCropTab = true;
          var objColl = extend([], parent.objColl, [], true);
          var pointColl = extend([], parent.pointColl, [], true);
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          var object = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: object }
          });
          var cropSelPointColl = object["selPointColl"];
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.img.destLeft -= point.x;
          parent.img.destTop -= point.y;
          parent.panPoint.currentPannedPoint = { x: parent.img.destLeft - destLeft, y: parent.img.destTop - destTop };
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
          parent.isCropTab = isCropTab;
          parent.objColl = objColl;
          parent.pointColl = pointColl;
          parent.freehandCounter = parent.pointColl.length;
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } }
          });
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: {
              ctx: this.lowerContext,
              shape: "pan",
              pen: "pan",
              x: parent.panPoint.currentPannedPoint.x,
              y: parent.panPoint.currentPannedPoint.y,
              panRegion: ""
            }
          });
        }
      }
    };
    Draw2.prototype.panToSel = function() {
      var parent = this.parent;
      var activeObj = extend({}, parent.activeObj, {}, true);
      var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", {
        prop: "getStraightenPoint",
        onPropertyChange: false,
        value: { obj: straightenObj }
      });
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        var panX = startX + width / 2 - straightenObj["straightenPoint"]["x"];
        var panY = startY + height / 2 - straightenObj["straightenPoint"]["y"];
        if (parent.transform.degree === 0) {
          parent.img.destLeft += panX;
          parent.img.destTop += panY;
          parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
        } else {
          parent.panPoint.currentPannedPoint = { x: panX, y: panY };
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          parent.notify("transform", { prop: "setTempPanMove", value: { point: null } });
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
        var _b = parent.img, destLeft_3 = _b.destLeft, destTop_3 = _b.destTop, destWidth_3 = _b.destWidth, destHeight_3 = _b.destHeight;
        var points = this.imgCanvasPoints;
        points.forEach(function(point) {
          point.x = point.ratioX * destWidth_3 + destLeft_3;
          point.y = point.ratioY * destHeight_3 + destTop_3;
        });
        this.imgCanvasPoints = points;
        var count = 0;
        if (parent.transform.straighten === 3 && !this.preventStraightening) {
          this.preventStraightening = true;
          var temp = parent.prevStraightenedDegree;
          parent.prevStraightenedDegree = parent.transform.straighten;
          parent.setStraighten(0);
          parent.setStraighten(3);
          parent.prevStraightenedDegree = temp;
          this.preventStraightening = false;
        }
        while (this.isLinesIntersect() && parent.transform.straighten !== 0 && parent.transform.straighten !== 360 && count < 100) {
          count++;
          this.performPointZoom(parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2, parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2, "zoomIn", false, 0.025);
          this.updateImgCanvasPoints();
        }
      }
    };
    Draw2.prototype.drawZoomPanImage = function(x, y) {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "pan", pen: "pan", x, y, panRegion: "" }
      });
      this.renderImage(true);
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.panPoint.totalPannedPoint.x += x;
      parent.panPoint.totalPannedPoint.y += y;
      parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point: { x: 0, y: 0 } } });
    };
    Draw2.prototype.openNewImage = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var inMemoryContext = parent.inMemoryCanvas.getContext("2d");
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var toolbar = document.querySelector("#" + id + "_currPos");
      if (toolbar) {
        toolbar.style.display = "none";
      }
      var obj = { defToolbarItems: null };
      parent.notify("toolbar", { prop: "getDefToolbarItems", value: { obj } });
      if (obj["defToolbarItems"].length === 0 && isNullOrUndefined(document.getElementById(id + "_toolbar")) && parent.element.querySelector("#" + id + "_toolbarArea")) {
        var height = parent.element.querySelector("#" + id + "_toolbarArea").clientHeight;
        parent.notify("toolbar", { prop: "setToolbarHeight", value: { height } });
      }
      parent.reset();
      parent.update();
      parent.transform.degree = 0;
      parent.transform.zoomFactor = 0;
      parent.isImageLoaded = false;
      parent.currSelectionPoint = null;
      var type = typeof this.openURL;
      if (type === "string") {
        var fileName = this.openURL.split(".");
        if (fileName.length > 1) {
          fileName = fileName[fileName.length - 2].split("/");
          this.fileName = fileName[fileName.length - 1];
        } else {
          this.fileName = "ImageEditor";
        }
        this.fileType = this.getFileExtensionFromURL(this.openURL);
        if (this.fileType) {
          this.fileType = parent.toPascalCase(this.fileType);
          var fileType = this.fileType.toLowerCase();
          if (fileType === "jpg" || fileType === "jpeg") {
            this.fileType = "Jpeg";
            fileType = "jpeg";
          }
          if (fileType !== "jpeg" && fileType !== "png" && fileType !== "svg") {
            this.fileType = null;
          }
        }
        this.imageOnLoad(this.openURL);
        if (typeof this.openURL !== "string" || this.openURL.indexOf("localhost") === -1) {
          this.getImageSizeFromURL(this.openURL.toString(), function(imageSizeMB) {
            if (imageSizeMB !== null) {
              _this.parent.notify("toolbar", { prop: "setInitialSize", value: { value: +imageSizeMB } });
            }
          });
        }
      } else {
        this.fileName = "ImageEditor";
        this.fileType = null;
        parent.lowerCanvas = document.querySelector("#" + id + "_lowerCanvas");
        parent.upperCanvas = document.querySelector("#" + id + "_upperCanvas");
        this.lowerContext = parent.lowerCanvas.getContext("2d");
        this.upperContext = parent.upperCanvas.getContext("2d");
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        parent.clearContext(inMemoryContext);
        parent.inMemoryCanvas.width = this.openURL.width;
        parent.inMemoryCanvas.height = this.openURL.height;
        inMemoryContext.putImageData(this.openURL, 0, 0);
        parent.baseImg.src = parent.inMemoryCanvas.toDataURL();
      }
    };
    Draw2.prototype.getImageSizeFromURL = function(imageUrl, callback) {
      return __awaiter(this, void 0, void 0, function() {
        var response, contentLength, imageSizeMB, ex_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, fetch(imageUrl, { method: "HEAD" })];
            case 1:
              response = _a.sent();
              contentLength = parseInt(response.headers.get("content-length") || "0", 10);
              imageSizeMB = contentLength;
              callback(imageSizeMB);
              return [3, 3];
            case 2:
              ex_1 = _a.sent();
              return [3, 3];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Draw2.prototype.dlgBtnClick = function() {
      this.parent.export();
      this.applyDialogOption();
    };
    Draw2.prototype.dlgCloseBtnClick = function() {
      this.applyDialogOption();
    };
    Draw2.prototype.applyDialogOption = function() {
      var parent = this.parent;
      if (this.isFileChanged) {
        parent.isImageLoaded = this.isFileChanged = false;
        parent.reset();
        this.checkToolbarTemplate(this.inputElem, this.openURL);
      } else {
        this.reset();
        this.openNewImage();
      }
      getComponent(document.getElementById(parent.element.id + "_dialog"), "dialog").destroy();
      this.isImageEdited = false;
    };
    Draw2.prototype.showDialogPopup = function() {
      var parent = this.parent;
      var headerObj = { key: "ConfirmDialogHeader" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
      var contentObj = { key: "ConfirmDialogContent" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
      var yesObj = { key: "Yes" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: yesObj } });
      var noObj = { key: "No" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: noObj } });
      parent.element.querySelector("#" + parent.element.id + "_dialog").style.display = "block";
      var dialog = new Dialog({
        header: headerObj["value"],
        closeOnEscape: true,
        content: "<span>" + contentObj["value"] + "</span>",
        target: document.getElementById("target"),
        width: "285px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        close: this.dlgCloseBtnClick.bind(this),
        buttons: [
          {
            click: this.dlgCloseBtnClick.bind(this),
            buttonModel: { content: noObj["value"], iconCss: "e-icons e-close" }
          },
          {
            click: this.dlgBtnClick.bind(this),
            buttonModel: { content: yesObj["value"], isPrimary: true, iconCss: "e-icons e-check" }
          }
        ]
      });
      dialog.appendTo("#" + parent.element.id + "_dialog");
    };
    Draw2.prototype.restoreOldImage = function() {
      if (this.parent.isImageLoaded) {
        this.reset();
        this.openNewImage();
      } else {
        this.openNewImage();
      }
    };
    Draw2.prototype.open = function(data) {
      var dropArea = document.getElementById(this.parent.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "none";
      }
      if (!this.parent.disabled) {
        this.openURL = data;
        this.restoreOldImage();
      }
    };
    Draw2.prototype.getInitialLoaded = function(object) {
      object["isInitialLoaded"] = this.isInitialLoading;
    };
    Draw2.prototype.getFileExtensionFromURL = function(url) {
      var lastDotIndex = url.lastIndexOf(".");
      if (lastDotIndex !== -1) {
        return url.slice(lastDotIndex + 1).toLowerCase();
      } else if (url.indexOf("base64") !== -1) {
        return url.slice(url.indexOf("/") + 1, url.indexOf(";")).toLowerCase();
      }
      return null;
    };
    Draw2.prototype.fileSelect = function(inputElement, args) {
      var parent = this.parent;
      var dropArea = document.getElementById(parent.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "none";
      }
      if (!parent.disabled) {
        var filesData = void 0;
        var fileData = void 0;
        if (args.target) {
          filesData = args.target.files[0];
          fileData = filesData;
        } else {
          filesData = fileData = args.filesData[0].rawFile;
        }
        var fileExtension = void 0;
        if (fileData.name) {
          var fileExtensionArray = fileData.name.split(".");
          fileExtension = fileExtensionArray[fileExtensionArray.length - 1].toLowerCase();
        }
        if (fileExtension && ["jpg", "jpeg", "png", "svg"].indexOf(fileExtension) === -1) {
          this.errorLoading();
          return;
        }
        showSpinner(parent.element);
        parent.element.style.opacity = "0.5";
        this.inputElem = inputElement;
        fileExtension = fileData.name && fileData.name.split(".")[1];
        if (fileExtension) {
          var fileType = parent.toPascalCase(fileExtension);
          if (fileType === "JPG" || fileType === "Jpg") {
            this.fileType = "Jpeg";
          } else {
            this.fileType = fileType;
          }
        } else {
          this.fileType = null;
        }
        var URL_1 = window.URL;
        var url = URL_1.createObjectURL(filesData);
        this.openURL = url;
        if (parent.isImageLoaded && !parent.isChangesSaved && (this.isImageEdited || parent.pointColl.length > 0 || parent.objColl.length > 0)) {
          this.isFileChanged = true;
          this.showDialogPopup();
        } else {
          this.checkToolbarTemplate(inputElement, url);
        }
      }
    };
    Draw2.prototype.checkToolbarTemplate = function(inputElement, url) {
      var parent = this.parent;
      if (isNullOrUndefined(parent.toolbarTemplate)) {
        parent.reset();
        parent.update();
      }
      this.fileName = inputElement.value.split("\\")[inputElement.value.split("\\").length - 1];
      this.fileName = this.fileName.split(".")[0];
      this.imageOnLoad(url.toString());
      inputElement.value = "";
    };
    Draw2.prototype.moveToSelectionRange = function(type, activeObj) {
      var parent = this.parent;
      if (parent.activeObj.shape) {
        var isRotated = false;
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          var degree = parent.rotateFlipColl[i];
          if (degree === 90 || degree === -90) {
            isRotated = true;
            break;
          }
        }
        if (isRotated) {
          if (parent.transform.degree === 0) {
            return;
          }
          var zoomFactor = parent.transform.zoomFactor;
          parent.objColl.push(parent.activeObj);
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          var currObj = parent.objColl[parent.objColl.length - 1];
          if (type === "rotateleft" || type === "rotateright") {
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
              if (currObj.activePoint.width < activeObj.activePoint.height) {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.width >= activeObj.activePoint.height || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: -0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor += 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              } else {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.width >= activeObj.activePoint.height || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: 0.1, zoomPoint: null, isResize: null }
                      });
                    }
                    break;
                  }
                  zoomFactor -= 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              }
            } else {
              if (currObj.activePoint.height < activeObj.activePoint.width) {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.height >= activeObj.activePoint.width || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: -0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor += 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              } else {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.height >= activeObj.activePoint.width || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: 0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor -= 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              }
            }
          }
          var panX = parent.lowerCanvas.clientWidth / 2 - (currObj.activePoint.startX + currObj.activePoint.width / 2);
          var panY = (parent.lowerCanvas.clientHeight + 1) / 2 - (currObj.activePoint.startY + currObj.activePoint.height / 2);
          if (isNullOrUndefined(parent.activeObj.shape)) {
            parent.activeObj = extend({}, activeObj, {}, true);
          }
          if (parent.transform.degree === 0) {
            parent.img.destLeft += panX;
            parent.img.destTop += panY;
            parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
          } else {
            parent.panPoint.currentPannedPoint = { x: panX, y: panY };
            parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          }
          parent.notify("transform", {
            prop: "setTempPanMove",
            onPropertyChange: false,
            value: { point: null }
          });
          parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1]);
          parent.objColl.pop();
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
      }
    };
    Draw2.prototype.isSelectionBiggerThanCanvas = function(obj) {
      var isBigger = false;
      var parent = this.parent;
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
      if (startX <= destLeft || startY <= destTop || endX >= destLeft + destWidth || endY >= destTop + destHeight) {
        isBigger = true;
      }
      return isBigger;
    };
    Draw2.prototype.isSelectionOutsideCanvas = function(obj) {
      var isOutside = false;
      var parent = this.parent;
      if (obj.activePoint.height < parent.lowerCanvas.height - parent.toolbarHeight || obj.activePoint.width < parent.lowerCanvas.width) {
        isOutside = true;
      }
      return isOutside;
    };
    Draw2.prototype.downScaleImgCanvas = function(ctx, isImgAnnotation, isHFlip, isVFlip) {
      var parent = this.parent;
      var canvas = isImgAnnotation ? parent.activeObj.imageCanvas : parent.baseImgCanvas;
      var img = isImgAnnotation ? parent.activeObj.imageElement : parent.baseImg;
      var width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.img.destWidth;
      var height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.img.destHeight;
      var obj = { width: 0, height: 0 };
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: img.height, height: img.width, obj, isImgShape: isImgAnnotation }
        });
      } else {
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: img.width, height: img.height, obj, isImgShape: isImgAnnotation }
        });
      }
      if (isImgAnnotation || parent.allowDownScale && !parent.isCropTab && !parent.isCropToolbar && img.width !== 0 && img.height !== 0 && obj["width"] * 0.75 > width && obj["height"] * 0.75 > height) {
        var tempCanvas = parent.createElement("canvas", {
          id: parent.element.id + "_downScaleCanvas",
          attrs: { name: "canvasImage" }
        });
        tempCanvas.width = isImgAnnotation ? img.width : parent.img.srcWidth;
        tempCanvas.height = isImgAnnotation ? img.height : parent.img.srcHeight;
        if (isImgAnnotation) {
          tempCanvas.getContext("2d").drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
        } else {
          tempCanvas.getContext("2d").drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
        }
        if (isImgAnnotation || this.isDownScale) {
          this.downScale(tempCanvas, width, height, isImgAnnotation);
        }
        if (isImgAnnotation) {
          ctx.canvas.width = tempCanvas.width;
          ctx.canvas.height = tempCanvas.height;
          if (isHFlip && isVFlip) {
            ctx.translate(parent.activeObj.imageCanvas.width, 0);
            ctx.scale(-1, 1);
            ctx.translate(0, parent.activeObj.imageCanvas.height);
            ctx.scale(1, -1);
          } else {
            if (isHFlip) {
              if (isNullOrUndefined(parent.activeObj.isHorImageFlip) || !parent.activeObj.isHorImageFlip) {
                parent.activeObj.isHorImageFlip = true;
                ctx.translate(parent.activeObj.imageCanvas.width, 0);
                ctx.scale(-1, 1);
              } else if (parent.activeObj.isHorImageFlip) {
                parent.activeObj.isHorImageFlip = false;
              }
              if (parent.activeObj.isVerImageFlip) {
                ctx.translate(0, parent.activeObj.imageCanvas.height);
                ctx.scale(1, -1);
              }
            } else if (isVFlip) {
              if (isNullOrUndefined(parent.activeObj.isVerImageFlip) || !parent.activeObj.isVerImageFlip) {
                parent.activeObj.isVerImageFlip = true;
                ctx.translate(0, parent.activeObj.imageCanvas.height);
                ctx.scale(1, -1);
              } else if (parent.activeObj.isVerImageFlip) {
                parent.activeObj.isVerImageFlip = false;
              }
              if (parent.activeObj.isHorImageFlip) {
                ctx.translate(parent.activeObj.imageCanvas.width, 0);
                ctx.scale(-1, 1);
              }
            }
          }
          ctx.drawImage(tempCanvas, 0, 0);
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        } else if (parent.isFinetuning) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.drawImage(parent.inMemoryCanvas, 0, 0);
          ctx.restore();
        } else {
          ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, parent.img.destLeft, parent.img.destTop, tempCanvas.width, tempCanvas.height);
        }
      } else {
        if ((isNullOrUndefined(isImgAnnotation) || !isImgAnnotation) && parent.baseImgCanvas.width !== 0 && parent.baseImgCanvas.height !== 0) {
          ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        }
      }
    };
    Draw2.prototype.downScale = function(canvas, width, height, isImgAnnotation) {
      var parent = this.parent;
      if (isImgAnnotation && parent.isStraightening) {
        return;
      }
      var widthSource = canvas.width;
      var heightSource = canvas.height;
      width = Math.round(width);
      height = Math.round(height);
      var widthRatio = widthSource / width;
      var heightRatio = heightSource / height;
      var halfWidthRatio = Math.ceil(widthRatio / 2);
      var halfHeightRatio = Math.ceil(heightRatio / 2);
      var ctx = canvas.getContext("2d");
      var img = ctx.getImageData(0, 0, widthSource, heightSource);
      var img2 = ctx.createImageData(width, height);
      var data = img.data;
      var data2 = img2.data;
      for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
          var x2 = (i + j * width) * 4;
          var weight = 0;
          var weights = 0;
          var alphaWeights = 0;
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          var centerY = (j + 0.5) * heightRatio;
          var startY = Math.floor(j * heightRatio);
          var stopY = Math.ceil((j + 1) * heightRatio);
          for (var y = startY; y < stopY; y++) {
            var dy = Math.abs(centerY - (y + 0.5)) / halfHeightRatio;
            var centerX = (i + 0.5) * widthRatio;
            var w0 = dy * dy;
            var startX = Math.floor(i * widthRatio);
            var stopX = Math.ceil((i + 1) * widthRatio);
            for (var x = startX; x < stopX; x++) {
              var dx = Math.abs(centerX - (x + 0.5)) / halfWidthRatio;
              var w = Math.sqrt(w0 + dx * dx);
              if (w >= 1) {
                continue;
              }
              weight = 2 * w * w * w - 3 * w * w + 1;
              var xPos = 4 * (x + y * widthSource);
              a += weight * data[xPos + 3];
              alphaWeights += weight;
              weight = weight * data[xPos + 3] / 250;
              r += weight * data[xPos];
              g += weight * data[xPos + 1];
              b += weight * data[xPos + 2];
              weights += weight;
            }
          }
          data2[x2] = r / weights;
          data2[x2 + 1] = g / weights;
          data2[x2 + 2] = b / weights;
          data2[x2 + 3] = a / alphaWeights;
        }
      }
      canvas.width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.lowerCanvas.width;
      canvas.height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.lowerCanvas.height;
      ctx.putImageData(img2, 0, 0);
    };
    Draw2.prototype.drawImgToCtx = function(ctx, preventImg) {
      var parent = this.parent;
      if (ctx.canvas.id !== parent.element.id + "_tempCanvas" && ctx !== this.upperContext && isNullOrUndefined(preventImg)) {
        this.downScaleImgCanvas(ctx, null, null, null);
      }
    };
    Draw2.prototype.getFrameColor = function(frameObj, ctx, points) {
      var parent = this.parent;
      var color = parent.frameObj.color;
      if (frameObj.gradientColor) {
        var gradient = ctx.createLinearGradient(points.startX, points.startY, points.startX + points.width, points.startY + points.height);
        gradient.addColorStop(0, frameObj.color);
        gradient.addColorStop(1, frameObj.gradientColor);
        color = gradient;
      } else {
        color = frameObj.color;
      }
      return color;
    };
    Draw2.prototype.applyFrame = function(ctx, frame, preventImg) {
      var parent = this.parent;
      parent.frameObj.type = frame;
      var tempLineWidth;
      var ratio = { width: 1, height: 1 };
      var points = {
        startX: parent.img.destLeft - ctx.lineWidth,
        startY: parent.img.destTop - ctx.lineWidth,
        width: parent.img.destWidth + 2 * ctx.lineWidth,
        height: parent.img.destHeight + 2 * ctx.lineWidth
      };
      var frameObj = {
        type: parent.frameObj.type,
        color: parent.frameObj.color,
        size: parent.frameObj.size,
        inset: parent.frameObj.inset,
        offset: parent.frameObj.offset / 2,
        radius: parent.frameObj.radius,
        amount: parent.frameObj.amount,
        border: parent.frameObj.border,
        gradientColor: parent.frameObj.gradientColor
      };
      var zoomFactor = parent.transform.zoomFactor;
      if (ctx.canvas.id === parent.element.id + "_tempCanvas") {
        var newWidth = ctx.canvas.width;
        var newHeight = ctx.canvas.height;
        var obj = { width: 0, height: 0 };
        parent.notify("crop", {
          prop: "calcRatio",
          onPropertyChange: false,
          value: { obj, dimension: { width: newWidth, height: newHeight } }
        });
        ratio = obj;
        frameObj.size *= (ratio.width + ratio.height) / 2;
        frameObj.inset *= (ratio.width + ratio.height) / 2;
        frameObj.offset *= (ratio.width + ratio.height) / 2;
        frameObj.radius *= (ratio.width + ratio.height) / 2;
        points = { startX: 0, startY: 0, width: ctx.canvas.width, height: ctx.canvas.height };
        parent.notify("export", { prop: "updateSaveContext", onPropertyChange: false, value: { context: ctx } });
      } else if (ctx === this.upperContext && parent.activeObj.shape) {
        points = { startX: parent.activeObj.activePoint.startX - ctx.lineWidth, startY: parent.activeObj.activePoint.startY - ctx.lineWidth, width: parent.activeObj.activePoint.width + 2 * ctx.lineWidth, height: parent.activeObj.activePoint.height + 2 * ctx.lineWidth };
      } else if (isNullOrUndefined(preventImg)) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      var valueForty = 40 * ((ratio.width + ratio.height) / 2);
      var valueFifty = 50 * ((ratio.width + ratio.height) / 2);
      if (ctx !== this.upperContext) {
        frameObj.size += frameObj.size * zoomFactor;
        frameObj.inset += frameObj.inset * zoomFactor;
        frameObj.offset += frameObj.offset * zoomFactor;
        frameObj.radius += frameObj.radius * zoomFactor;
        valueForty += valueForty * zoomFactor;
        valueFifty += valueFifty * zoomFactor;
      }
      if (ctx === this.upperContext && parent.activeObj.shape) {
        if (frame === "mat" && (points.width - 2 * frameObj.size < 0 || points.height - 2 * frameObj.size < 0) || frame === "bevel" && (points.width - 2 * frameObj.size < 40 || points.height - 2 * frameObj.size < 40) || frame === "inset" && (points.startX + points.width - frameObj.offset - (points.startX + frameObj.offset) < 0 || points.startY + points.height - frameObj.offset - (points.startY + frameObj.offset) < 0) || frame === "hook" && (points.width - 2 * frameObj.size < 50 || points.height - 2 * frameObj.size < 50)) {
          return;
        }
      }
      var bevelObj = { bevelFilter: ctx.filter };
      var filter = ctx.filter;
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop || ctx === this.lowerContext && parent.isCropTab) {
        this.drawImgToCtx(ctx, preventImg);
      } else {
        switch (frame) {
          case "none":
            this.drawImgToCtx(ctx, preventImg);
            break;
          case "mat":
            this.drawImgToCtx(ctx, preventImg);
            while ((points.width - 2 * frameObj.size < 0 || points.height - 2 * frameObj.size < 0) && frameObj.size > 0) {
              frameObj.size -= 20;
            }
            ctx.filter = "none";
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.beginPath();
            ctx.rect(points.startX, points.startY, points.width, points.height);
            ctx.rect(points.startX + frameObj.size, points.startY + frameObj.size, points.width - 2 * frameObj.size, points.height - 2 * frameObj.size);
            ctx.fill("evenodd");
            ctx.closePath();
            break;
          case "bevel":
            ctx.filter = "none";
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.beginPath();
            ctx.fillRect(points.startX, points.startY, points.width, points.height);
            ctx.closePath();
            points.startX += frameObj.size;
            points.startY += frameObj.size;
            points.width -= 2 * frameObj.size;
            points.height -= 2 * frameObj.size;
            while ((points.width - 2 * frameObj.size < 40 || points.height - 2 * frameObj.size < 40) && frameObj.size > 0) {
              points.startX -= frameObj.size;
              points.startY -= frameObj.size;
              points.width += 2 * frameObj.size;
              points.height += 2 * frameObj.size;
              frameObj.size -= 20;
              points.startX += frameObj.size;
              points.startY += frameObj.size;
              points.width -= 2 * frameObj.size;
              points.height -= 2 * frameObj.size;
            }
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(points.startX + valueForty, points.startY);
            ctx.lineTo(points.startX + points.width - valueForty, points.startY);
            ctx.quadraticCurveTo(points.startX + points.width, points.startY, points.startX + points.width, points.startY + valueForty);
            ctx.lineTo(points.startX + points.width, points.startY + points.height - valueForty);
            ctx.quadraticCurveTo(points.startX + points.width, points.startY + points.height, points.startX + points.width - valueForty, points.startY + points.height);
            ctx.lineTo(points.startX + valueForty, points.startY + points.height);
            ctx.quadraticCurveTo(points.startX, points.startY + points.height, points.startX, points.startY + points.height - valueForty);
            ctx.lineTo(points.startX, points.startY + valueForty);
            ctx.quadraticCurveTo(points.startX, points.startY, points.startX + valueForty, points.startY);
            ctx.closePath();
            ctx.clip();
            ctx.filter = filter === "none" ? parent.canvasFilter : filter;
            if (ctx.canvas.id === parent.element.id + "_tempCanvas") {
              preventImg = null;
              ctx.filter = "none";
              ctx.drawImage(parent.inMemoryCanvas, 0, 0);
              ctx.filter = filter === "none" ? parent.canvasFilter : filter;
            } else {
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              if (preventImg) {
                preventImg = null;
                if (parent.transform.zoomFactor !== 0) {
                  this.isRotateZoom = true;
                }
                parent.notify("filter", { prop: "getBevelFilter", onPropertyChange: false, value: { obj: bevelObj } });
                ctx.filter = bevelObj["bevelFilter"];
                this.updateCurrTransState("initial");
                this.drawImgToCtx(ctx, preventImg);
                this.updateCurrTransState("reverse");
                this.isRotateZoom = false;
                parent.frameObj.type = "none";
                ctx.filter = "none";
                parent.notify("shape", {
                  prop: "drawAnnotations",
                  onPropertyChange: false,
                  value: { ctx, shape: "iterate", pen: "iterate", isPreventApply: null }
                });
                parent.frameObj.type = "bevel";
                ctx.filter = filter === "none" ? parent.canvasFilter : filter;
              } else {
                parent.notify("filter", { prop: "getBevelFilter", onPropertyChange: false, value: { obj: bevelObj } });
                ctx.filter = bevelObj["bevelFilter"];
                this.drawImgToCtx(ctx, preventImg);
              }
            }
            ctx.restore();
            break;
          case "line":
            this.drawImgToCtx(ctx, preventImg);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            for (var i = 0; i < parent.frameObj.amount; i++) {
              if (i > 0) {
                points.startX += frameObj.offset;
                points.startY += frameObj.offset;
                points.width -= 2 * frameObj.offset;
                points.height -= 2 * frameObj.offset;
              }
              var arcY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
              var lineY = points.startY + frameObj.inset + frameObj.radius;
              var arcX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
              var lineX = points.startX + frameObj.inset + frameObj.radius;
              var arcX1 = points.startX + frameObj.inset + frameObj.radius;
              var lineX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
              var arcY1 = points.startY + frameObj.inset + frameObj.radius;
              var lineY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
              if (arcY2 >= lineY && arcX2 >= lineX && arcX1 <= lineX2 && arcY1 <= lineY2) {
                ctx.filter = "none";
                ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
                if (frameObj.border === "dashed") {
                  ctx.setLineDash([ctx.lineWidth * 2.5, ctx.lineWidth * 1.5]);
                } else if (frameObj.border === "dotted") {
                  ctx.setLineDash([ctx.lineWidth, ctx.lineWidth]);
                }
                ctx.beginPath();
                ctx.moveTo(points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset);
                ctx.lineTo(points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + frameObj.inset);
                ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset, points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + frameObj.radius, frameObj.radius);
                ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset - frameObj.radius);
                ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + points.height - frameObj.inset, frameObj.radius);
                ctx.lineTo(points.startX + frameObj.inset + frameObj.radius, points.startY + points.height - frameObj.inset);
                ctx.arcTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - frameObj.radius, frameObj.radius);
                ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + frameObj.radius);
                ctx.arcTo(points.startX + frameObj.inset, points.startY + frameObj.inset, points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset, frameObj.radius);
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
              }
            }
            ctx.lineWidth = tempLineWidth;
            break;
          case "inset":
            this.drawImgToCtx(ctx, preventImg);
            ctx.filter = "none";
            ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            ctx.beginPath();
            ctx.moveTo(points.startX + frameObj.offset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.offset, points.startY + frameObj.inset);
            ctx.moveTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.offset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.offset);
            ctx.moveTo(points.startX + points.width - frameObj.offset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.offset, points.startY + points.height - frameObj.inset);
            ctx.moveTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.offset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.offset);
            ctx.stroke();
            ctx.closePath();
            ctx.lineWidth = tempLineWidth;
            break;
          case "hook":
            this.drawImgToCtx(ctx, preventImg);
            ctx.filter = "none";
            ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            ctx.beginPath();
            ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + valueFifty);
            ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + valueFifty);
            ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
            ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
            ctx.stroke();
            ctx.lineWidth = tempLineWidth;
            break;
        }
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: ctx, isSave: ctx.canvas.id === parent.element.id + "_tempCanvas" ? true : null, isFlip: null }
          });
        }
        ctx.filter = filter;
      }
    };
    Draw2.prototype.triggerFrameChange = function(prevFrameSettings) {
      var parent = this.parent;
      var currFrameSettings = {
        type: parent.toPascalCase(parent.frameObj.type),
        color: parent.frameObj.color,
        gradientColor: parent.frameObj.gradientColor,
        size: parent.frameObj.size,
        inset: parent.frameObj.inset,
        offset: parent.frameObj.offset,
        borderRadius: parent.frameObj.radius,
        frameLineStyle: parent.toPascalCase(parent.frameObj.border),
        lineCount: parent.frameObj.amount
      };
      var frameChange = {
        cancel: false,
        previousFrameSetting: prevFrameSettings,
        currentFrameSetting: currFrameSettings
      };
      parent.trigger("frameChange", frameChange);
      if (!frameChange.cancel) {
        this.setFrameObj(frameChange.currentFrameSetting);
      }
      return frameChange;
    };
    Draw2.prototype.setFrameObj = function(currFrameSettings) {
      var parent = this.parent;
      parent.frameObj.type = currFrameSettings.type.toLowerCase();
      parent.frameObj.color = currFrameSettings.color;
      parent.frameObj.gradientColor = currFrameSettings.gradientColor;
      parent.frameObj.size = currFrameSettings.size;
      parent.frameObj.inset = currFrameSettings.inset;
      parent.frameObj.offset = currFrameSettings.offset;
      parent.frameObj.radius = currFrameSettings.borderRadius;
      parent.frameObj.border = currFrameSettings.frameLineStyle.toLowerCase();
      parent.frameObj.amount = currFrameSettings.lineCount;
    };
    Draw2.prototype.zoomToSel = function(activeObj, isToolbar) {
      var parent = this.parent;
      if (this.straightenActObj && JSON.stringify(this.straightenActObj.activePoint) === JSON.stringify(activeObj.activePoint)) {
        parent.activeObj = extend({}, this.straightenActObj, null, true);
        if (parent.transform.straighten === 0) {
          var destWidth = parent.img.destWidth;
          var destHeight = parent.img.destHeight;
          parent.transform.straighten = 360;
          while (true) {
            if (!isNullOrUndefined(this.straightenInitZoom) && Math.round(parent.transform.zoomFactor * Math.pow(10, 3)) / Math.pow(10, 3) > Math.round(this.straightenInitZoom * Math.pow(10, 3)) / Math.pow(10, 3)) {
              this.setZoomPan("out");
              if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
                this.performDummyZoom();
                break;
              }
              if (parent.transform.degree === 0) {
                parent.transform.zoomFactor -= 0.025;
                parent.transform.cropZoomFactor -= 0.025;
              }
            } else {
              this.performDummyZoom();
              break;
            }
          }
          parent.transform.straighten = 0;
          parent.img = {
            destLeft: parent.img.destLeft,
            destTop: parent.img.destTop,
            destWidth: parent.img.destWidth,
            destHeight: parent.img.destHeight,
            srcLeft: parent.img.srcLeft,
            srcTop: parent.img.srcTop,
            srcWidth: parent.img.srcWidth,
            srcHeight: parent.img.srcHeight
          };
        } else {
          if (isNullOrUndefined(this.straightenInitZoom)) {
            this.straightenInitZoom = parent.transform.zoomFactor;
          }
          if (this.straightenInitZoom - parent.transform.zoomFactor > 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -(this.straightenInitZoom - parent.transform.zoomFactor), zoomPoint: null, isResize: true }
            });
          } else if (this.straightenInitZoom - parent.transform.zoomFactor < 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: this.straightenInitZoom - parent.transform.zoomFactor, zoomPoint: null, isResize: true }
            });
          }
          parent.activeObj = extend({}, activeObj, null, true);
          parent.transform.zoomFactor += 1e-3;
          this.calcStraightenedPoints(isToolbar);
        }
      } else {
        this.straightenActObj = extend({}, activeObj, null, true);
        parent.activeObj = extend({}, this.straightenActObj, null, true);
        this.straightenInitZoom = parent.transform.zoomFactor;
        this.calcStraightenedPoints(isToolbar);
      }
    };
    Draw2.prototype.isDestPointSmall = function() {
      var parent = this.parent;
      var img = parent.img;
      var destPoints = {
        startX: img.destLeft,
        startY: img.destTop,
        width: img.destWidth,
        height: img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var isSmall = false;
      if (this.straightenDestPoints.destWidth && this.straightenDestPoints.destHeight && (img.destWidth < this.straightenDestPoints.destWidth || img.destHeight < this.straightenDestPoints.destHeight)) {
        isSmall = true;
      }
      img.destLeft = destPoints.startX;
      img.destTop = destPoints.startY;
      img.destWidth = destPoints.width;
      img.destHeight = destPoints.height;
      parent.img = img;
      return isSmall;
    };
    Draw2.prototype.calcStraightenedPoints = function(isToolbar) {
      var parent = this.parent;
      var destWidth = parent.img.destWidth;
      var destHeight = parent.img.destHeight;
      if (isNullOrUndefined(parent.transform.zoomFactor)) {
        parent.transform.zoomFactor += 0.025;
      }
      this.updateImgCanvasPoints();
      var _loop_1 = function() {
        if (this_1.isLinesIntersect() || this_1.isSelOutsideImg() || isToolbar && this_1.isDestPointSmall()) {
          parent.activeObj = extend({}, this_1.straightenActObj, null, true);
          this_1.setZoomPan("in");
          if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
            this_1.performDummyZoom();
            return "break";
          }
          if (parent.transform.degree === 0) {
            parent.transform.zoomFactor += 0.025;
            parent.transform.cropZoomFactor += 0.025;
          }
          var points = this_1.imgCanvasPoints;
          var left_1 = parent.img.destLeft;
          var top_1 = parent.img.destTop;
          var width_1 = parent.img.destWidth;
          var height_1 = parent.img.destHeight;
          points.forEach(function(point) {
            point.x = point.ratioX * width_1 + left_1;
            point.y = point.ratioY * height_1 + top_1;
          });
          this_1.imgCanvasPoints = points;
        } else {
          this_1.performDummyZoom();
          return "break";
        }
      };
      var this_1 = this;
      while (true) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
    };
    Draw2.prototype.performDummyZoom = function() {
      var parent = this.parent;
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: 0.025, zoomPoint: null, isResize: true }
      });
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: -0.025, zoomPoint: null, isResize: true }
      });
      var zoom = parent.transform.zoomFactor * 10;
      if (zoom < 1) {
        zoom = 1 + zoom / 10;
      }
      parent.setProperties({ zoomSettings: { zoomFactor: zoom } }, true);
      parent.notify("transform", {
        prop: "setPreviousZoomValue",
        onPropertyChange: false,
        value: { previousZoomValue: zoom }
      });
      this.panToSel();
    };
    Draw2.prototype.setZoomPan = function(type) {
      var parent = this.parent;
      var obj = { maxDimension: null };
      if (parent.transform.degree === 0) {
        parent.notify("transform", {
          prop: "cropZoom",
          onPropertyChange: false,
          value: { value: type === "in" ? 0.025 : -0.025, selectionObj: parent.activeObj, obj }
        });
        parent.img.destWidth = obj["maxDimension"]["width"];
        parent.img.destHeight = obj["maxDimension"]["height"];
      } else {
        parent.transform.zoomFactor += type === "in" ? 0.025 : -0.025;
        parent.transform.cropZoomFactor += type === "in" ? 0.025 : -0.025;
        this.updateCurrTransState("initial");
        this.isRotateZoom = true;
        this.setDestPoints();
        this.isRotateZoom = false;
        this.updateCurrTransState("reverse");
      }
    };
    Draw2.prototype.updateImgCanvasPoints = function() {
      var parent = this.parent;
      var points = this.getImagePoints();
      var obj = { width: 0, height: 0 };
      var width = parent.baseImgCanvas.width;
      var height = parent.baseImgCanvas.height;
      parent.notify("crop", {
        prop: "calcRatio",
        onPropertyChange: false,
        value: { obj, dimension: { width, height } }
      });
      var ratio = obj;
      width = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ? ratio.height : ratio.width;
      height = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ? ratio.width : ratio.height;
      var p1;
      var p2;
      var p3;
      var p4;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.transform.straighten > 0) {
        p1 = { x: destLeft + points[0].x / width, y: destTop };
        p2 = { x: destLeft + destWidth, y: destTop + points[1].y / height };
        p3 = { x: destLeft + destWidth - points[0].x / width, y: destTop + destHeight };
        p4 = { x: destLeft, y: destTop + destHeight - points[1].y / height };
      } else {
        p1 = { x: destLeft, y: destTop + points[0].y / height };
        p2 = { x: destLeft + points[1].x / width, y: destTop };
        p3 = { x: destLeft + destWidth, y: destTop + destHeight - points[0].y / height };
        p4 = { x: destLeft + destWidth - points[1].x / width, y: destTop + destHeight };
      }
      p1.ratioX = (p1.x - destLeft) / destWidth;
      p1.ratioY = (p1.y - destTop) / destHeight;
      p2.ratioX = (p2.x - destLeft) / destWidth;
      p2.ratioY = (p2.y - destTop) / destHeight;
      p3.ratioX = (p3.x - destLeft) / destWidth;
      p3.ratioY = (p3.y - destTop) / destHeight;
      p4.ratioX = (p4.x - destLeft) / destWidth;
      p4.ratioY = (p4.y - destTop) / destHeight;
      this.imgCanvasPoints = [p1, p2, p3, p4];
    };
    Draw2.prototype.isLinesIntersect = function(obj) {
      var parent = this.parent;
      var point = parent.activeObj.activePoint;
      var imgPoints = this.imgCanvasPoints;
      var isTopIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.endX, y: point.startY }, imgPoints[0], imgPoints[1]);
      var isRightIntersect = this.doIntersect({ x: point.endX, y: point.startY }, { x: point.endX, y: point.endY }, imgPoints[1], imgPoints[2]);
      var isBottomIntersect = this.doIntersect({ x: point.startX, y: point.endY }, { x: point.endX, y: point.endY }, imgPoints[2], imgPoints[3]);
      var isLeftIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.startX, y: point.endY }, imgPoints[3], imgPoints[0]);
      var isTopLeftInsideRect = this.isInsideRect(imgPoints[0]);
      var isTopRightInsideRect = this.isInsideRect(imgPoints[1]);
      var isBottomRightInsideRect = this.isInsideRect(imgPoints[2]);
      var isBottomLeftInsideRect = this.isInsideRect(imgPoints[3]);
      if (obj) {
        obj["arr"] = [isTopIntersect, isRightIntersect, isBottomIntersect, isLeftIntersect];
      }
      return isTopIntersect || isRightIntersect || isBottomIntersect || isLeftIntersect || isTopLeftInsideRect || isTopRightInsideRect || isBottomRightInsideRect || isBottomLeftInsideRect || imgPoints[0].x > point.startX && imgPoints[1].x < point.endX && imgPoints[2].x < point.endX && imgPoints[3].x > point.startX && imgPoints[0].y < point.startY && imgPoints[1].y < point.startY && imgPoints[2].y > point.endY && imgPoints[3].y > point.endY || imgPoints[0].x < point.startX && imgPoints[1].x > point.endX && imgPoints[2].x > point.endX && imgPoints[3].x < point.startX && imgPoints[0].y > point.startY && imgPoints[1].y > point.startY && imgPoints[2].y < point.endY && imgPoints[3].y < point.endY;
    };
    Draw2.prototype.isSelOutsideImg = function() {
      var parent = this.parent;
      var points = this.imgCanvasPoints;
      var actPoint = parent.activeObj.activePoint;
      return this.checkPointPosition(actPoint.startX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.endX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.startX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.endX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside";
    };
    Draw2.prototype.calcTriangleArea = function(x1, y1, x2, y2, x3, y3) {
      return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
    };
    Draw2.prototype.checkPointPosition = function(x, y, x1, y1, x2, y2, x3, y3, x4, y4) {
      var area1 = this.calcTriangleArea(x, y, x1, y1, x4, y4);
      var area2 = this.calcTriangleArea(x, y, x4, y4, x3, y3);
      var area3 = this.calcTriangleArea(x, y, x3, y3, x2, y2);
      var area4 = this.calcTriangleArea(x, y, x2, y2, x1, y1);
      var areaRectangle = this.calcTriangleArea(x1, y1, x2, y2, x3, y3) + this.calcTriangleArea(x3, y3, x4, y4, x1, y1);
      if (area1 + area2 + area3 + area4 > areaRectangle) {
        return "outside";
      } else if (area1 + area2 + area3 + area4 === areaRectangle && (area1 === 0 || area2 === 0 || area3 === 0 || area4 === 0)) {
        return "on";
      } else {
        return "inside";
      }
    };
    Draw2.prototype.getImagePoints = function() {
      var point = [];
      var parent = this.parent;
      var degree = parent.transform.degree;
      var width = parent.baseImg.width;
      var height = parent.baseImg.height;
      var obj = { dim: null, width: height, height: width, angle: parent.transform.straighten };
      obj["dim"] = parent.getRotatedCanvasDim(obj["width"], obj["height"], obj["angle"]);
      var baseImgCanvasWidth = degree % 90 === 0 && degree % 180 !== 0 ? obj["dim"]["width"] : parent.baseImgCanvas.width;
      var baseImgCanvasHeight = degree % 90 === 0 && degree % 180 !== 0 ? obj["dim"]["height"] : parent.baseImgCanvas.height;
      var baseImgWidth = degree % 90 === 0 && degree % 180 !== 0 ? height : width;
      var baseImgHeight = degree % 90 === 0 && degree % 180 !== 0 ? width : height;
      var centerX = baseImgCanvasWidth / 2;
      var centerY = baseImgCanvasHeight / 2;
      var startX = centerX - baseImgWidth / 2;
      var startY = centerY - baseImgHeight / 2;
      var endX = centerX + baseImgWidth / 2;
      var endY = centerY + baseImgHeight / 2;
      var center = { x: centerX, y: centerY };
      var radians = parent.transform.straighten * (Math.PI / 180);
      var p1 = {
        x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
        y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (startY - center.y) + center.y
      };
      var p2 = {
        x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
        y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (startY - center.y) + center.y
      };
      var p3 = {
        x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
        y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (endY - center.y) + center.y
      };
      var p4 = {
        x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
        y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (endY - center.y) + center.y
      };
      point.push(p1);
      point.push(p2);
      point.push(p3);
      point.push(p4);
      return point;
    };
    Draw2.prototype.doIntersect = function(a, b, c, d) {
      var point1 = this.initiation(a, b, c);
      var point2 = this.initiation(a, b, d);
      var point3 = this.initiation(c, d, a);
      var point4 = this.initiation(c, d, b);
      if (point1 !== point2 && point3 !== point4) {
        return true;
      }
      if (point1 === 0 && this.onSegment(a, c, b)) {
        return true;
      }
      if (point2 === 0 && this.onSegment(a, d, b)) {
        return true;
      }
      if (point3 === 0 && this.onSegment(c, a, d)) {
        return true;
      }
      if (point4 === 0 && this.onSegment(c, b, d)) {
        return true;
      }
      return false;
    };
    Draw2.prototype.initiation = function(a, b, c) {
      var value = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
      if (value === 0) {
        return 0;
      }
      return value > 0 ? 1 : 2;
    };
    Draw2.prototype.onSegment = function(a, b, c) {
      if (b.x <= Math.max(a.x, c.x) && b.x >= Math.min(a.x, c.x) && b.y <= Math.max(a.y, c.y) && b.y >= Math.min(a.y, c.y)) {
        return true;
      }
      return false;
    };
    Draw2.prototype.isInsideRect = function(point) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var isInside = false;
      if (point.x >= actPoint.startX && point.x <= actPoint.endX && point.y >= actPoint.startY && point.y <= actPoint.endY) {
        isInside = true;
      }
      return isInside;
    };
    Draw2.prototype.setDestForStraighten = function() {
      var parent = this.parent;
      if (isNullOrUndefined(this.straightenDestPoints)) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
        this.straightenDestPoints = extend({}, parent.img, {}, true);
        parent.img.destLeft = destLeft;
        parent.img.destTop = destTop;
        parent.img.destWidth = destWidth;
        parent.img.destHeight = destHeight;
      }
    };
    return Draw2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/export.js
var Export = (
  /** @class */
  function() {
    function Export2(parent) {
      this.parent = parent;
      this.addEventListener();
    }
    Export2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Export2.prototype.addEventListener = function() {
      this.parent.on("export", this.export, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Export2.prototype.removeEventListener = function() {
      this.parent.off("export", this.export);
      this.parent.off("destroyed", this.destroy);
    };
    Export2.prototype.export = function(args) {
      this.parent.notify("toolbar", { prop: "refreshShapeDrawing", onPropertyChange: false });
      this.updatePvtVar();
      switch (args.prop) {
        case "export":
          this.exportImg(args.value["type"], args.value["fileName"], args.value["imgQuality"]);
          break;
        case "exportToCanvas":
          this.exportToCanvas(args.value["object"]);
          break;
        case "updateSaveContext":
          this.updateSaveContext(args.value["context"]);
          break;
        case "setImageQuality":
          this.imageQuality = args.value["value"];
      }
    };
    Export2.prototype.getModuleName = function() {
      return "export";
    };
    Export2.prototype.updatePvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
    };
    Export2.prototype.exportImg = function(type, fileName, imgQuality) {
      var parent = this.parent;
      var obj = { fileName: "" };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj } });
      var imageName = obj["fileName"];
      if (!parent.disabled && parent.isImageLoaded) {
        var dummyObj = { bool: false };
        parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: dummyObj } });
        if (dummyObj["bool"]) {
          parent.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
        }
        if (parent.togglePen) {
          parent.currObjType.isZoomed = true;
          parent.notify("shape", { prop: "apply", onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
        }
        if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
          parent.notify("shape", {
            prop: "redrawActObj",
            onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: null }
          });
        }
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        var obj_1 = { canvasFilter: this.parent.canvasFilter };
        this.lowerContext.filter = obj_1["canvasFilter"];
        type = type ? type : "Png";
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        var beforeSave = {
          cancel: false,
          fileName: fileName ? fileName : imageName,
          fileType: type,
          imageQuality: imgQuality
        };
        parent.trigger("beforeSave", beforeSave);
        this.beforeSaveEvent(beforeSave, type, fileName, imageName, imgQuality);
      }
    };
    Export2.prototype.beforeSaveEvent = function(observableSaveArgs, type, fileName, imageName, imgQuality) {
      var parent = this.parent;
      if (!observableSaveArgs.cancel) {
        parent.currObjType.isSave = true;
        fileName = observableSaveArgs.fileName ? observableSaveArgs.fileName : fileName;
        var lowerCaseType = type.toLowerCase();
        fileName = fileName || imageName;
        if (lowerCaseType === "svg") {
          this.toSVGImg(fileName);
        } else {
          this.toBlobFn(fileName, lowerCaseType, imgQuality);
        }
        var saved = { fileName: fileName ? fileName : imageName, fileType: type };
        parent.trigger("saved", saved);
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.lowerCanvas.style.left = parent.upperCanvas.style.left = "";
        parent.lowerCanvas.style.top = parent.upperCanvas.style.top = "";
        parent.lowerCanvas.style.maxWidth = parent.upperCanvas.style.maxWidth = "";
        parent.lowerCanvas.style.maxHeight = parent.upperCanvas.style.maxHeight = "";
      }
    };
    Export2.prototype.toSVGImg = function(fileName) {
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var tempCanvas = this.exportToCanvas();
      var dataUrl = tempCanvas.toDataURL();
      hideSpinner(parent.element);
      parent.element.style.opacity = "1";
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", tempCanvas.style.maxWidth);
      svg.setAttribute("height", tempCanvas.style.maxHeight);
      var XLinkNS = "http://www.w3.org/1999/xlink";
      var img = document.createElementNS("http://www.w3.org/2000/svg", "image");
      img.setAttributeNS(null, "height", tempCanvas.height.toString());
      img.setAttributeNS(null, "width", tempCanvas.width.toString());
      img.setAttributeNS(XLinkNS, "xlink:href", dataUrl);
      svg.appendChild(img);
      var prefix = "data:image/svg+xml;base64,";
      var header = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"' + (' width="' + tempCanvas.width + '"') + (' height="' + tempCanvas.height + '"') + ">";
      var footer = "</svg>";
      var body = svg.innerHTML;
      var data = header + body + footer;
      var svgDataUrl = prefix + btoa(data);
      if (fileName === null) {
        return svgDataUrl;
      } else {
        this.downloadImg(svgDataUrl, fileName + ".svg");
        return null;
      }
    };
    Export2.prototype.toBlobFn = function(fileName, type, imgQuality) {
      var proxy = this;
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      if (!isNullOrUndefined(imgQuality)) {
        imgQuality = imgQuality > 1 ? 1 : imgQuality <= 0 ? 0.01 : imgQuality;
        this.imageQuality = imgQuality ? imgQuality : null;
      }
      var tempCanvas = this.exportToCanvas();
      var imagetype = type !== "jpeg" ? "image/png" : "image/jpeg";
      tempCanvas.toBlob(function(blob) {
        var blobUrl = URL.createObjectURL(blob);
        proxy.downloadImg(blobUrl, fileName + "." + type);
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
      }, imagetype, this.imageQuality ? this.imageQuality : null);
    };
    Export2.prototype.exportToCanvas = function(object) {
      var parent = this.parent;
      var width;
      var height;
      var tempCropObj = extend({}, parent.cropObj, {}, true);
      var tempObj = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: tempObj } });
      var prevObj = tempObj["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      if (this.parent.aspectWidth) {
        parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
        parent.notify("toolbar", { prop: "resizeClick", value: { bool: false } });
        parent.okBtn();
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
          width = this.parent.aspectHeight;
          height = this.parent.aspectWidth;
        } else {
          width = this.parent.aspectWidth;
          height = this.parent.aspectHeight;
        }
        parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
      } else if (parent.currSelectionPoint) {
        width = parent.img.srcWidth;
        height = parent.img.srcHeight;
      } else {
        width = parent.baseImgCanvas.width;
        height = parent.baseImgCanvas.height;
      }
      var obj = { width: 0, height: 0 };
      parent.notify("crop", {
        prop: "calcRatio",
        onPropertyChange: false,
        value: { obj, dimension: { width, height } }
      });
      var ratio = obj;
      var tempContextFilter = this.lowerContext.filter;
      if (this.lowerContext.filter !== "none") {
        var splitWords = this.lowerContext.filter.split(" ");
        var value = parseFloat(splitWords[5].split("(")[1]);
        value *= (ratio.width + ratio.height) / 2;
        splitWords[5] = "blur(" + value + "px)";
        this.lowerContext.filter = splitWords.join(" ");
      }
      var tempCanvas = parent.createElement("canvas", {
        id: parent.element.id + "_tempCanvas",
        attrs: { name: "canvasImage" }
      });
      var tempContext = tempCanvas.getContext("2d");
      tempCanvas.width = width;
      tempCanvas.height = height;
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width, height, obj: dimObj }
      });
      var maxDimension = dimObj;
      tempCanvas.style.maxWidth = maxDimension.width + "px";
      tempCanvas.style.maxHeight = maxDimension.height + "px";
      var temp = this.lowerContext.filter;
      tempContext.filter = this.lowerContext.filter;
      this.downScaleImgCanvas(tempContext, width, height);
      this.lowerContext.filter = temp;
      if (parent.transform.degree !== 0 || parent.transform.currFlipState !== "" || parent.transform.straighten !== 0) {
        this.updateSaveContext(tempContext);
        this.exportTransformedImage(tempContext);
      }
      this.drawAnnotation(tempContext, ratio);
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: tempContext, isSave: true, isFlip: null }
        });
      }
      this.updateFrame(tempContext, true);
      this.lowerContext.filter = tempContextFilter;
      parent.canvasFilter = tempContextFilter;
      if (object) {
        object["canvas"] = tempCanvas;
      }
      if (parent.aspectWidth) {
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: [] } }
        });
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: prevObj } });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: prevObj.selPointColl } }
        });
        parent.cropObj = tempCropObj;
        parent.objColl = extend([], prevObj.objColl, [], true);
        parent.pointColl = extend([], prevObj.pointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
        parent.transform.straighten = 0;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        this.lowerContext.filter = prevObj.filter;
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
      }
      return tempCanvas;
    };
    Export2.prototype.drawAnnotation = function(tempContext, ratio) {
      var parent = this.parent;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order) {
          if (parent.shapeColl[i].currIndex && parent.shapeColl[i].currIndex.indexOf("shape") > -1) {
            parent.objColl = [];
            parent.objColl.push(extend({}, parent.shapeColl[i], {}, true));
            this.drawShape(tempContext, ratio);
          } else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf("pen") > -1) {
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.pointColl.push(extend({}, parent.shapeColl[i], {}, true));
            parent.freehandCounter = parent.pointColl.length;
            this.drawPen(tempContext, ratio);
          }
        }
      }
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
    };
    Export2.prototype.drawShape = function(tempContext, ratio) {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        var temp = tempContext.filter;
        tempContext.filter = "none";
        var indexObj = { index: null };
        parent.notify("shape", { prop: "getSmallestIndex", onPropertyChange: false, value: { obj: indexObj } });
        var index = indexObj["index"];
        var objColl = extend([], parent.objColl, [], true);
        var tempObjColl = extend([], parent.objColl, [], true);
        while (objColl.length > 0) {
          var found = false;
          for (var i = 0; i < objColl.length; i++) {
            var currentObj = objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
              objColl.splice(i, 1);
              i--;
              continue;
            }
            if (currentObj.order === index) {
              var temp_1 = tempContext.filter;
              tempContext.filter = "none";
              var currObj = objColl[i];
              var activePoint = currObj.activePoint;
              activePoint.startX -= parent.img.destLeft;
              activePoint.startY -= parent.img.destTop;
              activePoint.endX -= parent.img.destLeft;
              activePoint.endY -= parent.img.destTop;
              activePoint.width = activePoint.endX - activePoint.startX;
              activePoint.height = activePoint.endY - activePoint.startY;
              activePoint.startX *= ratio.width;
              activePoint.startY *= ratio.height;
              activePoint.endX *= ratio.width;
              activePoint.endY *= ratio.height;
              activePoint.width = activePoint.endX - activePoint.startX;
              activePoint.height = activePoint.endY - activePoint.startY;
              currObj.strokeSettings.strokeWidth *= (ratio.width + ratio.height) / 2;
              if (currObj.shape === "text") {
                currObj.textSettings.fontSize *= (ratio.width + ratio.height) / 2;
              } else if (currObj.shape === "path") {
                for (var l = 0; l < currObj.pointColl.length; l++) {
                  currObj.pointColl[l].x = (currObj.pointColl[l].x - parent.img.destLeft) * ratio.width;
                  currObj.pointColl[l].y = (currObj.pointColl[l].y - parent.img.destTop) * ratio.height;
                }
              } else if (currObj.shape === "image") {
                parent.activeObj = extend({}, objColl[i], {}, true);
                parent.notify("selection", { prop: "upgradeImageQuality", onPropertyChange: false });
                objColl[i] = extend({}, parent.activeObj, {}, true);
              }
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
                canvas: "saveContext",
                obj: objColl[i],
                isCropRatio: null,
                points: null,
                isPreventDrag: true,
                saveContext: tempContext,
                isPreventSelection: null
              } });
              tempContext.filter = temp_1;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              index++;
              var indexBool = { bool: false };
              parent.notify("shape", { prop: "isIndexInObjColl", onPropertyChange: false, value: { obj: indexBool, index } });
              if (!indexBool["bool"]) {
                index++;
              }
              objColl.splice(i, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
        tempContext.filter = temp;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.objColl = tempObjColl;
      }
    };
    Export2.prototype.drawPen = function(tempContext, ratio) {
      var parent = this.parent;
      if (parent.freehandCounter > 0) {
        var widthObj = { penStrokeWidth: null };
        parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: widthObj } });
        var tempPointColl = extend({}, parent.pointColl, {}, true);
        for (var n = 0; n < parent.freehandCounter; n++) {
          parent.points = extend([], parent.pointColl[n].points, []);
          parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
          var len = parent.points.length;
          parent.pointColl[n].strokeWidth *= (ratio.width + ratio.height) / 2;
          for (var l = 0; l < len; l++) {
            parent.points[l].x = (parent.points[l].x - parent.img.destLeft) * ratio.width;
            parent.points[l].y = (parent.points[l].y - parent.img.destTop) * ratio.height;
          }
        }
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: tempContext, points: null }
        });
        parent.pointColl = tempPointColl;
        parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: widthObj["penStrokeWidth"] } });
      }
    };
    Export2.prototype.downScaleImgCanvas = function(ctx, width, height) {
      var parent = this.parent;
      var canvas = parent.baseImgCanvas;
      var img = parent.baseImg;
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: img.width, height: img.height, obj, isImgShape: null }
      });
      if (obj["width"] > width && obj["height"] > height) {
        var tempCanvas = parent.createElement("canvas", {
          id: parent.element.id + "_downScaleCanvas",
          attrs: { name: "canvasImage" }
        });
        tempCanvas.width = this.parent.img.srcWidth;
        tempCanvas.height = this.parent.img.srcHeight;
        tempCanvas.getContext("2d").drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
        parent.notify("draw", { prop: "downScale", value: { canvas: tempCanvas, width, height } });
        ctx.drawImage(tempCanvas, 0, 0);
      } else {
        ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, width, height);
      }
    };
    Export2.prototype.updateFrame = function(tempContext, isAnnotation) {
      if (this.parent.frameObj.type !== "none") {
        var temp = tempContext.filter;
        tempContext.filter = "none";
        this.parent.notify("draw", { prop: "applyFrame", value: { ctx: tempContext, frame: this.parent.frameObj.type, preventImg: isAnnotation } });
        tempContext.filter = temp;
      }
    };
    Export2.prototype.downloadImg = function(blob, fileName) {
      var a = document.createElement("a");
      a.href = blob;
      a.target = "_parent";
      a.download = fileName;
      (document.body || document.documentElement).appendChild(a);
      a.click();
      a.parentNode.removeChild(a);
    };
    Export2.prototype.exportTransformedImage = function(tempContext) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      if (parent.rotateFlipColl.length > 0) {
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          var flip2 = parent.rotateFlipColl[i];
          if (typeof flip2 === "number") {
            this.exportRotate(tempContext, flip2);
          } else if (flip2 === "horizontal") {
            this.exportFlip(tempContext, true, false);
          } else if (flip2 === "vertical") {
            this.exportFlip(tempContext, false, true);
          }
        }
      }
      parent.transform.degree = degree;
    };
    Export2.prototype.exportRotate = function(tempContext, degree) {
      var parent = this.parent;
      tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      this.setMaxDim(parent.transform.degree, tempContext.canvas);
      tempContext.translate(tempContext.canvas.width / 2, tempContext.canvas.height / 2);
      tempContext.rotate(Math.PI / 180 * degree);
      tempContext.drawImage(parent.inMemoryCanvas, -tempContext.canvas.height / 2, -tempContext.canvas.width / 2, tempContext.canvas.height, tempContext.canvas.width);
      this.updateSaveContext(tempContext);
    };
    Export2.prototype.exportFlip = function(tempContext, flipHorizontal, flipVertical) {
      tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      if (flipHorizontal) {
        tempContext.translate(tempContext.canvas.width, 0);
        tempContext.scale(-1, 1);
      }
      if (flipVertical) {
        tempContext.translate(0, tempContext.canvas.height);
        tempContext.scale(1, -1);
      }
      tempContext.drawImage(this.parent.inMemoryCanvas, 0, 0);
      this.updateSaveContext(tempContext);
    };
    Export2.prototype.updateSaveContext = function(tempContext) {
      var inMemoryContext = this.parent.inMemoryCanvas.getContext("2d");
      tempContext.setTransform(1, 0, 0, 1, 0, 0);
      var imageData = tempContext.getImageData(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      this.parent.inMemoryCanvas.width = imageData.width;
      this.parent.inMemoryCanvas.height = imageData.height;
      inMemoryContext.putImageData(imageData, 0, 0);
    };
    Export2.prototype.setMaxDim = function(degree, tempCanvas) {
      var newWidth;
      var newHeight;
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (isNullOrUndefined(this.parent.currSelectionPoint)) {
          newWidth = this.parent.baseImgCanvas.height;
          newHeight = this.parent.baseImgCanvas.width;
        } else {
          newWidth = this.parent.img.srcHeight;
          newHeight = this.parent.img.srcWidth;
        }
      } else if (degree % 180 === 0 || degree === 0) {
        if (isNullOrUndefined(this.parent.currSelectionPoint)) {
          newWidth = this.parent.baseImgCanvas.width;
          newHeight = this.parent.baseImgCanvas.height;
        } else {
          newWidth = this.parent.img.srcWidth;
          newHeight = this.parent.img.srcHeight;
        }
      }
      if (!isNullOrUndefined(this.parent.aspectWidth)) {
        newWidth = this.parent.aspectWidth;
        newHeight = this.parent.aspectHeight;
      }
      tempCanvas.width = newWidth;
      tempCanvas.height = newHeight;
      var obj = { width: 0, height: 0 };
      this.parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: newWidth, height: newHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      tempCanvas.style.maxWidth = maxDimension.width + "px";
      tempCanvas.style.maxHeight = maxDimension.height + "px";
    };
    return Export2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/filter.js
var Filter = (
  /** @class */
  function() {
    function Filter2(parent) {
      this.adjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempAdjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.adjustmentValue = "";
      this.isBrightnessAdjusted = false;
      this.bevelFilter = "none";
      this.tempAdjVal = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempFilVal = "";
      this.parent = parent;
      this.addEventListener();
    }
    Filter2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Filter2.prototype.addEventListener = function() {
      this.parent.on("filter", this.filter, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Filter2.prototype.removeEventListener = function() {
      this.parent.off("filter", this.filter);
      this.parent.off("destroyed", this.destroy);
    };
    Filter2.prototype.filter = function(args) {
      this.updatePrivateVariables();
      switch (args.prop) {
        case "finetuneImage":
          this.finetuneImage(args.value["option"], args.value["value"]);
          break;
        case "applyImageFilter":
          this.setFilter(args.value["option"]);
          break;
        case "update-finetunes":
          this.updateFinetunes();
          break;
        case "set-adjustment":
          this.setAdjustment(args.value["operation"]);
          break;
        case "initFilter":
          this.initFilter();
          break;
        case "setCurrAdjValue":
          this.setCurrAdjValue(args.value["type"], args.value["value"]);
          break;
        case "updateAdj":
          this.updateAdj(args.value["type"], args.value["value"], args.value["isPreview"], args.value["ctx"]);
          break;
        case "getCurrentObj":
          this.getCurrentObj(args.value["object"]);
          break;
        case "getAdjustmentLevel":
          if (isNullOrUndefined(this.parent.activeObj.opacity)) {
            this.adjustmentLevel.transparency = 100;
          } else {
            this.adjustmentLevel.transparency = this.parent.activeObj.opacity * 100;
          }
          args.value["obj"]["adjustmentLevel"] = this.adjustmentLevel;
          break;
        case "setAdjustmentLevel":
          this.adjustmentLevel = args.value["adjustmentLevel"];
          break;
        case "getTempAdjustmentLevel":
          args.value["obj"]["tempAdjustmentLevel"] = this.tempAdjustmentLevel;
          break;
        case "setTempAdjustmentLevel":
          this.tempAdjustmentLevel = args.value["tempAdjustmentLevel"];
          break;
        case "setAdjustmentValue":
          this.adjustmentValue = args.value["adjustmentValue"];
          break;
        case "getBrightnessAdjusted":
          args.value["obj"]["isBrightnessAdjusted"] = this.isBrightnessAdjusted;
          break;
        case "setBrightnessAdjusted":
          this.isBrightnessAdjusted = args.value["isBrightnessAdjusted"];
          if (this.parent.currentFilter.split("_") && this.parent.currentFilter.split("_")[1] === "cold") {
            this.isBrightnessAdjusted = false;
          }
          break;
        case "getBevelFilter":
          args.value["obj"]["bevelFilter"] = this.bevelFilter;
          break;
        case "setBevelFilter":
          this.bevelFilter = args.value["bevelFilter"];
          break;
        case "setTempAdjVal":
          this.tempAdjVal = extend({}, this.adjustmentLevel, {}, true);
          break;
        case "setTempFilVal":
          this.tempFilVal = this.parent.currentFilter;
          break;
        case "reset":
          this.reset();
          break;
      }
    };
    Filter2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
    };
    Filter2.prototype.getModuleName = function() {
      return "filter";
    };
    Filter2.prototype.reset = function() {
      this.adjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempAdjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.adjustmentValue = this.parent.getDefaultFilter();
      this.isBrightnessAdjusted = false;
      this.bevelFilter = "none";
      this.tempFilVal = "";
      this.tempAdjVal = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
    };
    Filter2.prototype.updateFinetunes = function() {
      var _this = this;
      var parent = this.parent;
      var fs = parent.finetuneSettings;
      if (fs) {
        var propertiesToSet = ["brightness", "contrast", "hue", "saturation", "exposure", "opacity", "blur"];
        propertiesToSet.forEach(function(property) {
          if (fs[property]) {
            _this.adjustmentLevel[property] = fs[property].defaultValue;
            _this.tempAdjustmentLevel[property] = fs[property].defaultValue;
          }
        });
        parent.notify("draw", { prop: "isInitialLoading", onPropertyChange: false, value: { isInitialLoading: true } });
      }
    };
    Filter2.prototype.initFilter = function() {
      this.setFilterAdj("brightness", this.adjustmentLevel.brightness);
      this.setFilterAdj("contrast", this.adjustmentLevel.contrast);
      this.setFilterAdj("hue", this.adjustmentLevel.hue);
      this.setFilterAdj("saturation", this.adjustmentLevel.saturation);
      this.setFilterAdj("exposure", this.adjustmentLevel.exposure);
      this.setFilterAdj("opacity", this.adjustmentLevel.opacity);
      this.setFilterAdj("blur", this.adjustmentLevel.blur);
    };
    Filter2.prototype.updateAdj = function(type, value, isPreview, ctx) {
      var parent = this.parent;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var splitWords = this.lowerContext.filter.split(" ");
      var values = [];
      var brightness = this.getFilterValue(this.adjustmentLevel.brightness);
      var excludedTypes = ["brightness", "contrast", "hue", "saturation", "exposure", "opacity", "blur"];
      if (excludedTypes.indexOf(type) === -1) {
        if (isNullOrUndefined(isPreview) && (this.adjustmentLevel.sharpen || this.adjustmentLevel.bw)) {
          parent.isUndoRedo = true;
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
          });
          this.lowerContext.filter = temp;
          parent.isUndoRedo = false;
        }
      }
      var saturate;
      var bright;
      var saturatePercent;
      var contrast;
      var saturatePercentage;
      switch (type) {
        case "brightness":
          value = this.getFilterValue(this.adjustmentLevel.exposure) + value * 5e-3;
          splitWords[0] = "brightness(" + value + ")";
          if (this.adjustmentLevel.brightness !== 0) {
            value = this.adjustmentLevel.opacity / 100 - this.adjustmentLevel.opacity * 0.3 / 100;
            splitWords[4] = "opacity(" + value + ")";
          } else {
            value = this.adjustmentLevel.opacity / 100;
            splitWords[4] = "opacity(" + value + ")";
          }
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "contrast":
          splitWords[1] = "contrast(" + value + "%)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "hue":
          splitWords[2] = "hue-rotate(" + value + "deg)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "saturation":
          splitWords[3] = "saturate(" + value + "%)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "opacity":
          if (parseFloat(splitWords[0].split("(")[1]) !== 1) {
            value -= 0.2;
          }
          if (value < 0) {
            value = 0;
          }
          splitWords[4] = "opacity(" + value + ")";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "blur":
          splitWords[5] = "blur(" + value + "px)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "exposure":
          if (value > 1) {
            value -= 1;
            value += brightness;
          } else if (value < 1) {
            value = 1 - value;
            value = brightness - value;
          }
          splitWords[0] = "brightness(" + value + ")";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "chrome":
          saturate = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturate *= 100;
          value = saturate + saturate * 0.4;
          splitWords[3] = "saturate(" + value + "%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "cold":
          bright = this.getFilterValue(this.adjustmentLevel.brightness);
          bright *= 100;
          value = bright * 0.9;
          value *= 0.01;
          splitWords[0] = "brightness(" + value + ")";
          contrast = this.getFilterValue(this.adjustmentLevel.contrast);
          contrast *= 100;
          value = contrast + contrast * 0.5;
          splitWords[1] = "contrast(" + value + "%)";
          saturatePercentage = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturatePercentage *= 100;
          value = saturatePercentage;
          splitWords[3] = "saturate(" + value + "%)";
          values = this.adjustmentValue.split(" ");
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "warm":
          saturatePercent = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturatePercent *= 100;
          value = saturatePercent + saturatePercent * 0.4;
          splitWords[3] = "saturate(" + value + "%)";
          splitWords[6] = "sepia(25%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "grayscale":
          splitWords[7] = "grayscale(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "sepia":
          splitWords[6] = "sepia(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "invert":
          splitWords[8] = "invert(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          break;
      }
      if (type !== "sharpen" && type !== "blackandwhite") {
        if (isNullOrUndefined(isPreview)) {
          if (type === "default") {
            splitWords = this.getDefaultCurrentFilter(splitWords);
          }
          this.lowerContext.filter = splitWords.join(" ");
        }
        splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
        parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
        var tempFilter = void 0;
        if (parent.frameObj.type === "bevel") {
          tempFilter = this.lowerContext.filter;
          this.bevelFilter = tempFilter;
        }
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
          parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        if (parent.transform.degree === 0) {
          parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
        }
        parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
          parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
        if (isNullOrUndefined(isPreview)) {
          this.lowerContext.filter = splitWords.join(" ");
        }
        parent.initialAdjustmentValue = splitWords.join(" ");
        tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
        this.bevelFilter = tempFilter;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.lowerContext.filter = tempFilter;
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        this.isBrightnessAdjusted = brightness !== 1;
      }
      var filter = splitWords.join(" ");
      if (ctx) {
        ctx.filter = filter;
      }
    };
    Filter2.prototype.setTempFilterValue = function(brightness, isPreview, splitWords, type) {
      if (isPreview) {
        if (type === "default") {
          splitWords = this.getDefaultCurrentFilter(splitWords);
        } else if (brightness !== 1) {
          var tempSplitWords = this.lowerContext.filter.split(" ");
          tempSplitWords[4] = splitWords[4];
          this.lowerContext.filter = tempSplitWords.join(" ");
        }
      }
      return splitWords;
    };
    Filter2.prototype.getDefaultCurrentFilter = function(splitWords) {
      var values = this.adjustmentValue.split(" ");
      splitWords = [values[0], values[1], values[2], values[3], values[4], values[5], "sepia(0%)", "grayscale(0%)", "invert(0%)"];
      return splitWords;
    };
    Filter2.prototype.getFilterValue = function(value) {
      return value === 0 ? 1 : 1 + value * 0.5 / 100;
    };
    Filter2.prototype.getSaturationFilterValue = function(value) {
      return value === 0 ? 1 : 1 + value / 100;
    };
    Filter2.prototype.setFilterAdj = function(type, value) {
      var parent = this.parent;
      parent.notify("freehand-draw", { prop: "apply-pen-draw", onPropertyChange: false });
      this.adjustmentLevel["" + type] = value;
      switch (type) {
        case "contrast":
        case "exposure":
          value = this.getFilterValue(value);
          if (type === "contrast") {
            value *= 100;
          }
          break;
        case "hue":
          value *= 3;
          break;
        case "saturation":
          value = this.getSaturationFilterValue(value) * 100;
          break;
        case "opacity":
          if (value < 10) {
            value += 1;
          }
          value /= 100;
          break;
        case "blur":
          if (value !== 0) {
            value /= 20;
            value += 0.5;
          }
          break;
      }
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = this.getCurrentObj();
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.updateAdj(type, value);
      parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
        operation: type,
        previousObj: prevObj,
        previousObjColl: prevObj.objColl,
        previousPointColl: prevObj.pointColl,
        previousSelPointColl: prevObj.selPointColl,
        previousCropObj: prevCropObj,
        previousText: null,
        currentText: null,
        previousFilter: null,
        isCircleCrop: null
      } });
    };
    Filter2.prototype.setFilter = function(type) {
      var parent = this.parent;
      type = type.toLowerCase();
      parent.notify("freehand-draw", { prop: "apply-pen-draw", onPropertyChange: false });
      var obj = { currentFilter: this.parent.currentFilter };
      var prevFilter = obj["currentFilter"];
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = this.getCurrentObj();
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.updateAdj(type, null);
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: type,
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: prevFilter,
          isCircleCrop: null
        }
      });
    };
    Filter2.prototype.setAdjustment = function(type) {
      var splitWords = this.lowerContext.filter.split(" ");
      var value;
      var valueArr;
      switch (type) {
        case "brightness":
          valueArr = splitWords[0].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          this.adjustmentLevel.brightness = this.setFilterValue(value);
          break;
        case "contrast":
          valueArr = splitWords[1].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 100;
          this.adjustmentLevel.contrast = this.setFilterValue(value);
          break;
        case "hue":
          valueArr = splitWords[2].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 3;
          this.adjustmentLevel.hue = value;
          break;
        case "saturation":
          valueArr = splitWords[3].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 100;
          this.adjustmentLevel.saturation = this.setSaturationFilterValue(value);
          break;
        case "opacity":
          valueArr = splitWords[4].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          if (value === 0.45) {
            value = 40;
          } else if (value === 0.4) {
            value = 30;
          } else if (value === 0.35) {
            value = 20;
          } else if (value === 0.3) {
            value = 10;
          } else if (value === 0.25) {
            value = 0;
          } else {
            value *= 100;
          }
          this.adjustmentLevel.opacity = value;
          break;
        case "blur":
          valueArr = splitWords[5].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value *= 20;
          this.adjustmentLevel.blur = value;
          break;
        case "exposure":
          valueArr = splitWords[0].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          this.adjustmentLevel.exposure = this.setFilterValue(value);
          break;
      }
    };
    Filter2.prototype.setFilterValue = function(value) {
      return Math.round(value === 1 ? 0 : (value - 1) * 100 / 0.5);
    };
    Filter2.prototype.setSaturationFilterValue = function(value) {
      return Math.round(value === 1 ? 0 : (value - 1) * 100);
    };
    Filter2.prototype.finetuneImage = function(finetuneOption, value) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        switch (finetuneOption.toLowerCase()) {
          case "brightness":
            this.setFilterAdj("brightness", value);
            break;
          case "contrast":
            this.setFilterAdj("contrast", value);
            break;
          case "hue":
            this.setFilterAdj("hue", value);
            break;
          case "saturation":
            this.setFilterAdj("saturation", value);
            break;
          case "opacity":
            this.setFilterAdj("opacity", value);
            break;
          case "blur":
            this.setFilterAdj("blur", value);
            break;
          case "exposure":
            this.setFilterAdj("exposure", value);
            break;
        }
        this.parent.canvasFilter = this.lowerContext.filter;
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    Filter2.prototype.setCurrAdjValue = function(type, value) {
      var parent = this.parent;
      this.parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      switch (type) {
        case "brightness":
          this.setFilterAdj("brightness", value);
          break;
        case "contrast":
          this.setFilterAdj("contrast", value);
          break;
        case "hue":
          this.setFilterAdj("hue", value);
          break;
        case "saturation":
          this.setFilterAdj("saturation", value);
          break;
        case "opacity":
          this.setFilterAdj("opacity", value);
          break;
        case "blur":
          this.setFilterAdj("blur", value);
          break;
        case "exposure":
          this.setFilterAdj("exposure", value);
          break;
      }
      parent.isFinetuneBtnClick = true;
      parent.curFinetuneObjEvent = { finetune: parent.toPascalCase(type), value };
    };
    Filter2.prototype.getCurrentObj = function(dummyObj) {
      var parent = this.parent;
      var tempFlipPanPointObj = { point: null };
      parent.notify("crop", { prop: "getTempFlipPanPoint", value: { obj: tempFlipPanPointObj } });
      var zoomObj = { previousZoomValue: null };
      parent.notify("transform", { prop: "getPreviousZoomValue", value: { obj: zoomObj } });
      var straightenObj = { zoomFactor: null };
      parent.notify("draw", { prop: "getStraightenInitZoom", value: { obj: straightenObj } });
      var obj = {
        cropZoom: 0,
        defaultZoom: 0,
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        tempFlipPanPoint: { x: 0, y: 0 },
        activeObj: {},
        rotateFlipColl: [],
        degree: 0,
        currFlipState: "",
        zoomFactor: 0,
        previousZoomValue: 0,
        straighten: 0,
        destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        frame: "none",
        srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        filter: "",
        isBrightAdjust: this.isBrightnessAdjusted,
        aspectWidth: null,
        aspectHeight: null,
        straightenZoom: 0,
        adjustmentLevel: extend({}, this.tempAdjVal, {}, true),
        currentFilter: this.tempFilVal
      };
      obj.cropZoom = parent.transform.cropZoomFactor;
      obj.defaultZoom = parent.transform.defaultZoomFactor;
      obj.zoomFactor = parent.zoomSettings.zoomFactor;
      obj.previousZoomValue = zoomObj["previousZoomValue"];
      obj.straightenZoom = straightenObj["zoomFactor"];
      obj.totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, {}, true);
      obj.totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
      obj.totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
      obj.tempFlipPanPoint = extend({}, tempFlipPanPointObj["point"], {}, true);
      obj.activeObj = extend({}, parent.activeObj, {}, true);
      obj.rotateFlipColl = extend([], parent.rotateFlipColl, [], true);
      obj.degree = parent.transform.degree;
      obj.straighten = parent.cropObj.straighten;
      obj.currFlipState = parent.transform.currFlipState;
      obj.destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        endX: 0,
        endY: 0,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      obj.srcPoints = {
        startX: parent.img.srcLeft,
        startY: parent.img.srcTop,
        endX: 0,
        endY: 0,
        width: parent.img.srcWidth,
        height: parent.img.srcHeight
      };
      obj.filter = this.lowerContext.filter;
      obj.aspectWidth = parent.aspectWidth;
      obj.aspectHeight = parent.aspectHeight;
      obj.frame = parent.frameObj.type;
      obj.frameObj = extend({}, parent.frameObj);
      if (dummyObj) {
        dummyObj["currObj"] = obj;
      }
      return obj;
    };
    return Filter2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/freehand-draw.js
var FreehandDrawing = (
  /** @class */
  function() {
    function FreehandDrawing2(parent) {
      this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
      this.isFreehandDrawing = false;
      this.freehandDownPoint = { x: 0, y: 0 };
      this.isFreehandPointMoved = false;
      this.pointCounter = 0;
      this.selPointColl = {};
      this.currFHDIdx = 0;
      this.selPoints = [];
      this.dummyPoints = [];
      this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
      this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
      this.straightenPointAngle = 0;
      this.parent = parent;
      this.addEventListener();
    }
    FreehandDrawing2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    FreehandDrawing2.prototype.addEventListener = function() {
      this.parent.on("freehand-draw", this.draw, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    FreehandDrawing2.prototype.removeEventListener = function() {
      this.parent.off("freehand-draw", this.draw);
      this.parent.off("destroyed", this.destroy);
    };
    FreehandDrawing2.prototype.draw = function(args) {
      this.updateFhdPvtVar();
      switch (args.prop) {
        case "hoverFhd": {
          this.hoverFhd(args.value["strokeColor"], args.value["strokeWidth"]);
          break;
        }
        case "freehandDownHandler":
          this.freehandDownHandler(args.value["e"], args.value["canvas"]);
          break;
        case "freehandUpHandler":
          this.freehandUpHandler(args.value["e"], args.value["canvas"], args.value["context"]);
          break;
        case "handle-freehand-draw": {
          var id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          if (this.isFHDIdx(id)) {
            this.deleteFhd(id, true);
          }
          break;
        }
        case "freehandRedraw":
          this.freehandRedraw(args.value["context"], args.value["points"]);
          break;
        case "deleteFhd": {
          var id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          this.deleteFhd(id, true);
          break;
        }
        case "selectFhd": {
          var id = null;
          if (args.value["id"]) {
            id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          }
          this.selectFhd(id);
          break;
        }
        case "applyFhd":
          this.applyFhd();
          break;
        case "cancelFhd":
          this.cancelFhd();
          break;
        case "updateFHDCurPts":
          this.updateFHDCurPts();
          break;
        case "rotateFhdColl":
          this.rotateFhdColl();
          break;
        case "flipFHDColl":
          this.flipFHDColl(args.value["value"]);
          break;
        case "panFHDColl":
          this.panFHDColl(args.value["xDiff"], args.value["yDiff"], args.value["panRegion"]);
          break;
        case "updateFHDColl":
          if (args.value && args.value["isPreventApply"]) {
            this.updateFHDColl(args.value["isPreventApply"]);
          } else {
            this.updateFHDColl();
          }
          break;
        case "zoomFHDColl":
          this.zoomFHDColl(args.value["isPreventApply"]);
          break;
        case "apply-pen-draw":
          this.applyPenDraw();
          break;
        case "freeHandDraw":
          this.freeHandDraw(args.value["value"]);
          break;
        case "isFHDIdx":
          this.isFHDIdx(args.value["index"], args.value["obj"]);
          break;
        case "getSqPtFD":
          this.getSqPtFD(args.value["idx"], args.value["obj"]);
          break;
        case "getSelPointColl":
          args.value["obj"]["selPointColl"] = extend([], this.selPointColl);
          break;
        case "setSelPointColl":
          this.selPointColl = extend([], args.value["obj"]["selPointColl"]);
          break;
        case "setFreehandDrawHoveredIndex":
          this.fhdHovIdx = args.value["index"];
          break;
        case "getFreehandDrawHoveredIndex":
          args.value["obj"]["index"] = this.fhdHovIdx;
          break;
        case "setPointCounter":
          this.pointCounter = args.value["value"];
          break;
        case "getPenStrokeWidth":
          args.value["obj"]["penStrokeWidth"] = this.penStrokeWidth;
          break;
        case "setPenStrokeWidth":
          this.penStrokeWidth = args.value["value"];
          break;
        case "getCurrentFreehandDrawIndex":
          args.value["obj"]["currentFreehandDrawIndex"] = this.currFHDIdx;
          break;
        case "setCurrentFreehandDrawIndex":
          this.currFHDIdx = args.value["value"];
          break;
        case "updateCropPtsForSel":
          this.updateCropPtsForSel();
          break;
        case "getFreehandDrawSelectedId":
          args.value["obj"]["freehandDrawSelectedId"] = this.fhdSelID;
          break;
        case "resetFreehandDrawSelectedId":
          this.fhdSelID = null;
          break;
        case "getTempFreeHandDrawEditingStyles":
          args.value["obj"]["tempFreeHandDrawEditingStyles"] = this.tempFHDStyles;
          break;
        case "setFreehandSelectedIndex":
          this.fhdSelIdx = args.value["index"];
          break;
        case "getFreehandSelectedIndex":
          args.value["obj"]["freehandSelectedIndex"] = this.fhdSelIdx;
          break;
        case "setCenterSelPoints":
          this.setCenterSelPoints();
          break;
        case "getStraightenPoint":
          args.value["obj"]["straightenPoint"] = extend({}, this.straightenPoint, {}, true);
          break;
        case "setStraightenPoint":
          this.straightenPoint.x = args.value["x"];
          this.straightenPoint.y = args.value["y"];
          if (args.value["ratioX"] && args.value["ratioY"]) {
            this.straightenPoint.ratioX = args.value["ratioX"];
            this.straightenPoint.ratioY = args.value["ratioY"];
          }
          break;
        case "resetStraightenPoint":
          this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
          this.prevStraightenObj = null;
          this.straightenPointAngle = 0;
          break;
        case "getStraightenPointAngle":
          args.value["obj"]["angle"] = this.straightenPointAngle;
          break;
        case "reset":
          this.reset();
          break;
        case "triggerShapeChanging":
          this.triggerShapeChanging(args.value["shapeChangingArgs"]);
          break;
      }
    };
    FreehandDrawing2.prototype.updateFhdPvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    FreehandDrawing2.prototype.reset = function() {
      this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
      this.isFreehandDrawing = this.isFreehandPointMoved = false;
      this.selPoints = [];
      this.dummyPoints = [];
      this.freehandDownPoint = { x: 0, y: 0 };
      this.selPointColl = {};
      this.straightenPointAngle = 0;
      this.fhdHovIdx = null;
      this.pointCounter = 0;
      this.fhdSelID = null;
      this.penStrokeWidth = void 0;
      this.currFHDIdx = 0;
      this.fhdSelIdx = null;
      this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
      this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
      this.prevStraightenObj = null;
    };
    FreehandDrawing2.prototype.getModuleName = function() {
      return "freehand-draw";
    };
    FreehandDrawing2.prototype.hoverFhd = function(fillStyle, strokeWidth) {
      var parent = this.parent;
      var context = this.upperContext;
      var idx = -1;
      if (this.fhdHovIdx > -1) {
        idx = this.fhdHovIdx;
      } else {
        idx = this.fhdSelIdx;
      }
      parent.points = extend([], parent.pointColl[idx].points);
      this.pointCounter = 0;
      var len = parent.points.length;
      var controlPoint1;
      var controlPoint2;
      var startPoint;
      var endPoint;
      var minStrokeWidth = 0;
      var maxStrokeWidth = 0;
      context.fillStyle = fillStyle ? fillStyle : parent.pointColl[idx].strokeColor;
      context.strokeStyle = context.fillStyle;
      minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = strokeWidth ? strokeWidth : parent.pointColl[idx].strokeWidth;
      if (len === 1) {
        controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
        this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
      }
      for (var l = 0; l < len - 3; l++) {
        if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
          controlPoint1 = this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2]).controlPoint2;
          controlPoint2 = this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3]).controlPoint1;
          if (l === 0) {
            startPoint = parent.points[l];
          } else {
            startPoint = parent.points[l + 1];
          }
          endPoint = parent.points[l + 2];
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
      }
      context.closePath();
      var point = this.getSqPtFD(idx);
      var tempLineWidth = context.lineWidth;
      context.lineWidth = 2;
      context.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      context.beginPath();
      context.rect(point.startX, point.startY, point.width, point.height);
      context.stroke();
      context.closePath();
      context.lineWidth = tempLineWidth;
    };
    FreehandDrawing2.prototype.freehandDownHandler = function(e, canvas) {
      var parent = this.parent;
      parent.lowerCanvas = document.querySelector("#" + parent.element.id + "_lowerCanvas");
      this.lowerContext = parent.lowerCanvas.getContext("2d");
      parent.upperCanvas = document.querySelector("#" + parent.element.id + "_upperCanvas");
      this.upperContext = parent.upperCanvas.getContext("2d");
      this.fhdObj.time = (/* @__PURE__ */ new Date()).getTime();
      this.isFreehandDrawing = true;
      if (e.type === "mousedown") {
        this.freehandDownPoint = { x: e.clientX, y: e.clientY };
      } else {
        this.freehandDownPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      this.isFreehandPointMoved = false;
      EventHandler.add(canvas, "mousemove touchmove", this.freehandMoveHandler, this);
      var shapeSettings = {
        id: "pen_" + (this.currFHDIdx + 1),
        type: ShapeType.FreehandDraw,
        startX: this.freehandDownPoint.x,
        startY: this.freehandDownPoint.y,
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        points: null,
        index: parent.objColl.length + parent.freehandCounter + 1
      };
      var shapeChangingArgs = {
        cancel: false,
        action: "draw-start",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      this.triggerShapeChanging(shapeChangingArgs);
    };
    FreehandDrawing2.prototype.freehandUpHandler = function(e, canvas, context) {
      var rect = canvas.getBoundingClientRect();
      var parent = this.parent;
      EventHandler.remove(canvas, "mousemove touchmove", this.freehandMoveHandler);
      if (parent.points.length === 0) {
        if (e.type === "mouseup") {
          this.processPoint(e.clientX - rect.left, e.clientY - rect.top, true, context);
        } else if (e.type === "touchend" && e.changedTouches) {
          this.processPoint(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top, true, context);
        } else {
          if (!this.isFreehandPointMoved) {
            this.processPoint(this.freehandDownPoint.x - rect.left, this.freehandDownPoint.y - rect.top, true, context);
          }
        }
      }
      context.closePath();
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var fhCnt = parent.freehandCounter;
      var order = parent.objColl.length + parent.freehandCounter + 1;
      parent.pointColl[fhCnt] = {
        points: extend([], parent.points),
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        flipState: parent.transform.currFlipState,
        id: "pen_" + (this.currFHDIdx + 1),
        order
      };
      parent.points = [];
      this.dummyPoints = [];
      this.selPointColl[fhCnt] = { points: extend([], this.selPoints) };
      this.selPoints = [];
      this.pointCounter = 0;
      parent.freehandCounter++;
      this.isFreehandDrawing = false;
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "freehand-draw",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      var shapeSettings = {
        id: "pen_" + (this.currFHDIdx + 1),
        type: ShapeType.FreehandDraw,
        startX: this.freehandDownPoint.x,
        startY: this.freehandDownPoint.y,
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        points: parent.pointColl[this.currFHDIdx].points,
        index: order
      };
      var shapeChangingArgs = {
        cancel: false,
        action: "draw-end",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      this.triggerShapeChanging(shapeChangingArgs);
      this.currFHDIdx++;
    };
    FreehandDrawing2.prototype.freehandMoveHandler = function(e) {
      this.isFreehandPointMoved = true;
      var rect = this.parent.upperCanvas.getBoundingClientRect();
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      } else {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      }
      if (this.isFreehandDrawing) {
        this.upperContext.fillStyle = this.parent.activeObj.strokeSettings.strokeColor;
        this.processPoint(x, y, false, this.upperContext);
      }
    };
    FreehandDrawing2.prototype.processPoint = function(x, y, mouseDown, context) {
      var parent = this.parent;
      var lastPoint = this.point(x, y, (/* @__PURE__ */ new Date()).getTime());
      lastPoint = parent.points.length > 0 && parent.points[parent.points.length - 1];
      var isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= 5 : false;
      var controlPoint1;
      var controlPoint2;
      var startPoint;
      var endPoint;
      this.selPoints.push({
        x,
        y,
        ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
        ratioY: (y - parent.img.destTop) / parent.img.destHeight,
        time: this.fhdObj.time
      });
      if (!lastPoint || !(lastPoint && isLastPointTooClose) || mouseDown) {
        this.fhdObj.time = (/* @__PURE__ */ new Date()).getTime();
        parent.points.push({
          x,
          y,
          ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
          ratioY: (y - parent.img.destTop) / parent.img.destHeight,
          time: this.fhdObj.time
        });
        this.dummyPoints.push({
          x,
          y,
          ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
          ratioY: (y - parent.img.destTop) / parent.img.destHeight,
          time: this.fhdObj.time
        });
        if (this.dummyPoints.length > 2) {
          if (this.dummyPoints.length === 3) {
            this.dummyPoints.unshift(this.dummyPoints[0]);
          }
          var p0 = this.dummyPoints[0];
          var p1 = this.dummyPoints[1];
          var p2 = this.dummyPoints[2];
          var p3 = this.dummyPoints[3];
          controlPoint1 = this.calcCurveCP(p0, p1, p2).controlPoint2;
          controlPoint2 = this.calcCurveCP(p1, p2, p3).controlPoint1;
          startPoint = this.dummyPoints[1];
          endPoint = this.dummyPoints[2];
          var minStrokeWidth = 0.5;
          var maxStrokeWidth = 5;
          if (!isNullOrUndefined(this.penStrokeWidth)) {
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
          }
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
          this.pointCounter++;
          this.dummyPoints.shift();
        }
        if (mouseDown) {
          controlPoint1 = controlPoint2 = startPoint = endPoint = { x, y, time: (/* @__PURE__ */ new Date()).getTime() };
          var minStrokeWidth = 0.5;
          var maxStrokeWidth = 5;
          if (!isNullOrUndefined(this.penStrokeWidth)) {
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
          }
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
      }
    };
    FreehandDrawing2.prototype.calcCurveCP = function(p1, p2, p3) {
      if (!p2) {
        p2 = p1;
      }
      if (!p3) {
        p3 = p2;
      }
      var dx1 = p1.x - p2.x;
      var dy1 = p1.y - p2.y;
      var dx2 = p2.x - p3.x;
      var dy2 = p2.y - p3.y;
      var m1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var m2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      var dxm = m1.x - m2.x;
      var dym = m1.y - m2.y;
      var k = l2 / (l1 + l2);
      var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
      var tx = p2.x - cm.x;
      var ty = p2.y - cm.y;
      return {
        controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),
        controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)
      };
    };
    FreehandDrawing2.prototype.point = function(x, y, time) {
      this.fhdObj.pointX = x;
      this.fhdObj.pointY = y;
      return { x: this.fhdObj.pointX, y: this.fhdObj.pointY, time };
    };
    FreehandDrawing2.prototype.startDraw = function(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth) {
      var tempVelocity;
      tempVelocity = this.pointVelocity(startPoint);
      tempVelocity = 0.7 * tempVelocity + (1 - 0.7) * this.fhdObj.lastVelocity;
      var newWidth = Math.max(maxStrokeWidth / (0.7 + 1), minStrokeWidth);
      this.drawCurve(this.fhdObj.time, newWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth);
      this.fhdObj.lastVelocity = tempVelocity;
      this.fhdObj.time = newWidth;
    };
    FreehandDrawing2.prototype.pointVelocity = function(startPoint) {
      return this.fhdObj.time !== startPoint.time ? this.distanceTo(startPoint) / (this.fhdObj.time - startPoint.time) : 0;
    };
    FreehandDrawing2.prototype.distanceTo = function(start) {
      return Math.sqrt(Math.pow(this.fhdObj.pointX - start.x, 2) + Math.pow(this.fhdObj.pointY - start.y, 2));
    };
    FreehandDrawing2.prototype.drawCurve = function(startWidth, endWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth) {
      var width;
      var i;
      var t1;
      var t2;
      var t3;
      var u1;
      var u2;
      var u3;
      var x;
      var y;
      var widthValue = endWidth - startWidth;
      var bezierLength = this.bezierLength(controlPoint1, controlPoint2, startPoint, endPoint);
      var drawSteps = Math.ceil(bezierLength) * 2;
      context.beginPath();
      for (i = 0; i < drawSteps; i++) {
        t1 = i / drawSteps;
        t2 = t1 * t1;
        t3 = t2 * t1;
        u1 = 1 - t1;
        u2 = u1 * u1;
        u3 = u2 * u1;
        x = u3 * startPoint.x;
        x += 3 * u2 * t1 * controlPoint1.x;
        x += 3 * u1 * t2 * controlPoint2.x;
        x += t3 * endPoint.x;
        y = u3 * startPoint.y;
        y += 3 * u2 * t1 * controlPoint1.y;
        y += 3 * u1 * t2 * controlPoint2.y;
        y += t3 * endPoint.y;
        width = Math.min(startWidth + t3 * widthValue, maxStrokeWidth);
        this.drawArc(x, y, width, context);
      }
      context.closePath();
      context.fill();
    };
    FreehandDrawing2.prototype.bezierLength = function(controlPoint1, controlPoint2, startPoint, endPoint) {
      var steps = 10;
      var length = 0;
      var i;
      var t;
      var pointX1;
      var pointY1;
      var pointX2;
      var pointY2;
      var pointX3;
      var pointY3;
      for (i = 0; i <= steps; i++) {
        t = i / steps;
        pointX1 = this.bezierPoint(t, startPoint.x, controlPoint1.x, controlPoint2.x, endPoint.x);
        pointY1 = this.bezierPoint(t, startPoint.y, controlPoint1.y, controlPoint2.y, endPoint.y);
        if (i > 0) {
          pointX3 = pointX1 - pointX2;
          pointY3 = pointY1 - pointY2;
          length += Math.sqrt(pointX3 * pointX3 + pointY3 * pointY3);
        }
        pointX2 = pointX1;
        pointY2 = pointY1;
      }
      return length;
    };
    FreehandDrawing2.prototype.bezierPoint = function(t, startPoint, cp1, cp2, endPoint) {
      return startPoint * (1 - t) * (1 - t) * (1 - t) + 3 * cp1 * (1 - t) * (1 - t) * t + 3 * cp2 * (1 - t) * t * t + endPoint * t * t * t;
    };
    FreehandDrawing2.prototype.drawArc = function(x, y, size, context) {
      var img = this.parent.img;
      if (x > img.destLeft && y > img.destTop && x < img.destLeft + img.destWidth && y < img.destTop + img.destHeight || context !== this.lowerContext && context !== this.upperContext) {
        context.moveTo(x, y);
        context.arc(x, y, size, 0, 2 * Math.PI, false);
      }
    };
    FreehandDrawing2.prototype.freehandRedraw = function(context, points) {
      var parent = this.parent;
      var temp = context.filter;
      context.filter = "none";
      if (points) {
        parent.pointColl[parent.freehandCounter] = {
          points,
          strokeColor: parent.activeObj.strokeSettings.strokeColor,
          strokeWidth: this.penStrokeWidth,
          flipState: parent.transform.currFlipState,
          id: "pen_" + (parent.freehandCounter + 1),
          order: parent.objColl.length + parent.freehandCounter + 1
        };
        this.selPointColl[parent.freehandCounter] = extend({}, parent.pointColl[parent.freehandCounter], {}, true);
        parent.freehandCounter++;
      }
      if (parent.freehandCounter > 0) {
        for (var n = 0; n < parent.freehandCounter; n++) {
          parent.points = extend([], parent.pointColl[n].points);
          this.pointCounter = 0;
          var len = parent.points.length;
          var controlPoint1 = void 0;
          var controlPoint2 = void 0;
          var startPoint = void 0;
          var endPoint = void 0;
          var minStrokeWidth = void 0;
          var maxStrokeWidth = void 0;
          if (len > 0) {
            context.fillStyle = parent.pointColl[n].strokeColor;
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = parent.pointColl[n].strokeWidth;
          }
          if (len === 1) {
            controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
            this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
          }
          for (var l = 0; l < len - 3; l++) {
            if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
              controlPoint1 = this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2]).controlPoint2;
              controlPoint2 = this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3]).controlPoint1;
              if (l === 0) {
                startPoint = parent.points[l];
              } else {
                startPoint = parent.points[l + 1];
              }
              endPoint = parent.points[l + 2];
              this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
          }
          context.closePath();
        }
        if (context === this.lowerContext) {
          parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
      context.filter = temp;
    };
    FreehandDrawing2.prototype.getSqPtFD = function(idx, obj) {
      var activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      var sPoints = extend([], this.selPointColl[idx].points, []);
      this.parent.points = extend([], this.parent.pointColl[idx].points);
      this.pointCounter = 0;
      var len = sPoints.length;
      for (var l = 0; l < len; l++) {
        if (activePoint.startX === 0 && activePoint.startY === 0 && activePoint.endX === 0 && activePoint.endY === 0) {
          activePoint.startX = sPoints[l].x;
          activePoint.startY = sPoints[l].y;
          activePoint.endX = sPoints[l].x;
          activePoint.endY = sPoints[l].y;
        } else {
          activePoint.startX = Math.min(activePoint.startX, sPoints[l].x);
          activePoint.startY = Math.min(activePoint.startY, sPoints[l].y);
          activePoint.endX = Math.max(activePoint.endX, sPoints[l].x);
          activePoint.endY = Math.max(activePoint.endY, sPoints[l].y);
        }
      }
      activePoint.startX -= this.penStrokeWidth;
      activePoint.startY -= this.penStrokeWidth;
      activePoint.endX += this.penStrokeWidth;
      activePoint.endY += this.penStrokeWidth;
      activePoint.width = activePoint.endX - activePoint.startX;
      activePoint.height = activePoint.endY - activePoint.startY;
      if (obj) {
        obj["activePoint"] = activePoint;
      }
      return activePoint;
    };
    FreehandDrawing2.prototype.applyPenDraw = function() {
      var parent = this.parent;
      if (parent.currObjType.shape === "freehanddraw") {
        parent.notify("shape", { prop: "apply", onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        parent.currObjType.shape = "";
      }
      parent.notify("shape", { prop: "clearActObj" });
    };
    FreehandDrawing2.prototype.applyFhd = function() {
      var parent = this.parent;
      var selectedPoint = parent.pointColl[this.fhdSelIdx];
      if (selectedPoint.strokeColor === "#42a5f5") {
        selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
      }
      parent.notify("toolbar", { prop: "setSelectedFreehandColor", value: { color: "#42a5f5" } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
      parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      if (selectedPoint) {
        selectedPoint.isSelected = false;
      }
      parent.notify("selection", { prop: "resetFreehandDrawVariables" });
      this.fhdHovIdx = this.fhdSelIdx = null;
    };
    FreehandDrawing2.prototype.cancelFhd = function() {
      var parent = this.parent;
      var selectedPoint = parent.pointColl[this.fhdSelIdx];
      parent.notify("toolbar", { prop: "setSelectedFreehandColor", value: { color: "#42a5f5" } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.pointCounter = 0;
      if (selectedPoint) {
        selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
        selectedPoint.strokeWidth = this.tempFHDStyles.strokeWidth;
        selectedPoint.isSelected = false;
      }
      this.fhdHovIdx = this.fhdSelIdx = this.fhdSelID = null;
      parent.notify("selection", { prop: "resetFreehandDrawVariables" });
      parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor;
      parent.activeObj.strokeSettings.strokeWidth = this.penStrokeWidth = this.tempFHDStyles.strokeWidth;
      this.tempFHDStyles = { strokeColor: null, strokeWidth: null, fillColor: null };
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
      parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
    };
    FreehandDrawing2.prototype.selectFhd = function(index) {
      var parent = this.parent;
      var tempFHDStyles = extend({}, this.tempFHDStyles, {}, true);
      parent.notify("selection", { prop: "setFreehandDrawEditing", onPropertyChange: false, value: { bool: true } });
      if (index || index === 0) {
        if (this.isFHDIdx(index)) {
          this.fhdSelIdx = this.fhdHovIdx = index;
          this.hoverFhd();
          parent.upperCanvas.style.cursor = parent.cursor = "pointer";
        } else {
          return;
        }
      }
      this.fhdSelIdx = this.fhdHovIdx;
      var point = parent.pointColl[this.fhdSelIdx];
      point.isSelected = true;
      this.fhdSelID = point.id;
      if (point.strokeColor !== "#42a5f5") {
        parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor = point.strokeColor;
      }
      parent.activeObj.strokeSettings.strokeWidth = this.tempFHDStyles.strokeWidth = parent.pointColl[this.fhdHovIdx].strokeWidth;
      var obj = { bool: false };
      parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var shapeSettings = {
          id: "pen_" + (this.fhdSelIdx + 1),
          type: ShapeType.FreehandDraw,
          startX: point.points[0].x,
          startY: point.points[0].y,
          strokeColor: point.strokeColor,
          strokeWidth: point.strokeWidth,
          points: point.points,
          opacity: point.opacity,
          index: point.order
        };
        var shapeChangingArgs = {
          cancel: false,
          action: "select",
          previousShapeSettings: shapeSettings,
          currentShapeSettings: shapeSettings
        };
        this.triggerShapeChanging(shapeChangingArgs);
      } else {
        parent.okBtn(null, true);
      }
      if (parent.isUndoRedoStack) {
        this.tempFHDStyles = tempFHDStyles;
      }
    };
    FreehandDrawing2.prototype.deleteFhd = function(index, isId) {
      var parent = this.parent;
      if (this.isFHDIdx(index)) {
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        var tempPointColl = extend({}, parent.pointColl, {}, true);
        var tempSelPointColl = extend({}, this.selPointColl, {}, true);
        parent.pointColl = {};
        this.selPointColl = {};
        var count = 0;
        if (isNullOrUndefined(isId)) {
          for (var i = 0; i < parent.freehandCounter; i++) {
            if (i !== index) {
              parent.pointColl[count] = tempPointColl[i];
              this.selPointColl[count] = tempSelPointColl[i];
              count++;
            }
          }
        } else {
          for (var i = 0; i < parent.freehandCounter; i++) {
            if (parseInt(tempPointColl[i].id.split("_")[1], 10) - 1 !== index) {
              parent.pointColl[count] = tempPointColl[i];
              this.selPointColl[count] = tempSelPointColl[i];
              count++;
            }
          }
        }
        parent.freehandCounter -= 1;
        this.fhdHovIdx = this.fhdSelIdx = null;
        parent.notify("selection", { prop: "resetFreehandDrawVariables" });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    FreehandDrawing2.prototype.zoomX = function(x) {
      return x * this.parent.img.destWidth + this.parent.img.destLeft;
    };
    FreehandDrawing2.prototype.zoomY = function(y) {
      return y * this.parent.img.destHeight + this.parent.img.destTop;
    };
    FreehandDrawing2.prototype.zoomFHDColl = function(isPreventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.x = this.zoomX(point.ratioX);
          point.y = this.zoomY(point.ratioY);
        }
      }
      this.updateFHDCurPts();
      if (this.straightenPoint.x && this.straightenPoint.y) {
        this.straightenPoint.x = this.zoomX(this.straightenPoint.ratioX);
        this.straightenPoint.y = this.zoomY(this.straightenPoint.ratioY);
      }
      if (parent.transform.straighten !== 0) {
        parent.notify("shape", { prop: "straightenFHD", onPropertyChange: false });
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      if (isNullOrUndefined(isPreventApply)) {
        this.freehandRedraw(this.lowerContext, null);
      }
    };
    FreehandDrawing2.prototype.updateFHDCurPts = function() {
      var parent = this.parent;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.x = this.zoomX(point.ratioX);
            point.y = this.zoomY(point.ratioY);
          }
        }
      }
    };
    FreehandDrawing2.prototype.rotateFhdColl = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.y = destTop + destHeight * point.ratioX;
          point.x = destLeft + destWidth - destWidth * point.ratioY;
          point.ratioX = (point.x - destLeft) / destWidth;
          point.ratioY = (point.y - destTop) / destHeight;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.y = destTop + destHeight * point.ratioX;
            point.x = destLeft + destWidth - destWidth * point.ratioY;
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.flipFHDColl = function(value) {
      var lowercaseValue = value.toLowerCase();
      if (lowercaseValue === "horizontal") {
        this.pointsHorizontalFlip();
      } else if (lowercaseValue === "vertical") {
        this.pointsVerticalFlip();
      } else {
        this.pointsHorizontalFlip();
        for (var i = 0; i < this.parent.freehandCounter; i++) {
          this.parent.pointColl[i].shapeFlip = "";
        }
        this.pointsVerticalFlip();
      }
    };
    FreehandDrawing2.prototype.pointsHorizontalFlip = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
          parent.points = extend([], parent.pointColl[n].points, []);
          this.pointCounter = 0;
          var len = parent.points.length;
          for (var l = 0; l < len; l++) {
            var point = parent.points[l];
            if (point.x <= destLeft + destWidth / 2) {
              point.x = destLeft + destWidth - (point.x - destLeft);
            } else if (point.x >= destLeft + destWidth / 2) {
              point.x = destLeft + (destLeft + destWidth - point.x);
            }
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
          parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
            this.selPoints = extend([], this.selPointColl[n].points, []);
            this.pointCounter = 0;
            var len = this.selPoints.length;
            for (var l = 0; l < len; l++) {
              var point = this.selPoints[l];
              if (point.x <= destLeft + destWidth / 2) {
                point.x = destLeft + destWidth - (point.x - destLeft);
              } else if (point.x >= destLeft + destWidth / 2) {
                point.x = destLeft + (destLeft + destWidth - point.x);
              }
              point.ratioX = (point.x - destLeft) / destWidth;
              point.ratioY = (point.y - destTop) / destHeight;
            }
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.pointsVerticalFlip = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
          parent.points = extend([], parent.pointColl[n].points, []);
          this.pointCounter = 0;
          var len = parent.points.length;
          for (var l = 0; l < len; l++) {
            var point = parent.points[l];
            if (point.y <= destTop + destHeight / 2) {
              point.y = destTop + destHeight - (point.y - destTop);
            } else if (point.y >= destTop + destHeight / 2) {
              point.y = destTop + (destTop + destHeight - point.y);
            }
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
          parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
            this.selPoints = extend([], this.selPointColl[n].points, []);
            this.pointCounter = 0;
            var len = this.selPoints.length;
            for (var l = 0; l < len; l++) {
              var point = this.selPoints[l];
              if (point.y <= destTop + destHeight / 2) {
                point.y = destTop + destHeight - (point.y - destTop);
              } else if (point.y >= destTop + destHeight / 2) {
                point.y = destTop + (destTop + destHeight - point.y);
              }
              point.ratioX = (point.x - destLeft) / destWidth;
              point.ratioY = (point.y - destTop) / destHeight;
            }
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.updateFHDColl = function(isPreventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
        var currObj = parent.objColl[i];
        if (currObj.shape === "line" || currObj.shape === "arrow") {
          parent.notify("shape", { prop: "straightenShapePoints", value: { obj: currObj, isReverse: true } });
        } else if (currObj.shape === "path") {
          var temp = parent.transform.straighten;
          parent.transform.straighten = -parent.transform.straighten;
          parent.notify("shape", { prop: "straightenPath", onPropertyChange: false, value: { obj: currObj } });
          parent.transform.straighten = temp;
        }
        currObj.imageRatio = {
          startX: (currObj.activePoint.startX - destLeft) / destWidth,
          startY: (currObj.activePoint.startY - destTop) / destHeight,
          endX: (currObj.activePoint.endX - destLeft) / destWidth,
          endY: (currObj.activePoint.endY - destTop) / destHeight,
          width: destWidth / currObj.activePoint.width,
          height: destHeight / currObj.activePoint.height
        };
        if (currObj.shape === "path") {
          for (var j = 0, jLen = currObj.pointColl.length; j < jLen; j++) {
            currObj.pointColl[j].ratioX = (currObj.pointColl[j].x - destLeft) / destWidth;
            currObj.pointColl[j].ratioY = (currObj.pointColl[j].y - destTop) / destHeight;
          }
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (parent.freehandCounter > 0 && parent.transform.straighten !== 0) {
        var temp = parent.transform.straighten;
        parent.transform.straighten = -parent.transform.straighten;
        parent.notify("shape", { prop: "straightenFHD", onPropertyChange: false });
        parent.transform.straighten = temp;
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.ratioX = (point.x - destLeft) / destWidth;
          point.ratioY = (point.y - destTop) / destHeight;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
        }
      }
      if (this.straightenPoint.x && this.straightenPoint.y) {
        this.straightenPoint.ratioX = (this.straightenPoint.x - destLeft) / destWidth;
        this.straightenPoint.ratioY = (this.straightenPoint.y - destTop) / destHeight;
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
      });
    };
    FreehandDrawing2.prototype.panFHDColl = function(xDiff, yDiff, panRegion) {
      var parent = this.parent;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          if (panRegion === "" || panRegion === "vertical") {
            point.x += xDiff;
          } else {
            point.x -= xDiff;
          }
          if (panRegion === "" || panRegion === "horizontal") {
            point.y += yDiff;
          } else {
            point.y -= yDiff;
          }
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            if (panRegion === "" || panRegion === "vertical") {
              point.x += xDiff;
            } else {
              point.x -= xDiff;
            }
            if (panRegion === "" || panRegion === "horizontal") {
              point.y += yDiff;
            } else {
              point.y -= yDiff;
            }
          }
        }
      }
      if (this.straightenPoint.x && this.straightenPoint.y) {
        if (panRegion === "" || panRegion === "vertical") {
          this.straightenPoint.x += xDiff;
        } else {
          this.straightenPoint.x -= xDiff;
        }
        if (panRegion === "" || panRegion === "horizontal") {
          this.straightenPoint.y += yDiff;
        } else {
          this.straightenPoint.y -= yDiff;
        }
      }
      this.freehandRedraw(this.lowerContext, null);
    };
    FreehandDrawing2.prototype.freeHandDraw = function(value) {
      var parent = this.parent;
      if (value) {
        parent.points = [];
        this.dummyPoints = [];
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.togglePen = true;
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        parent.upperCanvas.style.display = "block";
        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
          var obj = { strokeSettings: {} };
          parent.notify("shape", {
            prop: "getStrokeSettings",
            onPropertyChange: false,
            value: { obj }
          });
          parent.activeObj.strokeSettings = obj["strokeSettings"];
        }
        if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
          parent.activeObj.strokeSettings.strokeWidth = 2;
        }
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "pen",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
      } else {
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        var strokeWidth = this.penStrokeWidth;
        parent.notify("shape", { prop: "apply", onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
        parent.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
        this.penStrokeWidth = strokeWidth;
      }
    };
    FreehandDrawing2.prototype.isFHDIdx = function(index, obj) {
      var isIndex = false;
      for (var i = 0; i < this.parent.freehandCounter; i++) {
        if (this.parent.pointColl[i].id && parseInt(this.parent.pointColl[i].id.split("_")[1], 10) - 1 === index) {
          isIndex = true;
          break;
        }
      }
      if (obj) {
        obj["isIndex"] = isIndex;
      }
      return isIndex;
    };
    FreehandDrawing2.prototype.updateCropPtsForSel = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      for (var n = 0; n < parent.freehandCounter; n++) {
        var obj = { selPointColl: extend([], this.selPointColl) };
        if (obj["selPointColl"][n]) {
          this.selPoints = extend([], obj["selPointColl"][n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.ratioX = (point.x - actPoint.startX) / actPoint.width;
            point.ratioY = (point.y - actPoint.startY) / actPoint.height;
          }
        }
      }
    };
    FreehandDrawing2.prototype.triggerShapeChanging = function(shapeChangingArgs) {
      var parent = this.parent;
      var point = parent.pointColl[this.fhdSelIdx];
      parent.trigger("shapeChanging", shapeChangingArgs);
      if (shapeChangingArgs.currentShapeSettings.id.indexOf("pen_") === -1 && (shapeChangingArgs.action === "draw-end" || shapeChangingArgs.action === "select")) {
        var id = "pen_" + shapeChangingArgs.currentShapeSettings.id;
        if (this.fhdSelIdx) {
          parent.pointColl[this.fhdSelIdx].id = id;
        } else {
          parent.pointColl[parent.freehandCounter - 1].id = id;
        }
      }
      this.penStrokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
      if (parent.activeObj.strokeSettings.strokeColor !== shapeChangingArgs.currentShapeSettings.strokeColor) {
        parent.activeObj.strokeSettings.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      }
      if (this.fhdSelID && point && shapeChangingArgs.currentShapeSettings) {
        point.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
        point.strokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
        point.points = shapeChangingArgs.currentShapeSettings.points;
        point.opacity = shapeChangingArgs.currentShapeSettings.opacity;
      }
      if (shapeChangingArgs.action === "select") {
        this.freehandRedraw(this.upperContext);
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "pen",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
      }
    };
    FreehandDrawing2.prototype.setCenterSelPoints = function() {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(this.prevStraightenObj) || JSON.stringify(this.prevStraightenObj.activePoint) !== JSON.stringify(actPoint)) {
        this.straightenPoint = {
          x: actPoint.startX + actPoint.width / 2,
          y: actPoint.startY + actPoint.height / 2,
          ratioX: (actPoint.startX + actPoint.width / 2 - destLeft) / destWidth,
          ratioY: (actPoint.startY + actPoint.height / 2 - destTop) / destHeight
        };
        this.prevStraightenObj = extend({}, parent.activeObj, {}, true);
        this.straightenPointAngle = parent.transform.straighten;
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    return FreehandDrawing2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/selection.js
var Selection = (
  /** @class */
  function() {
    function Selection2(parent) {
      this.diffPoint = { x: 0, y: 0 };
      this.oldPoint = {};
      this.isTouch = false;
      this.isObjSelected = false;
      this.isFhdPoint = false;
      this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
      this.isShapeInserted = false;
      this.tempActiveObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        order: null
      };
      this.isFirstMove = false;
      this.startTouches = [];
      this.tempTouches = [];
      this.currMousePoint = { x: 0, y: 0 };
      this.cursorTargetId = "";
      this.isPreventDragging = false;
      this.dragElement = "";
      this.textRow = 1;
      this.mouseDownPoint = { x: 0, y: 0 };
      this.previousPoint = { x: 0, y: 0 };
      this.zoomType = "Toolbar";
      this.isInitialTextEdited = false;
      this.dragCanvas = false;
      this.isFhdCustomized = false;
      this.touchEndPoint = {};
      this.isFhdEditing = false;
      this.currentDrawingShape = "";
      this.initialPrevObj = {};
      this.touchTime = 0;
      this.resizedElement = "";
      this.isImageClarity = true;
      this.isPinching = false;
      this.isSliding = false;
      this.mouseDown = "";
      this.isSliderActive = false;
      this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
      this.parent = parent;
      this.addEventListener();
    }
    Selection2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Selection2.prototype.addEventListener = function() {
      this.parent.on("selection", this.selection, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Selection2.prototype.removeEventListener = function() {
      this.parent.off("selection", this.selection);
      this.parent.off("destroyed", this.destroy);
    };
    Selection2.prototype.selection = function(args) {
      var parent = this.parent;
      this.updatePrivateVariables();
      switch (args.prop) {
        case "setCursor":
          this.setCursor(args.value["x"], args.value["y"]);
          break;
        case "updateActivePoint":
          this.updateActivePoint(args.value["x"], args.value["y"], args.value["isCropSelection"]);
          break;
        case "updateCursorStyles":
          this.updateCursorStyles(args.value["x"], args.value["y"], args.value["type"]);
          break;
        case "setTextSelection":
          this.setTextSelection(args.value["width"], args.value["height"]);
          break;
        case "setActivePoint":
          this.setActivePoint(args.value["startX"], args.value["startY"]);
          break;
        case "clearSelection":
          this.clearSelection(args.value["resetCrop"]);
          break;
        case "calcShapeRatio":
          this.calcShapeRatio(args.value["x"], args.value["y"], args.value["imgWidth"], args.value["imgHeight"]);
          break;
        case "tab":
          this.performTabAction();
          break;
        case "setDragDirection":
          this.setDragDirection(args.value["width"], args.value["height"]);
          break;
        case "clearUpperCanvas":
          if (this.isTouch) {
            setTimeout(function() {
              parent.upperCanvas.getContext("2d").clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }, 550);
          }
          break;
        case "resetFreehandDrawVariables":
          this.isFhdEditing = this.isFhdPoint = false;
          break;
        case "isShapeInserted":
          this.isShapeInserted = args.value["bool"];
          break;
        case "redrawShape":
          this.redrawShape(args.value["obj"]);
          break;
        case "setTextBoxStylesToActObj":
          this.setTextBoxStylesToActObj();
          break;
        case "mouseDownEventHandler":
          this.mouseDownEventHandler(args.value["e"]);
          break;
        case "mouseMoveEventHandler":
          this.mouseMoveEventHandler(args.value["e"]);
          break;
        case "mouseUpEventHandler":
          this.mouseUpEventHandler(args.value["e"]);
          break;
        case "canvasMouseDownHandler":
          this.canvasMouseDownHandler(args.value["e"]);
          break;
        case "canvasMouseMoveHandler":
          this.canvasMouseMoveHandler(args.value["e"]);
          break;
        case "canvasMouseUpHandler":
          this.canvasMouseUpHandler(args.value["e"]);
          break;
        case "touchStartHandler":
          this.touchStartHandler(args.value["e"]);
          break;
        case "keyDownEventHandler":
          this.keyDownEventHandler(args.value["e"]);
          break;
        case "handleScroll":
          this.handleScroll(args.value["e"]);
          break;
        case "textKeyDown":
          setTimeout(this.textKeyDown.bind(this), 1, args.value["e"]);
          break;
        case "deleteItem":
          this.deleteItem();
          break;
        case "updatePrevShapeSettings":
          this.updatePrevShapeSettings(args.value["obj"]);
          break;
        case "getZoomType":
          args.value["obj"]["zoomType"] = this.zoomType;
          break;
        case "setZoomType":
          this.zoomType = args.value["zoomType"];
          break;
        case "setInitialTextEdit":
          this.isInitialTextEdited = args.value["bool"];
          break;
        case "setDragCanvas":
          this.dragCanvas = args.value["bool"];
          break;
        case "setFreehandDrawCustomized":
          this.isFhdCustomized = args.value["isFreehandDrawCustomized"];
          break;
        case "setTouchEndPoint":
          this.touchEndPoint.x = args.value["x"];
          this.touchEndPoint.y = args.value["y"];
          break;
        case "getPanDown":
          args.value["obj"]["panDown"] = this.panDown;
          break;
        case "setPanDown":
          this.panDown = args.value["panDown"];
          break;
        case "getFreehandDrawEditing":
          args.value["obj"]["bool"] = this.isFhdEditing;
          break;
        case "setFreehandDrawEditing":
          this.isFhdEditing = args.value["bool"];
          break;
        case "getTempActObj":
          args.value["obj"]["tempObj"] = this.tempActiveObj;
          break;
        case "setTempActObj":
          this.tempActiveObj = args.value["obj"];
          break;
        case "isInside":
          this.isInside(args.value["x"], args.value["y"], args.value["z1"], args.value["z2"], args.value["z3"], args.value["z4"]);
          break;
        case "setDragElement":
          this.dragElement = args.value["value"];
          break;
        case "setObjSelected":
          this.isObjSelected = args.value["bool"];
          break;
        case "adjustActObjForLineArrow":
          this.adjustActObjForLineArrow(args.value["obj"]);
          break;
        case "findTarget":
          this.findTarget(args.value["x"], args.value["y"], args.value["type"]);
          break;
        case "getCurrentFlipState":
          this.getCurrentFlipState();
          break;
        case "setDragWidth":
          this.setDragWidth(args.value["width"]);
          break;
        case "setDragHeight":
          this.setDragHeight(args.value["setDragHeight"]);
          break;
        case "annotate":
          this.currentDrawingShape = args.value["shape"];
          if (args.value["shape"] === "text") {
            parent.activeObj.textSettings.fontSize = 11;
            parent.activeObj.keyHistory = "Enter Text";
            parent.notify("shape", {
              prop: "initializeTextShape",
              onPropertyChange: false,
              value: { text: null, fontFamily: null, fontSize: null, bold: null, italic: null, strokeColor: null }
            });
          } else if (args.value["shape"] === "path") {
            parent.activeObj.pointColl = [];
          }
          break;
        case "getCurrentDrawingShape":
          args.value["obj"]["shape"] = this.currentDrawingShape;
          break;
        case "setCurrentDrawingShape":
          this.currentDrawingShape = args.value["value"];
          break;
        case "getTransRotationPoint":
          this.getTransRotationPoint(args.value["obj"], args.value["object"]);
          break;
        case "adjustNEPoints":
          this.adjustNEPoints(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"]);
          break;
        case "adjustRotationPoints":
          this.adjustRotationPoints(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"], args.value["type"], args.value["elem"]);
          break;
        case "getResizeDirection":
          this.getResizeDirection(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"]);
          break;
        case "setResizedElement":
          this.resizedElement = args.value["value"];
          break;
        case "reset":
          this.reset();
          break;
        case "unWireEvent":
          this.unwireEvent();
          break;
        case "updPtCollForShpRot":
          this.updPtCollForShpRot(args.value["obj"]);
          break;
        case "findImageRatio":
          this.findImageRatio(args.value["width"], args.value["height"], args.value["obj"]);
          break;
        case "getNumTextValue":
          this.getNumTextValue(args.value["obj"]);
          break;
        case "setImageClarity":
          this.isImageClarity = args.value["bool"];
          break;
        case "upgradeImageQuality":
          this.upgradeImageQuality();
          break;
        case "triggerShapeChange":
          this.triggerShapeChange(args.value["shapeResizingArgs"], args.value["shapeMovingArgs"], args.value["type"]);
          break;
        case "applyTransformToImg":
          this.applyTransformToImg(args.value["ctx"]);
          break;
        case "findTargetObj":
          args.value["obj"]["bool"] = this.findTargetObj(args.value["x"], args.value["y"], args.value["isCrop"]);
          break;
        case "setSliding":
          this.isSliding = args.value["bool"];
          break;
        case "setSliderActive":
          this.isSliderActive = args.value["bool"];
          break;
        case "getArrowType":
          args.value["obj"]["type"] = this.getArrowType(args.value["type"]);
          break;
        case "setArrowShape":
          if (args.value["type"] === "initial") {
            this.arrowShape[0] = args.value["shape"];
          } else {
            this.arrowShape[1] = args.value["shape"];
          }
          break;
        case "updateNWPoints":
          this.updateNWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateNPoints":
          this.updateNPoints(args.value["x"], args.value["y"]);
          break;
        case "updateNEPoints":
          this.updateNEPoints(args.value["x"], args.value["y"]);
          break;
        case "updateWPoints":
          this.updateWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateEPoints":
          this.updateEPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSWPoints":
          this.updateSWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSPoints":
          this.updateSPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSEPoints":
          this.updateSEPoints(args.value["x"], args.value["y"]);
          break;
      }
    };
    Selection2.prototype.getModuleName = function() {
      return "selection";
    };
    Selection2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    Selection2.prototype.reset = function() {
      this.diffPoint = { x: 0, y: 0 };
      this.oldPoint = {};
      this.isTouch = this.isObjSelected = this.isFhdPoint = this.isShapeInserted = false;
      this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
      this.tempActiveObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        order: null
      };
      this.isFirstMove = false;
      this.cursorTargetId = this.dragElement = "";
      this.startTouches = [];
      this.tempTouches = [];
      this.currMousePoint = { x: 0, y: 0 };
      this.isPreventDragging = false;
      this.timer = void 0;
      this.tempObjColl = void 0;
      this.textRow = 1;
      this.mouseDownPoint = { x: 0, y: 0 };
      this.previousPoint = { x: 0, y: 0 };
      this.zoomType = "Toolbar";
      this.isInitialTextEdited = false;
      this.dragCanvas = this.isPinching = false;
      this.isFhdCustomized = false;
      this.touchEndPoint = {};
      this.panDown = null;
      this.isSliding = false;
      this.isFhdEditing = false;
      this.pathAdjustedIndex = null;
      this.touchTime = 0;
      this.isImageClarity = true;
      this.currentDrawingShape = "";
      this.initialPrevObj = {};
      this.resizedElement = "";
      this.mouseDown = "";
      this.isSliderActive = false;
      this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
    };
    Selection2.prototype.performTabAction = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        var allowUndoRedoPush = this.applyCurrShape(false);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        if (allowUndoRedoPush) {
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
      }
      parent.isKBDNavigation = true;
    };
    Selection2.prototype.selMouseUpEvent = function() {
      this.oldPoint.x = void 0;
      this.oldPoint.y = void 0;
    };
    Selection2.prototype.getMouseCursor = function(actObj, x, y, isCropSelection, isApply) {
      var rotationCirclePoint = this.getTransRotationPoint(actObj);
      var radius = actObj.bottomCenterCircle.radius;
      var cursor = "default";
      var ratio = isApply ? 0 : actObj.topLeftCircle.radius * 2;
      if (x >= actObj.topLeftCircle.startX - ratio && x <= actObj.topLeftCircle.startX + ratio && y >= actObj.topLeftCircle.startY - ratio && y <= actObj.topLeftCircle.startY + ratio) {
        cursor = "nw-resize";
      } else if (x >= actObj.topLeftCircle.startX - ratio && x <= actObj.topRightCircle.startX - ratio && y >= actObj.topCenterCircle.startY - ratio && y <= actObj.topCenterCircle.startY + ratio) {
        cursor = "n-resize";
      } else if (x >= actObj.topRightCircle.startX - ratio && x <= actObj.topRightCircle.startX + ratio && y >= actObj.topRightCircle.startY - ratio && y <= actObj.topRightCircle.startY + ratio) {
        cursor = "ne-resize";
      } else if (x >= actObj.centerLeftCircle.startX - ratio && x <= actObj.centerLeftCircle.startX + ratio && y >= actObj.topLeftCircle.startY - ratio && y <= actObj.bottomLeftCircle.startY - ratio) {
        cursor = "w-resize";
      } else if (x >= actObj.centerRightCircle.startX - ratio && x <= actObj.centerRightCircle.startX + ratio && y >= actObj.topRightCircle.startY - ratio && y <= actObj.bottomRightCircle.startY - ratio) {
        cursor = "e-resize";
      } else if (x >= actObj.bottomLeftCircle.startX - ratio && x <= actObj.bottomLeftCircle.startX + ratio && y >= actObj.bottomLeftCircle.startY - ratio && y <= actObj.bottomLeftCircle.startY + ratio) {
        cursor = "sw-resize";
      } else if (x >= actObj.bottomLeftCircle.startX - ratio && x <= actObj.bottomRightCircle.startX - ratio && y >= actObj.bottomCenterCircle.startY - ratio && y <= actObj.bottomCenterCircle.startY + ratio) {
        cursor = "s-resize";
      } else if (x >= actObj.bottomRightCircle.startX - ratio && x <= actObj.bottomRightCircle.startX + ratio && y >= actObj.bottomRightCircle.startY - ratio && y <= actObj.bottomRightCircle.startY + ratio) {
        cursor = "se-resize";
      } else if (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX && (y >= actObj.activePoint.startY && y <= actObj.activePoint.endY)) {
        if (isCropSelection) {
          cursor = "grab";
        } else {
          cursor = "move";
        }
      } else if (rotationCirclePoint && !isApply && x >= rotationCirclePoint.x - (radius + 2) && x <= rotationCirclePoint.x + (radius + 2) && y >= rotationCirclePoint.y - (radius + 2) && y <= rotationCirclePoint.y + (radius + 2)) {
        cursor = "grabbing";
      } else {
        cursor = "default";
      }
      return cursor;
    };
    Selection2.prototype.setCursor = function(x, y) {
      var parent = this.parent;
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var frameObject = { bool: null };
      parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (parent.isResize || this.isSliding || frameObject["bool"]) {
        parent.upperCanvas.style.cursor = "default";
        return;
      }
      var isCropSelection = false;
      var splitWords;
      if (parent.currObjType.isDragging) {
        if (this.dragElement === "") {
          parent.upperCanvas.style.cursor = parent.cursor = "move";
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = this.dragElement;
        }
        return;
      }
      if (parent.togglePen) {
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        return;
      }
      if (parent.activeObj.shape) {
        this.setCursorForActObj(splitWords, isCropSelection, x, y);
      }
      if (parent.cursor === "default" || parent.cursor === "grab") {
        var highestOrder = this.getHighestOrder();
        var tempShapeColl = extend([], parent.shapeColl, [], true);
        var objColl = extend([], parent.objColl, [], true);
        var isShape = false;
        while (highestOrder > 0) {
          isShape = false;
          for (var i = tempShapeColl.length - 1; i >= 0; i--) {
            if (tempShapeColl[i].order === highestOrder) {
              isShape = true;
              if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf("pen") > -1) {
                if (parent.pointColl[0] && (parent.cursor !== "grab" || !isCropSelection) && !parent.currObjType.isDragging && !parent.currObjType.isResize) {
                  var points = extend([], parent.points, [], true);
                  if (!isCropSelection) {
                    this.setCursorForFreehandDrawing(x, y, parent.upperCanvas, tempShapeColl[i].id);
                  }
                  parent.points = points;
                }
              } else {
                parent.objColl = [];
                parent.objColl.push(extend({}, tempShapeColl[i], null, true));
                var cursor = parent.upperCanvas.style.cursor;
                if (parent.objColl.length > 0 && (parent.cursor !== "grab" || !isCropSelection)) {
                  this.setCursorFromObj(x, y, parent.objColl, parent.upperCanvas, isCropSelection);
                }
                if (cursor === "grab" && parent.cursor === "default") {
                  parent.upperCanvas.style.cursor = parent.cursor = "grab";
                }
              }
            } else if (isNullOrUndefined(tempShapeColl[i].order)) {
              isShape = true;
            }
          }
          if (parent.cursor !== "default" && parent.cursor !== "grab") {
            break;
          } else if (isShape) {
            var isBreak = false;
            while (!isBreak && highestOrder > 0) {
              for (var a = 0; a < tempShapeColl.length; a++) {
                if (tempShapeColl[a].order === highestOrder - 1) {
                  isBreak = true;
                  break;
                }
              }
              highestOrder--;
              if (!isBreak) {
                highestOrder--;
              }
            }
          }
        }
        parent.objColl = objColl;
        if (parent.cursor === "default" || parent.cursor === "grab") {
          if (parent.togglePan) {
            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
          }
        }
      }
      if (this.currentDrawingShape !== "" && (parent.cursor === "default" || parent.cursor === "grab")) {
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
      }
    };
    Selection2.prototype.getHighestOrder = function() {
      var highestOrder = 0;
      for (var i = 0; i < this.parent.shapeColl.length; i++) {
        if (this.parent.shapeColl[i].order > highestOrder) {
          highestOrder = this.parent.shapeColl[i].order;
        }
      }
      return highestOrder;
    };
    Selection2.prototype.setCursorForActObj = function(splitWords, isCropSelection, x, y) {
      var parent = this.parent;
      if (parent.activeObj.horTopLine !== void 0) {
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
          isCropSelection = true;
        } else if (splitWords !== void 0 && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (!isCropSelection && parent.togglePan) {
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
        var cursor = parent.upperCanvas.style.cursor;
        var actObj = extend({}, parent.activeObj, {}, true);
        this.cursorTargetId = actObj.currIndex;
        var degree = void 0;
        if (actObj.shapeDegree === 0) {
          degree = parent.transform.degree;
        } else {
          degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
          degree = 360 + degree;
        }
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, parent.upperCanvas);
        } else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
          this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, false);
          var cursorColl = ["n-resize", "s-resize", "e-resize", "w-resize"];
          if (actObj.shape === "text" && cursorColl.indexOf(parent.cursor) > -1) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
          }
        }
        if (cursor === "default" && parent.cursor === "default" && isCropSelection) {
          parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
        if (cursor === "grab" && parent.cursor === "default") {
          parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
      } else if (parent.togglePan && !parent.togglePen) {
        parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
      } else {
        if (parent.currObjType.isCustomCrop || parent.togglePen) {
          parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Selection2.prototype.setCursorForPath = function(actObj, x, y, upperCanvas) {
      this.setCursorForLineArrow(actObj, x, y, upperCanvas);
      var parent = this.parent;
      if (parent.cursor === "default") {
        var obj = extend({}, actObj, null, true);
        var isMove = false;
        for (var i = 1, len = actObj.pointColl.length; i < len; i++) {
          if (isMove) {
            break;
          }
          obj.activePoint.startX = actObj.pointColl[i - 1].x;
          obj.activePoint.startY = actObj.pointColl[i - 1].y;
          obj.activePoint.endX = actObj.pointColl[i].x;
          obj.activePoint.endY = actObj.pointColl[i].y;
          parent.notify("shape", {
            prop: "setPointCollForLineArrow",
            onPropertyChange: false,
            value: { obj }
          });
          var radius = actObj.topLeftCircle.radius;
          for (var j = 0, jLen = obj.pointColl.length; j < jLen; j++) {
            var point = obj.pointColl[j];
            if (!isNullOrUndefined(point.x - radius * 2) && !isNullOrUndefined(point.x + radius * 2) && !isNullOrUndefined(point.y - radius * 2) && !isNullOrUndefined(point.y + radius * 2) && x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
              upperCanvas.style.cursor = parent.cursor = "move";
              isMove = true;
              break;
            } else {
              upperCanvas.style.cursor = parent.cursor = "default";
            }
          }
        }
      }
      return parent.cursor;
    };
    Selection2.prototype.setCursorForLineArrow = function(actObj, x, y, upperCanvas) {
      var index;
      var radius = actObj.topLeftCircle.radius;
      if (isNullOrUndefined(actObj.pointColl)) {
        return index;
      }
      for (var i = 0, len = actObj.pointColl.length; i < len; i++) {
        var point = actObj.pointColl[i];
        if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
          upperCanvas.style.cursor = this.parent.cursor = "move";
          index = i;
          break;
        } else {
          upperCanvas.style.cursor = this.parent.cursor = "default";
        }
      }
      return index;
    };
    Selection2.prototype.setCursorForRotatedObject = function(actObj, x, y, upperCanvas) {
      this.resizedElement = "";
      var parent = this.parent;
      var radius = actObj.bottomCenterCircle.radius;
      var horTP = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)];
      var horTP1 = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)];
      var verLP = actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)];
      var verRP = actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)];
      var horBP = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)];
      var horBP1 = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)];
      var rotCP = actObj.rotationCirclePointColl;
      var horTP0 = actObj.horTopLinePointColl[0];
      var horBP0 = actObj.horBottomLinePointColl[0];
      if (x >= horTP0.x - (radius + 2) && x <= horTP0.x + (radius + 2) && y >= horTP0.y - (radius + 2) && y <= horTP0.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "nw-resize";
      } else if (x >= horTP.x - 5 && x <= horTP.x + 5 && y >= horTP.y - 5 && y <= horTP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "n-resize";
      } else if (x >= horTP1.x - (radius + 2) && x <= horTP1.x + (radius + 2) && y >= horTP1.y - (radius + 2) && y <= horTP1.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "ne-resize";
      } else if (x >= verLP.x - 5 && x <= verLP.x + 5 && y >= verLP.y - 5 && y <= verLP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "w-resize";
      } else if (x >= verRP.x - 5 && x <= verRP.x + 5 && y >= verRP.y - 5 && y <= verRP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "e-resize";
      } else if (x >= horBP0.x - (radius + 2) && x <= horBP0.x + (radius + 2) && y >= horBP0.y - (radius + 2) && y <= horBP0.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "sw-resize";
      } else if (x >= horBP.x - 5 && x <= horBP.x + 5 && y >= horBP.y - 5 && y <= horBP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "s-resize";
      } else if (x >= horBP1.x - (radius + 2) && x <= horBP1.x + (radius + 2) && y >= horBP1.y - (radius + 2) && y <= horBP1.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "se-resize";
      } else if (rotCP && x >= rotCP.x - (radius + 2) && x <= rotCP.x + (radius + 2) && y >= rotCP.y - (radius + 2) && y <= rotCP.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "grabbing";
      } else {
        upperCanvas.style.cursor = parent.cursor = "default";
        var isPointsInsideRectangle = this.getRectanglePoints(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height, actObj.rotatedAngle * (180 / Math.PI), x, y);
        if (isPointsInsideRectangle) {
          upperCanvas.style.cursor = parent.cursor = "move";
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.horTopLinePointColl.length; i < len; i++) {
          var horTP_1 = actObj.horTopLinePointColl[i];
          if (x >= horTP_1.x - 5 && x <= horTP_1.x + 5 && y >= horTP_1.y - 5 && y <= horTP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "n-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.horBottomLinePointColl.length; i < len; i++) {
          var horBP_1 = actObj.horBottomLinePointColl[i];
          if (x >= horBP_1.x - 5 && x <= horBP_1.x + 5 && y >= horBP_1.y - 5 && y <= horBP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "s-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.verLeftLinePointColl.length; i < len; i++) {
          var verLP_1 = actObj.verLeftLinePointColl[i];
          if (x >= verLP_1.x - 5 && x <= verLP_1.x + 5 && y >= verLP_1.y - 5 && y <= verLP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "w-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.verRightLinePointColl.length; i < len; i++) {
          var verRP_1 = actObj.verRightLinePointColl[i];
          if (x >= verRP_1.x - 5 && x <= verRP_1.x + 5 && y >= verRP_1.y - 5 && y <= verRP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "e-resize";
            break;
          }
        }
      }
      this.adjustCursorStylesForRotatedState(actObj);
      return parent.cursor;
    };
    Selection2.prototype.adjustCursorStylesForRotatedState = function(actObj) {
      var parent = this.parent;
      var length = actObj.rotatedAngle * (180 / Math.PI);
      length = length > 0 ? Math.floor(length) : Math.ceil(length);
      if (length >= 92 && length <= 182 || length >= -178 && length <= -88) {
        var cursorMap = {
          "nw-resize": "ne-resize",
          "n-resize": "s-resize",
          "ne-resize": "nw-resize",
          "w-resize": "e-resize",
          "e-resize": "w-resize",
          "sw-resize": "se-resize",
          "s-resize": "n-resize",
          "se-resize": "sw-resize"
        };
        if (parent.cursor in cursorMap) {
          parent.cursor = cursorMap[parent.cursor];
        }
      }
      parent.upperCanvas.style.cursor = this.getResizeElement(actObj.rotatedAngle * (180 / Math.PI), parent.cursor);
      return parent.cursor;
    };
    Selection2.prototype.getResizeElement = function(degree, element2) {
      var resizeMappings = [];
      switch (element2) {
        case "nw-resize":
          resizeMappings = [
            [337.5, 22.5, "nw-resize"],
            [22.5, 67.5, "n-resize"],
            [67.5, 112.5, "ne-resize"],
            [112.5, 157.5, "e-resize"],
            [157.5, 202.5, "se-resize"],
            [202.5, 247.5, "s-resize"],
            [247.5, 292.5, "sw-resize"],
            [292.5, 337.5, "w-resize"]
          ];
          break;
        case "n-resize":
          resizeMappings = [
            [337.5, 22.5, "n-resize"],
            [22.5, 67.5, "ne-resize"],
            [67.5, 112.5, "e-resize"],
            [112.5, 157.5, "se-resize"],
            [157.5, 202.5, "s-resize"],
            [202.5, 247.5, "sw-resize"],
            [247.5, 292.5, "w-resize"],
            [292.5, 337.5, "nw-resize"]
          ];
          break;
        case "ne-resize":
          resizeMappings = [
            [337.5, 22.5, "ne-resize"],
            [22.5, 67.5, "e-resize"],
            [67.5, 112.5, "se-resize"],
            [112.5, 157.5, "s-resize"],
            [157.5, 202.5, "sw-resize"],
            [202.5, 247.5, "w-resize"],
            [247.5, 292.5, "nw-resize"],
            [292.5, 337.5, "n-resize"]
          ];
          break;
        case "e-resize":
          resizeMappings = [
            [337.5, 22.5, "e-resize"],
            [22.5, 67.5, "se-resize"],
            [67.5, 112.5, "s-resize"],
            [112.5, 157.5, "sw-resize"],
            [157.5, 202.5, "w-resize"],
            [202.5, 247.5, "nw-resize"],
            [247.5, 292.5, "n-resize"],
            [292.5, 337.5, "ne-resize"]
          ];
          break;
        case "se-resize":
          resizeMappings = [
            [337.5, 22.5, "se-resize"],
            [22.5, 67.5, "s-resize"],
            [67.5, 112.5, "sw-resize"],
            [112.5, 157.5, "w-resize"],
            [157.5, 202.5, "nw-resize"],
            [202.5, 247.5, "n-resize"],
            [247.5, 292.5, "ne-resize"],
            [292.5, 337.5, "e-resize"]
          ];
          break;
        case "s-resize":
          resizeMappings = [
            [337.5, 22.5, "s-resize"],
            [22.5, 67.5, "sw-resize"],
            [67.5, 112.5, "w-resize"],
            [112.5, 157.5, "nw-resize"],
            [157.5, 202.5, "n-resize"],
            [202.5, 247.5, "ne-resize"],
            [247.5, 292.5, "e-resize"],
            [292.5, 337.5, "se-resize"]
          ];
          break;
        case "sw-resize":
          resizeMappings = [
            [337.5, 22.5, "sw-resize"],
            [22.5, 67.5, "w-resize"],
            [67.5, 112.5, "nw-resize"],
            [112.5, 157.5, "n-resize"],
            [157.5, 202.5, "ne-resize"],
            [202.5, 247.5, "e-resize"],
            [247.5, 292.5, "se-resize"],
            [292.5, 337.5, "s-resize"]
          ];
          break;
        case "w-resize":
          resizeMappings = [
            [337.5, 22.5, "w-resize"],
            [22.5, 67.5, "nw-resize"],
            [67.5, 112.5, "n-resize"],
            [112.5, 157.5, "ne-resize"],
            [157.5, 202.5, "e-resize"],
            [202.5, 247.5, "se-resize"],
            [247.5, 292.5, "s-resize"],
            [292.5, 337.5, "sw-resize"]
          ];
          break;
      }
      var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
      for (var _i = 0, resizeMappings_1 = resizeMappings; _i < resizeMappings_1.length; _i++) {
        var _a = resizeMappings_1[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
        if (positiveDegree > startDegree && positiveDegree <= endDegree || positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree) {
          return resizeElement;
        }
      }
      return element2;
    };
    Selection2.prototype.setCursorForFreehandDrawing = function(x, y, upperCanvas, id) {
      var upperContext = upperCanvas.getContext("2d");
      var parent = this.parent;
      var textArea = document.querySelector("#" + parent.element.id + "_textArea");
      var isEntered = false;
      parent.notify("freehand-draw", {
        prop: "setFreehandDrawHoveredIndex",
        onPropertyChange: false,
        value: { index: -1 }
      });
      var sPoints;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (id && id !== parent.pointColl[n].id) {
          continue;
        }
        var obj = { selPointColl: {} };
        parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj } });
        sPoints = extend([], obj["selPointColl"][n].points, []);
        parent.points = extend([], parent.pointColl[n].points, []);
        var ptc = parent.pointColl[n];
        parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
        var len = sPoints.length;
        for (var l = 0; l < len; l++) {
          if (l !== 0) {
            var isInside = false;
            if (sPoints[l - 1] && sPoints[l]) {
              isInside = this.isInside(x, y, sPoints[l - 1].x, sPoints[l - 1].y, sPoints[l].x, sPoints[l].y);
            }
            if (isInside) {
              this.isFhdPoint = true;
              parent.notify("freehand-draw", {
                prop: "setFreehandDrawHoveredIndex",
                onPropertyChange: false,
                value: { index: n }
              });
              parent.notify("freehand-draw", {
                prop: "hoverFhd",
                onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: null }
              });
              upperCanvas.style.cursor = parent.cursor = "pointer";
              isEntered = true;
              break;
            } else if (!this.isFhdEditing || ptc.isSelected) {
              if (this.isFhdPoint || this.isFhdEditing) {
                upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                if (parent.activeObj.shape && textArea.style.display === "none") {
                  parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
                }
              }
              if (this.isFhdEditing) {
                var indexObj = { freehandSelectedIndex: -1 };
                parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
                var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
                var strokeWidth = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth;
                parent.notify("freehand-draw", {
                  prop: "hoverFhd",
                  onPropertyChange: false,
                  value: { strokeColor, strokeWidth }
                });
              } else {
                parent.notify("freehand-draw", {
                  prop: "setFreehandDrawHoveredIndex",
                  onPropertyChange: false,
                  value: { index: null }
                });
              }
              this.isFhdPoint = false;
            }
          } else {
            var pt = parent.points[l];
            if (x > pt.x - ptc.strokeWidth && x < pt.x + ptc.strokeWidth && y > pt.y - ptc.strokeWidth && y < pt.y + ptc.strokeWidth) {
              this.isFhdPoint = true;
              parent.notify("freehand-draw", { prop: "setFreehandDrawHoveredIndex", onPropertyChange: false, value: { index: n } });
              parent.notify("freehand-draw", { prop: "hoverFhd", onPropertyChange: false, value: { strokeColor: null, strokeWidth: null } });
              upperCanvas.style.cursor = parent.cursor = "pointer";
              isEntered = true;
              break;
            } else if (!this.isFhdEditing || ptc.isSelected) {
              if (this.isFhdPoint || this.isFhdEditing) {
                upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                if (parent.activeObj.shape && textArea.style.display === "none") {
                  parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
                }
              }
              if (this.isFhdEditing) {
                var indexObj = { freehandSelectedIndex: -1 };
                parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
                var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
                var strokeWidth = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth;
                parent.notify("freehand-draw", {
                  prop: "hoverFhd",
                  onPropertyChange: false,
                  value: { strokeColor, strokeWidth }
                });
              }
              this.isFhdPoint = false;
            }
          }
        }
        if (isEntered) {
          break;
        }
      }
    };
    Selection2.prototype.setCursorFromObj = function(x, y, obj, upperCanvas, isCropSelection) {
      var parent = this.parent;
      for (var i = 0, len = obj.length; i < len; i++) {
        if (parent.cursor === "move") {
          return;
        }
        var actObj = extend({}, obj[i], {}, true);
        this.cursorTargetId = actObj.currIndex;
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, upperCanvas);
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, upperCanvas);
        } else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
          this.setCursorForRotatedObject(actObj, x, y, upperCanvas);
        } else {
          upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, true);
        }
      }
    };
    Selection2.prototype.isInside = function(x, y, z1, z2, z3, z4) {
      var x1 = Math.min(z1, z3);
      var x2 = Math.max(z1, z3);
      var y1 = Math.min(z2, z4);
      var y2 = Math.max(z2, z4);
      if (x1 <= x && x <= x2 && (y1 <= y && y <= y2)) {
        return true;
      } else {
        return false;
      }
    };
    Selection2.prototype.updateActivePoint = function(x, y, isCropSelection) {
      var parent = this.parent;
      var obj = { width: 0, height: 0 };
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var _b = parent.activeObj.activePoint, width = _b.width, height = _b.height;
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width, height, obj, isImgShape: null }
      });
      var previousShapeSettings = this.updatePrevShapeSettings();
      var shapeResizingArgs = { cancel: false, action: "resize", previousShapeSettings };
      var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings };
      this.shapeResizingArgs = shapeResizingArgs;
      this.shapeMovingArgs = shapeMovingArgs;
      if (parent.activeObj.shape === "text" && this.dragElement !== "") {
        parent.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: parent.activeObj, isTextArea: null }
        });
      }
      if (this.currentDrawingShape !== "" && (this.dragElement === "" || this.dragElement === "move") && parent.isShapeDrawing) {
        var shapeColl = ["line", "arrow", "path"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          this.dragElement = "e-resize";
        } else {
          if (x > startX && y > startY) {
            this.dragElement = "se-resize";
          } else if (x < startX && y > startY) {
            this.dragElement = "sw-resize";
          } else if (x > startX && y < startY) {
            this.dragElement = "ne-resize";
          } else if (x < startX && y < startY) {
            this.dragElement = "nw-resize";
          }
        }
      }
      if (parent.activeObj.shape === "arrow") {
        if (Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2) > 0) {
          parent.activeObj.rotatedAngle = -Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2);
        } else {
          parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2));
        }
      }
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      if (isCropSelection && parent.transform.straighten !== 0 && this.isMouseOutsideImg(x, y)) {
        return;
      }
      switch (this.dragElement.toLowerCase()) {
        case "nw-resize":
          this.updateNWPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "n-resize":
          this.updateNPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "ne-resize":
          this.updateNEPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "w-resize":
          this.updateWPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "e-resize":
          this.updateEPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "sw-resize":
          this.updateSWPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "s-resize":
          this.updateSPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "se-resize":
          this.updateSEPoints(x, y);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "grabbing":
          if (Math.atan2(x - (startX + width / 2), y - (startY + height / 2)) > 0) {
            parent.activeObj.rotatedAngle = -Math.atan2(x - (startX + width / 2), y - (startY + height / 2));
          } else {
            parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - (startX + width / 2), y - (startY + height / 2)));
          }
          if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
          } else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
          }
          if (degree < 0) {
            degree = 360 + degree;
          }
          for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
            if (parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal") {
              isHorizontalflip = true;
            } else if (parent.activeObj.flipObjColl[i].toLowerCase() === "vertical") {
              isVerticalflip = true;
            }
          }
          parent.activeObj.rotatedAngle -= degree * (Math.PI / 180);
          if (degree === 0 || degree === 360) {
            if (isVerticalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 90 || degree === -270) {
            if (isHorizontalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 180 || degree === -180) {
            if (isVerticalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 270 || degree === -90) {
            if (isHorizontalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          }
          break;
        case "pathdrag":
          if (!isNullOrUndefined(this.pathAdjustedIndex)) {
            parent.activeObj.pointColl[this.pathAdjustedIndex].x = x;
            parent.activeObj.pointColl[this.pathAdjustedIndex].y = y;
          }
          break;
        default:
          if (!isCropSelection && !parent.currObjType.isCustomCrop) {
            var activePoint = parent.activeObj.activePoint;
            if (this.dragPoint.startX) {
              var width_1 = this.dragPoint.endX - this.previousPoint.x;
              var height_1 = this.dragPoint.endY - this.previousPoint.y;
              activePoint.startX += width_1;
              activePoint.endX += width_1;
              activePoint.startY += height_1;
              activePoint.endY += height_1;
              startX = activePoint.startX;
              startY = activePoint.startY;
              endX = activePoint.endX;
              endY = activePoint.endY;
              if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.rotationCirclePointColl) {
                parent.activeObj.rotationCirclePointColl.x += width_1;
                parent.activeObj.rotationCirclePointColl.y += height_1;
                parent.activeObj.rotationCirclePoint.x += width_1;
                parent.activeObj.rotationCirclePoint.y += height_1;
              }
              if (parent.activeObj.shape === "path") {
                for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                  parent.activeObj.pointColl[i].x += width_1;
                  parent.activeObj.pointColl[i].y += height_1;
                }
              }
              if (!this.isPreventDragging && parent.activeObj.shape !== "line" && (parent.activeObj.rotatedAngle === 0 && (startX < parent.img.destLeft || startY < parent.img.destTop || endX > parent.img.destLeft + parent.img.destWidth || endY > parent.img.destTop + parent.img.destHeight))) {
                activePoint.startX -= width_1;
                activePoint.endX -= width_1;
                activePoint.startY -= height_1;
                activePoint.endY -= height_1;
                if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.rotationCirclePointColl) {
                  parent.activeObj.rotationCirclePointColl.x -= width_1;
                  parent.activeObj.rotationCirclePointColl.y -= height_1;
                  parent.activeObj.rotationCirclePoint.x -= width_1;
                  parent.activeObj.rotationCirclePoint.y -= height_1;
                }
                this.setDragWidth(width_1);
                this.setDragHeight(height_1);
              }
            } else {
              activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;
              activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;
              x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;
              y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;
              activePoint.endX = x;
              activePoint.endY = y;
            }
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "move");
          }
          break;
      }
    };
    Selection2.prototype.triggerShapeChange = function(shapeResizingArgs, shapeMovingArgs, type) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      var currentShapeSettings = this.updatePrevShapeSettings();
      if (!isNullOrUndefined(this.shapeResizingArgs) && !isNullOrUndefined(this.shapeMovingArgs)) {
        shapeResizingArgs.currentShapeSettings = this.shapeResizingArgs.currentShapeSettings = currentShapeSettings;
        shapeMovingArgs.currentShapeSettings = this.shapeMovingArgs.currentShapeSettings = currentShapeSettings;
      } else {
        shapeResizingArgs.currentShapeSettings = currentShapeSettings;
        shapeMovingArgs.currentShapeSettings = currentShapeSettings;
      }
      if (type === "resize") {
        this.isCropSelection = false;
        var splitWords = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== void 0 && splitWords[0] === "crop") {
          this.isCropSelection = true;
        }
        if (!this.isCropSelection) {
          if (this.currentDrawingShape !== "" && parent.upperCanvas.style.cursor === "crosshair") {
            shapeResizingArgs.action = "drawing";
          }
          parent.trigger("shapeChanging", shapeResizingArgs);
          this.isPreventShaping = shapeResizingArgs.cancel;
          parent.notify("shape", {
            prop: "updateShapeChangeEventArgs",
            onPropertyChange: false,
            value: { shapeSettings: shapeResizingArgs.currentShapeSettings }
          });
        } else {
          var selectionResizingArgs = {
            action: shapeResizingArgs.action,
            previousSelectionSettings: {
              type: parent.getSelectionType(parent.activeObj.shape),
              startX: shapeResizingArgs.previousShapeSettings.startX,
              startY: shapeResizingArgs.previousShapeSettings.startY,
              width: shapeResizingArgs.previousShapeSettings.width,
              height: shapeResizingArgs.previousShapeSettings.height
            },
            currentSelectionSettings: {
              type: parent.getSelectionType(parent.activeObj.shape),
              startX: shapeResizingArgs.currentShapeSettings.startX,
              startY: shapeResizingArgs.currentShapeSettings.startY,
              width: shapeResizingArgs.currentShapeSettings.width,
              height: shapeResizingArgs.currentShapeSettings.height
            }
          };
          this.selectionResizingArgs = selectionResizingArgs;
          parent.trigger("selectionChanging", selectionResizingArgs);
          parent.notify("shape", {
            prop: "updSelChangeEventArgs",
            onPropertyChange: false,
            value: { selectionSettings: selectionResizingArgs.currentSelectionSettings }
          });
        }
      } else if (type === "mouse-down" || type === "mouse-up") {
        parent.trigger("shapeChanging", shapeResizingArgs);
        this.isPreventShaping = shapeResizingArgs.cancel;
        parent.notify("shape", {
          prop: "updateShapeChangeEventArgs",
          onPropertyChange: false,
          value: { shapeSettings: shapeResizingArgs.currentShapeSettings }
        });
      } else {
        parent.trigger("shapeChanging", shapeMovingArgs);
        this.isPreventShaping = shapeMovingArgs.cancel;
        parent.notify("shape", {
          prop: "updateShapeChangeEventArgs",
          onPropertyChange: false,
          value: { shapeSettings: shapeMovingArgs.currentShapeSettings }
        });
      }
      parent.eventType = type;
    };
    Selection2.prototype.setDragWidth = function(width) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destWidth = _a.destWidth;
      var tempWidth = width;
      if (tempWidth >= 0) {
        for (var i = 0; i < tempWidth; i++) {
          width = tempWidth - i;
          actPoint.startX += width;
          actPoint.endX += width;
          if (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth) {
            break;
          } else {
            actPoint.startX -= width;
            actPoint.endX -= width;
          }
        }
      } else {
        for (var i = 1; i < Math.abs(tempWidth); i++) {
          width = tempWidth + i;
          actPoint.startX += width;
          actPoint.endX += width;
          if (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth) {
            break;
          } else {
            actPoint.startX -= width;
            actPoint.endX -= width;
          }
        }
      }
    };
    Selection2.prototype.setDragHeight = function(height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destTop = _a.destTop, destHeight = _a.destHeight;
      var tempHeight = height;
      if (tempHeight >= 0) {
        for (var i = 1; i < tempHeight; i++) {
          height = tempHeight - i;
          actPoint.startY += height;
          actPoint.endY += height;
          if (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight) {
            break;
          } else {
            actPoint.startY -= height;
            actPoint.endY -= height;
          }
        }
      } else {
        for (var i = 0; i < Math.abs(tempHeight); i++) {
          height = tempHeight + i;
          actPoint.startY += height;
          actPoint.endY += height;
          if (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight) {
            break;
          } else {
            actPoint.startY -= height;
            actPoint.endY -= height;
          }
        }
      }
    };
    Selection2.prototype.limitDrag = function(isStart) {
      var isLimiting = false;
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var actPoint = parent.activeObj.activePoint;
      var startX = isStart ? actPoint.startX : actPoint.endX;
      var startY = isStart ? actPoint.startY : actPoint.endY;
      var endX = isStart ? actPoint.endX : actPoint.startX;
      var endY = isStart ? actPoint.endY : actPoint.startY;
      if (startX < destLeft) {
        startX = destLeft;
      }
      if (startY < destTop) {
        startY = destTop;
      }
      if (endX > destLeft + destWidth) {
        endX = destLeft + destWidth;
      }
      if (endY > destTop + destHeight) {
        endY = destTop + destHeight;
      }
      if (parent.transform.straighten !== 0) {
        var obj = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        if (obj["arr"][0] || obj["arr"][1] || obj["arr"][2] || obj["arr"][3]) {
          isLimiting = true;
        }
      }
      if (isStart) {
        actPoint.startX = startX;
        actPoint.startY = startY;
        actPoint.endX = endX;
        actPoint.endY = endY;
      } else {
        actPoint.startX = endX;
        actPoint.startY = endY;
        actPoint.endX = startX;
        actPoint.endY = startY;
      }
      return isLimiting;
    };
    Selection2.prototype.isMouseOutsideImg = function(x, y) {
      var obj = { bool: false };
      this.parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      this.parent.notify("draw", { prop: "isPointsInsideImg", value: { obj, x, y } });
      return obj["bool"];
    };
    Selection2.prototype.preventDraggingInvertly = function() {
      var isLimiting = false;
      var parent = this.parent;
      if (parent.activeObj.shape === "image") {
        return isLimiting;
      }
      if (!this.isPreventDragging && parent.activeObj.rotatedAngle === 0) {
        isLimiting = this.limitDrag(true);
        var shapeColl = ["line", "arrow", "path"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          isLimiting = this.limitDrag(false);
        }
      }
      return isLimiting;
    };
    Selection2.prototype.preventTextDraggingInvertly = function() {
      var parent = this.parent;
      var isLimiting = false;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (!this.isPreventDragging) {
        if (actPoint.startX < destLeft || actPoint.startY < destTop || actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
          isLimiting = true;
        }
      }
      return isLimiting;
    };
    Selection2.prototype.preventInverseResize = function(tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (actPoint.width < 0) {
        actPoint.width = 0;
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.endX = tempActiveObj.activePoint.endX;
      }
      if (actPoint.height < 0) {
        actPoint.height = 0;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endY = tempActiveObj.activePoint.endY;
      }
    };
    Selection2.prototype.getScaleRatio = function(scale) {
      var parent = this.parent;
      var point = { x: scale, y: scale };
      if (parent.activeObj.shape && parent.activeObj.shape !== "crop-custom" && parent.activeObj.shape !== "crop-circle" && parent.activeObj.shape !== "crop-square") {
        var ratio = parent.activeObj.shape === "image" || parent.activeObj.shape === "text" ? this.findImageRatio(parent.activeObj.activePoint.width, parent.activeObj.activePoint.height).split("-") : parent.activeObj.shape.split("-");
        if (ratio.length > 1 || parent.activeObj.shape === "image" || parent.activeObj.shape === "text") {
          ratio = parent.activeObj.shape === "image" || parent.activeObj.shape === "text" ? ratio[0].split(":") : ratio[1].split(":");
          var newScale = scale / parseInt(ratio[1], 10);
          point.x = newScale * parseInt(ratio[0], 10);
          point.y = newScale * parseInt(ratio[1], 10);
        }
      }
      return point;
    };
    Selection2.prototype.findImageRatio = function(width, height, obj) {
      var gcd = function(a, b) {
        if (b === 0) {
          return a;
        }
        return gcd(b, a % b);
      };
      var divisor = gcd(width, height);
      var ratio = width / divisor + ":" + height / divisor;
      if (obj) {
        obj["ratio"] = ratio;
      }
      return ratio;
    };
    Selection2.prototype.revertResizing = function(tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (this.preventDraggingInvertly()) {
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endX = tempActiveObj.activePoint.endX;
        actPoint.endY = tempActiveObj.activePoint.endY;
      }
    };
    Selection2.prototype.performSEResize = function(x, y, tempActiveObj, actPoint) {
      var parent = this.parent;
      this.resizeImg(x, y, "se-resize", tempActiveObj);
      if (actPoint.endX < actPoint.startX) {
        var temp = actPoint.endX;
        actPoint.endX = actPoint.startX;
        actPoint.startX = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
      }
      if (actPoint.endY < actPoint.startY) {
        var temp = actPoint.endY;
        actPoint.endY = actPoint.startY;
        actPoint.startY = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
      }
      this.revertCustomSelection(actPoint, tempActiveObj, "se-resize");
      this.revertResizing(tempActiveObj);
    };
    Selection2.prototype.performNWResize = function(x, y, tempActiveObj, actPoint) {
      var parent = this.parent;
      this.resizeImg(x, y, "nw-resize", tempActiveObj);
      if (actPoint.startX > actPoint.endX) {
        var temp = actPoint.startX;
        actPoint.startX = actPoint.endX;
        actPoint.endX = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
      }
      if (actPoint.startY > actPoint.endY) {
        var temp = actPoint.startY;
        actPoint.startY = actPoint.endY;
        actPoint.endY = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
      }
      this.revertCustomSelection(actPoint, tempActiveObj, "nw-resize");
      this.revertResizing(tempActiveObj);
    };
    Selection2.prototype.isCustomSelection = function() {
      if (this.parent.activeObj.shape) {
        var shapeColl = ["custom", "circle", "square", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "5:7", "7:5", "9:16", "16:9"];
        return this.parent.activeObj.shape.indexOf("crop-") > -1 && shapeColl.indexOf(this.parent.activeObj.shape.split("-")[1]) === -1;
      }
      return false;
    };
    Selection2.prototype.revertCustomSelection = function(actPoint, tempActiveObj, type) {
      var parent = this.parent;
      if (this.isCustomSelection()) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
        var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
        var left = destLeft > 0 ? destLeft : 0;
        var top_1 = destTop > 0 ? destTop : 0;
        var endY1 = destTop > 0 ? destTop : 0;
        var endX1 = destLeft > 0 ? destLeft : 0;
        if (type === "se-resize" && (actPoint.endX > endX || actPoint.endY > endY) || type === "nw-resize" && (actPoint.startX < left || actPoint.startY < top_1) || type === "ne-resize" && (actPoint.endX > endX || actPoint.startY < endY1) || type === "sw-resize" && (actPoint.startX < endX1 || actPoint.endY > endY)) {
          this.revertPoints(actPoint, tempActiveObj);
        }
      }
    };
    Selection2.prototype.revertPoints = function(actPoint, tempActiveObj) {
      actPoint.startX = tempActiveObj.activePoint.startX;
      actPoint.startY = tempActiveObj.activePoint.startY;
      actPoint.endX = tempActiveObj.activePoint.endX;
      actPoint.endY = tempActiveObj.activePoint.endY;
      actPoint.width = tempActiveObj.activePoint.width;
      actPoint.height = tempActiveObj.activePoint.height;
    };
    Selection2.prototype.updateNWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "nw-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== void 0 && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "nw-resize", tempActiveObj);
          } else {
            this.adjustNWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "nw-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
          if (actPoint.startX < x && actPoint.startY < y) {
            width = x - actPoint.startX;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.startY += newScale.y;
            var left = destLeft > 0 ? destLeft : 0;
            var top_2 = destTop > 0 ? destTop : 0;
            if (actPoint.startX < left || actPoint.startY < top_2) {
              actPoint.startX -= newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.startY -= newScale.y;
            var left = destLeft > 0 ? destLeft : 0;
            var top_3 = destTop > 0 ? destTop : 0;
            if (actPoint.startX < left || actPoint.startY < top_3) {
              actPoint.startX += newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateNPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.startY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = this.resizedElement = "s-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
          if (this.isCustomSelection()) {
            this.performNWResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.startY < y) {
            width = actPoint.endX - x;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.startY += newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.startY < destTop) {
              actPoint.endX += newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = actPoint.startY - y;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.startY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.startY < destTop) {
              actPoint.endX -= newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateNEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "ne-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== void 0 && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "ne-resize", tempActiveObj);
          } else {
            this.adjustNEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "ne-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
          if (actPoint.endX > x && actPoint.startY < y) {
            width = actPoint.endX - x;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.startY += newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop > 0 ? destTop : 0;
            if (actPoint.endX > endX || actPoint.startY < endY) {
              actPoint.endX += newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = actPoint.startY - y;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.startY -= newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop > 0 ? destTop : 0;
            if (actPoint.endX > endX || actPoint.startY < endY) {
              actPoint.endX -= newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.startX = x;
            actPoint.width = actPoint.endX - actPoint.startX;
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path") {
            actPoint.startY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
            if (this.adjustActObjForLineArrow()) {
              this.dragElement = "e-resize";
              if (parent.activeObj.triangleDirection === "right") {
                parent.activeObj.triangleDirection = "left";
              } else if (parent.activeObj.triangleDirection === "left") {
                parent.activeObj.triangleDirection = "right";
              }
            }
          } else if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = this.resizedElement = "e-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performNWResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.startX < x && actPoint.endY > y) {
            width = x - actPoint.startX;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.startX < destLeft || actPoint.endY > destTop + destHeight) {
              actPoint.startX -= newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.endY += newScale.y;
            if (actPoint.startX < destLeft || actPoint.endY > destTop + destHeight) {
              actPoint.startX += newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.endX = x;
            actPoint.width = actPoint.endX - actPoint.startX;
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path") {
            actPoint.endY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
            if (this.adjustActObjForLineArrow()) {
              this.dragElement = "w-resize";
              if (parent.activeObj.triangleDirection === "right") {
                parent.activeObj.triangleDirection = "left";
              } else if (parent.activeObj.triangleDirection === "left") {
                parent.activeObj.triangleDirection = "right";
              }
            }
          } else if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = this.resizedElement = "w-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performSEResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateSWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "sw-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== void 0 && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "sw-resize", tempActiveObj);
          } else {
            this.adjustSWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "sw-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
          if (actPoint.startX < x && actPoint.endY > y) {
            width = x - actPoint.startX;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.endY -= newScale.y;
            var endX = destLeft > 0 ? destLeft : 0;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.startX < endX || actPoint.endY > endY) {
              actPoint.startX -= newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.endY += newScale.y;
            var endX = destLeft > 0 ? destLeft : 0;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.startX < endX || actPoint.endY > endY) {
              actPoint.startX += newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateSPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.endY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = this.resizedElement = "n-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performSEResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.x;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateSEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "se-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = void 0;
        var newScale = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== void 0 && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "se-resize", tempActiveObj);
          } else {
            this.adjustSEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "se-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.endX > endX || actPoint.endY > endY) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.endX > endX || actPoint.endY > endY) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.resizeImg = function(x, y, elem, tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var newScale;
      if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
        if (this.currentDrawingShape === "text") {
          this.setCursor(x, y);
          if (parent.activeObj.textSettings.fontSize === 0) {
            parent.activeObj.textSettings.fontSize = 11;
            parent.notify("shape", {
              prop: "updateFontRatio",
              onPropertyChange: false,
              value: { obj: parent.activeObj, isTextArea: null }
            });
            parent.activeObj.textSettings.text = parent.activeObj.keyHistory = "Enter Text";
            parent.notify("shape", {
              prop: "updateFontStyles",
              onPropertyChange: false,
              value: { isTextBox: null }
            });
            var width_2 = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
            actPoint.endX = actPoint.startX + width_2;
            actPoint.endY = actPoint.startY + parent.activeObj.textSettings.fontSize;
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            tempActiveObj = extend({}, parent.activeObj, null, true);
            parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
              actPoint: parent.activeObj.activePoint,
              obj: parent.activeObj,
              isMouseMove: null,
              x: null,
              y: null
            } });
          }
        }
        switch (parent.upperCanvas.style.cursor) {
          case "se-resize":
          case "s-resize":
            if (this.previousPoint.x > x || this.previousPoint.y > y) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "sw-resize":
            if (this.previousPoint.x < x || this.previousPoint.y > y) {
              width = x - this.previousPoint.x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = this.previousPoint.x - x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "w-resize":
          case "nw-resize":
            if (this.previousPoint.x < x || this.previousPoint.y < y) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "n-resize":
          case "ne-resize":
            if (this.previousPoint.x > x || this.previousPoint.y < y) {
              width = this.previousPoint.x - x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "e-resize":
            if (this.previousPoint.x > x || this.previousPoint.y > y) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        if (actPoint.width < 10 || actPoint.height < 10 || parent.activeObj.shape === "text" && parent.activeObj.rotatedAngle === 0 && this.preventTextDraggingInvertly()) {
          parent.activeObj = extend({}, tempActiveObj, null, true);
        }
      }
      this.previousPoint = { x, y };
    };
    Selection2.prototype.adjustNWPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedC[0] + x) / 2, (rotatedC[1] + y) / 2];
      var newBottomRight = this.rotatePoints(rotatedC[0], rotatedC[1], newCenter[0], newCenter[1], -angle);
      var newTopLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.endX = newBottomRight[0];
      rectangle.endY = newBottomRight[1];
      rectangle.startY = newTopLeft[1];
      rectangle.startX = newTopLeft[0];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.adjustNEPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedD[0] + x) / 2, (rotatedD[1] + y) / 2];
      var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
      var newTopRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.startX = newBottomLeft[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = newTopRight[0] - newBottomLeft[0];
      rectangle.height = newBottomLeft[1] - newTopRight[1];
      rectangle.endX = rectangle.startX + rectangle.width;
      rectangle.startY = rectangle.endY - rectangle.height;
      return rectangle;
    };
    Selection2.prototype.adjustSWPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
      var newCenter = [(rotatedB[0] + x) / 2, (rotatedB[1] + y) / 2];
      var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
      var newBottomLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.endX = newTopRight[0];
      rectangle.startY = newTopRight[1];
      rectangle.startX = newBottomLeft[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.adjustSEPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
      var newCenter = [(rotatedA[0] + x) / 2, (rotatedA[1] + y) / 2];
      var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
      var newBottomRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.startX = newTopLeft[0];
      rectangle.startY = newTopLeft[1];
      rectangle.width = newBottomRight[0] - newTopLeft[0];
      rectangle.height = newBottomRight[1] - newTopLeft[1];
      rectangle.endX = rectangle.startX + rectangle.width;
      rectangle.endY = rectangle.startY + rectangle.height;
      return rectangle;
    };
    Selection2.prototype.adjustRotationPoints = function(rectangle, x, y, angle, type, elem) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      this.getResizeDirection(rectangle, x, y, angle, type, elem);
      var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
      var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
      var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
      var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedA[0] + rotatedC[0]) / 2, (rotatedA[1] + rotatedC[1]) / 2];
      var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
      var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
      var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
      rectangle.startX = newTopLeft[0];
      rectangle.startY = newTopLeft[1];
      rectangle.endX = newTopRight[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.rotatePoints = function(x, y, cx, cy, angle) {
      return [
        (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
        (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
      ];
    };
    Selection2.prototype.setResizedValue = function(element2, value, x, y) {
      switch (element2) {
        case "x":
          value += x;
          break;
        case "y":
          value += y;
          break;
        case "abs-x":
          value += x > 0 ? -x : Math.abs(x);
          break;
        case "abs-y":
          value += y > 0 ? -y : Math.abs(y);
          break;
        case "y-abs-x":
          value += y + (x > 0 ? -x : Math.abs(x)) / 2;
          break;
        case "abs-x-abs-y":
          value += (x > 0 ? -x : Math.abs(x)) + (y > 0 ? -y : Math.abs(y)) / 2;
          break;
        case "abs-y-x":
          value += (y > 0 ? -y : Math.abs(y)) + x / 2;
          break;
        case "x-y":
          value += x + y / 2;
          break;
        case "y-x":
          value += y + x / 2;
          break;
        case "img-resize-x":
          value += x;
          break;
        case "img-resize-y":
          value += y;
          break;
      }
      return value;
    };
    Selection2.prototype.getResizeDirection = function(rectangle, x, y, angle, type, elem) {
      var rotatedAngle = angle * (180 / Math.PI);
      var element2 = this.getResizedElement(rotatedAngle, this.resizedElement);
      if (this.resizedElement === "e-resize") {
        rectangle.width = this.setResizedValue(element2, rectangle.width, x, y);
        rectangle.endX = rectangle.width + rectangle.startX;
      } else if (this.resizedElement === "n-resize") {
        rectangle.startY = this.setResizedValue(element2, rectangle.startY, x, y);
        rectangle.height = rectangle.endY - rectangle.startY;
      } else if (this.resizedElement === "w-resize") {
        rectangle.startX = this.setResizedValue(element2, rectangle.startX, x, y);
        rectangle.width = rectangle.startX + rectangle.endX;
      } else if (this.resizedElement === "s-resize") {
        rectangle.height = this.setResizedValue(element2, rectangle.height, x, y);
        rectangle.endY = rectangle.height + rectangle.startY;
      } else if (type && type === "img-resize") {
        rectangle.width = this.setResizedValue("img-resize-x", rectangle.width, x, y);
        rectangle.height = this.setResizedValue("img-resize-y", rectangle.height, x, y);
        if (elem === "se-resize") {
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "sw-resize") {
          rectangle.startX = rectangle.endX - rectangle.width;
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "ne-resize") {
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.startY = rectangle.endY - rectangle.height;
        } else if (elem === "nw-resize") {
          rectangle.startX = rectangle.endX - rectangle.width;
          rectangle.startY = rectangle.endY - rectangle.height;
        }
      } else if (type && type === "text") {
        if (elem === "widthHeight") {
          rectangle.width = this.setResizedValue("x-y", rectangle.width, x, y);
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.height = this.setResizedValue("y-x", rectangle.height, x, y);
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "width") {
          rectangle.width = this.setResizedValue("x-y", rectangle.width, x, y);
          rectangle.endX = rectangle.width + rectangle.startX;
        } else if (elem === "height") {
          rectangle.height = this.setResizedValue("y-abs-x", rectangle.height, x, y);
          rectangle.endY = rectangle.height + rectangle.startY;
        }
      }
    };
    Selection2.prototype.getResizedElement = function(degree, element2) {
      var resizeMappings = [];
      if (element2 === "n-resize") {
        resizeMappings = [
          [337.5, 360, "y"],
          [0, 22.5, "y"],
          [22.5, 67.5, "y-abs-x"],
          [67.5, 112.5, "abs-x"],
          [112.5, 157.5, "abs-x-abs-y"],
          [157.5, 202.5, "abs-y"],
          [202.5, 247.5, "abs-y-x"],
          [247.5, 292.5, "x"],
          [292.5, 337.5, "x-y"]
        ];
      } else if (element2 === "e-resize") {
        resizeMappings = [
          [337.5, 360, "x"],
          [0, 22.5, "x"],
          [22.5, 67.5, "x-y"],
          [67.5, 112.5, "y"],
          [112.5, 157.5, "y-abs-x"],
          [157.5, 202.5, "abs-x"],
          [202.5, 247.5, "abs-x-abs-y"],
          [247.5, 292.5, "abs-y"],
          [292.5, 337.5, "abs-y-x"]
        ];
      } else if (element2 === "s-resize") {
        resizeMappings = [
          [337.5, 360, "y"],
          [0, 22.5, "y"],
          [22.5, 67.5, "y-abs-x"],
          [67.5, 112.5, "abs-x"],
          [112.5, 157.5, "abs-x-abs-y"],
          [157.5, 202.5, "abs-y"],
          [202.5, 247.5, "abs-y-x"],
          [247.5, 292.5, "x"],
          [292.5, 337.5, "x-y"]
        ];
      } else if (element2 === "w-resize") {
        resizeMappings = [
          [337.5, 360, "x"],
          [0, 22.5, "x"],
          [22.5, 67.5, "x-y"],
          [67.5, 112.5, "y"],
          [112.5, 157.5, "y-abs-x"],
          [157.5, 202.5, "abs-x"],
          [202.5, 247.5, "abs-x-abs-y"],
          [247.5, 292.5, "abs-y"],
          [292.5, 337.5, "abs-y-x"]
        ];
      }
      var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
      for (var _i = 0, resizeMappings_2 = resizeMappings; _i < resizeMappings_2.length; _i++) {
        var _a = resizeMappings_2[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
        if (positiveDegree > startDegree && positiveDegree <= endDegree || positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree) {
          return resizeElement;
        }
      }
      return element2;
    };
    Selection2.prototype.updateCursorStyles = function(x, y, type) {
      var parent = this.parent;
      var isResize = false;
      if (parent.activeObj.keyHistory !== "" && parent.activeObj.shape === void 0 && !parent.currObjType.isCustomCrop && !parent.currObjType.isLine && parent.currObjType.isText) {
        parent.activeObj.shape = "text";
      }
      var actObj = extend({}, parent.activeObj, {}, true);
      if (isNullOrUndefined(actObj.topLeftCircle)) {
        return;
      }
      var degree;
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (this.isObjSelected) {
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          isResize = this.updateCursorStylesForLineArrow(x, y, actObj);
        } else if (actObj.shape === "path") {
          isResize = this.updateCursorStylesForPath(x, y, actObj);
        } else if (actObj.rotatedAngle) {
          this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "grabbing") {
            parent.upperCanvas.style.cursor = parent.cursor = "grabbing";
            this.dragElement = parent.cursor;
          } else if (parent.cursor === "move") {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          } else if (parent.cursor !== "default") {
            isResize = true;
            this.dragElement = parent.cursor;
            parent.currObjType.isResize = true;
          }
        } else {
          var rotationCirclePoint = this.getTransRotationPoint(actObj);
          var radius = actObj.topLeftCircle.radius;
          if (x >= actObj.topLeftCircle.startX - radius * 2 && x <= actObj.topLeftCircle.startX + radius * 2 && y >= actObj.topLeftCircle.startY - radius * 2 && y <= actObj.topLeftCircle.startY + radius * 2 && this.dragElement !== "nw-resize") {
            actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.topLeftCircle.startX - radius * 2 && x <= actObj.topRightCircle.startX - radius * 2 && y >= actObj.topCenterCircle.startY - radius * 2 && y <= actObj.topCenterCircle.startY + radius * 2 && this.dragElement !== "n-resize") {
            actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "n-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.topRightCircle.startX - radius * 2 && x <= actObj.topRightCircle.startX + radius * 2 && y >= actObj.topRightCircle.startY - radius * 2 && y <= actObj.topRightCircle.startY + radius * 2 && this.dragElement !== "ne-resize") {
            actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.centerLeftCircle.startX - radius * 2 && x <= actObj.centerLeftCircle.startX + radius * 2 && y >= actObj.topLeftCircle.startY - radius * 2 && y <= actObj.bottomLeftCircle.startY - radius * 2 && this.dragElement !== "w-resize") {
            actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "w-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.centerRightCircle.startX - radius * 2 && x <= actObj.centerRightCircle.startX + radius * 2 && y >= actObj.topRightCircle.startY - radius * 2 && y <= actObj.bottomRightCircle.startY - radius * 2 && this.dragElement !== "e-resize") {
            actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "e-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomLeftCircle.startX - radius * 2 && x <= actObj.bottomLeftCircle.startX + radius * 2 && y >= actObj.bottomLeftCircle.startY - radius * 2 && y <= actObj.bottomLeftCircle.startY + radius * 2 && this.dragElement !== "sw-resize") {
            actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomLeftCircle.startX - radius * 2 && x <= actObj.bottomRightCircle.startX - radius * 2 && y >= actObj.bottomCenterCircle.startY - radius * 2 && y <= actObj.bottomCenterCircle.startY + radius * 2 && this.dragElement !== "s-resize") {
            actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "s-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomRightCircle.startX - radius * 2 && x <= actObj.bottomRightCircle.startX + radius * 2 && y >= actObj.bottomRightCircle.startY - radius * 2 && y <= actObj.bottomRightCircle.startY + radius * 2 && this.dragElement !== "se-resize") {
            actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (rotationCirclePoint && x >= rotationCirclePoint.x - radius * 2 && x <= rotationCirclePoint.x + radius * 2 && y >= rotationCirclePoint.y - radius * 2 && y <= rotationCirclePoint.y + radius * 2 && this.dragElement !== "grabbing") {
            parent.upperCanvas.style.cursor = parent.cursor = "grabbing";
            this.dragElement = parent.upperCanvas.style.cursor;
          } else {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          }
          if (actObj.shape === "text" && (parent.cursor === "n-resize" || parent.cursor === "s-resize" || parent.cursor === "e-resize" || parent.cursor === "w-resize")) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
            this.dragElement = "";
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          }
        }
      } else {
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
      this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;
      if (type === "touchstart") {
        if (isResize || x >= actObj.activePoint.startX && x <= actObj.activePoint.endX && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY || this.dragElement === "grabbing") {
          parent.currObjType.isDragging = true;
        } else if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "move") {
            parent.currObjType.isDragging = true;
          }
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "move") {
            parent.currObjType.isDragging = true;
          }
        }
      } else {
        parent.currObjType.isDragging = true;
      }
      if (actObj.rotatedAngle !== 0 && (this.dragElement === "e-resize" || this.dragElement === "w-resize" || this.dragElement === "n-resize" || this.dragElement === "s-resize")) {
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
    };
    Selection2.prototype.updateCursorStylesForLineArrow = function(x, y, actObj) {
      var isResize = false;
      var parent = this.parent;
      var point;
      var radius = actObj.topLeftCircle.radius;
      for (var i = 0; i < 5; i++) {
        point = actObj.pointColl[i];
        if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
          actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
          this.dragElement = "w-resize";
          isResize = true;
          break;
        }
      }
      if (!isResize) {
        for (var i = 1; i < 6; i++) {
          point = actObj.pointColl[actObj.pointColl.length - i];
          if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
            actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
            this.dragElement = "e-resize";
            isResize = true;
            break;
          }
        }
      }
      if (!isResize) {
        for (var i = 0; i < actObj.pointColl.length; i++) {
          point = actObj.pointColl[i];
          if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
            break;
          } else {
            parent.upperCanvas.style.cursor = parent.cursor = "default";
          }
        }
      }
      return isResize;
    };
    Selection2.prototype.updateCursorStylesForPath = function(x, y, actObj) {
      var isResize = false;
      var parent = this.parent;
      this.pathAdjustedIndex = this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
      if (parent.cursor === "move") {
        isResize = true;
        this.dragElement = "pathDrag";
      }
      if (!isResize) {
        parent.upperCanvas.style.cursor = parent.cursor = "move";
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
      return isResize;
    };
    Selection2.prototype.setTextSelection = function(width, height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var degree = parent.transform.degree;
      if (parent.activeObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - parent.activeObj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
        var flip2 = parent.activeObj.flipObjColl[i].toLowerCase();
        switch (degree) {
          case 0:
            switch (flip2) {
              case "horizontal":
                actPoint = {
                  startX: actPoint.endX - width,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (height ? height : 0)
                };
                break;
              case "vertical":
                actPoint.startY = actPoint.endY - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + (width ? width : 0),
                  endY: actPoint.endY
                };
                break;
              default:
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + (width ? width : 0),
                  endY: actPoint.startY + (height ? height : 0)
                };
                break;
            }
            break;
          case 90:
            switch (flip2) {
              case "horizontal":
                actPoint.endX = actPoint.startX + height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
              case "vertical":
                actPoint.startX = actPoint.endX - height;
                actPoint = { startX: actPoint.startX, startY: actPoint.endY - width, endX: actPoint.endX, endY: actPoint.endY };
                break;
              default:
                actPoint.startX = actPoint.endX - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
            }
            break;
          case 180:
            switch (flip2) {
              case "horizontal":
                actPoint.startY = actPoint.endY - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + width,
                  endY: actPoint.endY
                };
                break;
              case "vertical":
                actPoint.endY = actPoint.startY + height;
                actPoint = {
                  endX: actPoint.endX,
                  endY: actPoint.endY,
                  startX: actPoint.endX - (width ? width : 0),
                  startY: actPoint.startY
                };
                break;
              default:
                actPoint = {
                  endX: actPoint.endX,
                  endY: actPoint.endY,
                  startX: actPoint.endX - (width ? width : 0),
                  startY: actPoint.endY - (height ? height : 0)
                };
                break;
            }
            break;
          case 270:
            switch (flip2) {
              case "horizontal":
                actPoint.startX = actPoint.endX - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.endY - (width ? width : 0),
                  endX: actPoint.endX,
                  endY: actPoint.endY
                };
                break;
              case "vertical":
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + height,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
              default:
                actPoint.endX = actPoint.startX + height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.endY - (width ? width : 0),
                  endX: actPoint.endX,
                  endY: actPoint.endY
                };
                break;
            }
            break;
        }
      }
      if (parent.activeObj.flipObjColl.length === 0) {
        switch (degree) {
          case 0:
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.startY,
              endX: actPoint.startX + (width ? width : 0),
              endY: actPoint.startY + (height ? height : 0)
            };
            break;
          case 90:
            actPoint.startX = actPoint.endX - height;
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.startY,
              endX: actPoint.endX,
              endY: actPoint.startY + (width ? width : 0)
            };
            break;
          case 180:
            actPoint = {
              endX: actPoint.endX,
              endY: actPoint.endY,
              startX: actPoint.endX - (width ? width : 0),
              startY: actPoint.endY - (height ? height : 0)
            };
            break;
          case 270:
            actPoint.endX = actPoint.startX + height;
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.endY - (width ? width : 0),
              endX: actPoint.endX,
              endY: actPoint.endY
            };
            break;
        }
      }
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      parent.activeObj.activePoint = actPoint;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Selection2.prototype.setActivePoint = function(startX, startY) {
      var parent = this.parent;
      var activePoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(activePoint)) {
        return;
      }
      if (parent.currObjType.isText) {
        var textWidth = startX ? startX : 0;
        var textHeight = startY ? startY : parent.activeObj.textSettings.fontSize;
        if (parent.activeObj.textSettings.fontSize === void 0) {
          parent.activeObj.textSettings.fontSize = Math.abs(parent.baseImgCanvas.width - parent.baseImgCanvas.height) * 0.1;
        }
        this.setTextSelection(textWidth, textHeight);
        this.mouseDownPoint.x = activePoint.endX;
        this.mouseDownPoint.y = activePoint.endY;
        if (parent.activeObj.horTopLine !== void 0) {
          parent.activeObj.activePoint = extend({}, activePoint, {}, true);
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      } else if (startX && startY) {
        activePoint.startX = this.mouseDownPoint.x = startX;
        activePoint.startY = this.mouseDownPoint.y = startY;
        parent.currObjType.isDragging = true;
      } else {
        var selectInfo = parent.activeObj;
        activePoint = {
          startX: selectInfo.horTopLine.startX,
          startY: selectInfo.horTopLine.startY,
          endX: selectInfo.horTopLine.endX,
          endY: selectInfo.horTopLine.endY
        };
        activePoint.width = activePoint.endX - activePoint.startX;
        activePoint.height = activePoint.endY - activePoint.startY;
      }
    };
    Selection2.prototype.mouseDownEventHandler = function(e) {
      var parent = this.parent;
      parent.isKBDNavigation = false;
      this.mouseDown = e.currentTarget === parent.lowerCanvas || e.currentTarget === parent.upperCanvas ? "canvas" : "";
      if (e.type === "touchstart") {
        this.isTouch = true;
      } else {
        this.isTouch = false;
      }
      if (e.type === "touchstart" && e.currentTarget === parent.lowerCanvas && !parent.isImageLoaded) {
        return;
      }
      this.isCropSelection = false;
      this.isPan = true;
      var splitWords;
      if (parent.activeObj.shape !== void 0) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== void 0 && splitWords[0] === "crop") {
        this.isCropSelection = true;
      }
      if (this.isCropSelection) {
        this.dragCanvas = parent.togglePan = true;
      }
      if (parent.cursor === "grabbing") {
        var obj = { shapeSettingsObj: {} };
        this.isGrabbing = true;
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotate-start", previousShapeSettings: shapeSettings };
        var shapeMovingArgs = { cancel: false, action: "rotate-start", previousShapeSettings: shapeSettings };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
      }
      var imageEditorClickEventArgs = { point: this.setXYPoints(e) };
      parent.trigger("click", imageEditorClickEventArgs);
      this.clickEvent(imageEditorClickEventArgs, e);
    };
    Selection2.prototype.getImagePoints = function(x, y) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (x < destLeft) {
        x = destLeft;
      } else if (x > destLeft + destWidth) {
        x = destLeft + destWidth;
      }
      if (y < destTop) {
        y = destTop;
      } else if (y > destTop + destHeight) {
        y = destTop + destHeight;
      }
      return { x, y };
    };
    Selection2.prototype.clickEvent = function(imageEditorClickEventArgs, e) {
      var parent = this.parent;
      var activePoint = parent.activeObj.activePoint;
      var x = imageEditorClickEventArgs.point.x;
      var y = imageEditorClickEventArgs.point.y;
      var cursor = parent.activeObj.shape && parent.activeObj.shape === "text" ? parent.cursor : "default";
      if (parent.isResize) {
        this.performEnterAction();
        parent.upperCanvas.style.cursor = "default";
        return;
      } else if (JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
        parent.okBtn();
      } else if (this.currentDrawingShape !== "" && (this.isTouch && !this.isShapeTouch(e, this.isCropSelection) || parent.upperCanvas.style.cursor === "crosshair" || parent.isShapeDrawing)) {
        if (parent.drawingShape && !parent.isShapeDrawing) {
          parent.okBtn();
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        }
        activePoint = parent.activeObj.activePoint;
        var object_1 = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: object_1 } });
        this.initialPrevObj = object_1["currObj"];
        this.initialPrevObj.objColl = extend([], parent.objColl, [], true);
        this.initialPrevObj.pointColl = extend([], parent.pointColl, [], true);
        this.initialPrevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        this.initialPrevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.setActivePoint(x, y);
        activePoint = parent.activeObj.activePoint;
        if (this.currentDrawingShape === "path") {
          var point = this.getImagePoints(x, y);
          parent.activeObj.pointColl.push({ x: point.x, y: point.y });
          if (activePoint.width !== 0 && activePoint.height !== 0) {
            activePoint.width = 0;
            activePoint.height = 0;
            activePoint.startX = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].x;
            activePoint.startY = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].y;
          }
        }
        activePoint.endX = activePoint.startX;
        activePoint.endY = activePoint.startY;
        if (this.currentDrawingShape === "text") {
          parent.activeObj.textSettings.fontSize = 11;
          this.previousPoint.x = activePoint.startX;
          this.previousPoint.y = activePoint.startY;
          parent.notify("shape", {
            prop: "updateFontStyles",
            onPropertyChange: false,
            value: { isTextBox: null }
          });
          var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
          activePoint.endX = activePoint.startX + width;
          activePoint.endY = activePoint.startY + parent.activeObj.textSettings.fontSize;
          activePoint.width = activePoint.endX - activePoint.startX;
          activePoint.height = activePoint.endY - activePoint.startY;
        } else if (this.currentDrawingShape === "arrow") {
          parent.activeObj.start = this.arrowShape[0];
          parent.activeObj.end = this.arrowShape[1];
        }
        parent.currObjType.isDragging = true;
        var previousShapeSettings = this.updatePrevShapeSettings();
        var shapeResizingArgs = { cancel: false, action: "draw-start", previousShapeSettings };
        var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings };
        this.shapeResizingArgs = shapeResizingArgs;
        this.shapeMovingArgs = shapeMovingArgs;
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
        parent.activeObj.activePoint = activePoint;
        parent.isShapeDrawing = true;
        return;
      }
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: true } });
      if (this.isCropSelection && this.dragCanvas) {
        this.setCursor(x, y);
        if (parent.cursor !== "move" && parent.cursor !== "crosshair" && parent.cursor !== "default" && parent.cursor !== "grab") {
          this.isPan = false;
        }
      }
      if (parent.activeObj.shape) {
        this.isObjSelected = true;
      } else {
        this.isObjSelected = false;
      }
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      var activeObj = extend({}, parent.activeObj, null, true);
      var isShape = this.isShapeTouch(e, this.isCropSelection);
      var isFreehandDraw = this.isFreehandDrawTouch(e, this.isCropSelection);
      var isShapeClick = isShape ? isShape : this.isShapeClick(e, this.isCropSelection);
      var allowUndoRedoPush = this.applyCurrShape(isShapeClick);
      var isTextArea = parent.textArea.style.display !== "none" ? true : false;
      if (this.isTouch && !isShape && activeObj.shape && !this.isCropSelection) {
        if (this.applyObj(x, y)) {
          parent.okBtn(true);
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: parent.isCircleCrop
          }
        });
        if (allowUndoRedoPush) {
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
      }
      if (!isShape && !parent.togglePen && !this.isCropSelection) {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
      }
      if (this.dragCanvas && this.isPan && (parent.cursor === "grab" || this.isTouch) && !isShape && !isFreehandDraw && !parent.togglePen) {
        if (this.applyObj(x, y)) {
          parent.okBtn(true);
          if (allowUndoRedoPush) {
            var cursor_1 = parent.cursor;
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
            parent.cursor = cursor_1;
          }
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        if (this.isFhdEditing) {
          parent.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
          this.isFhdCustomized = false;
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        var shape = parent.activeObj.shape;
        var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image"];
        if (shape && shapeColl.indexOf(shape) > -1) {
          parent.notify("shape", {
            prop: "redrawActObj",
            onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: null }
          });
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        }
        this.canvasMouseDownHandler(e);
      } else {
        var isLineArrow = false;
        if (parent.activeObj.shape && (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow")) {
          isLineArrow = true;
        }
        var points = this.setXYPoints(e);
        var x_1 = points.x;
        var y_1 = points.y;
        if (this.applyObj(x_1, y_1)) {
          parent.okBtn(true);
          if (allowUndoRedoPush) {
            var cursor_2 = parent.cursor;
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
            parent.cursor = cursor_2;
          }
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: x_1, y: y_1, isMouseDown: true }
        });
        var obj = { index: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawHoveredIndex", onPropertyChange: false, value: { obj } });
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (this.isFhdPoint || this.isFhdCustomized && !parent.togglePen) {
          if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] !== obj["index"]) {
            var tempHoveredIndex = obj["index"];
            parent.okBtn();
            this.isFhdCustomized = false;
            parent.notify("freehand-draw", {
              prop: "setFreehandDrawHoveredIndex",
              onPropertyChange: false,
              value: { index: tempHoveredIndex }
            });
            if (obj["index"] > -1) {
              var strokeColor = parent.pointColl[obj["index"]].strokeColor;
              parent.notify("freehand-draw", {
                prop: "hoverFhd",
                onPropertyChange: false,
                value: { strokeColor, strokeWidth: parent.pointColl[obj["index"]].strokeWidth }
              });
            }
          }
          indexObj["freehandSelectedIndex"] = null;
          parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
          var objColl = extend([], parent.objColl, [], true);
          if (!isNullOrUndefined(obj["index"]) && obj["index"] > -1) {
            parent.notify("freehand-draw", { prop: "selectFhd", value: { type: "ok" } });
            parent.notify("freehand-draw", {
              prop: "hoverFhd",
              onPropertyChange: false,
              value: { strokeColor: null, strokeWidth: null }
            });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
          } else if (indexObj["freehandSelectedIndex"]) {
            parent.okBtn();
            var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
            parent.notify("freehand-draw", {
              prop: "hoverFhd",
              onPropertyChange: false,
              value: { strokeColor, strokeWidth: parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth }
            });
          } else if (this.findTargetObj(x_1, y_1, false)) {
            parent.objColl = objColl;
            this.findTarget(x_1, y_1, e.type);
            parent.notify("draw", { prop: "redrawDownScale" });
          }
        } else {
          if (this.isFhdEditing) {
            parent.apply();
            var qbArea = document.getElementById(parent.element.id + "_quickAccessToolbarArea");
            if (qbArea) {
              qbArea.style.display = "none";
            }
            var point = parent.pointColl[indexObj["freehandSelectedIndex"]];
            var shapeSettings = {
              id: "pen_" + (indexObj["freehandSelectedIndex"] + 1),
              type: ShapeType.FreehandDraw,
              startX: point.points[0].x,
              startY: point.points[0].y,
              strokeColor: point.strokeColor,
              strokeWidth: point.strokeWidth,
              points: point.points,
              opacity: point.opacity,
              index: point.order
            };
            var shapeChangedArgs = { action: "apply", currentShapeSettings: extend({}, shapeSettings, {}, true) };
            parent.trigger("shapeChange", shapeChangedArgs);
          }
          var isPenDraw = parent.togglePen;
          parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
          if (isPenDraw) {
            parent.freeHandDraw(true);
          }
          this.isFhdEditing = false;
          if (isLineArrow) {
            this.setCursor(x_1, y_1);
          } else if (cursor !== "default") {
            parent.upperCanvas.style.cursor = parent.cursor = cursor;
          }
          if (parent.cursor === "crosshair" || Browser.isDevice && parent.togglePen) {
            if (parent.togglePen) {
              if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                var obj_1 = { strokeSettings: {} };
                parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj: obj_1 } });
                parent.activeObj.strokeSettings = obj_1["strokeSettings"];
              }
              var obj_2 = { penStrokeWidth: null };
              parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: obj_2 } });
              if (isNullOrUndefined(obj_2["penStrokeWidth"])) {
                parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: 2 } });
              }
              this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
              this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
              parent.notify("freehand-draw", {
                prop: "freehandDownHandler",
                onPropertyChange: false,
                value: { e, canvas: parent.upperCanvas }
              });
            } else {
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            parent.currObjType.isActiveObj = false;
            this.dragElement = "";
            this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
          }
          if (parent.cursor !== "crosshair" && e.type.toLowerCase() === "touchstart" || parent.currObjType.isActiveObj && parent.cursor !== "default" && !parent.togglePen) {
            parent.notify("draw", { prop: "updateTempObjColl" });
            parent.notify("draw", { prop: "updateTempPointColl" });
            this.findTarget(x_1, y_1, e.type);
            parent.notify("draw", { prop: "redrawDownScale" });
          } else if ((parent.currObjType.shape === "" || parent.currObjType.isCustomCrop) && !parent.togglePen && parent.cursor !== "default") {
            this.setActivePoint(x_1, y_1);
          }
          if (isTextArea) {
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          }
        }
      }
      this.isShapeInserted = false;
      this.tempActiveObj = extend({}, parent.activeObj, {}, true);
    };
    Selection2.prototype.mouseMoveEventHandler = function(e) {
      var parent = this.parent;
      var cursor = parent.cursor;
      var canvasCursor = parent.upperCanvas.style.cursor;
      e.preventDefault();
      if (this.isPreventShaping) {
        return;
      }
      if (parent.cursor === "grabbing" && this.isGrabbing) {
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotating", previousShapeSettings: shapeSettings };
        var shapeMovingArgs = { cancel: false, action: "rotating", previousShapeSettings: shapeSettings };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
      }
      if (this.timer && this.timer > 0) {
        this.timer = 0;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      if (e.type === "touchmove" && e.touches.length === 2) {
        if (this.isFirstMove) {
          this.startTouches = this.targetTouches(e.touches);
          this.tempTouches = [];
          this.tempTouches.push({
            x: e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft - bbox.left,
            y: (e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop) - bbox.top
          });
          this.tempTouches.push({
            x: (e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft) - bbox.left,
            y: (e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop) - bbox.top
          });
        } else {
          var firstFingerX = (e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft) - bbox.left;
          var firstFingerY = (e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop) - bbox.top;
          var secondFingerX = (e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft) - bbox.left;
          var secondFingerY = (e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop) - bbox.top;
          var center = { x: firstFingerX < secondFingerX ? secondFingerX - (secondFingerX - firstFingerX) / 2 : firstFingerX - (firstFingerX - secondFingerX) / 2, y: firstFingerY < secondFingerY ? secondFingerY - (secondFingerY - firstFingerY) / 2 : firstFingerY - (firstFingerY - secondFingerY) / 2 };
          if (this.currMousePoint.x !== center.x && this.currMousePoint.y !== center.y) {
            var type = "";
            if (e.type === "touchmove" && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Pinch) === ZoomTrigger.Pinch) {
              this.zoomType = "Pinch";
              var scale = this.calculateScale(this.startTouches, this.targetTouches(e.touches));
              this.startTouches = this.targetTouches(e.touches);
              if (scale > 1) {
                type = "zoomIn";
              } else if (scale < 1) {
                type = "zoomOut";
              }
            }
            if (type !== "") {
              parent.notify("draw", {
                prop: "performPointZoom",
                onPropertyChange: false,
                value: { x: center.x, y: center.y, type, isResize: null }
              });
            }
            this.tempTouches = [];
            this.tempTouches.push({
              x: e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft,
              y: e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop
            });
            this.tempTouches.push({
              x: e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft,
              y: e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop
            });
            this.currMousePoint.x = center.x;
            this.currMousePoint.y = center.y;
            this.isPinching = true;
          }
        }
        this.isFirstMove = false;
        return;
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.clientX;
        y = e.clientY;
      } else {
        this.touchEndPoint.x = x = e.touches[0].clientX;
        this.touchEndPoint.y = y = e.touches[0].clientY;
      }
      x -= bbox.left;
      y -= bbox.top;
      this.canvasMouseMoveHandler(e);
      var isCropSelection = false;
      var splitWords;
      if (parent.activeObj.shape !== void 0) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== void 0 && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection) {
        parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
      }
      parent.upperCanvas.style.cursor = canvasCursor;
      parent.cursor = cursor;
      if (parent.currObjType.isActiveObj && (parent.activeObj.activePoint !== void 0 || parent.objColl.length > 0) && !this.dragCanvas || parent.activeObj.activePoint !== void 0) {
        if (this.dragElement === "") {
          this.setCursor(x, y);
          if (parent.activeObj.activePoint && (parent.activeObj.activePoint.width === 0 || !isNullOrUndefined(parent.activeObj.currIndex) && this.cursorTargetId !== parent.activeObj.currIndex) && parent.cursor !== "default" && parent.cursor !== "move" && parent.cursor !== "crosshair" && parent.cursor !== "grab" && parent.cursor !== "pointer") {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
          }
          this.findTarget(x, y, e.type);
        }
      }
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.currObjType.isDragging) {
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.updateActivePoint(x, y, isCropSelection);
        parent.notify("shape", { prop: "updateTrianglePoints", onPropertyChange: false, value: { obj: parent.activeObj } });
        if (this.isPreventDragging) {
          if (parent.activeObj.activePoint.startX > destLeft && parent.activeObj.activePoint.endX < destLeft + destWidth && parent.activeObj.activePoint.startY > destTop && parent.activeObj.activePoint.endY < destTop + destHeight) {
            this.isPreventDragging = false;
          }
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: null,
            saveContext: null,
            isPreventSelection: null
          } });
        }
        if (isCropSelection) {
          this.dragCanvas = parent.togglePan = true;
        }
      }
    };
    Selection2.prototype.mouseUpEventHandler = function(e) {
      var parent = this.parent;
      var id = parent.element.id;
      parent.isKBDNavigation = false;
      if (!Browser.isDevice && (parent.element.querySelector("#" + id + "_contextualToolbar") && !parent.element.querySelector("#" + id + "_contextualToolbar").parentElement.classList.contains("e-hide") || parent.element.querySelector("#" + id + "_headWrapper") && !parent.element.querySelector("#" + id + "_headWrapper").parentElement.classList.contains("e-hide"))) {
        return;
      }
      if (parent.cursor === "grabbing" && this.isGrabbing) {
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotate-end", previousShapeSettings: shapeSettings };
        var shapeMovingArgs = { cancel: false, action: "rotate-end", previousShapeSettings: shapeSettings };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-up");
      }
      this.isGrabbing = false;
      if (this.isPreventShaping) {
        this.isPreventShaping = false;
      }
      if (this.mouseDown === "canvas" || this.isSliderActive || /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
      e.target.closest(".e-image-editor") || e.target.closest(".e-ie-ddb-popup")) {
        if (e.type === "touchstart") {
          this.isTouch = false;
        } else if (e.type === "touchend") {
          e.stopImmediatePropagation();
        }
        e.preventDefault();
        if (parent.togglePan) {
          this.canvasMouseUpHandler(e);
        }
        var x = void 0;
        var y = void 0;
        if (e.type === "mouseup") {
          x = e.clientX;
          y = e.clientY;
        } else {
          x = this.touchEndPoint.x;
          y = this.touchEndPoint.y;
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        var activeObjShape = void 0;
        var currentDrawingShape = this.currentDrawingShape;
        var dummyClick = false;
        if (e.type === "touchend") {
          this.startTouches = this.tempTouches = [];
          this.isFirstMove = false;
          if (parent.textArea.style.display === "none") {
            this.timer = 0;
          }
          if (this.isPinching) {
            this.isPinching = false;
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
            return;
          }
        }
        var isCropSelection = false;
        var splitWords = void 0;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== void 0 && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (this.currentDrawingShape === "path" && parent.isShapeDrawing) {
          var elem = e.srcElement;
          var elemId = elem.parentElement.id;
          var id_1 = parent.element.id;
          if (e.currentTarget !== parent.upperCanvas && e.currentTarget !== parent.lowerCanvas && parent.activeObj.pointColl.length > 0 && (elem.classList.contains("e-upload-icon") || elemId === id_1 + "_zoomIn" || elemId === id_1 + "_zoomOut" || elemId === id_1 + "_annotationBtn" || elemId === id_1 + "_borderColorBtn" || elemId === id_1 + "_borderWidthBtn")) {
            parent.notify("shape", { prop: "stopPathDrawing", onPropertyChange: false, value: { e, isApply: true } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
              canvas: "duplicate",
              obj: parent.activeObj,
              isCropRatio: null,
              points: null,
              isPreventDrag: true,
              saveContext: null,
              isPreventSelection: true
            } });
          }
          return;
        }
        if (e.currentTarget === parent.upperCanvas && !parent.isResize) {
          this.pathAdjustedIndex = null;
          if (this.currentDrawingShape !== "") {
            if (this.currentDrawingShape === "text") {
              var prevCropObj_1 = extend({}, parent.cropObj, {}, true);
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeInsert",
                  previousObj: this.initialPrevObj,
                  previousObjColl: this.initialPrevObj.objColl,
                  previousPointColl: this.initialPrevObj.pointColl,
                  previousSelPointColl: this.initialPrevObj.selPointColl,
                  previousCropObj: prevCropObj_1,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
            } else {
              parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl: this.initialPrevObj.objColl, operation: "shapeInsert" } });
            }
            this.isShapeInserted = true;
            this.currentDrawingShape = "";
            if (parent.activeObj.shape && parent.activeObj.shape === "path" && parent.activeObj.pointColl.length === 0 || (!parent.activeObj.shape || parent.activeObj.shape !== "path") && parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
              dummyClick = true;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            var previousShapeSettings = this.updatePrevShapeSettings();
            var shapeResizingArgs = { cancel: false, action: "draw-end", previousShapeSettings };
            var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings };
            this.shapeResizingArgs = shapeResizingArgs;
            this.shapeMovingArgs = shapeMovingArgs;
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-up");
          }
          this.adjustActObjForLineArrow();
          this.updPtCollForShpRot();
          parent.currObjType.shape = parent.currObjType.shape.toLowerCase();
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          var prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          if (!parent.togglePen && !isCropSelection) {
            if (this.tempObjColl && parent.activeObj.activePoint.width !== 0) {
              parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
              parent.objColl.push(parent.activeObj);
              if (JSON.stringify(parent.activeObj.activePoint) !== JSON.stringify(this.tempActiveObj.activePoint)) {
                parent.notify("undo-redo", {
                  prop: "updateUndoRedoColl",
                  onPropertyChange: false,
                  value: {
                    operation: "shapeTransform",
                    previousObj: prevObj,
                    previousObjColl: this.tempObjColl,
                    previousPointColl: prevObj.pointColl,
                    previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj,
                    previousText: null,
                    currentText: null,
                    previousFilter: null,
                    isCircleCrop: null
                  }
                });
              }
              var tempObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
              parent.objColl.pop();
              this.redrawShape(tempObj);
              parent.objColl.push(tempObj);
              this.tempObjColl = void 0;
            }
            if (!this.isFhdEditing) {
              this.applyCurrActObj(x, y);
              parent.currObjType.isResize = false;
              parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            }
          }
          if (parent.activeObj) {
            var isCropSelection_1 = false;
            var splitWords_1;
            if (parent.activeObj.shape !== void 0) {
              splitWords_1 = parent.activeObj.shape.split("-");
            }
            if (splitWords_1 === void 0 && (parent.currObjType.isCustomCrop || parent.togglePen)) {
              isCropSelection_1 = true;
            } else if (splitWords_1 !== void 0 && splitWords_1[0] === "crop") {
              isCropSelection_1 = true;
            }
            var shape = parent.activeObj.shape;
            activeObjShape = shape;
            var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path"];
            if (shapeColl.indexOf(shape) > -1) {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (shape === "text") {
              if (parent.textArea.style.display === "none") {
                parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                  type: "text",
                  isApplyBtn: null,
                  isCropping: null,
                  isZooming: null,
                  cType: null
                } });
              }
            } else if (this.isFhdEditing) {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "pen",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (!isCropSelection_1) {
              var eventargs = { type: "main", isApplyBtn: null, isCropping: false, isZooming: null };
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
            }
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
            if (!this.isFhdEditing) {
              if (parent.activeObj.shape && parent.activeObj.shape === "text" && parent.activeObj.textSettings.fontSize === 11 && Math.floor(parent.activeObj.activePoint.width) === 55 && Math.floor(parent.activeObj.activePoint.height) === 11) {
                parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              }
              if (!isCropSelection_1) {
                this.adjustActObjForLineArrow();
                if (parent.isShapeDrawing) {
                  var temp = this.currentDrawingShape;
                  parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
                  this.currentDrawingShape = temp;
                } else {
                  parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
                }
              }
            }
          }
        }
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== void 0 && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (parent.activeObj.shape && !isCropSelection && e.currentTarget === parent.upperCanvas && parent.textArea.style.display === "none") {
          if (parent.activeObj.shape === "text") {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "text",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
          } else {
            var temp = this.currentDrawingShape;
            this.currentDrawingShape = "";
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "shapes",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
            this.currentDrawingShape = temp;
          }
          parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
        }
        var obj = { freehandDrawSelectedId: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
        if (parent.togglePen && e.currentTarget === parent.upperCanvas && !obj["freehandDrawSelectedId"]) {
          parent.notify("freehand-draw", {
            prop: "freehandUpHandler",
            onPropertyChange: false,
            value: { e, canvas: parent.upperCanvas, context: this.upperContext }
          });
          if (parent.togglePen && (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 || !isNullOrUndefined(parent.toolbarTemplate))) {
            parent.okBtn();
            parent.freeHandDraw(true);
          }
        } else {
          parent.currObjType.shape = "";
        }
        this.dragElement = "";
        this.mouseDown = "";
        this.isSliderActive = false;
        parent.currObjType.isInitialLine = parent.currObjType.isDragging = false;
        this.selMouseUpEvent();
        if (isNullOrUndefined(parent.drawingShape) && activeObjShape && currentDrawingShape !== "") {
          parent.drawingShape = activeObjShape;
        }
        if (parent.drawingShape) {
          this.currentDrawingShape = parent.drawingShape.toLowerCase();
          if (dummyClick) {
            parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
            parent.upperCanvas.style.cursor = "crosshair";
          }
        }
        parent.isShapeDrawing = false;
      }
    };
    Selection2.prototype.adjustActObjForLineArrow = function(obj) {
      var isAdjusted = false;
      var parent = this.parent;
      obj = obj ? obj : parent.activeObj;
      if (obj.shape && (obj.shape === "line" || parent.activeObj.shape === "arrow")) {
        var temp = void 0;
        if (this.dragElement === "e-resize" && obj.activePoint.endX < obj.activePoint.startX || this.dragElement === "w-resize" && obj.activePoint.startX > obj.activePoint.endX) {
          isAdjusted = true;
          temp = obj.activePoint.startX;
          obj.activePoint.startX = obj.activePoint.endX;
          obj.activePoint.endX = temp;
          temp = obj.activePoint.startY;
          obj.activePoint.startY = obj.activePoint.endY;
          obj.activePoint.endY = temp;
        }
        obj.activePoint.width = Math.abs(obj.activePoint.endX - obj.activePoint.startX);
        obj.activePoint.height = Math.abs(obj.activePoint.endY - obj.activePoint.startY);
        if (parent.activeObj.shape !== "path") {
          parent.notify("shape", {
            prop: "setPointCollForLineArrow",
            onPropertyChange: false,
            value: { obj }
          });
          for (var i = 0; i < obj.pointColl.length; i++) {
            obj.pointColl[i].ratioX = (obj.pointColl[i].x - parent.img.destLeft) / parent.img.destWidth;
            obj.pointColl[i].ratioY = (obj.pointColl[i].y - parent.img.destTop) / parent.img.destHeight;
          }
        }
      }
      return isAdjusted;
    };
    Selection2.prototype.updPtCollForShpRot = function(obj) {
      var parent = this.parent;
      obj = obj ? obj : parent.activeObj;
      if (obj.shape && obj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj } });
        var _a = parent.img, destLeft_1 = _a.destLeft, destTop_1 = _a.destTop, destWidth_1 = _a.destWidth, destHeight_1 = _a.destHeight;
        var horTopLinePointColl = obj.horTopLinePointColl, horBottomLinePointColl = obj.horBottomLinePointColl, verLeftLinePointColl = obj.verLeftLinePointColl, verRightLinePointColl = obj.verRightLinePointColl;
        var setRatio = function(point) {
          point.ratioX = (point.x - destLeft_1) / destWidth_1;
          point.ratioY = (point.y - destTop_1) / destHeight_1;
        };
        horTopLinePointColl.forEach(setRatio);
        horBottomLinePointColl.forEach(setRatio);
        verLeftLinePointColl.forEach(setRatio);
        verRightLinePointColl.forEach(setRatio);
      }
    };
    Selection2.prototype.setXYPoints = function(e) {
      e.preventDefault();
      var x;
      var y;
      if (e.type === "mousedown") {
        x = e.clientX;
        y = e.clientY;
      } else {
        this.touchEndPoint.x = x = e.touches[0].clientX;
        this.touchEndPoint.y = y = e.touches[0].clientY;
      }
      var bbox = this.parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      return { x, y };
    };
    Selection2.prototype.getCurrentIndex = function() {
      var index;
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.activeObj.currIndex === parent.objColl[i].currIndex) {
          index = i;
          break;
        }
      }
      return index;
    };
    Selection2.prototype.isShapeClick = function(e, isCropSelection) {
      var parent = this.parent;
      var isShape = false;
      if (parent.togglePen) {
        return isShape;
      }
      if (parent.activeObj.shape && parent.activeObj.shape === "text" && this.isShapeInserted) {
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        isShape = this.findTargetObj(x, y, isCropSelection);
        if (!isCropSelection) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          if (isShape) {
            parent.notify("shape", {
              prop: "redrawActObj",
              onPropertyChange: false,
              value: { x: null, y: null, isMouseDown: true }
            });
          }
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (!isShape && activeObj.shape) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
            parent.objColl.splice(index, 1);
          } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.objColl.pop();
          }
        }
      }
      return isShape;
    };
    Selection2.prototype.isShapeTouch = function(e, isCropSelection) {
      var parent = this.parent;
      var isShape = false;
      if (e.type === "touchstart" && !parent.togglePen) {
        if (parent.activeObj && parent.activeObj.shape === "text") {
          this.timer = setTimeout(this.setTimer.bind(this), 1e3, e);
        }
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        isShape = this.findTargetObj(x, y, isCropSelection);
        if (!isCropSelection) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (!isShape && activeObj.shape) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isCropSelection) {
            if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
              parent.objColl.splice(index, 1);
            } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.objColl.pop();
            }
          }
        }
      }
      return isShape;
    };
    Selection2.prototype.isFreehandDrawTouch = function(e, isCropSelection) {
      var parent = this.parent;
      var isFreehandDraw = false;
      if (e.type === "touchstart" && !isCropSelection && !parent.togglePen) {
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        this.setCursor(x, y);
        if (this.isFhdPoint) {
          isFreehandDraw = true;
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (activeObj.shape) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isCropSelection) {
            if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
              parent.objColl.splice(index, 1);
            } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.objColl.pop();
            }
          }
        }
      }
      return isFreehandDraw;
    };
    Selection2.prototype.applyObj = function(x, y) {
      var parent = this.parent;
      var isApply = false;
      if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
        return false;
      }
      var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "image", "text"];
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (parent.activeObj.shape && shapeColl.indexOf(parent.activeObj.shape) > -1) {
        var radius = parent.activeObj.topLeftCircle.radius;
        if (x >= startX - radius * 2 && x <= endX + radius * 2 && y >= startY - radius * 2 && y <= endY + radius * 2) {
          isApply = false;
        } else if (parent.upperCanvas.style.cursor !== "default" && parent.upperCanvas.style.cursor !== "grab" && parent.upperCanvas.style.cursor !== "crosshair" && parent.upperCanvas.style.cursor !== "pointer" && parent.upperCanvas.style.cursor !== "move") {
          isApply = false;
        } else {
          isApply = true;
        }
      }
      return isApply;
    };
    Selection2.prototype.applyCurrShape = function(isShapeClick) {
      var parent = this.parent;
      var isApply = false;
      if (parent.togglePen) {
        return isApply;
      }
      var obj = extend({}, parent.activeObj, null, true);
      if (this.isShapeInserted && parent.activeObj.shape === "text" && isShapeClick) {
        this.isInitialTextEdited = true;
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: true } });
      }
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        obj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
        parent.objColl.pop();
        parent.activeObj = extend({}, activeObj, null, true);
        parent.textArea.value = obj.keyHistory;
        parent.textArea.style.display = "block";
        var strokeColor = obj.strokeSettings && obj.strokeSettings.strokeColor ? obj.strokeSettings.strokeColor.split("(")[0] === "rgb" ? this.rgbToHex(parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[0]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[1]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[2]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[3])) : obj.strokeSettings.strokeColor : null;
        if (strokeColor && strokeColor === "#ffffff") {
          strokeColor = "#fff";
        }
        if (this.tempActiveObj.strokeSettings && this.tempActiveObj.strokeSettings.strokeColor && this.tempActiveObj.strokeSettings.strokeColor === "#ffffff") {
          this.tempActiveObj.strokeSettings.strokeColor = "#fff";
        }
        if (obj.keyHistory !== this.tempActiveObj.keyHistory || strokeColor && strokeColor !== this.tempActiveObj.strokeSettings.strokeColor || obj.textSettings && obj.textSettings.fontFamily !== this.tempActiveObj.textSettings.fontFamily || obj.textSettings && Math.round(obj.textSettings.fontSize) !== Math.round(this.tempActiveObj.textSettings.fontSize) || obj.textSettings && Math.round(obj.textSettings.fontRatio) !== Math.round(this.tempActiveObj.textSettings.fontRatio) || obj.textSettings && obj.textSettings.bold !== this.tempActiveObj.textSettings.bold || obj.textSettings && obj.textSettings.italic !== this.tempActiveObj.textSettings.italic || obj.textSettings && obj.textSettings.underline !== this.tempActiveObj.textSettings.underline) {
          isApply = true;
        }
        if (this.isInitialTextEdited && !isApply) {
          isApply = true;
          this.isInitialTextEdited = false;
        }
      } else {
        this.tempActiveObj.activePoint.height = Math.abs(this.tempActiveObj.activePoint.height);
        isApply = JSON.stringify(obj) !== JSON.stringify(this.tempActiveObj);
      }
      return isApply;
    };
    Selection2.prototype.canvasMouseDownHandler = function(e) {
      var parent = this.parent;
      e.preventDefault();
      var x;
      var y;
      if (e.type === "mousedown") {
        x = e.offsetX || e.pageX - parent.lowerCanvas.offsetLeft;
        y = e.offsetY || e.pageY - parent.lowerCanvas.offsetTop;
      } else {
        x = e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft;
        y = e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      this.panDown = { x, y };
      var tempPanMoveObj = { tempPanMove: null };
      parent.notify("transform", {
        prop: "getTempPanMove",
        onPropertyChange: false,
        value: { obj: tempPanMoveObj }
      });
      if (isNullOrUndefined(tempPanMoveObj["tempPanMove"])) {
        parent.notify("transform", {
          prop: "setTempPanMove",
          onPropertyChange: false,
          value: { point: { x, y } }
        });
      }
    };
    Selection2.prototype.canvasMouseMoveHandler = function(e) {
      var parent = this.parent;
      var frameObject = { bool: null };
      parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (parent.isResize || frameObject["bool"]) {
        parent.upperCanvas.style.cursor = "default";
        return;
      }
      if (this.dragCanvas) {
        parent.lowerCanvas.style.cursor = "grab";
      } else {
        this.dragCanvas = parent.togglePan = false;
        parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "default";
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.offsetX;
        y = e.offsetY;
      } else {
        x = e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft;
        y = e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      var panMove = { x, y };
      parent.notify("transform", {
        prop: "setPanMove",
        onPropertyChange: false,
        value: { point: { x, y } }
      });
      if (this.panDown && panMove && parent.togglePan && this.dragCanvas) {
        if (parent.isCropTab || parent.activeObj.shape) {
          parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
          parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
        }
        parent.notify("transform", {
          prop: "drawPannedImage",
          onPropertyChange: false,
          value: { xDiff: null, yDiff: null }
        });
      }
    };
    Selection2.prototype.canvasMouseUpHandler = function(e) {
      var parent = this.parent;
      e.preventDefault();
      var panMoveObj = { panMove: null };
      parent.notify("transform", {
        prop: "getPanMove",
        onPropertyChange: false,
        value: { obj: panMoveObj }
      });
      if (parent.togglePan) {
        if (this.panDown && panMoveObj["panMove"] && parent.togglePan && this.dragCanvas) {
          this.panDown = null;
          parent.notify("transform", {
            prop: "setPanMove",
            onPropertyChange: false,
            value: { point: null }
          });
          parent.notify("transform", {
            prop: "setTempPanMove",
            onPropertyChange: false,
            value: { point: null }
          });
        }
      }
      if (this.currentDrawingShape !== "path") {
        parent.currObjType.isDragging = false;
      }
    };
    Selection2.prototype.touchStartHandler = function(e) {
      e.preventDefault();
      var parent = this.parent;
      if (this.touchTime === 0) {
        this.touchTime = (/* @__PURE__ */ new Date()).getTime();
      } else {
        if ((/* @__PURE__ */ new Date()).getTime() - this.touchTime < 400) {
          parent.notify("shape", { prop: "stopPathDrawing", onPropertyChange: false, value: { e, isApply: null } });
          this.touchTime = 0;
        } else {
          this.touchTime = (/* @__PURE__ */ new Date()).getTime();
        }
      }
      if (e.touches.length === 2) {
        this.isFirstMove = true;
      } else {
        this.mouseDownEventHandler(e);
      }
      EventHandler.add(parent.lowerCanvas, "touchend", this.mouseUpEventHandler, this);
      EventHandler.add(parent.lowerCanvas, "touchmove", this.mouseMoveEventHandler, this);
      EventHandler.add(parent.upperCanvas, "touchend", this.mouseUpEventHandler, this);
      EventHandler.add(parent.upperCanvas, "touchmove", this.mouseMoveEventHandler, this);
    };
    Selection2.prototype.unwireEvent = function() {
      var parent = this.parent;
      EventHandler.remove(parent.lowerCanvas, "touchend", this.mouseUpEventHandler);
      EventHandler.remove(parent.lowerCanvas, "touchmove", this.mouseMoveEventHandler);
      EventHandler.remove(parent.upperCanvas, "touchend", this.mouseUpEventHandler);
      EventHandler.remove(parent.upperCanvas, "touchmove", this.mouseMoveEventHandler);
    };
    Selection2.prototype.keyDownEventHandler = function(e) {
      var parent = this.parent;
      if (e.ctrlKey && (e.key === "+" || e.key === "-")) {
        e.preventDefault();
      }
      var obj = { fileName: "", fileType: null };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj } });
      var beforeSave = { fileName: obj["fileName"], fileType: obj["fileType"], cancel: false };
      switch (e.key) {
        case (e.ctrlKey && "s"):
          parent.trigger("beforeSave", beforeSave);
          this.beforeSaveEvent(beforeSave, e);
          break;
        case (e.ctrlKey && "z"):
          if (parent.allowUndoRedo) {
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-undo" });
          }
          break;
        case (e.ctrlKey && "y"):
          if (parent.allowUndoRedo) {
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-redo" });
          }
          break;
        case (e.ctrlKey && "+"):
          if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
            this.zoomType = "Commands";
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: 0.1, zoomPoint: null },
              isResize: null
            });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
          }
          break;
        case (e.ctrlKey && "-"):
          if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
            this.zoomType = "Commands";
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -0.1, zoomPoint: null },
              isResize: null
            });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
          }
          break;
        case "Delete":
          this.deleteItem();
          break;
        case "Escape":
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isFinalCancel: true } });
          break;
        case "Enter":
          this.performEnterAction(e);
          break;
        case "Tab":
          this.performTabAction();
          break;
        default:
          if (Browser.isDevice && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            setTimeout(this.textKeyDown.bind(this), 1, e);
          }
          break;
      }
    };
    Selection2.prototype.performEnterAction = function(e) {
      var parent = this.parent;
      if (parent.isResize) {
        var target = e.target;
        var isIcon = target.id.indexOf("aspectratio") || target.id.indexOf("non-aspectratio") > -1 ? true : false;
        var isValue = this.isValueUpdated();
        if (!isValue) {
          if (isIcon) {
            this.focusRatioBtn();
          }
          return;
        }
        var point = this.getNumTextValue();
        var aspectRatioElement = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
        var blrAspRatElem = parent.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
        if (point && point.x && point.y) {
          if (aspectRatioElement || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
            parent.notify("transform", { prop: "resize", value: { width: point.x, height: null, isAspectRatio: true } });
          } else {
            parent.notify("transform", { prop: "resize", value: { width: point.x, height: point.y, isAspectRatio: false } });
          }
        }
        var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
        var aspectRatioWidth = parent.element.querySelector("#" + parent.element.id + "_resizeWidth");
        if (isNullOrUndefined(aspectRatioElement)) {
          if (aspectRatioHeight) {
            var elem = getComponent(aspectRatioHeight, "numerictextbox");
            if (aspectRatioHeight && aspectRatioHeight.value === "") {
              elem.value = parseFloat(elem.placeholder);
              aspectRatioHeight.value = elem.placeholder + "px";
            }
          }
          if (aspectRatioWidth) {
            var elem = getComponent(aspectRatioWidth, "numerictextbox");
            if (aspectRatioWidth && aspectRatioWidth.value === "") {
              elem.value = parseFloat(elem.placeholder);
              aspectRatioWidth.value = elem.placeholder + "px";
            }
          }
        }
        parent.notify("draw", { prop: "redrawDownScale" });
        if (isIcon) {
          this.focusRatioBtn();
        }
      } else if (e.target.classList.contains("e-upload")) {
        var upload = parent.element.querySelector(".e-image-upload");
        if (upload && upload.querySelector(".e-tbar-btn")) {
          upload.querySelector(".e-tbar-btn").click();
        }
      } else if (e.target.classList.contains("filter-wrapper")) {
        e.target.parentElement.click();
      } else {
        var splitWords = void 0;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (e && this.isKeyBoardCrop(e) && parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] === "crop")) {
          parent.crop();
        }
      }
    };
    Selection2.prototype.focusRatioBtn = function() {
      var id = this.parent.element.id;
      if (this.parent.isKBDNavigation) {
        setTimeout(function() {
          if (document.getElementById(id + "_aspectratio")) {
            document.getElementById(id + "_aspectratio").focus();
          } else if (document.getElementById(id + "_nonaspectratio")) {
            document.getElementById(id + "_nonaspectratio").focus();
          }
        }, 50);
      }
    };
    Selection2.prototype.isKeyBoardCrop = function(e) {
      var bool = false;
      var target = e.target;
      if (target.id === this.parent.element.id + "_ok" || target.id === "") {
        bool = true;
      }
      return bool;
    };
    Selection2.prototype.beforeSaveEvent = function(observableSaveArgs, e) {
      var parent = this.parent;
      if (!observableSaveArgs.cancel) {
        parent.notify("export", {
          prop: "export",
          onPropertyChange: false,
          value: { type: observableSaveArgs.fileType, fileName: observableSaveArgs.fileName }
        });
      }
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    Selection2.prototype.handleScroll = function(e) {
      var parent = this.parent;
      var x;
      var y;
      var isInsideCanvas = false;
      if (e.type === "mousewheel") {
        x = e.clientX;
        y = e.clientY;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      if (x > parent.img.destLeft && x < parent.img.destLeft + parent.img.destWidth && y > parent.img.destTop && y < parent.img.destTop + parent.img.destHeight) {
        isInsideCanvas = true;
      }
      e.stopPropagation();
      if (e.ctrlKey === true && isInsideCanvas) {
        e.preventDefault();
        if (!parent.isCropTab && (parent.activeObj.shape && parent.activeObj.shape.split("-")[0] !== "crop")) {
          parent.okBtn(null, true);
          parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
        }
        var type = "";
        if (e.type === "mousewheel" && (parent.zoomSettings.zoomTrigger & ZoomTrigger.MouseWheel) === ZoomTrigger.MouseWheel) {
          this.zoomType = "MouseWheel";
          if (e.wheelDelta > 0) {
            type = "zoomIn";
          } else {
            type = "zoomOut";
          }
        }
        if (type !== "") {
          parent.notify("draw", {
            prop: "performPointZoom",
            onPropertyChange: false,
            value: { x, y, type, isResize: null }
          });
          parent.notify("draw", { prop: "redrawDownScale" });
          if (parent.isCropTab || parent.activeObj.shape) {
            parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent.isStraightening) {
            parent.notify("draw", { prop: "resetStraightenDestPoints" });
            parent.notify("draw", { prop: "setDestForStraighten" });
          }
        }
      }
    };
    Selection2.prototype.textKeyDown = function(e) {
      var parent = this.parent;
      if (parent.activeObj.rotatedAngle !== 0) {
        return;
      }
      if (String.fromCharCode(e.which) === "\r") {
        this.textRow += 1;
      }
      parent.textArea.setAttribute("rows", this.textRow.toString());
      parent.textArea.style.height = "auto";
      parent.textArea.style.height = parent.textArea.scrollHeight + "px";
      parent.notify("shape", { prop: "setTextBoxWidth", onPropertyChange: false, value: { e } });
      if (Browser.isDevice) {
        parent.textArea.style.width = parseFloat(parent.textArea.style.width) + parent.textArea.style.fontSize + "px";
      }
      var rows = parent.textArea.value.split("\n");
      this.textRow = rows.length;
      parent.textArea.setAttribute("rows", this.textRow.toString());
      this.isInitialTextEdited = false;
    };
    Selection2.prototype.clearSelection = function(resetCrop) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (resetCrop) {
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        } else {
          parent.togglePen = false;
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.dragElement = "";
          this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
          parent.currObjType.shape = "";
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.currObjType.isActiveObj = true;
          parent.currObjType.isCustomCrop = false;
          parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Selection2.prototype.setDragDirection = function(width, height) {
      var arcRadius = 7.5;
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (parent.img.destWidth > parent.img.destHeight) {
        actPoint.startX = this.dragPoint.startX = width / 2 - height / 2 + arcRadius;
        actPoint.startY = this.dragPoint.startY = height / 2 - height / 2 + arcRadius;
        actPoint.endX = width / 2 + height / 2 - arcRadius;
        actPoint.endY = height / 2 + height / 2 - arcRadius;
      } else {
        actPoint.startY = this.dragPoint.startX = height / 2 - width / 2 + arcRadius;
        actPoint.endY = height / 2 + width / 2 - arcRadius;
        actPoint.startX = this.dragPoint.startX = arcRadius;
        actPoint.endX = width - arcRadius;
      }
    };
    Selection2.prototype.calcShapeRatio = function(x, y, imgWidth, imgHeight) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var arcRadius = 7.5;
      var presetRatio = x / y;
      var originalWidth2 = imgWidth;
      var originalHeight2 = imgHeight;
      var standardSize = originalWidth2 >= originalHeight2 ? originalWidth2 : originalHeight2;
      var width = standardSize * presetRatio;
      var height = standardSize;
      var scaleWidth = this.getScale(width, originalWidth2);
      var snippetArray = [];
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var i = 0; i < 2; i++) {
        if (i === 0) {
          snippetArray.push(width * scaleWidth);
        } else {
          snippetArray.push(height * scaleWidth);
        }
      }
      width = snippetArray[0];
      height = snippetArray[1];
      var scaleHeight = this.getScale(height, originalHeight2);
      var snippetArray1 = [];
      for (var i = 0; i < 2; i++) {
        if (i === 0) {
          snippetArray1.push(width * scaleHeight);
        } else {
          snippetArray1.push(height * scaleHeight);
        }
      }
      width = snippetArray1[0];
      height = snippetArray1[1];
      actPoint.width = width;
      actPoint.height = height;
      actPoint.startX = (this.dragPoint.startX = (originalWidth2 - width) / 2) + arcRadius;
      actPoint.startY = (this.dragPoint.startY = (originalHeight2 - height) / 2) + arcRadius;
      actPoint.endX = actPoint.startX + actPoint.width;
      actPoint.endY = actPoint.startY + actPoint.height;
      if (actPoint.startX < destLeft && destLeft + destWidth > parent.lowerCanvas.clientWidth) {
        actPoint.startX = destLeft;
        actPoint.endX = actPoint.startX + width - arcRadius;
      }
      if (actPoint.startY < destTop && destTop + destHeight > parent.lowerCanvas.clientHeight) {
        actPoint.startY = destTop;
        actPoint.endY = actPoint.startY + height - arcRadius;
      }
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
    };
    Selection2.prototype.getScale = function(value, originalValue) {
      return value > originalValue ? originalValue / value : 1;
    };
    Selection2.prototype.findTarget = function(x, y, type) {
      var parent = this.parent;
      if (type.toLowerCase() === "mousedown" || type.toLowerCase() === "touchstart") {
        var splitWords = void 0;
        var isCrop = false;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
          if (splitWords[0] === "crop") {
            isCrop = true;
          }
        }
        this.findTargetObj(x, y, isCrop);
        this.updateCursorStyles(x, y, type);
      } else {
        var _a = parent.activeObj, topLeftCircle = _a.topLeftCircle, topCenterCircle = _a.topCenterCircle, topRightCircle = _a.topRightCircle, centerLeftCircle = _a.centerLeftCircle, centerRightCircle = _a.centerRightCircle, bottomLeftCircle = _a.bottomLeftCircle, bottomCenterCircle = _a.bottomCenterCircle, bottomRightCircle = _a.bottomRightCircle;
        switch (this.dragElement.toLowerCase()) {
          case "nw-resize":
            topLeftCircle.startX = x;
            topLeftCircle.startY = y;
            break;
          case "n-resize":
            topCenterCircle.startX = x;
            topCenterCircle.startY = y;
            break;
          case "ne-resize":
            topRightCircle.startX = x;
            topRightCircle.startY = y;
            break;
          case "w-resize":
            centerLeftCircle.startX = x;
            centerLeftCircle.startY = y;
            break;
          case "e-resize":
            centerRightCircle.startX = x;
            centerRightCircle.startY = y;
            break;
          case "sw-resize":
            bottomLeftCircle.startX = x;
            bottomLeftCircle.startY = y;
            break;
          case "s-resize":
            bottomCenterCircle.startX = x;
            bottomCenterCircle.startY = y;
            break;
          case "se-resize":
            bottomRightCircle.startX = x;
            bottomRightCircle.startY = y;
            break;
          default:
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            break;
        }
      }
    };
    Selection2.prototype.findTargetObj = function(x, y, isCrop) {
      var parent = this.parent;
      var isShape = false;
      if (parent.objColl.length !== 0 && !parent.currObjType.isCustomCrop && !isCrop) {
        var prevIndex = 0;
        var i = void 0;
        for (var index = 0; index < parent.objColl.length; index++) {
          var cursor = parent.upperCanvas.style.cursor;
          this.setCursor(x, y);
          var actObj = extend({}, parent.objColl[index], {}, true);
          var radius = actObj.topLeftCircle.radius;
          if (actObj.shape === "line" || actObj.shape === "arrow") {
            for (var j = 0; j < actObj.pointColl.length; j++) {
              if (x >= actObj.pointColl[j].x - radius * 2 && x <= actObj.pointColl[j].x + radius * 2 && y >= actObj.pointColl[j].y - radius * 2 && y <= actObj.pointColl[j].y + radius * 2) {
                if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                  i = index;
                  break;
                } else {
                  if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                    if (prevIndex === 0 || prevIndex < actObj.order) {
                      prevIndex = actObj.order;
                      i = index;
                    }
                  } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                    i = index;
                  }
                }
                break;
              }
            }
          } else if (actObj.shape === "path") {
            var cursor_3 = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
            if (cursor_3 !== "default" && cursor_3 !== "grab") {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                  if (prevIndex === 0 || prevIndex < actObj.order) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          } else if (actObj.rotatedAngle !== 0) {
            var cursor_4 = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
            if (cursor_4 !== "default" && cursor_4 !== "grab") {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                  if (prevIndex === 0 || prevIndex < actObj.order) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          } else {
            var rotationCirclePoint = this.getTransRotationPoint(actObj);
            if (x >= actObj.activePoint.startX - radius * 2 && x <= actObj.activePoint.endX + radius * 2 && y >= actObj.activePoint.startY - radius * 2 && y <= actObj.activePoint.endY + radius * 2 || rotationCirclePoint && x >= rotationCirclePoint.x - radius * 2 && x <= rotationCirclePoint.x + radius * 2 && y >= rotationCirclePoint.y - radius * 2 && y <= rotationCirclePoint.y + radius * 2) {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || cursor === "move" || cursor === "grabbing" || this.isShapeInserted || parent.cursor === "move" || parent.cursor === "grabbing") {
                  if (prevIndex === 0 || prevIndex < actObj.order) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          }
        }
        if (isNullOrUndefined(i)) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          isShape = false;
        } else {
          this.tempObjColl = extend([], parent.objColl, [], true);
          parent.currObjType.isCustomCrop = false;
          parent.activeObj = extend({}, parent.objColl[i], {}, true);
          var temp = extend({}, parent.objColl[i], {}, true);
          parent.objColl.splice(i, 1);
          if (parent.transform.degree === 0) {
            var temp_1 = this.lowerContext.filter;
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
            this.lowerContext.filter = "none";
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
            });
            parent.activeObj = extend({}, temp_1, {}, true);
            this.lowerContext.filter = temp_1;
            this.getCurrentFlipState();
          } else {
            var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            var destPoints = {
              startX: parent.img.destLeft,
              startY: parent.img.destTop,
              width: parent.img.destWidth,
              height: parent.img.destHeight
            };
            parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.activeObj = extend({}, temp, {}, true);
          this.setActivePoint();
          parent.activeObj = extend({}, temp, {}, true);
          var tempStrokeSettings = extend({}, parent.activeObj.strokeSettings, {}, true);
          parent.notify("draw", {
            prop: "setTempStrokeSettings",
            onPropertyChange: false,
            value: { tempStrokeSettings }
          });
          var tempTextSettings = extend({}, parent.activeObj.textSettings, {}, true);
          parent.notify("draw", { prop: "setTempTextSettings", onPropertyChange: false, value: { tempTextSettings } });
          var shapeSettings = this.updatePrevShapeSettings();
          var shapeChangingArgs = {
            cancel: false,
            action: "select",
            previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings
          };
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow") {
            shapeChangingArgs.currentShapeSettings.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            shapeChangingArgs.currentShapeSettings.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
          }
          this.isCropSelection = false;
          var splitWords = void 0;
          if (parent.activeObj.shape !== void 0) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (splitWords !== void 0 && splitWords[0] === "crop") {
            this.isCropSelection = true;
          }
          if (!this.isCropSelection) {
            parent.trigger("shapeChanging", shapeChangingArgs);
            this.shapeEvent(shapeChangingArgs);
          } else {
            var selectionChangingArgs = {
              action: shapeChangingArgs.action,
              previousSelectionSettings: {
                type: parent.getSelectionType(parent.activeObj.shape),
                startX: shapeChangingArgs.previousShapeSettings.startX,
                startY: shapeChangingArgs.previousShapeSettings.startY,
                width: shapeChangingArgs.previousShapeSettings.width,
                height: shapeChangingArgs.previousShapeSettings.height
              },
              currentSelectionSettings: {
                type: parent.getSelectionType(parent.activeObj.shape),
                startX: shapeChangingArgs.currentShapeSettings.startX,
                startY: shapeChangingArgs.currentShapeSettings.startY,
                width: shapeChangingArgs.currentShapeSettings.width,
                height: shapeChangingArgs.currentShapeSettings.height
              }
            };
            parent.trigger("selectionChanging", selectionChangingArgs);
            shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;
            shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;
            shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;
            shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;
            this.shapeEvent(shapeChangingArgs);
          }
          isShape = true;
        }
      }
      return isShape;
    };
    Selection2.prototype.shapeEvent = function(shapeChangingArgs) {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "updateShapeChangeEventArgs",
        onPropertyChange: false,
        value: { shapeSettings: shapeChangingArgs.currentShapeSettings }
      });
      if (parent.activeObj.activePoint) {
        var obj = { prevActObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        if (isNullOrUndefined(obj["prevActObj"])) {
          parent.notify("draw", {
            prop: "setPrevActObj",
            onPropertyChange: false,
            value: { prevActObj: extend({}, parent.activeObj, {}, true) }
          });
        }
        if (parent.activeObj.shape === "image" && !this.isImageClarity) {
          this.upgradeImageQuality();
          this.isImageClarity = true;
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: true
        } });
        if (!this.isShapeInserted) {
          var activePoint = parent.activeObj.activePoint;
          var _a = parent.img, destLeft = _a.destLeft, destWidth = _a.destWidth, destTop = _a.destTop, destHeight = _a.destHeight;
          this.isPreventDragging = activePoint.startX < destLeft || activePoint.endX > destLeft + destWidth || activePoint.startY < destTop || activePoint.endY > destTop + destHeight;
        }
      }
    };
    Selection2.prototype.upgradeImageQuality = function() {
      var parent = this.parent;
      var activeObj = extend({}, parent.activeObj, null, true);
      var ctx = parent.activeObj.imageCanvas.getContext("2d");
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: {
        width: parent.activeObj.imageElement.width,
        height: parent.activeObj.imageElement.height,
        obj: dimObj,
        isImgShape: null
      } });
      parent.notify("shape", { prop: "updateObj", onPropertyChange: false, value: { dimObj, x: null, y: null } });
      ctx.clearRect(0, 0, parent.activeObj.imageCanvas.width, parent.activeObj.imageCanvas.height);
      this.applyTransformToImg(ctx);
      parent.activeObj = activeObj;
    };
    Selection2.prototype.applyTransformToImg = function(ctx) {
      var parent = this.parent;
      if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
        parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: true, isVFlip: true }
        });
      } else if (parent.activeObj.isHorImageFlip) {
        parent.activeObj.isHorImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: true, isVFlip: false }
        });
      } else if (parent.activeObj.isVerImageFlip) {
        parent.activeObj.isVerImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: false, isVFlip: true }
        });
      } else {
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: false, isVFlip: false }
        });
      }
    };
    Selection2.prototype.targetTouches = function(touches) {
      var bbox = this.parent.lowerCanvas.getBoundingClientRect();
      var p1 = { x: touches[0].pageX - bbox.left, y: touches[0].pageY - bbox.top };
      var p2 = { x: touches[1].pageX - bbox.left, y: touches[1].pageY - bbox.top };
      var points = [p1, p2];
      return points;
    };
    Selection2.prototype.calculateScale = function(startTouches, endTouches) {
      var startDistance = this.getDistance(startTouches[0], startTouches[1]);
      var endDistance = this.getDistance(endTouches[0], endTouches[1]);
      return endDistance / startDistance;
    };
    Selection2.prototype.getDistance = function(a, b) {
      var x = 0;
      var y = 0;
      if (a && b) {
        x = a.x - b.x;
        y = a.y - b.y;
      }
      return Math.sqrt(x * x + y * y);
    };
    Selection2.prototype.redrawShape = function(obj, isMouseUp) {
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (JSON.stringify(obj) === JSON.stringify(parent.objColl[i])) {
          parent.objColl.splice(i, 1);
          break;
        }
      }
      if (obj.shape === "path" && obj.pointColl.length === 0 || obj.shape !== "path" && (obj.activePoint.width === 0 && obj.activePoint.height === 0)) {
        return;
      }
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (this.isPreventDragging) {
        if (parent.activeObj.activePoint.startX > parent.img.destLeft) {
          this.isPreventDragging = false;
        }
        if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        }
      } else {
        if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        }
      }
    };
    Selection2.prototype.setTimer = function(e) {
      var parent = this.parent;
      if (this.timer > 10) {
        clearTimeout(this.timer);
        this.timer = 0;
        parent.notify("shape", { prop: "findTextTarget", onPropertyChange: false, value: { e } });
        if (Browser.isDevice) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
    };
    Selection2.prototype.applyCurrActObj = function(x, y) {
      var parent = this.parent;
      var isInside = false;
      var actObj = extend({}, parent.activeObj, {}, true);
      if (isNullOrUndefined(actObj.activePoint)) {
        return;
      }
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var radius = actObj.topLeftCircle ? actObj.topLeftCircle.radius : 0;
      if (x >= Math.floor(startX) && x <= Math.ceil(endX) && y >= Math.floor(startY) && y <= Math.ceil(endY)) {
        isInside = true;
      } else if (radius !== 0 && (x >= Math.floor(startX) - radius && x <= Math.ceil(endX) + radius && y >= Math.floor(startY) - radius && y <= Math.ceil(endY) + radius)) {
        isInside = true;
        this.tempActiveObj = {
          activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
          flipObjColl: [],
          triangle: [],
          triangleRatio: []
        };
      } else if ((actObj.shape === "text" || actObj.shape === "image") && this.dragElement !== "") {
        isInside = true;
      } else if (actObj.shape === "line" || actObj.shape === "arrow") {
        var smallPoint = { x: startX < endX ? startX : endX, y: startY < endY ? startY : endY };
        var largePoint = { x: startX > endX ? startX : endX, y: startY > endY ? startY : endY };
        if (x >= Math.floor(smallPoint.x) - 5 && x <= Math.ceil(largePoint.x) + 5 && y >= Math.floor(smallPoint.y) - 5 && y <= Math.ceil(largePoint.y) + 5) {
          isInside = true;
        }
      } else if (actObj.shape === "path") {
        var cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
        if (cursor === "move") {
          isInside = true;
        }
      } else if (this.dragElement === "grabbing") {
        isInside = true;
      } else if (actObj.rotatedAngle !== 0) {
        var cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
        if (cursor !== "default" && cursor !== "grab" || this.dragElement === "n-resize" || this.dragElement === "e-resize" || this.dragElement === "s-resize" || this.dragElement === "w-resize") {
          isInside = true;
        }
      } else if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        isInside = true;
      }
      if (!isInside) {
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
          var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
          parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
          parent.activeObj.currIndex = shapeIDObj["id"];
        }
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        if (parent.activeObj.horTopLine !== void 0 && parent.activeObj.horTopLine.startX !== 0 && parent.activeObj.horTopLine.endX !== 0 && !parent.currObjType.isCustomCrop && parent.currObjType.shape !== "") {
          parent.objColl.push(extend({}, parent.activeObj, {}, true));
        }
        var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          var tempFilter = this.lowerContext.filter;
          this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
          for (var i = 0; i < parent.objColl.length; i++) {
            var obj = { isInside: false };
            parent.notify("crop", {
              prop: "isObjInImage",
              onPropertyChange: false,
              value: { obj: parent.objColl[i], object: obj }
            });
            if (obj["isInside"]) {
              parent.notify("shape", {
                prop: "apply",
                onPropertyChange: false,
                value: { shape: parent.objColl[i].shape, obj: parent.objColl[i], canvas: null }
              });
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
            }
          }
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
          });
          this.lowerContext.filter = tempFilter;
          if (parent.activeObj.shape) {
            parent.notify("shape", {
              prop: "apply",
              onPropertyChange: false,
              value: { shape: null, obj: null, canvas: null }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
          if (parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
        }
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    Selection2.prototype.getCurrentFlipState = function() {
      var parent = this.parent;
      if (parent.rotateFlipColl.length !== 0) {
        var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
        parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
      } else {
        parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
      }
    };
    Selection2.prototype.setTextBoxStylesToActObj = function() {
      var parent = this.parent;
      parent.activeObj.textSettings.fontFamily = parent.textArea.style.fontFamily;
      parent.activeObj.strokeSettings.strokeColor = parent.textArea.style.color !== "" && parent.textArea.style.color.split("(")[1] && parent.textArea.style.color.split("(")[1].split(",")[0] && parent.textArea.style.color.split("(")[1].split(",")[1] && parent.textArea.style.color.split("(")[1].split(",")[2] && parent.textArea.style.color.split("(")[1].split(",")[3] ? this.rgbToHex(parseFloat(parent.textArea.style.color.split("(")[1].split(",")[0]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[1]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[2]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[3])) : parent.textArea.style.color;
      if (parent.textArea.style.fontWeight === "bold") {
        parent.activeObj.textSettings.bold = true;
      } else {
        parent.activeObj.textSettings.bold = false;
      }
      if (parent.textArea.style.fontStyle === "italic") {
        parent.activeObj.textSettings.italic = true;
      } else {
        parent.activeObj.textSettings.italic = false;
      }
      parent.activeObj.textSettings.fontSize = parseFloat(parent.textArea.style.fontSize);
    };
    Selection2.prototype.rgbToHex = function(r, g, b, a) {
      r = Math.max(0, Math.min(255, Math.round(r)));
      g = Math.max(0, Math.min(255, Math.round(g)));
      b = Math.max(0, Math.min(255, Math.round(b)));
      a = Math.max(0, Math.min(1, a));
      var hexR = this.padLeft(r.toString(16), 2, "0");
      var hexG = this.padLeft(g.toString(16), 2, "0");
      var hexB = this.padLeft(b.toString(16), 2, "0");
      var hexA = this.padLeft(Math.round(a * 255).toString(16), 2, "0");
      var hex = "#" + hexR + hexG + hexB + hexA;
      return hex;
    };
    Selection2.prototype.padLeft = function(value, length, padChar) {
      while (value.length < length) {
        value = padChar + value;
      }
      return value;
    };
    Selection2.prototype.deleteItem = function() {
      var parent = this.parent;
      var shapeChangingArgs = { cancel: false };
      var previousShapeSettings = {};
      if (this.isFhdEditing) {
        this.updateFreehandDrawColorChange();
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        var obj = { freehandDrawSelectedId: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
        parent.notify("freehand-draw", { prop: "deleteFhd", value: { id: obj["freehandDrawSelectedId"] } });
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "deleteFreehandDrawing",
            previousObj: prevObj,
            previousObjColl: this.tempObjColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        parent.notify("freehand-draw", { prop: "resetFreehandDrawSelectedId" });
      } else if (parent.textArea.style.display === "none") {
        var obj = { prevActObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        if (obj["prevActObj"]) {
          obj["prevActObj"]["activePoint"]["width"] = Math.abs(obj["prevActObj"]["activePoint"]["width"]);
          obj["prevActObj"]["activePoint"]["height"] = Math.abs(obj["prevActObj"]["activePoint"]["height"]);
        }
        if (obj["prevActObj"] && JSON.stringify(obj["prevActObj"]) !== JSON.stringify(parent.activeObj)) {
          var index = parent.activeObj.currIndex;
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isFinalCancel: true } });
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === index) {
              parent.objColl.splice(i, 1);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
              break;
            }
          }
        }
        var object = { isNewPath: null };
        parent.notify("draw", { prop: "getNewPath", value: { obj: object } });
        if (object["isNewPath"]) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        } else if (parent.activeObj.shape) {
          parent.objColl.push(parent.activeObj);
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object_2 = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: object_2 } });
          var prevObj = object_2["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          parent.objColl.pop();
          previousShapeSettings = this.updatePrevShapeSettings();
          shapeChangingArgs = { cancel: false, action: "delete", previousShapeSettings, currentShapeSettings: null };
          parent.notify("shape", { prop: "setKeyHistory", onPropertyChange: false, value: { keyHistory: "" } });
          parent.clearSelection();
          parent.trigger("shapeChanging", shapeChangingArgs);
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
          if (!isNullOrUndefined(prevObj.objColl[prevObj.objColl.length - 1].currIndex)) {
            parent.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "deleteObj",
                previousObj: prevObj,
                previousObjColl: this.tempObjColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
        }
        parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        if (parent.drawingShape) {
          this.currentDrawingShape = parent.drawingShape.toLowerCase();
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
          parent.upperCanvas.style.cursor = "crosshair";
        }
      }
      if (document.getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        document.getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
    };
    Selection2.prototype.updateFreehandDrawColorChange = function() {
      var parent = this.parent;
      var indexObj = { freehandSelectedIndex: null };
      parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && !isNullOrUndefined(parent.pointColl[indexObj["freehandSelectedIndex"]]) && parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor === "#42a5f5") {
        var obj = { tempFreeHandDrawEditingStyles: null };
        parent.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
        parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor = obj["tempFreeHandDrawEditingStyles"].strokeColor;
      }
    };
    Selection2.prototype.updatePrevShapeSettings = function(obj) {
      var parent = this.parent;
      var fontStyle = [];
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
        parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
        parent.activeObj.currIndex = shapeIDObj["id"];
      }
      if (parent.activeObj.shape === "text" && parent.activeObj.textSettings) {
        if (parent.activeObj.textSettings.bold) {
          fontStyle.push("bold");
        }
        if (parent.activeObj.textSettings.italic) {
          fontStyle.push("italic");
        }
        if (parent.activeObj.textSettings.underline) {
          fontStyle.push("underline");
        }
      }
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var _b = parent.activeObj, keyHistory = _b.keyHistory, currIndex = _b.currIndex, shape = _b.shape, textSettings = _b.textSettings, strokeSettings = _b.strokeSettings, rotatedAngle = _b.rotatedAngle, imageElement = _b.imageElement, opacity = _b.opacity;
      var shapeSettingsObj = {
        id: !isNullOrUndefined(currIndex) ? currIndex : null,
        type: parent.toPascalCase(shape),
        startX,
        startY,
        width,
        height,
        strokeColor: strokeSettings ? strokeSettings.strokeColor : null,
        strokeWidth: strokeSettings ? strokeSettings.strokeWidth : null,
        fillColor: strokeSettings ? strokeSettings.fillColor : null,
        radius: shape === "ellipse" ? width / 2 : null,
        length: shape === "line" || shape === "arrow" ? width : null,
        text: shape === "text" ? keyHistory ? keyHistory : textSettings.text ? textSettings.text : null : null,
        fontSize: shape === "text" ? textSettings ? textSettings.fontSize : null : null,
        fontFamily: shape === "text" ? textSettings ? textSettings.fontFamily : null : null,
        fontStyle: shape === "text" ? fontStyle : null,
        color: shape === "text" ? strokeSettings ? strokeSettings.strokeColor : null : null,
        degree: shape === "ellipse" || shape === "rectangle" || shape === "image" || shape === "text" ? rotatedAngle * (180 / Math.PI) : null,
        imageData: shape === "image" ? imageElement.src : null,
        opacity: shape === "image" ? opacity : null,
        radiusX: shape === "ellipse" ? width / 2 : null,
        radiusY: shape === "ellipse" ? height / 2 : null,
        endX: shape === "line" || shape === "arrow" ? endX : null,
        endY: shape === "line" || shape === "arrow" ? endY : null,
        arrowHead: shape === "arrow" ? this.getArrowType(parent.activeObj.start) : null,
        arrowTail: shape === "arrow" ? this.getArrowType(parent.activeObj.end) : null,
        points: shape === "path" ? parent.activeObj.pointColl : null,
        index: parent.activeObj.order
      };
      if (obj) {
        obj["shapeSettingsObj"] = shapeSettingsObj;
      }
      return shapeSettingsObj;
    };
    Selection2.prototype.getArrowType = function(type) {
      var typeToArrowType = {
        "none": "None",
        "arrow": "Arrow",
        "arrowSolid": "SolidArrow",
        "circle": "Circle",
        "circleSolid": "SolidCircle",
        "square": "Square",
        "squareSolid": "SolidSquare",
        "bar": "Bar"
      };
      return typeToArrowType["" + type];
    };
    Selection2.prototype.getRectanglePoints = function(rectX, rectY, rectWidth, rectHeight, rectAngle, pointX, pointY) {
      var centerX = rectX + rectWidth / 2;
      var centerY = rectY + rectHeight / 2;
      var angleRad = rectAngle * (Math.PI / 180);
      var cosAngle = Math.cos(angleRad);
      var sinAngle = Math.sin(angleRad);
      var localX = pointX - centerX;
      var localY = pointY - centerY;
      var rotatedX = localX * cosAngle + localY * sinAngle;
      var rotatedY = -localX * sinAngle + localY * cosAngle;
      var halfWidth = rectWidth / 2;
      var halfHeight = rectHeight / 2;
      if (rotatedX >= -halfWidth && rotatedX <= halfWidth && rotatedY >= -halfHeight && rotatedY <= halfHeight) {
        return true;
      } else {
        return false;
      }
    };
    Selection2.prototype.getTransRotationPoint = function(obj, object) {
      var rotationCirclePoint;
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      degree = obj.shapeDegree === 0 ? this.parent.transform.degree : this.parent.transform.degree - obj.shapeDegree;
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (obj.flipObjColl) {
        for (var i = 0, iLen = obj.flipObjColl.length; i < iLen; i++) {
          if (obj.flipObjColl[i].toLowerCase() === "horizontal") {
            isHorizontalflip = true;
          } else if (obj.flipObjColl[i].toLowerCase() === "vertical") {
            isVerticalflip = true;
          }
        }
      }
      if (degree === 0 || degree === 360) {
        if (isVerticalflip) {
          rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
        } else {
          rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
        }
      } else if (degree === 90 || degree === -270) {
        if (isHorizontalflip) {
          rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        } else {
          rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        }
      } else if (degree === 180 || degree === -180) {
        if (isVerticalflip) {
          rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
        } else {
          rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
        }
      } else if (degree === 270 || degree === -90) {
        if (isHorizontalflip) {
          rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        } else {
          rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        }
      }
      if (object) {
        object["rotationCirclePoint"] = rotationCirclePoint;
      }
      return rotationCirclePoint;
    };
    Selection2.prototype.getNumTextValue = function(obj) {
      var parent = this.parent;
      var elem = parent.element;
      var height;
      var width;
      var widthElement;
      var heightElement;
      widthElement = elem.querySelector("#" + elem.id + "_resizeWidth");
      heightElement = elem.querySelector("#" + elem.id + "_resizeHeight");
      if (widthElement && heightElement) {
        var heightString = heightElement.value.replace(/,/g, "");
        var widthString = widthElement.value.replace(/,/g, "");
        if (heightString === "") {
          heightString = heightElement.placeholder.replace(/,/g, "");
        }
        if (widthString === "") {
          widthString = widthElement.placeholder.replace(/,/g, "");
        }
        height = parseFloat(heightString);
        width = parseFloat(widthString);
      }
      if (obj) {
        obj["width"] = width;
        obj["height"] = height;
      }
      return { x: width, y: height };
    };
    Selection2.prototype.isValueUpdated = function() {
      var isValue = true;
      var widthElement;
      var heightElement;
      widthElement = this.parent.element.querySelector("#" + this.parent.element.id + "_resizeWidth");
      heightElement = this.parent.element.querySelector("#" + this.parent.element.id + "_resizeHeight");
      if (widthElement && heightElement) {
        if (heightElement.value.replace(/,/g, "") === "" && widthElement.value.replace(/,/g, "") === "") {
          isValue = false;
        }
      }
      return isValue;
    };
    return Selection2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/shape.js
var Shape = (
  /** @class */
  function() {
    function Shape2(parent) {
      this.textSettings = { text: "Enter Text", fontFamily: "", fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.strokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
      this.keyHistory = "";
      this.preventFrameAnnotation = false;
      this.parent = parent;
      this.addEventListener();
    }
    Shape2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Shape2.prototype.addEventListener = function() {
      this.parent.on("shape", this.shape, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Shape2.prototype.removeEventListener = function() {
      this.parent.off("shape", this.shape);
      this.parent.off("destroyed", this.destroy);
    };
    Shape2.prototype.shape = function(args) {
      var parent = this.parent;
      this.initShapePvtProps();
      var uploader;
      switch (args.prop) {
        case "drawEllipse":
          this.drawEllipse(args.value["x"], args.value["y"], args.value["radiusX"], args.value["radiusY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["degree"], args.value["isSelected"]);
          break;
        case "drawLine":
          this.drawLine(args.value["startX"], args.value["startY"], args.value["endX"], args.value["endY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["isSelected"]);
          break;
        case "drawArrow":
          this.drawArrow(args.value["startX"], args.value["startY"], args.value["endX"], args.value["endY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["arrowStart"], args.value["arrowEnd"], args.value["isSelected"]);
          break;
        case "drawPath":
          this.drawPath(args.value["pointColl"], args.value["strokeWidth"], args.value["strokeColor"], args.value["isSelected"]);
          break;
        case "drawRectangle":
          this.drawRectangle(args.value["x"], args.value["y"], args.value["width"], args.value["height"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["degree"], args.value["isSelected"]);
          break;
        case "drawText":
          this.drawText(args.value["x"], args.value["y"], args.value["text"], args.value["fontFamily"], args.value["fontSize"], args.value["bold"], args.value["italic"], args.value["color"], args.value["isSelected"], args.value["degree"]);
          break;
        case "redrawActObj":
          this.redrawActObj(args.value["x"], args.value["y"], args.value["isMouseDown"]);
          break;
        case "apply":
          this.apply(args.value["shape"], args.value["obj"], args.value["canvas"]);
          break;
        case "updateShapeChangeEventArgs":
          this.updateShapeChangeEventArgs(args.value["shapeSettings"]);
          break;
        case "updSelChangeEventArgs":
          this.updSelChangeEventArgs(args.value["selectionSettings"]);
          break;
        case "iterateObjColl":
          this.iterateObjColl();
          break;
        case "updImgRatioForActObj":
          this.updImgRatioForActObj();
          break;
        case "redrawObj":
          this.redrawObj(args.value["degree"]);
          break;
        case "redraw-text":
          this.redrawText();
          break;
        case "draw-shape":
          this.drawShape(args.value["obj"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["start"], args.value["width"], args.value["height"]);
          break;
        case "renderTextArea":
          this.renderTextArea(args.value["x"], args.value["y"], args.value["actObj"]);
          break;
        case "setTextBoxWidth":
          this.setTextBoxWidth(args.value["e"]);
          break;
        case "findTextTarget":
          this.findTextTarget(args.value["e"]);
          break;
        case "updateFontStyles":
          this.updateFontStyles(args.value["isTextBox"]);
          break;
        case "applyFontStyle":
          this.applyFontStyle(args.value["item"]);
          break;
        case "updateFontRatio":
          this.updateFontRatio(args.value["obj"], args.value["isTextArea"]);
          break;
        case "updateFontSize":
          this.updateFontSize(args.value["obj"]);
          break;
        case "pushActItemIntoObj":
          this.pushActItemIntoObj();
          break;
        case "clearActObj":
          this.clearActObj();
          break;
        case "refreshActiveObj":
          this.refreshActiveObj();
          break;
        case "applyActObj":
          this.applyActObj(args.value["isMouseDown"]);
          break;
        case "wireEvent":
          EventHandler.add(parent.upperCanvas, "dblclick", this.findTextTarget, this);
          EventHandler.add(parent.textArea, "mousedown", this.findTextTarget, this);
          uploader = document.getElementById(parent.element.id + "_fileUpload");
          if (uploader) {
            EventHandler.add(uploader, "change", this.fileChanged, this);
          }
          break;
        case "unWireEvent":
          EventHandler.remove(parent.upperCanvas, "dblclick", this.findTextTarget);
          EventHandler.remove(parent.textArea, "mousedown", this.findTextTarget);
          uploader = document.getElementById(parent.element.id + "_fileUpload");
          if (uploader) {
            EventHandler.remove(uploader, "change", this.fileChanged);
          }
          break;
        case "getShapeSetting":
          this.getShapeSetting(args.value["id"], args.value["obj"]);
          break;
        case "getShapeSettings":
          this.getShapeSettings(args.value["obj"]);
          break;
        case "isPointsInRange":
          this.isPointsInRange(args.value["x"], args.value["y"], args.value["obj"]);
          break;
        case "alignRotateFlipColl":
          this.alignRotateFlipColl(args.value["collection"], args.value["isRotateFlipCollection"], args.value["obj"]);
          break;
        case "selectShape":
          this.selectShape(args.value["id"], args.value["obj"]);
          break;
        case "deleteShape":
          this.deleteShape(args.value["id"]);
          break;
        case "getMaxText":
          this.getMaxText(args.value["isTextBox"], args.value["text"], args.value["obj"]);
          break;
        case "setPointCollForLineArrow":
          args.value["obj"].pointColl = this.getLinePoints(args.value["obj"].activePoint.startX, args.value["obj"].activePoint.startY, args.value["obj"].activePoint.endX, args.value["obj"].activePoint.endY);
          break;
        case "setPointCollForShapeRotation":
          this.setPointCollForShapeRotation(args.value["obj"]);
          break;
        case "setTextSettings":
          if (args.value["textSettings"]) {
            this.textSettings = args.value["textSettings"];
          } else if (args.value["fontFamily"]) {
            this.textSettings.fontFamily = args.value["fontFamily"];
          } else if (args.value["fontSize"]) {
            this.textSettings.fontSize = args.value["fontSize"];
          }
          break;
        case "setStrokeSettings":
          if (args.value["strokeSettings"]) {
            this.strokeSettings = args.value["strokeSettings"];
          } else if (args.value["strokeColor"]) {
            this.strokeSettings.strokeColor = args.value["strokeColor"];
          } else if (args.value["fillColor"]) {
            this.strokeSettings.fillColor = args.value["fillColor"];
          } else if (args.value["strokeWidth"]) {
            this.strokeSettings.strokeWidth = args.value["strokeWidth"];
          }
          break;
        case "getStrokeSettings":
          args.value["obj"]["strokeSettings"] = this.strokeSettings;
          break;
        case "setKeyHistory":
          this.keyHistory = args.value["keyHistory"];
          break;
        case "getKeyHistory":
          args.value["obj"]["keyHistory"] = this.keyHistory;
          break;
        case "setTextBoxPos":
          this.setTextBoxPos(args.value["actObj"], args.value["degree"], args.value["flip"], args.value["x"], args.value["y"]);
          break;
        case "setTextBoxPoints":
          this.setTextBoxPoints(args.value["actObj"], args.value["degree"], args.value["flip"], args.value["x"], args.value["y"]);
          break;
        case "alignTextAreaIntoCanvas":
          this.alignTextAreaIntoCanvas();
          break;
        case "initializeTextShape":
          this.initializeTextShape(args.value["text"], args.value["fontFamily"], args.value["fontSize"], args.value["bold"], args.value["italic"], args.value["strokeColor"]);
          break;
        case "stopPathDrawing":
          this.stopPathDrawing(args.value["e"], args.value["isApply"]);
          break;
        case "updateArrowRatio":
          this.updateArrowRatio(args.value["obj"]);
          break;
        case "getSquarePointForRotatedShape":
          this.getSquarePointForRotatedShape(args.value["obj"], args.value["object"]);
          break;
        case "drawImage":
          this.drawImage(args.value["x"], args.value["y"], args.value["width"], args.value["height"], args.value["src"], args.value["degree"], args.value["isAspectRatio"], args.value["opacity"], args.value["isSelected"]);
          break;
        case "reset":
          this.reset();
          break;
        case "updateObj":
          this.updateObj(args.value["dimObj"], args.value["x"], args.value["y"]);
          break;
        case "straightenShapes":
          this.straightenShapes();
          break;
        case "straightenShapePoints":
          this.straightenShapePoints(args.value["obj"], args.value["isReverse"]);
          break;
        case "straightenPath":
          this.straightenPath(args.value["obj"]);
          break;
        case "straightenFHD":
          this.straightenFHD();
          break;
        case "getTextBoxPosition":
          this.getTextBoxPosition(args.value["obj"], args.value["object"]);
          break;
        case "setFlipState":
          this.setFlipState(args.value["x"], args.value["y"], args.value["obj"], args.value["object"]);
          break;
        case "getNewShapeId":
          args.value["obj"]["id"] = this.getNewShapeId();
          break;
        case "z-order":
          this.updateZOrder(args.value["obj"], args.value["value"]);
          break;
        case "getSmallestIndex":
          args.value["obj"]["index"] = this.getSmallestIndex();
          break;
        case "isIndexInObjColl":
          args.value["obj"]["bool"] = this.isIndexInObjColl(args.value["index"]);
          break;
        case "drawAnnotations":
          this.drawAnnotations(args.value["ctx"], args.value["shape"], args.value["pen"], args.value["isPreventApply"], args.value["x"], args.value["y"], args.value["panRegion"]);
          break;
        case "updateShapeColl":
          this.updateShapeColl();
          break;
        case "getNewOrder":
          args.value["obj"]["order"] = this.getNewOrder();
          break;
        case "getHighestOrder":
          args.value["obj"]["order"] = this.getHighestOrder();
          break;
        case "getLowestOrder":
          args.value["obj"]["order"] = this.getLowestOrder();
          break;
      }
    };
    Shape2.prototype.getModuleName = function() {
      return "shape";
    };
    Shape2.prototype.initShapePvtProps = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (isNullOrUndefined(this.shapeImg)) {
        this.shapeImg = parent.createElement("img", {
          id: parent.element.id + "_shapeImg",
          attrs: { name: "Image", crossorigin: "anonymous" }
        });
      }
      if (this.textSettings.fontFamily === "") {
        this.textSettings.fontFamily = parent.fontFamily.default;
      }
    };
    Shape2.prototype.reset = function() {
      this.textSettings = { text: "Enter Text", fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.strokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null };
      this.preventFrameAnnotation = false;
    };
    Shape2.prototype.drawEllipse = function(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      this.initializeShape("ellipse");
      var start = x && y ? { x, y } : null;
      this.drawShape("ellipse", strokeWidth, strokeColor, fillColor, start, radiusX, radiusY, null, null, null, degree, null, isSelected);
    };
    Shape2.prototype.drawLine = function(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
      this.initializeShape("line");
      var start = startX && startY ? { x: startX, y: startY } : null;
      var width = endX - startX;
      var height = endY - startY;
      this.drawShape("line", strokeWidth, strokeColor, null, start, width, height, null, null, null, null, null, isSelected);
    };
    Shape2.prototype.drawPath = function(pointColl, strokeWidth, strokeColor, isSelected) {
      var parent = this.parent;
      this.initializeShape("path");
      if (pointColl) {
        this.drawShape("path", strokeWidth, strokeColor, null, null, null, null, pointColl, null, null, null, null, isSelected);
      } else {
        this.drawShape("line", strokeWidth, strokeColor, null, null, null, null, null, null, null, null, null, isSelected);
        var obj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
        obj.shape = "path";
        obj.lineDraw = null;
        obj.pointColl = [
          { x: obj.activePoint.startX, y: obj.activePoint.startY },
          { x: obj.activePoint.endX, y: obj.activePoint.endY }
        ];
        parent.objColl[parent.objColl.length - 1] = obj;
      }
    };
    Shape2.prototype.drawArrow = function(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
      this.initializeShape("arrow");
      var start = startX && startY ? { x: startX, y: startY } : null;
      var width = endX - startX;
      var height = endY - startY;
      this.drawShape("arrow", strokeWidth, strokeColor, null, start, width, height, null, arrowStart, arrowEnd, null, null, isSelected);
    };
    Shape2.prototype.drawRectangle = function(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      this.initializeShape("rectangle");
      var start = x && y ? { x, y } : null;
      this.drawShape("rectangle", strokeWidth, strokeColor, fillColor, start, width, height, null, null, null, degree, null, isSelected);
    };
    Shape2.prototype.drawText = function(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree) {
      this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y, isSelected, degree);
    };
    Shape2.prototype.initializeShape = function(type) {
      var parent = this.parent;
      this.redrawActObj();
      parent.activeObj.shape = type;
      if (parent.currObjType.shape === "freehanddraw") {
        this.apply();
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        parent.currObjType.shape = "";
      }
      parent.currObjType.isCustomCrop = false;
    };
    Shape2.prototype.updateWidthHeight = function(obj) {
      obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
      obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
      return obj;
    };
    Shape2.prototype.setDimension = function(width, height) {
      var parent = this.parent;
      if (width && height) {
        parent.activeObj.activePoint.width = width;
        parent.activeObj.activePoint.height = height;
        if (parent.currObjType.shape.toLowerCase() === "ellipse") {
          parent.activeObj.activePoint.width = 2 * width;
          parent.activeObj.activePoint.height = 2 * height;
        }
      }
    };
    Shape2.prototype.getArrowType = function(type) {
      var arrowType = type;
      if (type) {
        var typeToArrowType = {
          "None": "none",
          "Arrow": "arrow",
          "SolidArrow": "arrowSolid",
          "Circle": "circle",
          "SolidCircle": "circleSolid",
          "Square": "square",
          "SolidSquare": "squareSolid",
          "Bar": "bar"
        };
        arrowType = typeToArrowType["" + type];
      }
      return arrowType;
    };
    Shape2.prototype.drawShape = function(type, strokeWidth, strokeColor, fillColor, start, width, height, pointColl, arrowStart, arrowEnd, degree, opacity, isSelected) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        this.redrawActObj();
        var objColl = extend([], parent.objColl, [], true);
        parent.togglePen = false;
        this.keyHistory = "";
        parent.upperCanvas.style.display = "block";
        this.refreshActiveObj();
        parent.currObjType.shape = type = type.toLowerCase();
        if (type === "path" && isNullOrUndefined(pointColl)) {
          parent.activeObj.shape = type;
          parent.activeObj.pointColl = [];
          parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
          parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "path" } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "shapes",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
          parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
        } else {
          if (type !== "freehanddraw" && type !== "") {
            parent.activeObj.shape = type;
            var strokeSettings = parent.activeObj.strokeSettings;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (isNullOrUndefined(strokeSettings)) {
              strokeSettings = this.strokeSettings;
            }
            if (type === "path" && pointColl) {
              parent.activeObj.pointColl = pointColl;
            }
            if (opacity !== null && opacity !== void 0) {
              parent.activeObj.opacity = opacity;
            }
            strokeSettings.strokeWidth = strokeWidth ? strokeWidth : strokeSettings.strokeWidth;
            strokeSettings.strokeColor = strokeColor ? strokeColor : strokeSettings.strokeColor;
            strokeSettings.fillColor = fillColor ? fillColor : strokeSettings.fillColor;
            var tempWidth = parent.img.destWidth > 100 ? 100 : parent.img.destWidth / 2;
            var tempHeight = parent.img.destHeight > 100 ? 100 : parent.img.destHeight / 2;
            parent.activeObj.activePoint.width = tempWidth;
            parent.activeObj.activePoint.height = tempHeight;
            if (type === "line" || type === "arrow") {
              parent.activeObj.lineDraw = "horizontal";
              parent.activeObj.activePoint.height = 0;
              if (type === "arrow") {
                parent.activeObj.activePoint.width += 50;
                parent.activeObj.start = this.getArrowType(arrowStart);
                parent.activeObj.end = this.getArrowType(arrowEnd);
              }
            } else if (type === "rectangle") {
              parent.activeObj.activePoint.width += parent.activeObj.activePoint.width / 2;
            }
            this.setDimension(width, height);
            if (start) {
              parent.activeObj.activePoint.startX = start.x;
              parent.activeObj.activePoint.startY = start.y;
              parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
              parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            } else {
              this.setCenterPoints();
            }
            this.setPointCollForLineAndArrow();
            if (type === "arrow") {
              parent.activeObj.triangleDirection = "right";
            }
            parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
            this.initShapeProps();
            var obj = { shapeSettingsObj: {} };
            parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
            var shapeSettings = obj["shapeSettingsObj"];
            var shapeChangingArgs = {
              cancel: false,
              action: "insert",
              previousShapeSettings: shapeSettings,
              currentShapeSettings: shapeSettings
            };
            parent.trigger("shapeChanging", shapeChangingArgs);
            this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
            this.setDimension(width, height);
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
            if (degree) {
              parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
              parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
            }
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
            parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
            parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "shapes",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
            if (parent.isPublicMethod && !isSelected) {
              parent.notify("undo-redo", { prop: "updateUndoRedo", value: { operation: "shapeInsert" }, onPropertyChange: false });
            }
            parent.isPublicMethod = false;
          }
        }
      }
    };
    Shape2.prototype.initShapeProps = function() {
      var parent = this.parent;
      parent.activeObj.shapeDegree = parent.transform.degree;
      parent.activeObj.shapeFlip = parent.transform.currFlipState;
      parent.activeObj.textFlip = parent.transform.currFlipState;
      parent.activeObj.flipObjColl = [];
      parent.activeObj.order = this.getNewOrder();
    };
    Shape2.prototype.setPointCollForLineAndArrow = function() {
      var parent = this.parent;
      var shape = parent.activeObj.shape;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (shape === "line" || shape === "arrow") {
        parent.activeObj.pointColl = this.getLinePoints(startX, startY, endX, endY);
        if (parent.activeObj.pointColl) {
          for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
            parent.activeObj.pointColl[i].ratioX = (parent.activeObj.pointColl[i].x - parent.img.destLeft) / parent.img.destWidth;
            parent.activeObj.pointColl[i].ratioY = (parent.activeObj.pointColl[i].y - parent.img.destTop) / parent.img.destHeight;
          }
        }
      }
    };
    Shape2.prototype.prevObjColl = function() {
      var parent = this.parent;
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      this.prevObj = object["currObj"];
      this.prevObj.objColl = extend([], parent.objColl, [], true);
      this.prevObj.pointColl = extend([], parent.pointColl, [], true);
      this.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      this.prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
    };
    Shape2.prototype.drawShapeText = function(text, fontFamily, fontSize, bold, italic, strokeColor, x, y, isSelected, degree) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.currObjType.shape === "freehanddraw") {
          this.apply();
          parent.upperCanvas.style.cursor = parent.cursor = "default";
          parent.currObjType.shape = "";
        }
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        parent.togglePen = false;
        this.redrawActObj();
        this.prevObjColl();
        this.refreshActiveObj();
        parent.activeObj.shape = parent.currObjType.shape = "text";
        parent.currObjType.isCustomCrop = false;
        this.initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor);
        parent.currObjType.isText = parent.currObjType.isInitialText = true;
        if (isNullOrUndefined(parent.activeObj.textSettings.fontSize)) {
          parent.getFontSizes();
          parent.activeObj.textSettings.fontSize = parseInt(parent.fontSizeColl[parseInt("3", 10) - 1].text, 10);
        }
        if (parent.img.destWidth < 100) {
          parent.activeObj.textSettings.fontSize = Math.floor(parent.img.destWidth / 20);
        } else if (parent.img.destHeight < 100) {
          parent.activeObj.textSettings.fontSize = Math.floor(parent.img.destHeight / 20);
        }
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
        this.updateFontStyles();
        parent.activeObj.order = this.getNewOrder();
        var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
        var height = parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25;
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
          parent.activeObj.activePoint.startX = x;
          parent.activeObj.activePoint.startY = y;
          parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width;
          parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;
        } else {
          this.setCenterPoints(true, width, height);
        }
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeChangingArgs = {
          cancel: false,
          action: "insert",
          previousShapeSettings: shapeSettings,
          currentShapeSettings: shapeSettings
        };
        parent.trigger("shapeChanging", shapeChangingArgs);
        this.drawShapeTextEvent(shapeChangingArgs);
        if (degree) {
          parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
          parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: parent.activeObj,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
        }
        if (text && text.indexOf("\n") > -1 && parent.isPublicMethod) {
          var fontSizeInd = String(parent.fontSizeColl.findIndex(function(item) {
            return item.text === String(parent.activeObj.textSettings.fontSize);
          }) + 1);
          parent.noPushUndo = true;
          parent.updateFontSize("5");
          parent.updateFontSize(fontSizeInd);
          parent.noPushUndo = false;
        }
        if (parent.isPublicMethod && !isSelected) {
          parent.notify("undo-redo", { prop: "updateUndoRedo", value: { operation: "shapeInsert" }, onPropertyChange: false });
        }
        parent.isPublicMethod = false;
      }
    };
    Shape2.prototype.drawShapeImageEvent = function(shapeChangingArgs, isSelect) {
      var parent = this.parent;
      this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      parent.objColl.push(parent.activeObj);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "shapeInsert",
          previousObj: this.prevObj,
          previousObjColl: this.prevObj.objColl,
          previousPointColl: this.prevObj.pointColl,
          previousSelPointColl: this.prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.objColl[parent.objColl.length - 1] }
      });
      if (isSelect) {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "shapes",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
        parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      } else {
        parent.okBtn(null, true);
      }
      parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
    };
    Shape2.prototype.drawShapeTextEvent = function(shapeChangingArgs) {
      var parent = this.parent;
      this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
      this.addLetter(parent.activeObj.textSettings.text);
      parent.activeObj.textFlip = parent.transform.currFlipState;
      this.updateFontRatio(parent.activeObj);
      parent.objColl.push(parent.activeObj);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "shapeInsert",
          previousObj: this.prevObj,
          previousObjColl: this.prevObj.objColl,
          previousPointColl: this.prevObj.pointColl,
          previousSelPointColl: this.prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.objColl[parent.objColl.length - 1] }
      });
      parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "text",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
    };
    Shape2.prototype.initializeTextShape = function(text, fontFamily, fontSize, bold, italic, strokeColor) {
      var parent = this.parent;
      this.keyHistory = "";
      parent.upperCanvas.style.display = "block";
      if (isNullOrUndefined(parent.activeObj.textSettings)) {
        parent.activeObj.textSettings = this.textSettings;
      }
      if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
        parent.activeObj.strokeSettings = this.strokeSettings;
      }
      parent.activeObj.strokeSettings.strokeColor = strokeColor || parent.activeObj.strokeSettings.strokeColor;
      parent.activeObj.textSettings.text = text || parent.activeObj.textSettings.text;
      parent.activeObj.textSettings.fontFamily = fontFamily || parent.activeObj.textSettings.fontFamily;
      parent.activeObj.textSettings.fontSize = fontSize || parent.activeObj.textSettings.fontSize;
      parent.activeObj.textSettings.bold = bold || parent.activeObj.textSettings.bold;
      parent.activeObj.textSettings.italic = italic || parent.activeObj.textSettings.italic;
    };
    Shape2.prototype.drawImage = function(x, y, width, height, src, degree, isAspectRatio, opacity, isSelected) {
      this.initializeShape("image");
      this.onLoadImgShape(x, y, width, height, src, null, degree, isAspectRatio, opacity, isSelected);
    };
    Shape2.prototype.redrawActObj = function(x, y, isMouseDown) {
      var splitWords;
      var parent = this.parent;
      if (parent.activeObj.shape) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] !== "crop")) {
        if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
          parent.notify("selection", { prop: "setTextBoxStylesToActObj", onPropertyChange: false });
          this.updateFontRatio(parent.activeObj, true);
          if (x && y) {
            if (x !== parent.activeObj.activePoint.startX && y !== parent.activeObj.activePoint.startY) {
              this.updateTextFromTextArea();
            }
          } else {
            this.updateTextFromTextArea();
            parent.textArea.style.transform = "";
            parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          }
          this.refreshActiveObj();
        } else {
          this.applyActObj(isMouseDown);
        }
      }
    };
    Shape2.prototype.apply = function(shape, obj, canvas) {
      var parent = this.parent;
      if (!parent.disabled) {
        if (parent.togglePen && !parent.currObjType.isCustomCrop) {
          var destLeft = parent.img.destLeft;
          var destTop = parent.img.destTop;
          var destWidth = parent.img.destWidth;
          var destHeight = parent.img.destHeight;
          parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          parent.togglePen = false;
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
          parent.img.destWidth = destWidth;
          parent.img.destHeight = destHeight;
          this.lowerContext.filter = temp;
        } else {
          canvas = canvas ? canvas : "original";
          if (isNullOrUndefined(parent.activeObj.shape) && isNullOrUndefined(shape)) {
            parent.currObjType.shape = "";
          } else {
            parent.currObjType.shape = shape || parent.currObjType.shape;
          }
          if (parent.currObjType.shape !== "") {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.shape === "text") {
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
                canvas,
                obj,
                isCropRatio: null,
                points: null,
                isPreventDrag: true,
                saveContext: null,
                isPreventSelection: null
              } });
            } else {
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas, obj } });
            }
            parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
            if (!shape && parent.currObjType.shape !== "" && !parent.currObjType.isCustomCrop) {
              parent.objColl.push(extend({}, parent.activeObj, {}, true));
            }
            this.keyHistory = "";
          }
        }
      }
    };
    Shape2.prototype.setCenterPoints = function(text, width, height) {
      var parent = this.parent;
      var renderWidth;
      var renderHeight;
      if (text && width && height) {
        renderWidth = width;
        renderHeight = height;
      } else {
        renderWidth = parent.activeObj.activePoint.width;
        renderHeight = parent.activeObj.activePoint.height;
      }
      parent.activeObj.activePoint.startX = parent.lowerCanvas.width / 2 - renderWidth / 2;
      parent.activeObj.activePoint.startY = parent.lowerCanvas.height / 2 - renderHeight / 2;
      parent.activeObj.activePoint.endX = parent.lowerCanvas.width / 2 + renderWidth / 2;
      parent.activeObj.activePoint.endY = parent.lowerCanvas.height / 2 + renderHeight / 2;
    };
    Shape2.prototype.updSelChangeEventArgs = function(selectionSettings) {
      var parent = this.parent;
      parent.activeObj.activePoint = {
        startX: selectionSettings.startX,
        startY: selectionSettings.startY,
        endX: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width,
        endY: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height,
        width: selectionSettings.width,
        height: selectionSettings.height
      };
      parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
      parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
    };
    Shape2.prototype.updateShapeChangeEventArgs = function(shapeSettings) {
      var parent = this.parent;
      var shapeId;
      if (shapeSettings.id && shapeSettings.id.indexOf("shape_") === -1 && shapeSettings.id.indexOf("pen_") === -1) {
        if (parent.activeObj.currIndex) {
          parent.activeObj.currIndex = "shape_" + shapeSettings.id;
        } else {
          parent.pointColl[shapeId].id = "pen_" + shapeSettings.id;
        }
      }
      if (shapeSettings.id && shapeSettings.id.split("_")[0] && shapeSettings.id.split("_")[0] === "pen") {
        shapeId = parseInt(shapeSettings.id.split("_")[1], 10) - 1;
        parent.pointColl[shapeId].points = shapeSettings.points;
        parent.pointColl[shapeId].strokeColor = shapeSettings.strokeColor;
        parent.pointColl[shapeId].strokeWidth = shapeSettings.strokeWidth;
        parent.pointColl[shapeId].opacity = shapeSettings.opacity;
        parent.pointColl[shapeId].order = shapeSettings.index;
      } else {
        parent.activeObj.activePoint.startX = shapeSettings.startX;
        parent.activeObj.activePoint.startY = shapeSettings.startY;
        if (shapeSettings.width && shapeSettings.height) {
          parent.activeObj.activePoint.width = shapeSettings.width;
          parent.activeObj.activePoint.height = shapeSettings.height;
          parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
          parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
        }
        parent.activeObj.strokeSettings.strokeColor = shapeSettings.strokeColor;
        parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
        parent.activeObj.strokeSettings.strokeWidth = shapeSettings.strokeWidth;
        parent.activeObj.opacity = shapeSettings.opacity;
        parent.activeObj.order = shapeSettings.index;
        if (isNullOrUndefined(shapeSettings.degree)) {
          shapeSettings.degree = 0;
        }
        switch (parent.activeObj.shape) {
          case "ellipse":
            parent.activeObj.activePoint.width = shapeSettings.radiusX * 2;
            parent.activeObj.activePoint.height = shapeSettings.radiusY * 2;
            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            break;
          case "line":
          case "arrow":
            parent.activeObj.activePoint.width = shapeSettings.length;
            parent.activeObj.activePoint.endX = shapeSettings.endX;
            parent.activeObj.activePoint.endY = shapeSettings.endY;
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            if (parent.activeObj.shape === "arrow") {
              parent.activeObj.start = this.getArrowType(shapeSettings.arrowHead);
              parent.activeObj.end = this.getArrowType(shapeSettings.arrowTail);
            }
            break;
          case "text":
            parent.activeObj.keyHistory = parent.activeObj.textSettings.text = shapeSettings.text;
            parent.activeObj.textSettings.fontSize = shapeSettings.fontSize;
            parent.activeObj.strokeSettings.strokeColor = shapeSettings.color;
            parent.activeObj.textSettings.fontFamily = shapeSettings.fontFamily;
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            this.updateFontRatio(parent.activeObj);
            break;
          case "rectangle":
          case "image":
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            break;
          case "path":
            parent.activeObj.pointColl = shapeSettings.points;
            break;
        }
        if (parent.activeObj.shape === "text" && parent.activeObj.textSettings) {
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          parent.activeObj.textSettings.underline = false;
          for (var i = 0; i < shapeSettings.fontStyle.length; i++) {
            switch (shapeSettings.fontStyle[i]) {
              case "bold":
                parent.activeObj.textSettings.bold = true;
                break;
              case "italic":
                parent.activeObj.textSettings.italic = true;
                break;
              case "underline":
                parent.activeObj.textSettings.underline = true;
                break;
            }
          }
        }
      }
    };
    Shape2.prototype.addLetter = function(letter) {
      var parent = this.parent;
      if (parent.textArea.style.display === "none" && (parent.currObjType.isText || parent.activeObj.shape === "text")) {
        var fontSize = parent.activeObj.textSettings.fontSize;
        if (letter === "Backspace") {
          this.keyHistory = this.keyHistory.slice(0, -1);
        } else {
          this.keyHistory += letter;
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.updateFontStyles();
        var width = this.upperContext.measureText(this.keyHistory).width + fontSize * 0.5;
        var height = fontSize + fontSize * 0.25;
        this.upperContext.fillText(this.keyHistory, parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY + fontSize);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.isText = true;
        parent.notify("selection", {
          prop: "setActivePoint",
          onPropertyChange: false,
          value: { startX: width, startY: height }
        });
      }
    };
    Shape2.prototype.redrawText = function() {
      var parent = this.parent;
      var _a = parent.activeObj.textSettings, fontSize = _a.fontSize, fontFamily = _a.fontFamily, bold = _a.bold, italic = _a.italic;
      var fontStyle = "";
      if (bold) {
        fontStyle += "bold ";
      }
      if (italic) {
        fontStyle += "italic ";
      }
      this.upperContext.font = fontStyle + fontSize + "px " + fontFamily;
      var rows = parent.activeObj.keyHistory.split("\n");
      var text = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? this.getMaxText(true) : this.getMaxText();
      var width = this.upperContext.measureText(text).width + fontSize * 0.5;
      var height = rows.length * (fontSize + fontSize * 0.25);
      parent.notify("selection", {
        prop: "setTextSelection",
        onPropertyChange: false,
        value: { width, height }
      });
      parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
        actPoint: parent.activeObj.activePoint,
        obj: parent.activeObj,
        isMouseMove: null,
        x: null,
        y: null
      } });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.activeObj }
      });
    };
    Shape2.prototype.updateTextFromTextArea = function() {
      var parent = this.parent;
      var allowUndoRedo = false;
      var fontSize = parent.activeObj.textSettings.fontSize;
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (parent.activeObj.keyHistory !== parent.textArea.value) {
        allowUndoRedo = true;
      }
      parent.activeObj.keyHistory = parent.textArea.value;
      parent.textArea.style.display = "none";
      parent.textArea.value = "";
      this.updateFontStyles();
      var width = this.upperContext.measureText(parent.activeObj.keyHistory).width + fontSize * 0.5;
      var height = fontSize + fontSize * 0.25;
      var rows = parent.activeObj.keyHistory.split("\n");
      if (rows.length > 1) {
        height *= rows.length;
        var widthColl = [];
        for (var i = 0, len = rows.length; i < len; i++) {
          widthColl.push(this.upperContext.measureText(rows[i]).width + fontSize * 0.5);
        }
        width = Math.max.apply(Math, widthColl);
      }
      parent.notify("selection", {
        prop: "setTextSelection",
        onPropertyChange: false,
        value: { width, height }
      });
      if (parent.activeObj.rotatedAngle !== 0) {
        var width_1 = parent.activeObj.activePoint.width - tempActiveObj.activePoint.width;
        var height_1 = parent.activeObj.activePoint.height - tempActiveObj.activePoint.height;
        var value = "";
        if (width_1 > 0 && height_1 > 0) {
          value = "widthHeight";
        } else if (width_1 !== 0) {
          value = "width";
        } else if (height_1 !== 0) {
          value = "height";
        }
        parent.activeObj.activePoint = extend({}, tempActiveObj.activePoint, {}, true);
        parent.notify("selection", { prop: "adjustRotationPoints", onPropertyChange: false, value: {
          rectangle: parent.activeObj.activePoint,
          x: width_1,
          y: height_1,
          angle: parent.activeObj.rotatedAngle,
          type: "text",
          elem: value
        } });
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      }
      parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
        actPoint: parent.activeObj.activePoint,
        obj: parent.activeObj,
        isMouseMove: null,
        x: null,
        y: null
      } });
      this.updImgRatioForActObj();
      if (parent.activeObj.rotatedAngle !== 0) {
        parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
      }
      if (allowUndoRedo) {
        this.apply(parent.activeObj.shape, parent.activeObj);
        parent.objColl.push(extend({}, parent.activeObj, {}, true));
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "text",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: parent.activeObj.keyHistory,
            currentText: parent.textArea.value,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      } else {
        this.apply(parent.activeObj.shape, parent.activeObj);
        parent.objColl.push(extend({}, parent.activeObj, {}, true));
      }
    };
    Shape2.prototype.iterateObjColl = function() {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        var index = this.getSmallestIndex();
        var objColl = extend([], parent.objColl, [], true);
        while (objColl.length > 0) {
          var found = false;
          for (var i = 0; i < objColl.length; i++) {
            var currentObj = objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
              objColl.splice(i, 1);
              i--;
              continue;
            }
            if (currentObj.order === index) {
              this.apply(currentObj.shape, currentObj);
              this.refreshActiveObj();
              index++;
              if (!this.isIndexInObjColl(index)) {
                index++;
              }
              objColl.splice(i, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
      }
    };
    Shape2.prototype.getSmallestIndex = function() {
      var parent = this.parent;
      var smallestIndex;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currentObj = parent.objColl[i];
        if (isNullOrUndefined(currentObj.order)) {
          continue;
        }
        if (isNullOrUndefined(smallestIndex) || currentObj.order < smallestIndex) {
          smallestIndex = currentObj.order;
        }
      }
      return smallestIndex;
    };
    Shape2.prototype.isIndexInObjColl = function(index) {
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currentObj = parent.objColl[i];
        if (isNullOrUndefined(currentObj.order)) {
          continue;
        }
        if (currentObj.order === index) {
          return true;
        }
      }
      return false;
    };
    Shape2.prototype.updImgRatioForActObj = function() {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.straightenShapes();
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var activePoint = parent.activeObj.activePoint;
      parent.activeObj.imageRatio = {
        startX: (activePoint.startX - destLeft) / destWidth,
        startY: (activePoint.startY - destTop) / destHeight,
        endX: (activePoint.endX - destLeft) / destWidth,
        endY: (activePoint.endY - destTop) / destHeight,
        width: destWidth / activePoint.width,
        height: destHeight / activePoint.height
      };
      if (parent.activeObj.rotationCirclePointColl) {
        parent.activeObj.rotationCirclePointColl.ratioX = (parent.activeObj.rotationCirclePointColl.x - destLeft) / destWidth;
        parent.activeObj.rotationCirclePointColl.ratioY = (parent.activeObj.rotationCirclePointColl.y - destTop) / destHeight;
      }
      if (parent.activeObj.shape === "path") {
        this.updatePathRatio(parent.activeObj);
      } else if (parent.activeObj.shape === "arrow") {
        this.updateArrowRatio(parent.activeObj);
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    Shape2.prototype.zoomObjColl = function(preventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.straightenShapes();
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var currObj = parent.objColl[i];
          if (currObj.imageRatio) {
            currObj.activePoint.startX = currObj.imageRatio.startX * parent.img.destWidth + parent.img.destLeft;
            currObj.activePoint.startY = currObj.imageRatio.startY * parent.img.destHeight + parent.img.destTop;
            currObj.activePoint.endX = currObj.imageRatio.endX * parent.img.destWidth + parent.img.destLeft;
            currObj.activePoint.endY = currObj.imageRatio.endY * parent.img.destHeight + parent.img.destTop;
          }
          currObj = this.updateWidthHeight(currObj);
          if (currObj.shape === "text") {
            this.updateFontSize(currObj);
          } else if (currObj.shape === "line" || currObj.shape === "arrow") {
            currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
            for (var n = 0, len_1 = currObj.pointColl.length; n < len_1; n++) {
              currObj.pointColl[n].ratioX = (currObj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;
              currObj.pointColl[n].ratioY = (currObj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;
            }
            if (currObj.shape === "arrow") {
              this.updateArrowSize(currObj);
            }
            if (parent.transform.straighten !== 0 && (currObj.shape === "line" || currObj.shape === "arrow")) {
              this.straightenShapePoints(currObj);
            }
          } else if (currObj.shape === "path") {
            for (var l = 0, len_2 = currObj.pointColl.length; l < len_2; l++) {
              currObj.pointColl[l].x = currObj.pointColl[l].ratioX * parent.img.destWidth + parent.img.destLeft;
              currObj.pointColl[l].y = currObj.pointColl[l].ratioY * parent.img.destHeight + parent.img.destTop;
            }
            this.updatePathRatio(currObj);
            if (parent.transform.straighten !== 0) {
              this.straightenPath(currObj);
            }
          }
          parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: currObj.activePoint,
            obj: currObj
          } });
          if (currObj.shape !== "line" && currObj.shape !== "arrow" && currObj.shape !== "path" && currObj.rotatedAngle !== 0) {
            this.setPointCollForShapeRotation(currObj);
            currObj.rotationCirclePoint.x = currObj.rotationCirclePoint.ratioX * parent.img.destWidth + parent.img.destLeft;
            currObj.rotationCirclePoint.y = currObj.rotationCirclePoint.ratioY * parent.img.destHeight + parent.img.destTop;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.x = currObj.rotationCirclePointColl.ratioX * parent.img.destWidth + parent.img.destLeft;
              currObj.rotationCirclePointColl.y = currObj.rotationCirclePointColl.ratioY * parent.img.destHeight + parent.img.destTop;
            }
          }
        }
        if (isNullOrUndefined(preventApply)) {
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          this.iterateObjColl();
          this.lowerContext.filter = temp;
        }
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    Shape2.prototype.straightenPath = function(obj) {
      var point;
      for (var j = 0, len = obj.pointColl.length; j < len; j++) {
        point = this.straightenPoints(obj.pointColl[j].x, obj.pointColl[j].y);
        obj.pointColl[j].x = point.x;
        obj.pointColl[j].y = point.y;
      }
    };
    Shape2.prototype.straightenFHD = function() {
      var parent = this.parent;
      for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
        parent.points = extend([], parent.pointColl[i].points, []);
        var len = parent.points.length;
        var point = void 0;
        for (var l = 0; l < len; l++) {
          point = this.straightenPoints(parent.points[l].x, parent.points[l].y);
          parent.points[l].x = point.x;
          parent.points[l].y = point.y;
        }
      }
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
        var len = selPointCollObj["selPointColl"][i].points.length;
        var point = void 0;
        for (var l = 0; l < len; l++) {
          point = this.straightenPoints(selPointCollObj["selPointColl"][i].points[l].x, selPointCollObj["selPointColl"][i].points[l].y);
          selPointCollObj["selPointColl"][i].points[l].x = point.x;
          selPointCollObj["selPointColl"][i].points[l].y = point.y;
        }
      }
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", { prop: "getStraightenPoint", onPropertyChange: false, value: { obj: straightenObj } });
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        var obj = { angle: 0 };
        parent.notify("freehand-draw", { prop: "getStraightenPointAngle", onPropertyChange: false, value: { obj } });
        var angle = ((parent.transform.straighten === 360 ? 0 : parent.transform.straighten) - obj["angle"]) * (Math.PI / 180);
        var point = this.straightenPoints(straightenObj["straightenPoint"]["x"], straightenObj["straightenPoint"]["y"], angle);
        if (angle === 0) {
          point.x = straightenObj["straightenPoint"]["x"];
          point.y = straightenObj["straightenPoint"]["y"];
        }
        parent.notify("freehand-draw", { prop: "setStraightenPoint", onPropertyChange: false, value: { x: point.x, y: point.y } });
      }
    };
    Shape2.prototype.straightenPoints = function(x, y, angle) {
      var parent = this.parent;
      var center = { x: parent.img.destLeft + parent.img.destWidth / 2, y: parent.img.destTop + parent.img.destHeight / 2 };
      angle = angle ? angle : parent.transform.straighten * (Math.PI / 180);
      var point = {
        x: Math.cos(angle) * (x - center.x) - Math.sin(angle) * (y - center.y) + center.x,
        y: Math.sin(angle) * (x - center.x) + Math.cos(angle) * (y - center.y) + center.y
      };
      return point;
    };
    Shape2.prototype.straightenShapes = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var straightenObj = { bool: parent.isStraightening };
      if (!straightenObj["bool"] || parent.transform.straighten === 0) {
        return;
      }
      parent.notify("draw", { prop: "updateImgCanvasPoints" });
      var object = { points: null };
      parent.notify("draw", { prop: "getImageCanvasPoints", value: { obj: object } });
      var center = { x: destLeft + destWidth / 2, y: destTop + destHeight / 2 };
      var angle = -(parent.transform.straighten * (Math.PI / 180));
      var p1 = {
        x: Math.cos(angle) * (object["points"][0]["x"] - center.x) - Math.sin(angle) * (object["points"][0]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][0]["x"] - center.x) + Math.cos(angle) * (object["points"][0]["y"] - center.y) + center.y
      };
      var p2 = {
        x: Math.cos(angle) * (object["points"][1]["x"] - center.x) - Math.sin(angle) * (object["points"][1]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][1]["x"] - center.x) + Math.cos(angle) * (object["points"][1]["y"] - center.y) + center.y
      };
      var p3 = {
        x: Math.cos(angle) * (object["points"][2]["x"] - center.x) - Math.sin(angle) * (object["points"][2]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][2]["x"] - center.x) + Math.cos(angle) * (object["points"][2]["y"] - center.y) + center.y
      };
      parent.img.destWidth = p2.x - p1.x;
      parent.img.destHeight = p3.y - p2.y;
      parent.img.destLeft = p1.x;
      parent.img.destTop = p1.y;
    };
    Shape2.prototype.straightenShapePoints = function(obj, isReverse) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var straightenObj = { bool: parent.isStraightening };
      if (!straightenObj["bool"]) {
        return;
      }
      if (obj.shape === "line" || obj.shape === "arrow") {
        obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX - obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
        obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY - obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
        var center = { x: destLeft + destWidth / 2, y: destTop + destHeight / 2 };
        var angle = (isReverse ? -parent.transform.straighten : parent.transform.straighten) * (Math.PI / 180);
        var start = { x: Math.cos(angle) * (obj.activePoint.startX - center.x) - Math.sin(angle) * (obj.activePoint.startY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.startX - center.x) + Math.cos(angle) * (obj.activePoint.startY - center.y) + center.y };
        var end = { x: Math.cos(angle) * (obj.activePoint.endX - center.x) - Math.sin(angle) * (obj.activePoint.endY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.endX - center.x) + Math.cos(angle) * (obj.activePoint.endY - center.y) + center.y };
        obj.activePoint.startX = start.x;
        obj.activePoint.startY = start.y;
        obj.activePoint.endX = end.x;
        obj.activePoint.endY = end.y;
        obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX - obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
        obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY - obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
        parent.notify("selection", { prop: "adjustActObjForLineArrow", onPropertyChange: false, value: { obj } });
      }
    };
    Shape2.prototype.redrawObj = function(degree) {
      var parent = this.parent;
      var isShape = false;
      if (parent.objColl.length > 0) {
        if (degree === "horizontal" || degree === "vertical" || degree === "Horizontal" || degree === "Vertical" || degree === "horizontalVertical" || degree === "verticalHorizontal") {
          this.updateCurrentActiveObjPoint(degree.toLowerCase());
        } else if (typeof degree === "number") {
          this.updateCurrentActiveObjPoint(degree);
          var tempFilter = this.lowerContext.filter;
          this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var splitWords = parent.objColl[i].shape.split("-");
            if (splitWords[0] !== "crop") {
              this.apply(parent.objColl[i].shape, parent.objColl[i]);
              isShape = true;
            }
          }
          if (isShape) {
            parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
          }
          this.lowerContext.filter = tempFilter;
        }
      }
    };
    Shape2.prototype.updateCurrentActiveObjPoint = function(degree) {
      var parent = this.parent;
      var currActObjIndex;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var index = 0, len = parent.objColl.length; index < len; index++) {
        var currObj = parent.objColl[index];
        if (parent.activeObj.shape === currObj.shape && parent.activeObj.activePoint.startX === currObj.activePoint.startX && parent.activeObj.activePoint.startY === currObj.activePoint.startY && parent.activeObj.activePoint.endX === currObj.activePoint.endX && parent.activeObj.activePoint.endY === currObj.activePoint.endY && parent.activeObj.currIndex === currObj.currIndex) {
          currActObjIndex = index;
          break;
        }
      }
      if (degree === "horizontal" || degree === "vertical" || degree === "Horizontal" || degree === "Vertical" || degree === "horizontalvertical" || degree === "verticalhorizontal") {
        if (degree === "horizontal" || degree === "Horizontal") {
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startX <= destLeft + destWidth / 2) {
                currObj.activePoint.endX = destLeft + destWidth - (currObj.activePoint.startX - destLeft);
                currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startX >= destLeft + destWidth / 2) {
                currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);
                currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, "horizontal");
              } else if (currObj.rotatedAngle !== 0) {
                currObj.rotatedAngle = currObj.rotatedAngle + (Math.PI - currObj.rotatedAngle) * 2;
                if (currObj.rotationCirclePointColl.x <= destLeft + destWidth / 2) {
                  currObj.rotationCirclePointColl.x = destLeft + destWidth - (currObj.rotationCirclePointColl.x - destLeft);
                } else if (currObj.rotationCirclePointColl.x >= destLeft + destWidth / 2) {
                  currObj.rotationCirclePointColl.x = destLeft + (destLeft + destWidth - currObj.rotationCirclePointColl.x);
                }
                currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        } else if (degree === "vertical" || degree === "Vertical") {
          for (var i = 0; i < parent.objColl.length; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startY <= destTop + destHeight / 2) {
                currObj.activePoint.endY = destTop + destHeight - (currObj.activePoint.startY - destTop);
                currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                  actPoint: currObj.activePoint,
                  obj: currObj
                } });
              } else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);
                currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                  actPoint: currObj.activePoint,
                  obj: currObj
                } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, "vertical");
              } else if (currObj.rotatedAngle !== 0) {
                currObj.rotatedAngle = -currObj.rotatedAngle;
                if (currObj.rotationCirclePointColl.y <= destTop + destHeight / 2) {
                  currObj.rotationCirclePointColl.y = destTop + destHeight - (currObj.rotationCirclePointColl.y - destTop);
                } else if (currObj.rotationCirclePointColl.y >= destTop + destHeight / 2) {
                  currObj.rotationCirclePointColl.y = destTop + (destTop + destHeight - currObj.rotationCirclePointColl.y);
                }
                currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        } else if (degree === "verticalhorizontal" || degree === "horizontalvertical") {
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startX <= destLeft + destWidth / 2) {
                currObj.activePoint.endX = destLeft + destWidth - (currObj.activePoint.startX - destLeft);
                currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startX >= destLeft + destWidth / 2) {
                currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);
                currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.activePoint.startY <= destTop + destHeight / 2) {
                currObj.activePoint.endY = destTop + destHeight - (currObj.activePoint.startY - destTop);
                currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);
                currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, degree);
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        }
        if (currActObjIndex !== void 0) {
          parent.activeObj = extend({}, parent.objColl[currActObjIndex], {}, true);
        }
      } else if (degree === 90) {
        this.rotateObjColl();
      } else if (degree === -90) {
        for (var i = 0; i < 3; i++) {
          this.rotateObjColl();
        }
      } else if (typeof degree === "number") {
        if (degree > 0) {
          this.rotateObjColl();
        } else {
          for (var i = 0; i < 3; i++) {
            this.rotateObjColl();
          }
        }
      }
    };
    Shape2.prototype.rotateObjColl = function() {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currObj = parent.objColl[i];
        var shape = currObj.shape;
        currObj.activePoint.startY = destTop + destHeight * currObj.imageRatio.startX;
        currObj.activePoint.endY = destTop + destHeight * currObj.imageRatio.endX;
        currObj.activePoint.startX = destLeft + destWidth - destWidth * currObj.imageRatio.endY;
        currObj.activePoint.endX = destLeft + destWidth - destWidth * currObj.imageRatio.startY;
        currObj = this.updateWidthHeight(parent.objColl[i]);
        this.updateFontSize(currObj);
        if (shape === "line" || shape === "arrow" || shape === "path") {
          this.rotateLineArrowObj(currObj);
          if (shape === "arrow") {
            this.updateArrowSize(currObj);
          }
        } else if (currObj.rotatedAngle !== 0) {
          currObj.rotationCirclePointColl.y = destTop + destHeight * currObj.rotationCirclePointColl.ratioX;
          currObj.rotationCirclePointColl.x = destLeft + destWidth - destWidth * currObj.rotationCirclePointColl.ratioY;
          currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
          currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;
        }
      }
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: parent.objColl[i].activePoint, obj: parent.objColl[i] } });
      }
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currObj = parent.objColl[i];
        currObj.imageRatio = {
          startX: (currObj.activePoint.startX - destLeft) / destWidth,
          startY: (currObj.activePoint.startY - destTop) / destHeight,
          endX: (currObj.activePoint.endX - destLeft) / destWidth,
          endY: (currObj.activePoint.endY - destTop) / destHeight,
          width: destWidth / currObj.activePoint.width,
          height: destHeight / currObj.activePoint.height
        };
      }
    };
    Shape2.prototype.rotateLineArrowObj = function(obj) {
      if (isNullOrUndefined(obj.pointColl)) {
        return;
      }
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.pointColl.length > 0) {
        for (var n = 0; n < obj.pointColl.length; n++) {
          obj.pointColl[n].y = destTop + destHeight * obj.pointColl[n].ratioX;
          obj.pointColl[n].x = destLeft + destWidth - destWidth * obj.pointColl[n].ratioY;
        }
        for (var n = 0; n < obj.pointColl.length; n++) {
          obj.pointColl[n].ratioX = (obj.pointColl[n].x - destLeft) / destWidth;
          obj.pointColl[n].ratioY = (obj.pointColl[n].y - destTop) / destHeight;
        }
        var prevPoint = void 0;
        if (isNullOrUndefined(obj.pointColl[obj.pointColl.length - 2])) {
          prevPoint = { x: 0, y: 0 };
        } else {
          prevPoint = { x: obj.pointColl[obj.pointColl.length - 2].x, y: obj.pointColl[obj.pointColl.length - 2].y };
        }
        var diffX = obj.pointColl[obj.pointColl.length - 1].x - prevPoint.x;
        var diffY = obj.pointColl[obj.pointColl.length - 1].y - prevPoint.y;
        obj.activePoint.startX = obj.pointColl[0].x;
        obj.activePoint.startY = obj.pointColl[0].y;
        obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x + diffX / 2;
        obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y + diffY / 2;
        obj = this.updateWidthHeight(obj);
      }
    };
    Shape2.prototype.flipLineArrowObj = function(obj, value) {
      value = value.toLowerCase();
      if (isNullOrUndefined(obj.pointColl)) {
        return;
      }
      if (value === "horizontal") {
        this.lineArrowHorizontalFlip(obj);
      } else if (value === "vertical") {
        this.lineArrowVerticalFlip(obj);
      } else {
        this.lineArrowHorizontalFlip(obj);
        obj.shapeFlip = "";
        this.lineArrowVerticalFlip(obj);
      }
      obj.activePoint.startX = obj.pointColl[0].x;
      obj.activePoint.startY = obj.pointColl[0].y;
      obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x;
      obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y;
      if (obj.activePoint.startX > obj.activePoint.endX) {
        var temp = obj.activePoint.startX;
        obj.activePoint.startX = obj.activePoint.endX;
        obj.activePoint.endX = temp;
        temp = obj.activePoint.startY;
        obj.activePoint.startY = obj.activePoint.endY;
        obj.activePoint.endY = temp;
      }
    };
    Shape2.prototype.lineArrowHorizontalFlip = function(obj) {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.shapeFlip !== parent.transform.currFlipState) {
        for (var l = 0, len = obj.pointColl.length; l < len; l++) {
          var currPoint = obj.pointColl[l];
          if (currPoint.x <= destLeft + destWidth / 2) {
            currPoint.x = destLeft + destWidth - (currPoint.x - destLeft);
          } else if (currPoint.x >= destLeft + destWidth / 2) {
            currPoint.x = destLeft + (destLeft + destWidth - currPoint.x);
          }
          currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
          currPoint.ratioY = (currPoint.y - destTop) / destHeight;
        }
        if (obj.shape === "arrow") {
          var value = obj.start;
          obj.start = obj.end;
          obj.end = value;
        }
        obj.shapeFlip = parent.transform.currFlipState;
      }
    };
    Shape2.prototype.lineArrowVerticalFlip = function(obj) {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.shapeFlip !== parent.transform.currFlipState) {
        for (var l = 0, len = obj.pointColl.length; l < len; l++) {
          var currPoint = obj.pointColl[l];
          if (currPoint.y <= destTop + destHeight / 2) {
            currPoint.y = destTop + destHeight - (currPoint.y - destTop);
          } else if (currPoint.y >= destTop + destHeight / 2) {
            currPoint.y = destTop + (destTop + destHeight - currPoint.y);
          }
          currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
          currPoint.ratioY = (currPoint.y - destTop) / destHeight;
        }
        obj.shapeFlip = parent.transform.currFlipState;
      }
    };
    Shape2.prototype.getRotDegOfShape = function(obj) {
      var degree;
      if (obj.shapeDegree === 0) {
        degree = this.parent.transform.degree;
      } else {
        degree = this.parent.transform.degree - obj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      return degree;
    };
    Shape2.prototype.renderTextArea = function(x, y, actObj) {
      var parent = this.parent;
      var degree = this.getRotDegOfShape(parent.activeObj);
      this.transformTextArea();
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      var zOrderElem = parent.element.querySelector("#" + parent.element.id + "_zOrderBtn");
      var dupElem = parent.element.querySelector("#" + parent.element.id + "_duplicate");
      var removeElem = parent.element.querySelector("#" + parent.element.id + "_remove");
      var editTextElem = parent.element.querySelector("#" + parent.element.id + "_editText");
      if (zOrderElem) {
        zOrderElem.classList.add("e-disabled");
      }
      if (dupElem) {
        dupElem.classList.add("e-disabled");
      }
      if (removeElem) {
        removeElem.classList.add("e-disabled");
      }
      if (editTextElem) {
        editTextElem.classList.add("e-disabled");
      }
      parent.textArea.style.display = "block";
      parent.textArea.style.left = x + "px";
      parent.textArea.style.top = y + "px";
      parent.textArea.style.fontFamily = actObj.textSettings.fontFamily;
      parent.textArea.style.fontSize = actObj.textSettings.fontSize + "px";
      parent.textArea.style.color = actObj.strokeSettings.strokeColor;
      parent.textArea.style.fontWeight = actObj.textSettings.bold ? "bold" : "normal";
      parent.textArea.style.fontStyle = actObj.textSettings.italic ? "italic" : "normal";
      parent.textArea.style.border = "2px solid " + parent.themeColl[parent.theme]["primaryColor"];
      parent.textArea.value = actObj.keyHistory;
      parent.textArea.style.overflow = "hidden";
      parent.textArea.style.width = "auto";
      parent.textArea.style.height = "auto";
      parent.textArea.focus();
      var zoomFactor = parent.transform.zoomFactor;
      var _a = actObj.activePoint, width = _a.width, height = _a.height;
      if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {
        parent.textArea.style.width = (zoomFactor === 0 ? height : height) + "px";
        parent.textArea.style.height = (zoomFactor === 0 ? width : width) + "px";
      } else {
        parent.textArea.style.width = (zoomFactor === 0 ? width : width) + "px";
        parent.textArea.style.height = (zoomFactor === 0 ? height : height) + "px";
      }
      this.setTextBoxWidth();
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      if (obj["flipColl"].length <= 1) {
        this.setTextBoxHeight();
      }
      if (parseFloat(parent.textArea.style.maxHeight) < parent.activeObj.textSettings.fontSize) {
        parent.textArea.style.maxHeight = parent.activeObj.textSettings.fontSize + "px";
      }
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destTop + parent.img.destHeight) {
          this.alignTextAreaIntoCanvas();
        }
      } else {
        if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destLeft + parent.img.destWidth) {
          this.alignTextAreaIntoCanvas();
        }
      }
      if (actObj.rotatedAngle !== 0) {
        var tempLeft = parseFloat(parent.textArea.style.left);
        var tempTop = parseFloat(parent.textArea.style.top);
        if (actObj.flipObjColl.length > 0) {
          var panObj = { panRegion: "" };
          var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
          var center_1 = { x: 0, y: 0 };
          parent.notify("crop", {
            prop: "getCurrFlipState",
            onPropertyChange: false,
            value: { panObj }
          });
          if (panObj["panRegion"] !== "") {
            if (panObj["panRegion"] === "horizontal") {
              center_1.x = clientWidth - clientWidth / 2;
              tempLeft = center_1.x - tempLeft + center_1.x;
            } else if (panObj["panRegion"] === "vertical") {
              center_1.y = clientHeight - clientHeight / 2;
              tempTop = center_1.y - tempTop + center_1.y;
            } else {
              center_1 = { x: clientWidth - clientWidth / 2, y: clientHeight - clientHeight / 2 };
              tempLeft = center_1.x - tempLeft + center_1.x;
              tempTop = center_1.y - tempTop + center_1.y;
            }
          }
        }
        var left = tempLeft + parseFloat(parent.textArea.style.width);
        var top_1 = tempTop + parseFloat(parent.textArea.style.height);
        var width1 = parseFloat(parent.textArea.style.width);
        var height1 = parseFloat(parent.textArea.style.height);
        var center = { x: left - width1 / 2, y: top_1 - height1 / 2 };
        var cosAngle = Math.cos(actObj.rotatedAngle);
        var sinAngle = Math.sin(actObj.rotatedAngle);
        var p1 = {
          x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
          y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y
        };
        if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth && // eslint-disable-next-line max-len
        p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) {
          parent.textArea.style.width = parent.textArea.style.width;
        } else {
          var count = 0;
          var width2 = parseFloat(parent.textArea.style.width);
          while (true) {
            count++;
            width1 -= 1;
            left = tempLeft + width1;
            center = { x: left - width1 / 2, y: top_1 - height1 / 2 };
            p1 = {
              x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
              y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y
            };
            if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth && // eslint-disable-next-line max-len
            p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight || count === width2) {
              parent.textArea.style.width = width1 + "px";
              break;
            }
          }
        }
      }
      parent.notify("selection", { prop: "clearUpperCanvas", onPropertyChange: false });
    };
    Shape2.prototype.setTextBoxWidth = function(e) {
      var parent = this.parent;
      if (parent.activeObj.rotatedAngle !== 0) {
        parent.textArea.style.whiteSpace = "nowrap";
        parent.textArea.style.textOverflow = "ellipsis";
        parent.textArea.style.display = "inline-block";
        return;
      } else {
        parent.textArea.style.whiteSpace = "";
        parent.textArea.style.textOverflow = "";
        if (parent.textArea.style.display === "inline-block") {
          parent.textArea.style.display = "block";
        }
      }
      var text = this.getMaxText(true);
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        this.updateFontStyles(true);
      } else {
        this.updateFontStyles();
      }
      var textAreaWidth = this.upperContext.measureText(text).width + parseFloat(parent.textArea.style.fontSize) / 2;
      var letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;
      var actObj = extend({}, parent.activeObj, {}, true);
      var flip2 = "";
      var degree = this.getRotDegOfShape(actObj);
      if (actObj.shapeFlip !== parent.transform.currFlipState) {
        flip2 = "";
      } else {
        flip2 = parent.transform.currFlipState;
      }
      if (e && parseFloat(parent.textArea.style.width) < textAreaWidth + letterWidth || isNullOrUndefined(e)) {
        if (degree === 0) {
          if (flip2.toLowerCase() === "horizontal") {
            if (parseFloat(parent.textArea.style.left) - parent.img.destLeft - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else if (parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) > textAreaWidth + letterWidth) {
            parent.textArea.style.width = textAreaWidth + letterWidth + "px";
          }
        } else if (degree === 90) {
          if (flip2.toLowerCase() === "vertical") {
            if (parseFloat(parent.textArea.style.top) - parent.img.destTop - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else if (parent.img.destHeight - (parseFloat(parent.textArea.style.top) - parent.img.destTop) > textAreaWidth + letterWidth) {
            parent.textArea.style.width = textAreaWidth + letterWidth + "px";
          }
        } else if (degree === 180) {
          var textAreaLeft = parseFloat(parent.textArea.style.left);
          var destLeft = parent.img.destLeft;
          if (flip2.toLowerCase() === "horizontal") {
            var remainingWidth = parent.img.destWidth - (textAreaLeft - destLeft);
            if (remainingWidth > textAreaWidth + letterWidth) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else {
            var distanceToLeft = textAreaLeft - destLeft;
            if (distanceToLeft - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          }
        } else if (degree === 270) {
          var textAreaTop = parseFloat(parent.textArea.style.top);
          var destTop = parent.img.destTop;
          if (flip2.toLowerCase() === "vertical") {
            var remainingHeight = parent.img.destHeight - (textAreaTop - destTop);
            if (remainingHeight > textAreaWidth + letterWidth) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else {
            var distanceToTop = textAreaTop - destTop;
            if (distanceToTop - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          }
        }
      }
    };
    Shape2.prototype.setTextBoxHeight = function() {
      var parent = this.parent;
      var textAreaTop;
      var actObj = extend({}, parent.activeObj, {}, true);
      var flip2 = "";
      var degree = this.getRotDegOfShape(actObj);
      if (actObj.textFlip === parent.transform.currFlipState) {
        flip2 = "";
      } else if (actObj.textFlip === "") {
        flip2 = parent.transform.currFlipState;
      } else {
        flip2 = actObj.textFlip;
      }
      switch (degree) {
        case 0:
          if (flip2.toLowerCase() === "vertical") {
            parent.textArea.style.maxHeight = parent.img.destHeight - (parent.img.destHeight - parseFloat(parent.textArea.style.top)) + "px";
          } else {
            textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
            parent.textArea.style.maxHeight = parent.img.destHeight - textAreaTop + "px";
          }
          break;
        case 90:
          if (flip2.toLowerCase() === "horizontal") {
            parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + "px";
          } else {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.left) - parent.img.destLeft + "px";
          }
          break;
        case 180:
          if (flip2.toLowerCase() === "vertical") {
            textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
            parent.textArea.style.maxHeight = parent.img.destHeight - textAreaTop + "px";
          } else {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.top) - parent.img.destTop + "px";
          }
          break;
        case 270:
          if (flip2.toLowerCase() === "horizontal") {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.left) - parent.img.destLeft + "px";
          } else {
            parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + "px";
          }
          break;
      }
    };
    Shape2.prototype.updatePathRatio = function(obj) {
      var parent = this.parent;
      for (var i = 0, len = obj.pointColl.length; i < len; i++) {
        var currPoint = obj.pointColl[i];
        currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
        currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
      }
    };
    Shape2.prototype.stopPathDrawing = function(e, isApply) {
      var parent = this.parent;
      if (parent.activeObj.shape === "path") {
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          var prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "" } });
          parent.currObjType.isDragging = false;
          if (e && e.type !== "touchstart" && isNullOrUndefined(isApply)) {
            parent.activeObj.pointColl.pop();
          }
          this.updatePathRatio(parent.activeObj);
          if (isNullOrUndefined(parent.activeObj.imageRatio)) {
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          }
          parent.objColl.push(parent.activeObj);
          parent.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          parent.objColl.pop();
          if (e) {
            parent.notify("selection", { prop: "mouseUpEventHandler", value: { e } });
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
          }
          parent.notify("draw", { prop: "setNewPath", value: { bool: true } });
          if (parent.objColl[parent.objColl.length - 1]) {
            var shape = parent.drawingShape;
            parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "" } });
            parent.selectShape(parent.objColl[parent.objColl.length - 1].currIndex);
            parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "path" } });
            parent.drawingShape = shape;
          }
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          var obj_1 = { shapeSettingsObj: {} };
          parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: obj_1 } });
          var shapeSettings = obj_1["shapeSettingsObj"];
          var shapeResizingArgs = { cancel: false, action: "draw-end", previousShapeSettings: shapeSettings };
          var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings: shapeSettings };
          parent.notify("selection", {
            prop: "triggerShapeChange",
            onPropertyChange: false,
            value: { shapeResizingArgs, shapeMovingArgs, type: "mouse-up" }
          });
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      }
    };
    Shape2.prototype.findTextTarget = function(e) {
      var parent = this.parent;
      if (parent.activeObj.shape !== "text") {
        if (parent.activeObj.shape === "path") {
          this.stopPathDrawing(e, null);
          return;
        } else if (e.type === "dblclick") {
          var activeObj = extend({}, parent.activeObj, {}, true);
          var objColl = extend([], parent.objColl, [], true);
          var obj = { bool: null };
          parent.notify("selection", {
            prop: "findTargetObj",
            onPropertyChange: false,
            value: { x: e.clientX, y: e.clientY, isCrop: false, obj }
          });
          parent.objColl = objColl;
          if (!obj["bool"] || parent.activeObj.shape !== "text") {
            parent.activeObj = extend({}, activeObj, {}, true);
            return;
          }
        } else {
          return;
        }
      }
      var x;
      var y;
      if (e.type === "dblclick") {
        x = e.clientX;
        y = e.clientY;
      } else if (e.type === "touchstart") {
        x = e.touches[0].clientX;
        y = e.touches[0].clientY;
        parent.notify("selection", {
          prop: "setTouchEndPoint",
          onPropertyChange: false,
          value: { x: e.touches[0].clientX, y: e.touches[0].clientY }
        });
      }
      parent.notify("toolbar", { prop: "setPreventZoomBtn", onPropertyChange: false, value: { isPrevent: true } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "text",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "setPreventZoomBtn", onPropertyChange: false, value: { isPrevent: false } });
      parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        var flip2 = "";
        var degree = this.getRotDegOfShape(parent.activeObj);
        if (parent.activeObj.textFlip === "") {
          if (parent.activeObj.textFlip === parent.transform.currFlipState) {
            flip2 = "";
          } else {
            flip2 = parent.transform.currFlipState;
          }
        } else {
          if (parent.activeObj.textFlip === parent.transform.currFlipState) {
            flip2 = "";
          } else if (parent.transform.currFlipState === "") {
            flip2 = parent.activeObj.textFlip;
          } else {
            flip2 = parent.transform.currFlipState;
          }
        }
        var temp = void 0;
        if (parent.textArea.style.display === "none") {
          temp = extend({}, parent.activeObj, {}, true);
          for (var i = 0; i < parent.objColl.length; i++) {
            if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
              parent.objColl.splice(i, 1);
            }
          }
          this.refreshActiveObj();
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
          parent.notify("draw", { prop: "redrawDownScale" });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
          if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.activeObj = temp;
          this.updateFontStyles();
          var actObj = extend({}, parent.activeObj, {}, true);
          var radius = actObj.topLeftCircle.radius;
          var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
          var center = { x: startX + width / 2, y: startY + height / 2 };
          var cosAngle = Math.cos(actObj.rotatedAngle);
          var sinAngle = Math.sin(actObj.rotatedAngle);
          var p1 = {
            x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p2 = {
            x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p3 = {
            x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
          };
          var p4 = {
            x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
          };
          var obj = {
            position: null,
            x,
            y,
            x1: p1.x,
            y1: p1.y,
            x2: p2.x,
            y2: p2.y,
            x3: p3.x,
            y3: p3.y,
            x4: p4.x,
            y4: p4.y
          };
          parent.notify("draw", { prop: "checkPointPosition", onPropertyChange: false, value: { obj } });
          if (actObj.rotatedAngle !== 0 && (obj["position"] === "inside" || obj["position"] === "on") || actObj.rotatedAngle === 0 && x >= actObj.activePoint.startX - radius * 2 && x <= actObj.activePoint.endX + radius * 2 && y >= actObj.activePoint.startY - radius * 2 && y <= actObj.activePoint.endY + radius * 2) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (actObj.flipObjColl.length === 4) {
              actObj.flipObjColl = [];
              flip2 = "";
              actObj.shapeFlip = "";
            }
            if (flip2 === "" && actObj.flipObjColl.length > 1) {
              flip2 = actObj.flipObjColl[actObj.flipObjColl.length - 1];
            }
            if (actObj.flipObjColl.length <= 1) {
              var points = this.setTextBoxPos(actObj, degree, flip2, x, y);
              x = points.x;
              y = points.y;
            } else {
              var points = this.setTextBoxPoints(actObj, degree, flip2, x, y);
              x = points.x;
              y = points.y;
            }
            if (parent.activeObj.rotatedAngle !== 0) {
              var point = this.getTextBoxPosition(parent.activeObj);
              x = point.x;
              y = point.y;
              point = this.setFlipState(x, y, parent.activeObj);
              x = point.x;
              y = point.y;
            }
            this.renderTextArea(x, y, actObj);
          } else {
            this.applyActObj();
          }
        }
      } else if ((parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") && this.selectedText() !== "" && e.type === "mousedown") {
        var temp = parent.textArea.value;
        parent.textArea.value += "a";
        parent.textArea.value = temp;
      } else if (parent.textArea.style.display === "none") {
        parent.textArea.style.display = "block";
      }
    };
    Shape2.prototype.getTextBoxPosition = function(obj, object) {
      var point = { x: 0, y: 0 };
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var degree = this.getRotDegOfShape(obj);
      if (degree === 0 || degree === 360) {
        point = { x: p1.x, y: p1.y };
      } else if (degree === 90 || degree === -270) {
        point = { x: p2.x, y: p2.y };
      } else if (degree === 180 || degree === -180) {
        point = { x: p4.x, y: p4.y };
      } else if (degree === 270 || degree === -90) {
        point = { x: p3.x, y: p3.y };
      }
      if (object) {
        object["x"] = point.x;
        object["y"] = point.y;
      }
      return point;
    };
    Shape2.prototype.setFlipState = function(x, y, obj, object) {
      var parent = this.parent;
      var panObj = { panRegion: "" };
      var _a = parent.lowerCanvas, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
      var center = { x: 0, y: 0 };
      parent.notify("crop", {
        prop: "getCurrFlipState",
        onPropertyChange: false,
        value: { panObj }
      });
      if (panObj["panRegion"] !== "") {
        if (panObj["panRegion"] === "horizontal") {
          center.x = clientWidth - clientWidth / 2;
          x = center.x - x + center.x;
        } else if (panObj["panRegion"] === "vertical") {
          center.y = clientHeight - clientHeight / 2;
          y = center.y - y + center.y;
        } else {
          center = { x: clientWidth - clientWidth / 2, y: clientHeight - clientHeight / 2 };
          x = center.x - x + center.x;
          y = center.y - y + center.y;
        }
      }
      if (object) {
        object["x"] = x;
        object["y"] = y;
      }
      return { x, y };
    };
    Shape2.prototype.fileChanged = function(e) {
      var filesData = e.target.files[0];
      var fileData = filesData;
      var fileExtension = fileData.name && fileData.name.split(".")[1].toLowerCase();
      if (fileExtension && ["jpg", "jpeg", "png", "svg"].indexOf(fileExtension) === -1) {
        this.refreshActiveObj();
        return;
      }
      var URL2 = window.URL;
      var url = URL2.createObjectURL(e.target.files[0]);
      this.onLoadImgShape(null, null, null, null, url.toString(), true);
      document.getElementById(this.parent.element.id + "_fileUpload").value = "";
    };
    Shape2.prototype.onLoadImgShape = function(x, y, width, height, url, isSelect, degree, isAspectRatio, opacity, isSelected) {
      var proxy = this;
      var parent = this.parent;
      if (typeof url === "string") {
        this.shapeImg.src = url;
      } else {
        parent.inMemoryCanvas.width = url.width;
        parent.inMemoryCanvas.height = url.height;
        parent.inMemoryCanvas.getContext("2d").putImageData(url, 0, 0);
        this.shapeImg.src = parent.inMemoryCanvas.toDataURL();
      }
      this.prevObjColl();
      parent.activeObj.shape = "image";
      this.initShapeProps();
      this.shapeImg.onload = function() {
        proxy.upperContext.drawImage(proxy.shapeImg, 0, 0, proxy.shapeImg.width, proxy.shapeImg.height);
        proxy.updateImgCanvas(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected);
      };
    };
    Shape2.prototype.updateImgCanvas = function(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected) {
      var parent = this.parent;
      parent.activeObj.imageElement = this.shapeImg;
      parent.activeObj.imageCanvas = parent.createElement("canvas");
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: null }
      });
      if (width && height) {
        if (isAspectRatio) {
          var obj_2 = { ratio: null };
          parent.notify("selection", {
            prop: "findImageRatio",
            onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_2 }
          });
          dimObj = this.resizeImage(width, obj_2["ratio"]);
        } else {
          dimObj = { width, height };
        }
      }
      this.updateObj(dimObj, x, y);
      parent.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: parent.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: null }
      });
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: true }
      });
      if (width && height) {
        if (isAspectRatio) {
          var obj_3 = { ratio: null };
          parent.notify("selection", {
            prop: "findImageRatio",
            onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_3 }
          });
          dimObj = this.resizeImage(width, obj_3["ratio"]);
        } else {
          dimObj = { width, height };
        }
      }
      if (opacity !== null && opacity !== void 0) {
        parent.activeObj.opacity = opacity;
      }
      this.updateObj(dimObj, x, y);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.shapeImg = null;
      if (degree) {
        parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
        parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
      }
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      var shapeChangingArgs = {
        cancel: false,
        action: "insert",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      parent.trigger("shapeChanging", shapeChangingArgs);
      isSelect = isSelect ? isSelect : isSelected;
      this.drawShapeImageEvent(shapeChangingArgs, isSelect);
      if (parent.isPublicMethod && !isSelected) {
        parent.notify("undo-redo", { prop: "updateUndoRedo", onPropertyChange: false });
      } else if (!parent.isPublicMethod) {
        parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
      }
      parent.isPublicMethod = false;
    };
    Shape2.prototype.updateObj = function(dimObj, x, y) {
      var parent = this.parent;
      parent.activeObj.activePoint.width = dimObj["width"];
      parent.activeObj.activePoint.height = dimObj["height"];
      parent.activeObj.activePoint.startX = x ? x : parent.lowerCanvas.width / 2 - dimObj["width"] / 2;
      parent.activeObj.activePoint.startY = y ? y : parent.lowerCanvas.height / 2 - dimObj["height"] / 2;
      parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + dimObj["width"];
      parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + dimObj["height"];
    };
    Shape2.prototype.resizeImage = function(newWidth, aspectRatio) {
      var aspectRatioArray = aspectRatio.split(":");
      var aspectRatioWidth = parseInt(aspectRatioArray[0], 10);
      var aspectRatioHeight = parseInt(aspectRatioArray[1], 10);
      var newHeight = Math.round(newWidth * aspectRatioHeight / aspectRatioWidth);
      return { width: newWidth, height: newHeight };
    };
    Shape2.prototype.setTextBoxPos = function(actObj, degree, flip2, x, y) {
      var point = { x, y };
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      flip2 = flip2.toLowerCase();
      switch (degree) {
        case 0:
          if (flip2 === "horizontal") {
            point.x = endX;
            point.y = startY;
          } else if (flip2 === "vertical") {
            point.x = startX;
            point.y = endY;
          } else {
            point.x = startX;
            point.y = startY;
          }
          break;
        case 90:
          if (flip2 === "horizontal") {
            point.x = startX;
            point.y = startY;
          } else if (flip2 === "vertical") {
            point.x = endX;
            point.y = endY;
          } else {
            point.x = endX;
            point.y = startY;
          }
          break;
        case 180:
          if (flip2 === "horizontal") {
            point.x = startX;
            point.y = endY;
          } else if (flip2 === "vertical") {
            point.x = endX;
            point.y = startY;
          } else {
            point.x = endX;
            point.y = endY;
          }
          break;
        case 270:
          if (flip2 === "horizontal") {
            point.x = endX;
            point.y = endY;
          } else if (flip2 === "vertical") {
            point.x = startX;
            point.y = startY;
          } else {
            point.x = startX;
            point.y = endY;
          }
          break;
      }
      return point;
    };
    Shape2.prototype.setTextBoxPoints = function(actObj, degree, flip2, x, y) {
      var point = { x, y };
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      flip2 = flip2.toLowerCase();
      switch (degree) {
        case 0:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = endY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = startY;
            }
          }
          break;
        case 90:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = endY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = startY;
            }
          }
          break;
        case 180:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = startY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = endY;
            }
          }
          break;
        case 270:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = startY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = endY;
            }
          }
          break;
      }
      return point;
    };
    Shape2.prototype.selectedText = function() {
      var parent = this.parent;
      var start = parent.textArea.selectionStart;
      var finish = parent.textArea.selectionEnd;
      return parent.textArea.value.substring(start, finish);
    };
    Shape2.prototype.panObjColl = function(xDiff, yDiff, panRegion) {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var currObj = parent.objColl[i];
          if (panRegion === "") {
            currObj.activePoint.startX += xDiff;
            currObj.activePoint.endX += xDiff;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.x += xDiff;
            }
            if (currObj.shape === "path") {
              for (var l = 0, len_3 = currObj.pointColl.length; l < len_3; l++) {
                currObj.pointColl[l].x += xDiff;
              }
            }
            currObj.activePoint.startY += yDiff;
            currObj.activePoint.endY += yDiff;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.y += yDiff;
            }
            if (currObj.shape === "path") {
              for (var l = 0; l < currObj.pointColl.length; l++) {
                currObj.pointColl[l].y += yDiff;
              }
            }
          }
          currObj = this.updateWidthHeight(currObj);
          parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: currObj.activePoint,
            obj: currObj
          } });
          if (currObj.shape === "line" || currObj.shape === "arrow") {
            currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
            for (var j = 0, len_4 = currObj.pointColl.length; j < len_4; j++) {
              currObj.pointColl[j].ratioX = (currObj.pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;
              currObj.pointColl[j].ratioY = (currObj.pointColl[j].y - parent.img.destTop) / parent.img.destHeight;
            }
          }
          this.refreshActiveObj();
        }
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        this.iterateObjColl();
        this.lowerContext.filter = temp;
        this.refreshActiveObj();
        parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
      }
    };
    Shape2.prototype.updateFontStyles = function(isTextBox) {
      var parent = this.parent;
      this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
      this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
      var textStyle = "";
      if (parent.activeObj.textSettings.bold) {
        textStyle = "bold ";
      }
      if (parent.activeObj.textSettings.italic) {
        textStyle = "italic ";
      }
      if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
        textStyle = "italic bold ";
      }
      var fontSize = isTextBox ? parseFloat(parent.textArea.style.fontSize) : parent.activeObj.textSettings.fontSize;
      var fontFamily = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? parent.textArea.style.fontFamily : parent.activeObj.textSettings.fontFamily;
      this.upperContext.font = textStyle + fontSize + "px " + fontFamily;
    };
    Shape2.prototype.applyFontStyle = function(item) {
      var parent = this.parent;
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      this.pushActItemIntoObj();
      var objColl = extend([], parent.objColl, [], true);
      parent.objColl.pop();
      if (parent.textArea.style.display === "none") {
        this.updateFontRatio(parent.activeObj);
      } else {
        this.updateFontRatio(parent.activeObj, true);
      }
      switch (item) {
        case "default":
          this.updateFontStyle(item, objColl, "normal", "normal");
          break;
        case "bold":
          this.updateFontStyle(item, objColl, "bold", "normal");
          break;
        case "italic":
          this.updateFontStyle(item, objColl, "normal", "italic");
          break;
        case "bolditalic":
          this.updateFontStyle(item, objColl, "bold", "italic");
          break;
      }
      var shapeChangedArgs = { action: "font-style", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontStyle = [item];
      parent.trigger("shapeChange", shapeChangedArgs);
    };
    Shape2.prototype.updateFontStyle = function(item, objColl, fontWeight, fontStyle) {
      var parent = this.parent;
      var style = parent.textArea.style;
      if (style.display === "block" || style.display === "inline-block") {
        if (style.fontWeight === "normal" && fontWeight === "bold") {
          style.fontWeight = "bold";
        } else if (style.fontWeight === "bold" && fontWeight === "bold") {
          style.fontWeight = "normal";
        }
        if (style.fontStyle === "normal" && fontStyle === "italic") {
          style.fontStyle = "italic";
        } else if (style.fontStyle === "italic" && fontStyle === "italic") {
          style.fontStyle = "normal";
        }
        var value = style.fontWeight === "normal" && style.fontStyle === "normal" ? "default" : style.fontWeight === "bold" && style.fontStyle === "normal" ? "bold" : style.fontWeight === "normal" && style.fontStyle === "italic" ? "italic" : "bolditalic";
        var width = this.getTextAreaWidth(value);
        style.width = width + "px";
        this.updateObjColl(item, objColl);
      } else {
        this.textSettings.bold = parent.activeObj.textSettings.bold = fontWeight === "normal" ? false : true;
        this.textSettings.italic = parent.activeObj.textSettings.italic = fontStyle === "normal" ? false : true;
        if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
          this.redrawText();
        }
        parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      }
    };
    Shape2.prototype.updateArrowRatio = function(obj) {
      var parent = this.parent;
      var object = { arrowDimension: null };
      parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: object } });
      var length;
      if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
        length = Math.abs(obj.activePoint.width);
      } else {
        length = Math.abs(obj.activePoint.height);
      }
      var dimension;
      var dimensions = ["bar", "arrow", "arrowSolid", "circle", "square"];
      for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {
        dimension = dimensions_1[_i];
        var ratioX = length / object["arrowDimension"][dimension]["width"];
        var ratioY = length / object["arrowDimension"][dimension]["height"];
        object["arrowDimension"][dimension]["ratioX"] = ratioX;
        object["arrowDimension"][dimension]["ratioY"] = ratioY;
      }
    };
    Shape2.prototype.updateArrowSize = function(obj) {
      var object = { arrowDimension: null };
      this.parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: object } });
      var length;
      if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
        length = Math.abs(obj.activePoint.width);
      } else {
        length = Math.abs(obj.activePoint.height);
      }
      var dimension;
      var dimensions = ["bar", "arrow", "arrowSolid", "circle", "square"];
      for (var _i = 0, dimensions_2 = dimensions; _i < dimensions_2.length; _i++) {
        dimension = dimensions_2[_i];
        var ratioX = object["arrowDimension"][dimension]["ratioX"];
        var ratioY = object["arrowDimension"][dimension]["ratioY"];
        object["arrowDimension"][dimension]["width"] = length / ratioX;
        object["arrowDimension"][dimension]["height"] = length / ratioY;
      }
    };
    Shape2.prototype.updateFontRatio = function(obj, isTextArea) {
      var parent = this.parent;
      var text = this.getMaxText(isTextArea);
      var width = this.upperContext.measureText(text).width + parent.activeObj.textSettings.fontSize * 0.5;
      var height = parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25;
      var degree = this.getRotDegOfShape(obj);
      if (isNullOrUndefined(isTextArea)) {
        if (degree === 0 || Math.abs(degree) === 180) {
          obj.textSettings.fontRatio = width / obj.textSettings.fontSize;
        } else {
          obj.textSettings.fontRatio = height / obj.textSettings.fontSize;
        }
      } else if (isTextArea) {
        obj.textSettings.fontRatio = width / parseFloat(parent.textArea.style.fontSize);
      }
    };
    Shape2.prototype.updateFontSize = function(obj) {
      var degree = this.getRotDegOfShape(obj);
      if (degree === 0 || Math.abs(degree) === 180) {
        obj.textSettings.fontSize = obj.activePoint.width / obj.textSettings.fontRatio;
      } else {
        obj.textSettings.fontSize = obj.activePoint.height / obj.textSettings.fontRatio;
      }
    };
    Shape2.prototype.updateObjColl = function(item, objColl) {
      var parent = this.parent;
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = objColl;
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var tempBold = parent.activeObj.textSettings.bold;
      var tempItalic = parent.activeObj.textSettings.italic;
      switch (item) {
        case "default":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          break;
        case "bold":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = false;
          break;
        case "italic":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = true;
          break;
        case "bolditalic":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = true;
          break;
      }
      parent.objColl.push(parent.activeObj);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "textAreaCustomization",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.objColl.pop();
      parent.activeObj.textSettings.bold = tempBold;
      parent.activeObj.textSettings.italic = tempItalic;
    };
    Shape2.prototype.pushActItemIntoObj = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "none") {
        if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
          parent.objColl.push(parent.activeObj);
        }
      } else {
        var temp = extend({}, parent.activeObj, {}, true);
        parent.notify("selection", { prop: "setTextBoxStylesToActObj", onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
        parent.activeObj = temp;
      }
    };
    Shape2.prototype.clearActObj = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "none") {
        this.refreshActiveObj();
        this.applyActObj();
        this.refreshActiveObj();
        parent.currObjType.isCustomCrop = false;
      }
    };
    Shape2.prototype.refreshActiveObj = function() {
      var parent = this.parent;
      parent.activeObj = {};
      parent.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      parent.activeObj.triangle = [];
      parent.activeObj.triangleRatio = [];
      parent.activeObj.order = null;
      parent.activeObj.flipObjColl = [];
      parent.activeObj.strokeSettings = this.strokeSettings;
      parent.activeObj.textSettings = this.textSettings;
      parent.activeObj.rotatedAngle = 0;
      parent.activeObj.opacity = 1;
    };
    Shape2.prototype.applyActObj = function(isMouseDown) {
      var parent = this.parent;
      var isActObj = false;
      if (parent.activeObj.shape !== void 0 && parent.activeObj.shape === "text" && parent.activeObj.keyHistory === "") {
        this.refreshActiveObj();
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else {
        var splitWords = void 0;
        var isCropSelection = false;
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
          isCropSelection = true;
        } else if (splitWords !== void 0 && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (parent.activeObj.shape && !isCropSelection && parent.activeObj.shape !== "shape") {
          for (var i = 0; i < parent.objColl.length; i++) {
            if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
              isActObj = true;
              break;
            }
          }
          if (!isActObj) {
            if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.activeObj.currIndex = this.getNewShapeId();
            }
            if (isNullOrUndefined(parent.activeObj.order)) {
              parent.activeObj.order = this.getNewOrder();
            }
            this.updImgRatioForActObj();
            var splitWords_1 = parent.activeObj.currIndex.split("_");
            var tempObjColl = parent.objColl.splice(0, parseInt(splitWords_1[1], 10) - 1);
            tempObjColl.push(extend({}, parent.activeObj, {}, true));
            for (var i = 0; i < parent.objColl.length; i++) {
              tempObjColl.push(parent.objColl[i]);
            }
            parent.objColl = tempObjColl;
            tempObjColl = [];
            this.refreshActiveObj();
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
            parent.currObjType.shape = "";
            this.refreshActiveObj();
            if (parent.isCircleCrop) {
              parent.notify("crop", {
                prop: "cropCircle",
                onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null }
              });
            }
            parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            if (isNullOrUndefined(isMouseDown)) {
              parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
              parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
            }
          }
        }
      }
    };
    Shape2.prototype.getNewShapeId = function() {
      var parent = this.parent;
      var value = parent.objColl.length + 1;
      for (var i = 0; i < parent.objColl.length; i++) {
        if (parent.objColl[i].currIndex === "shape_" + value) {
          value++;
          i = -1;
        }
      }
      return "shape_" + value;
    };
    Shape2.prototype.getNewOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = parent.shapeColl.length + 1;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order === value) {
          value++;
          i = -1;
        }
      }
      return value;
    };
    Shape2.prototype.getHighestOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = 0;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order > value) {
          value = parent.shapeColl[i].order;
        }
      }
      return value;
    };
    Shape2.prototype.getLowestOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = 1;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order < value) {
          value = parent.shapeColl[i].order;
        }
      }
      return value;
    };
    Shape2.prototype.alignTextAreaIntoCanvas = function() {
      var parent = this.parent;
      var letters = parent.textArea.value;
      parent.textArea.value = "";
      for (var i = 0, len = letters.length; i < len; i++) {
        parent.textArea.value += letters[i];
        parent.textArea.style.height = "auto";
        parent.textArea.style.height = parent.textArea.scrollHeight + "px";
        this.setTextBoxWidth();
      }
    };
    Shape2.prototype.transformTextArea = function() {
      var parent = this.parent;
      if (parent.activeObj.shape === "text") {
        parent.textArea.style.transformOrigin = "0 0";
        var rotatedDegree = parent.activeObj.rotatedAngle * (180 / Math.PI);
        var scale = "";
        var degree = this.getRotDegOfShape(parent.activeObj);
        if (parent.activeObj.flipObjColl.length > 0) {
          for (var i = 0; i < parent.activeObj.flipObjColl.length; i++) {
            if (degree !== 0 && degree % 90 === 0 && degree !== 180) {
              scale += parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal" ? "scale(1, -1)" : "scale(-1, 1)";
            } else {
              scale += parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal" ? "scale(-1, 1)" : "scale(1, -1)";
            }
            degree += rotatedDegree;
            if (parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal") {
              parent.textArea.style.transform = "rotate(" + degree + "deg)" + scale;
            } else if (parent.activeObj.flipObjColl[i].toLowerCase() === "vertical") {
              parent.textArea.style.transform = "rotate(" + degree + "deg)" + scale;
            }
          }
        } else {
          degree += rotatedDegree;
          parent.textArea.style.transform = "rotate(" + degree + "deg)";
        }
      }
    };
    Shape2.prototype.getTextAreaWidth = function(item) {
      var parent = this.parent;
      var tempBold = parent.activeObj.textSettings.bold;
      var tempItalic = parent.activeObj.textSettings.italic;
      switch (item) {
        case "default":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          break;
        case "bold":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = false;
          break;
        case "italic":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = true;
          break;
        case "bolditalic":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = true;
          break;
      }
      var isTextArea = parent.textArea.style.display === "none" ? false : true;
      this.updateFontStyles(isTextArea);
      var width;
      if (!isTextArea) {
        width = this.upperContext.measureText(parent.activeObj.keyHistory).width + parent.activeObj.textSettings.fontSize * 0.5;
      } else {
        width = this.upperContext.measureText(parent.textArea.value).width + parent.activeObj.textSettings.fontSize * 0.5;
      }
      parent.activeObj.textSettings.bold = tempBold;
      parent.activeObj.textSettings.italic = tempItalic;
      return width;
    };
    Shape2.prototype.getObjDetails = function(obj) {
      var parent = this.parent;
      var shapeDetails = {};
      shapeDetails.id = obj.currIndex;
      shapeDetails.type = parent.toPascalCase(obj.shape);
      shapeDetails.startX = obj.activePoint.startX;
      shapeDetails.startY = obj.activePoint.startY;
      shapeDetails.index = obj.order;
      switch (obj.shape) {
        case "rectangle":
          shapeDetails.width = obj.activePoint.width;
          shapeDetails.height = obj.activePoint.height;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.fillColor = obj.strokeSettings.fillColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          break;
        case "ellipse":
          shapeDetails.radius = obj.activePoint.width / 2;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.fillColor = obj.strokeSettings.fillColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.radiusX = obj.activePoint.width / 2;
          shapeDetails.radiusY = obj.activePoint.height / 2;
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          break;
        case "line":
        case "arrow":
          shapeDetails.length = obj.activePoint.width;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.endX = obj.activePoint.endX;
          shapeDetails.endY = obj.activePoint.endY;
          if (obj.shape === "arrow") {
            var arrowObj = { type: null };
            parent.notify("selection", { prop: "getArrowType", onPropertyChange: false, value: { type: obj.start, obj: arrowObj } });
            shapeDetails.arrowHead = arrowObj["type"];
            parent.notify("selection", { prop: "getArrowType", onPropertyChange: false, value: { type: obj.end, obj: arrowObj } });
            shapeDetails.arrowTail = arrowObj["type"];
          }
          break;
        case "text":
          shapeDetails.text = obj.keyHistory;
          shapeDetails.fontSize = obj.textSettings.fontSize;
          shapeDetails.fontFamily = obj.textSettings.fontFamily;
          shapeDetails.color = obj.strokeSettings.strokeColor;
          shapeDetails.fontStyle = [];
          if (obj.textSettings.bold) {
            shapeDetails.fontStyle.push("bold");
          }
          if (obj.textSettings.italic) {
            shapeDetails.fontStyle.push("italic");
          }
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          break;
        case "path":
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.points = obj.pointColl;
          break;
        case "image":
          shapeDetails.imageData = obj.imageCanvas.toDataURL();
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          shapeDetails.width = obj.activePoint.width;
          shapeDetails.height = obj.activePoint.height;
          shapeDetails.opacity = obj.opacity;
          break;
      }
      return shapeDetails;
    };
    Shape2.prototype.getFreehandDrawDetails = function(index) {
      var parent = this.parent;
      var shapeDetails = {};
      shapeDetails.id = parent.pointColl[index].id;
      shapeDetails.type = ShapeType.FreehandDraw;
      shapeDetails.points = extend([], parent.pointColl[index].points);
      shapeDetails.strokeColor = parent.pointColl[index].strokeColor;
      shapeDetails.strokeWidth = parent.pointColl[index].strokeWidth;
      shapeDetails.index = parent.pointColl[index].order;
      return shapeDetails;
    };
    Shape2.prototype.getShapeSetting = function(id, obj) {
      var parent = this.parent;
      var shapeDetails;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.textArea.style.display !== "none") {
          parent.okBtn(null, true);
        } else {
          this.applyActObj(true);
        }
        if (id.split("_")[0] === "shape") {
          var obj_4;
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === id) {
              obj_4 = extend({}, parent.objColl[i], {}, true);
              break;
            }
          }
          shapeDetails = this.getObjDetails(obj_4);
        } else if (id.split("_")[0] === "pen") {
          shapeDetails = this.getFreehandDrawDetails(parseInt(id.split("_")[1], 10) - 1);
        }
      }
      obj["shapeDetails"] = shapeDetails;
    };
    Shape2.prototype.getShapeSettings = function(obj) {
      var parent = this.parent;
      var shapeDetailsColl = [];
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.textArea.style.display !== "none") {
          parent.okBtn(null, true);
        } else {
          this.applyActObj(true);
        }
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var shapeDetails = this.getObjDetails(parent.objColl[i]);
          shapeDetailsColl.push(shapeDetails);
        }
        for (var i = 0; i < parent.freehandCounter; i++) {
          var shapeDetails = this.getFreehandDrawDetails(i);
          shapeDetailsColl.push(shapeDetails);
        }
      }
      obj["shapeDetailsColl"] = shapeDetailsColl;
    };
    Shape2.prototype.isPointsInRange = function(x, y, obj) {
      var inRange = false;
      var parent = this.parent;
      if (!isNullOrUndefined(x) && !isNullOrUndefined(y) && x >= parent.img.destLeft && y >= parent.img.destTop && x <= parent.img.destLeft + parent.img.destWidth && y <= parent.img.destTop + parent.img.destHeight) {
        inRange = true;
      }
      obj["inRange"] = inRange;
    };
    Shape2.prototype.alignRotateFlipColl = function(collection, isRotateFlipCollection, obj) {
      collection = this.popForDefaultTransformedState(collection);
      collection = this.popForDefaultFlipState(collection);
      collection = this.popForDefaultRotateState(collection);
      if (collection.length === 0 && isRotateFlipCollection) {
        this.parent.transform.degree = 0;
        this.parent.transform.currFlipState = "";
      }
      obj["collection"] = collection;
      return collection;
    };
    Shape2.prototype.popForDefaultTransformedState = function(collection) {
      var rotateRight = 0;
      var rotateleft = 0;
      var horizontal = 0;
      var vertical = 0;
      for (var i = 0; i < collection.length; i++) {
        if (collection[i] === 90 || collection[i] === "rotateRight") {
          rotateRight++;
          rotateleft = 0;
          horizontal = 0;
          vertical = 0;
          if (rotateRight === 4) {
            collection.pop();
            collection.pop();
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === -90 || collection[i] === "rotateLeft") {
          rotateleft++;
          rotateRight = 0;
          horizontal = 0;
          vertical = 0;
          if (rotateleft === 4) {
            collection.pop();
            collection.pop();
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === "horizontal" || collection[i] === "Horizontal" || collection[i] === "horizontalflip") {
          horizontal++;
          rotateleft = 0;
          rotateRight = 0;
          vertical = 0;
          if (horizontal === 2) {
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === "vertical" || collection[i] === "Vertical" || collection[i] === "verticalflip") {
          vertical++;
          horizontal = 0;
          rotateleft = 0;
          rotateRight = 0;
          if (vertical === 2) {
            collection.pop();
            collection.pop();
          }
        }
      }
      return collection;
    };
    Shape2.prototype.popForDefaultFlipState = function(collection) {
      for (var i = 0, iLen = collection.length - 3; i < iLen; i++) {
        var isHorizontal = collection[i] === "horizontal" || collection[i] === "Horizontal" || collection[i] === "horizontalFlip";
        var isVertical = collection[i] === "vertical" || collection[i] === "Vertical" || collection[i] === "verticalFlip";
        var isNextHorizontal = collection[i + 1] === "horizontal" || collection[i + 1] === "Horizontal" || collection[i + 1] === "horizontalFlip";
        var isNextVertical = collection[i + 1] === "vertical" || collection[i + 1] === "Vertical" || collection[i + 1] === "verticalFlip";
        var isNextToNextHorizontal = collection[i + 2] === "horizontal" || collection[i + 2] === "Horizontal" || collection[i + 2] === "horizontalFlip";
        var isNextToNextVertical = collection[i + 2] === "vertical" || collection[i + 2] === "Vertical" || collection[i + 2] === "verticalFlip";
        var isNextToNextToNextHorizontal = collection[i + 3] === "horizontal" || collection[i + 3] === "Horizontal" || collection[i + 3] === "horizontalFlip";
        if (isHorizontal && isNextVertical && isNextToNextHorizontal && isNextToNextVertical || isVertical && isNextHorizontal && isNextToNextVertical && isNextToNextToNextHorizontal) {
          collection.splice(i, 4);
          i -= 4;
        }
      }
      return collection;
    };
    Shape2.prototype.popForDefaultRotateState = function(collection) {
      for (var i = 0; i < collection.length - 1; i++) {
        var curr = collection[i];
        var next = collection[i + 1];
        if ((curr === 90 || curr === "rotateRight") && (next === -90 || next === "rotateLeft")) {
          collection.splice(i, 2);
          i -= 2;
        } else if ((curr === -90 || curr === "rotateLeft") && (next === 90 || next === "rotateRight")) {
          collection.splice(i, 2);
          i -= 2;
        }
      }
      return collection;
    };
    Shape2.prototype.selectShape = function(id, obj) {
      var parent = this.parent;
      var isSelected = false;
      if (!parent.disabled && parent.isImageLoaded) {
        this.applyActObj();
        if (id.split("_")[0] === "shape") {
          var obj_5;
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === id) {
              obj_5 = extend({}, parent.objColl[i], {}, true);
              break;
            }
          }
          if (isNullOrUndefined(obj_5)) {
            isSelected = false;
          } else {
            isSelected = true;
            parent.activeObj = obj_5;
            var object = { canvasFilter: null };
            parent.notify("toolbar", { prop: "getCanvasFilter", onPropertyChange: false, value: { obj: object } });
            this.lowerContext.filter = object["canvasFilter"];
            parent.notify("selection", {
              prop: "redrawShape",
              onPropertyChange: false,
              value: { obj: parent.activeObj }
            });
            if (parent.activeObj.shape === "text") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "text",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (parent.activeObj.shape === "pen") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "pen",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          }
        } else if (id.split("_")[0] === "pen") {
          var object = { bool: false };
          parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: object } });
          if (object["bool"]) {
            parent.okBtn(null, true);
          }
          var obj_6 = { isIndex: false };
          parent.notify("freehand-draw", { prop: "isFHDIdx", value: { index: parseInt(id.split("_")[1], 10) - 1, obj: obj_6 } });
          if (obj_6["isIndex"]) {
            isSelected = true;
            parent.notify("freehand-draw", { prop: "selectFhd", value: { id } });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
          } else {
            isSelected = false;
          }
        }
      }
      obj["isSelected"] = isSelected;
    };
    Shape2.prototype.deleteShape = function(id) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.activeObj.currIndex && parent.activeObj.currIndex === id) {
          parent.notify("selection", { prop: "deleteItem", onPropertyChange: false });
        } else {
          this.applyActObj();
          if (id.split("_")[0] === "shape") {
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
              if (parent.objColl[i].currIndex === id) {
                parent.objColl.splice(i, 1);
                break;
              }
            }
          } else if (id.split("_")[0] === "pen") {
            parent.notify("freehand-draw", { prop: "handle-freehand-draw", value: { id } });
          }
        }
        var object = { canvasFilter: null };
        parent.notify("toolbar", { prop: "getCanvasFilter", onPropertyChange: false, value: { obj: object } });
        this.lowerContext.filter = object["canvasFilter"];
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    Shape2.prototype.getMaxText = function(isTextBox, text, obj) {
      if (isNullOrUndefined(text)) {
        text = isTextBox ? this.parent.textArea.value : this.parent.activeObj.keyHistory;
      }
      var maxi;
      var rows = text.split("\n");
      var maxStr = rows[0].length;
      var maxText = rows[0];
      for (var i = 1; i < rows.length; i++) {
        maxi = rows[i].length;
        if (maxi > maxStr) {
          maxText = rows[i];
          maxStr = maxi;
        }
      }
      if (obj) {
        obj["maxText"] = maxText;
      }
      return maxText;
    };
    Shape2.prototype.getLinePoints = function(x1, y1, x2, y2) {
      var points = [];
      var i;
      var j;
      if (x1 === x2) {
        if (y1 < y2) {
          i = [x1, y1];
          j = [x2, y2];
        } else {
          j = [x1, y1];
          i = [x2, y2];
        }
        var m = this.getSlope(i, j, true);
        var b = this.getIntercept(i, m);
        for (var y = i[1]; y <= j[1]; y++) {
          var x = m * y + b;
          points.push({ x, y });
        }
      } else {
        if (x1 < x2) {
          i = [x1, y1];
          j = [x2, y2];
        } else {
          j = [x1, y1];
          i = [x2, y2];
        }
        var m = this.getSlope(i, j, false);
        var b = this.getIntercept(i, m);
        for (var x = i[0]; x <= j[0]; x++) {
          var y = m * x + b;
          points.push({ x, y });
        }
      }
      if (Math.floor(x1) === Math.floor(x2) || points.length < 10 && (y2 - y1 > 10 || y1 - y2 > 10)) {
        points = [];
        var lesserY = Math.min(y1, y2);
        for (var i_1 = 0; i_1 < Math.abs(Math.floor(y2) - Math.floor(y1)); i_1++) {
          points.push({ x: x1, y: lesserY + i_1 });
        }
        if (points.length > 1) {
          var prev = void 0;
          if (isNullOrUndefined(points[points.length - 2])) {
            prev = { x: 0, y: 0 };
          } else {
            prev = points[points.length - 2];
          }
          var diffX = points[points.length - 1]["x"] - prev.x;
          var diffY = points[points.length - 1]["y"] - prev.y;
          points.push({ x: points[points.length - 1]["x"] + diffX / 2, y: points[points.length - 1]["y"] + diffY / 2 });
        }
      } else if (Math.floor(y1) === Math.floor(y2) || points.length < 10 && (x2 - x1 > 10 || x1 - x2 > 10)) {
        points = [];
        var lesserX = Math.min(x1, x2);
        for (var i_2 = 0; i_2 < Math.abs(Math.floor(x2) - Math.floor(x1)); i_2++) {
          points.push({ x: lesserX + i_2, y: y1 });
        }
        if (points.length > 1) {
          var prev = void 0;
          if (isNullOrUndefined(points[points.length - 2])) {
            prev = { x: 0, y: 0 };
          } else {
            prev = points[points.length - 2];
          }
          var diffX = points[points.length - 1]["x"] - prev.x;
          var diffY = points[points.length - 1]["y"] - prev.y;
          points.push({ x: points[points.length - 1]["x"] + diffX / 2, y: points[points.length - 1]["y"] + diffY / 2 });
        }
      }
      return points;
    };
    Shape2.prototype.getSlope = function(a, b, isSameAxis) {
      var slope;
      if (isSameAxis) {
        if (a[1] === b[1]) {
          return null;
        }
        slope = (b[0] - a[0]) / (b[1] - a[1]);
      } else {
        if (a[0] === b[0]) {
          return null;
        }
        slope = (b[1] - a[1]) / (b[0] - a[0]);
      }
      return slope;
    };
    Shape2.prototype.getIntercept = function(point, getSlope) {
      if (getSlope === null) {
        return point[0];
      }
      return point[1] - getSlope * point[0];
    };
    Shape2.prototype.setPointCollForShapeRotation = function(obj) {
      var parent = this.parent;
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
      obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
      obj.horBottomLinePointColl = this.getLinePoints(p3.x, p3.y, p4.x, p4.y);
      obj.verLeftLinePointColl = this.getLinePoints(p1.x, p1.y, p3.x, p3.y);
      obj.verRightLinePointColl = this.getLinePoints(p2.x, p2.y, p4.x, p4.y);
      obj.verLeftLinePointColl.reverse();
      obj.verRightLinePointColl.reverse();
      for (var i = 0; i < obj.horTopLinePointColl.length; i++) {
        obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.horBottomLinePointColl.length; i++) {
        obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.verLeftLinePointColl.length; i++) {
        obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.verRightLinePointColl.length; i++) {
        obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      if (parent.upperCanvas.style.cursor !== "move") {
        var object = { rotationCirclePoint: null };
        parent.notify("selection", { prop: "getTransRotationPoint", value: { obj, object } });
        var rotationCirclePoint = object["rotationCirclePoint"];
        if (rotationCirclePoint) {
          obj.rotationCirclePointColl = {
            x: cosAngle * (rotationCirclePoint.x - center.x) - sinAngle * (rotationCirclePoint.y - center.y) + center.x,
            y: sinAngle * (rotationCirclePoint.x - center.x) + cosAngle * (rotationCirclePoint.y - center.y) + center.y
          };
          obj.rotationCirclePointColl.ratioX = (obj.rotationCirclePointColl.x - parent.img.destLeft) / parent.img.destWidth;
          obj.rotationCirclePointColl.ratioY = (obj.rotationCirclePointColl.y - parent.img.destTop) / parent.img.destHeight;
        }
      }
    };
    Shape2.prototype.getSquarePointForRotatedShape = function(obj, object) {
      var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      point.startX = p1.x;
      point.startY = p1.y;
      point.endX = p1.x;
      point.endY = p1.y;
      if (point.startX > p2.x) {
        point.startX = p2.x;
      }
      if (point.startX > p3.x) {
        point.startX = p3.x;
      }
      if (point.startX > p4.x) {
        point.startX = p4.x;
      }
      if (point.startY > p2.y) {
        point.startY = p2.y;
      }
      if (point.startY > p3.y) {
        point.startY = p3.y;
      }
      if (point.startY > p4.y) {
        point.startY = p4.y;
      }
      if (point.endX < p2.x) {
        point.endX = p2.x;
      }
      if (point.endX < p3.x) {
        point.endX = p3.x;
      }
      if (point.endX < p4.x) {
        point.endX = p4.x;
      }
      if (point.endY < p2.y) {
        point.endY = p2.y;
      }
      if (point.endY < p3.y) {
        point.endY = p3.y;
      }
      if (point.endY < p4.y) {
        point.endY = p4.y;
      }
      point.width = point.endX - point.startX;
      point.height = point.endY - point.startY;
      if (object) {
        object["activePoint"] = point;
      }
      return point;
    };
    Shape2.prototype.updateZOrder = function(obj, value) {
      var parent = this.parent;
      value = value.toLowerCase();
      var object = obj;
      if (isNullOrUndefined(object.order)) {
        return;
      }
      var index;
      var prevIndex;
      var highestOrder = this.getHighestOrder();
      this.updateShapeColl();
      if (parent.shapeColl.length === 0) {
        return;
      }
      var coll;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        coll = parent.shapeColl[i];
        if (object.id && object.id.indexOf("pen") > -1) {
          if (coll.id && coll.id === object.id) {
            parent.shapeColl.splice(i, 1);
          }
        } else if (coll.shape && coll.shape.indexOf("crop-") > -1) {
          parent.shapeColl.splice(i, 1);
        }
      }
      switch (value) {
        case "sendtoback":
          prevIndex = object.order;
          index = object.order;
          object.order = 1;
          break;
        case "sendbackward":
          object.order -= 1;
          index = object.order;
          break;
        case "bringtofront":
          prevIndex = object.order;
          index = highestOrder;
          object.order = index;
          break;
        case "bringforward":
          object.order += 1;
          index = object.order;
          break;
      }
      this.reArrangeObjColl(index, value, prevIndex);
      if (object.id && object.id.indexOf("pen") > -1) {
        this.reUpdateShapeColl(object);
      }
    };
    Shape2.prototype.reArrangeObjColl = function(index, value, prevIndex) {
      var parent = this.parent;
      var obj;
      switch (value) {
        case "sendtoback":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order < prevIndex && obj.order <= index) {
              obj.order += 1;
              this.reUpdateShapeColl(obj);
            }
          }
          break;
        case "sendbackward":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order === index) {
              obj.order += 1;
              this.reUpdateShapeColl(obj);
              break;
            }
          }
          break;
        case "bringtofront":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order > prevIndex && obj.order <= index) {
              obj.order -= 1;
              this.reUpdateShapeColl(obj);
            }
          }
          break;
        case "bringforward":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order === index) {
              obj.order -= 1;
              this.reUpdateShapeColl(obj);
              break;
            }
          }
          break;
      }
    };
    Shape2.prototype.updateShapeColl = function() {
      var parent = this.parent;
      var isOrdered = false;
      var tempOrder = 1;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      if (parent.shapeColl.length > 0 && parent.shapeColl.length === parent.objColl.length + parent.pointColl.length) {
        for (var i = 0; i < parent.shapeColl.length; i++) {
          if (parent.shapeColl[i].order === tempOrder) {
            isOrdered = true;
            tempOrder++;
          } else {
            isOrdered = false;
            break;
          }
        }
        if (isOrdered) {
          for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].currIndex && parent.shapeColl[i].currIndex.indexOf("shape") > -1) {
              for (var j = 0; j < tempObjColl.length; j++) {
                if (parent.shapeColl[i].currIndex === tempObjColl[j].currIndex) {
                  parent.shapeColl[i] = extend({}, tempObjColl[j], {}, true);
                  tempObjColl.splice(j, 1);
                  break;
                }
              }
            } else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf("pen") > -1) {
              for (var j = 0; j < tempPointColl.length; j++) {
                if (parent.shapeColl[i].id === tempPointColl[j].id) {
                  parent.shapeColl[i] = extend([], tempPointColl[j], [], true);
                  tempPointColl.splice(j, 1);
                  break;
                }
              }
            }
          }
          return;
        }
      }
      tempObjColl = extend([], parent.objColl, [], true);
      tempPointColl = extend([], parent.pointColl, [], true);
      parent.shapeColl = [];
      var order = 1;
      var isBreak;
      var isCrop = false;
      while (tempObjColl.length !== 0 || tempPointColl.length !== 0) {
        isBreak = isCrop = false;
        for (var i = 0; i < tempObjColl.length; i++) {
          if (tempObjColl[i].order === order || !tempObjColl[i].order && tempObjColl[i].shape && tempObjColl[i].shape.indexOf("crop-") > -1) {
            parent.shapeColl.push(extend({}, tempObjColl[i], {}, true));
            if (tempObjColl[i].shape && tempObjColl[i].shape.indexOf("crop-") > -1) {
              isCrop = true;
            }
            tempObjColl.splice(i, 1);
            isBreak = true;
            break;
          }
        }
        if (!isBreak) {
          for (var i = 0; i < tempPointColl.length; i++) {
            if (tempPointColl[i].order === order) {
              parent.shapeColl.push(extend([], tempPointColl[i], [], true));
              tempPointColl.splice(i, 1);
              isBreak = true;
              break;
            }
          }
        }
        if (!isCrop) {
          order++;
        }
      }
    };
    Shape2.prototype.reUpdateShapeColl = function(obj) {
      var parent = this.parent;
      if (obj.id && obj.id.indexOf("pen") > -1) {
        if (parent.freehandCounter > 0) {
          for (var i = 0; i < parent.freehandCounter; i++) {
            if (parent.pointColl[i].id === obj.id) {
              parent.pointColl[i].order = obj.order;
            }
          }
        }
      } else if (obj.currIndex && obj.currIndex.indexOf("shape") > -1) {
        for (var i = 0; i < parent.objColl.length; i++) {
          if (parent.objColl[i].currIndex === obj.currIndex) {
            parent.objColl[i].order = obj.order;
          }
        }
      }
    };
    Shape2.prototype.drawAnnotations = function(ctx, shape, pen, isPreventApply, x, y, panRegion) {
      var parent = this.parent;
      var activeObj = extend({}, parent.activeObj, {}, true);
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      this.updateShapeColl();
      var tempShapeColl = extend([], parent.shapeColl, [], true);
      var isPrevented = false;
      if (!this.preventFrameAnnotation) {
        this.preventFrameAnnotation = isPrevented = true;
      }
      for (var i = 0; i < tempShapeColl.length; i++) {
        var isPenId = tempShapeColl[i].id;
        if (tempShapeColl[i].order || !tempShapeColl[i].order && tempShapeColl[i].shape && tempShapeColl[i].shape.indexOf("crop-") > -1 || !tempShapeColl[i].order && tempShapeColl[i].shape === "path" && parent.drawingShape === "path") {
          if (tempShapeColl[i].currIndex && tempShapeColl[i].currIndex.indexOf("shape") > -1) {
            parent.objColl = [];
            parent.objColl.push(extend({}, tempShapeColl[i], {}, true));
            if (shape === "iterate") {
              var temp = this.lowerContext.filter;
              this.lowerContext.filter = "none";
              this.iterateObjColl();
              this.lowerContext.filter = temp;
            } else if (shape === "zoom" || shape === "pan") {
              var tempObjCollIndex = -1;
              for (var i_3 = 0; i_3 < tempObjColl.length; i_3++) {
                if (JSON.stringify(tempObjColl[i_3]) === JSON.stringify(parent.objColl[0])) {
                  tempObjCollIndex = i_3;
                  break;
                }
              }
              if (shape === "zoom") {
                this.zoomObjColl(isPreventApply);
              } else {
                this.panObjColl(x, y, panRegion);
              }
              if (tempObjCollIndex > -1) {
                tempObjColl[tempObjCollIndex] = extend({}, parent.objColl[0], {}, true);
              }
            }
          } else if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf("pen") > -1) {
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.pointColl.push(extend({}, tempShapeColl[i], {}, true));
            parent.freehandCounter = parent.pointColl.length;
            if (pen === "iterate") {
              parent.notify("freehand-draw", {
                prop: "freehandRedraw",
                onPropertyChange: false,
                value: { context: ctx, points: null }
              });
            } else if (pen === "zoom" || pen === "pan") {
              if (pen === "zoom") {
                parent.notify("freehand-draw", {
                  prop: "zoomFHDColl",
                  onPropertyChange: false,
                  value: { isPreventApply }
                });
              } else {
                parent.notify("freehand-draw", {
                  prop: "panFHDColl",
                  onPropertyChange: false,
                  value: { xDiff: x, yDiff: y, panRegion }
                });
              }
              for (var i_4 = 0; i_4 < tempPointColl.length; i_4++) {
                if (tempPointColl[i_4].id === parent.pointColl[0].id) {
                  tempPointColl[i_4] = extend({}, parent.pointColl[0], {}, true);
                  break;
                }
              }
            }
          }
        } else if (!tempShapeColl[i].shape && !isPenId || !tempShapeColl[i].currIndex && !isPenId) {
          tempShapeColl.splice(i, 1);
        }
      }
      if (pen && pen === "zoom") {
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify("freehand-draw", { prop: "zoomFHDColl", onPropertyChange: false, value: { isPreventApply } });
      }
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
      if (isPrevented && this.preventFrameAnnotation) {
        parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
        this.preventFrameAnnotation = false;
      }
      parent.activeObj = activeObj;
    };
    return Shape2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/transform.js
var Transform = (
  /** @class */
  function() {
    function Transform2(parent) {
      this.isReverseFlip = false;
      this.disablePan = false;
      this.isReverseRotate = false;
      this.flipColl = [];
      this.prevZoomValue = 1;
      this.cropDimension = { width: 0, height: 0 };
      this.isPreventSelect = false;
      this.preventDownScale = false;
      this.resizedImgAngle = null;
      this.parent = parent;
      this.addEventListener();
    }
    Transform2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Transform2.prototype.addEventListener = function() {
      this.parent.on("transform", this.transform, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Transform2.prototype.removeEventListener = function() {
      this.parent.off("transform", this.transform);
      this.parent.off("destroyed", this.destroy);
    };
    Transform2.prototype.transform = function(args) {
      this.initTransformPvtVar();
      switch (args.prop) {
        case "flipImage":
          this.flipImage(args.value["direction"]);
          break;
        case "setDestPointsForFlipState":
          this.setDestPointsForFlipState();
          break;
        case "zoomAction":
          this.zoomAction(args.value["zoomFactor"], args.value["zoomPoint"], args.value["isResize"]);
          break;
        case "disableZoomOutBtn":
          this.disableZoomOutBtn(args.value["isZoomOut"]);
          break;
        case "rotatedFlip":
          this.rotatedFlip();
          break;
        case "drawPannedImage":
          this.drawPannedImage(args.value["xDiff"], args.value["yDiff"]);
          break;
        case "drawPannImage":
          this.drawPannImage(args.value["point"]);
          break;
        case "performTransformation":
          this.performTransformation(args.value["text"]);
          break;
        case "updateTransform":
          this.updateTransform(args.value["text"]);
          break;
        case "rotatePan":
          this.rotatePan(args.value["isCropSelection"], args.value["isDefaultZoom"]);
          break;
        case "resetZoom":
          this.resetZoom();
          break;
        case "pan":
          this.pan(args.value["value"], args.value["x"], args.value["y"]);
          break;
        case "zoom":
          this.zoom(args.value["zoomFactor"], args.value["zoomPoint"]);
          break;
        case "setCurrPanRegion":
          this.setCurrPanRegion(args.value["region"], args.value["type"], args.value["obj"]);
          break;
        case "rotate":
          this.rotate(args.value["degree"], args.value["obj"]);
          break;
        case "flip":
          this.flip(args.value["direction"]);
          break;
        case "update":
          this.update();
          break;
        case "calcMaxDimension":
          this.calcMaxDimension(args.value["width"], args.value["height"], args.value["obj"], args.value["isImgShape"]);
          break;
        case "getPanMove":
          args.value["obj"]["panMove"] = this.panMove;
          break;
        case "setPanMove":
          this.panMove = args.value["point"];
          break;
        case "getTempPanMove":
          args.value["obj"]["tempPanMove"] = this.tempPanMove;
          break;
        case "setTempPanMove":
          this.tempPanMove = args.value["point"];
          break;
        case "setReverseFlip":
          this.isReverseFlip = args.value["isReverseFlip"];
          break;
        case "setDisablePan":
          this.disablePan = args.value["bool"];
          break;
        case "setCurrDestinationPoint":
          this.currDestPoint = args.value["point"];
          this.currDestPoint.startX -= this.parent.cropObj.totalPannedPoint.x;
          this.currDestPoint.startY -= this.parent.cropObj.totalPannedPoint.y;
          break;
        case "setReverseRotate":
          this.isReverseRotate = args.value["bool"];
          break;
        case "getFlipColl":
          args.value["obj"]["flipColl"] = this.flipColl;
          break;
        case "setFlipColl":
          this.flipColl = args.value["flipColl"];
          break;
        case "getPreviousZoomValue":
          args.value["obj"]["previousZoomValue"] = this.prevZoomValue;
          break;
        case "setPreviousZoomValue":
          this.prevZoomValue = args.value["previousZoomValue"];
          break;
        case "getCropDimension":
          args.value["obj"]["cropDimension"] = this.cropDimension;
          break;
        case "setCropDimension":
          this.cropDimension.width = args.value["width"];
          this.cropDimension.height = args.value["height"];
          break;
        case "getPreventSelect":
          args.value["obj"]["bool"] = this.isPreventSelect;
          break;
        case "setPreventSelect":
          this.isPreventSelect = args.value["bool"];
          break;
        case "resizeImage":
          this.resizeImage(args.value["width"], args.value["height"]);
          break;
        case "resizeCrop":
          this.resizeCrop(args.value["width"], args.value["height"]);
          break;
        case "updateResize":
          this.updateResize();
          break;
        case "resize":
          this.resize(args.value["width"], args.value["height"], args.value["isAspectRatio"]);
          break;
        case "straightenImage":
          this.straightenImage(args.value["degree"]);
          break;
        case "reset":
          this.reset();
          break;
        case "cropZoom":
          args.value["obj"]["maxDimension"] = this.cropZoom(args.value["value"], args.value["selectionObj"]);
          break;
        case "setResizedImgAngle":
          this.resizedImgAngle = args.value["angle"];
          break;
      }
    };
    Transform2.prototype.getModuleName = function() {
      return "transform";
    };
    Transform2.prototype.initTransformPvtVar = function() {
      if (this.parent.lowerCanvas) {
        this.lowerContext = this.parent.lowerCanvas.getContext("2d");
      }
      if (this.parent.upperCanvas) {
        this.upperContext = this.parent.upperCanvas.getContext("2d");
      }
    };
    Transform2.prototype.reset = function() {
      this.zoomBtnHold = null;
      this.tempPanMove = null;
      this.panMove = null;
      this.disablePan = false;
      this.currDestPoint = null;
      this.isReverseRotate = false;
      this.flipColl = [];
      this.resizedImgAngle = null;
      this.transCurrObj = null;
      this.prevZoomValue = 1;
      this.isPreventSelect = this.preventDownScale = false;
    };
    Transform2.prototype.rotateImage = function(degree) {
      var parent = this.parent;
      var transitionArgs = {
        cancel: false,
        previousDegree: parent.transform.degree,
        currentDegree: Math.abs(parent.transform.degree + degree) === 360 ? 0 : parent.transform.degree + degree
      };
      if (!this.isPreventSelect) {
        parent.trigger("rotating", transitionArgs);
      }
      this.rotateEvent(transitionArgs, degree);
    };
    Transform2.prototype.rotateEvent = function(transitionArgs, degree) {
      var parent = this.parent;
      if (!transitionArgs.cancel) {
        var prevObj = void 0;
        if (isNullOrUndefined(this.transCurrObj)) {
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, null, true);
          prevObj.pointColl = extend({}, parent.pointColl, null, true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        }
        parent.afterCropActions.push(degree === 90 ? "rotateRight" : "rotateLeft");
        var splitWords = [];
        var activeObjShape = void 0;
        if (parent.activeObj.activePoint && parent.activeObj.shape) {
          if (parent.activeObj.shape !== void 0) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (parent.currObjType.isCustomCrop || splitWords[0] === "crop") {
            activeObjShape = parent.currObjType.isCustomCrop ? "custom" : splitWords[1];
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          }
        }
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.drawRotatedImage(degree);
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        if (activeObjShape) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
          parent.objColl.pop();
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
        parent.isUndoRedo = false;
        var obj = { collection: parent.rotateFlipColl };
        parent.notify("shape", {
          prop: "alignRotateFlipColl",
          onPropertyChange: false,
          value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj }
        });
        parent.rotateFlipColl = obj["collection"];
        if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
          parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
          this.isPreventSelect = true;
          parent.notify("draw", {
            prop: "select",
            onPropertyChange: false,
            value: { type: "custom", startX: null, startY: null, width: null, height: null }
          });
          this.isPreventSelect = false;
          parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
          this.prevZoomValue = parent.zoomSettings.zoomFactor;
        }
      } else {
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
        parent.activeObj = parent.prevEventSelectionPoint;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
      }
    };
    Transform2.prototype.drawRotatedImage = function(degree) {
      var parent = this.parent;
      if (degree === 0) {
        parent.transform.degree = 0;
      } else {
        parent.transform.degree += degree;
      }
      if (Math.abs(parent.transform.degree) === 360) {
        parent.transform.degree = 0;
      }
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (!this.isReverseRotate) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
      }
      this.rotateDegree(degree);
      if (!this.isReverseRotate) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        parent.rotateFlipColl.push(degree);
      }
      parent.objColl = extend([], tempObjColl, [], true);
      parent.activeObj = extend({}, tempActiveObj, {}, true);
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (degree > 0) {
        parent.notify("freehand-draw", { prop: "rotateFhdColl", onPropertyChange: false });
      } else {
        for (var i = 0; i < 3; i++) {
          parent.notify("freehand-draw", { prop: "rotateFhdColl", onPropertyChange: false });
        }
      }
      parent.notify("freehand-draw", {
        prop: "freehandRedraw",
        onPropertyChange: false,
        value: { context: this.lowerContext, points: null }
      });
      this.updateCurrSelectionPoint(degree);
    };
    Transform2.prototype.rotateDegree = function(degree) {
      var parent = this.parent;
      this.lowerContext.save();
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
      this.lowerContext.rotate(Math.PI / 180 * degree);
      this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
      this.lowerContext.rotate(Math.PI / 180 * -degree);
      this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
      this.lowerContext.restore();
    };
    Transform2.prototype.updateCurrSelectionPoint = function(degree) {
      var parent = this.parent;
      if (parent.currSelectionPoint && this.currDestPoint) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        var objColl = extend([], parent.objColl, [], true);
        var srcPoints = {
          startX: parent.img.srcLeft,
          startY: parent.img.srcTop,
          width: parent.img.srcWidth,
          height: parent.img.srcHeight
        };
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.objColl = [];
        parent.objColl.push(extend({}, parent.currSelectionPoint, {}, true));
        if (isNullOrUndefined(parent.objColl[0].imageRatio)) {
          parent.activeObj = parent.objColl[0];
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          parent.objColl[0] = parent.activeObj;
        }
        parent.img = {
          srcLeft: 0,
          srcTop: 0,
          srcWidth: parent.baseImgCanvas.width,
          srcHeight: parent.baseImgCanvas.height,
          destLeft: this.currDestPoint.startX,
          destTop: this.currDestPoint.startY,
          destWidth: this.currDestPoint.width,
          destHeight: this.currDestPoint.height
        };
        if (typeof degree === "number") {
          parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
          parent.notify("draw", {
            prop: "setClientTransDim",
            onPropertyChange: false,
            value: { isPreventDimension: null }
          });
        }
        parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree } });
        parent.currSelectionPoint = extend({}, parent.objColl[0], {}, true);
        this.currDestPoint = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.objColl = objColl;
        parent.activeObj = activeObj;
        parent.img = {
          srcLeft: srcPoints.startX,
          srcTop: srcPoints.startY,
          srcWidth: srcPoints.width,
          srcHeight: srcPoints.height,
          destLeft: destPoints.startX,
          destTop: destPoints.startY,
          destWidth: destPoints.width,
          destHeight: destPoints.height
        };
      }
    };
    Transform2.prototype.flipImage = function(direction) {
      var parent = this.parent;
      var transitionArgs = {
        direction,
        cancel: false,
        previousDirection: parent.toPascalCase(parent.transform.currFlipState || direction)
      };
      if (!this.isPreventSelect) {
        parent.trigger("flipping", transitionArgs);
      }
      this.flipEvent(transitionArgs, direction);
    };
    Transform2.prototype.flipEvent = function(transitionArgs, direction) {
      var parent = this.parent;
      if (transitionArgs.cancel) {
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
        parent.activeObj = parent.prevEventSelectionPoint;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        return;
      }
      var prevObj;
      if (isNullOrUndefined(this.transCurrObj)) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], parent.objColl, null, true);
        prevObj.pointColl = extend({}, parent.pointColl, null, true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      }
      parent.afterCropActions.push(direction.toLowerCase() === "horizontal" ? "horizontalflip" : "verticalflip");
      var splitWords = [];
      var activeObjShape;
      if (parent.activeObj.activePoint) {
        if (parent.activeObj.shape !== void 0) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.currObjType.isCustomCrop || splitWords[0] === "crop") {
          activeObjShape = parent.currObjType.isCustomCrop ? "custom" : splitWords[1];
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          parent.objColl.push(parent.activeObj);
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
      }
      parent.notify("shape", {
        prop: "redrawActObj",
        onPropertyChange: false,
        value: { x: null, y: null, isMouseDown: true }
      });
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (!this.isReverseFlip) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
      }
      var lowercaseDirection = direction.toLowerCase();
      this.updateFlipState(lowercaseDirection);
      var flipState = parent.transform.currFlipState.toLowerCase();
      parent.transform.currFlipState = lowercaseDirection === "horizontal" && flipState === "horizontal" || lowercaseDirection === "vertical" && flipState === "vertical" ? "" : lowercaseDirection;
      var selObj = { isSelected: null };
      parent.notify("draw", { prop: "getRotatedFlipCropSelection", onPropertyChange: false, value: { bool: selObj } });
      if (selObj["isSelected"]) {
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      }
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      this.updateFlipState(direction.toLowerCase());
      if (!this.isReverseFlip) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        this.updateFlipColl(direction.toLocaleLowerCase());
        parent.rotateFlipColl.push(direction.toLowerCase());
      }
      if (parent.rotateFlipColl.length === 1) {
        var panObj = { panRegion: "" };
        parent.notify("crop", {
          prop: "getCurrFlipState",
          onPropertyChange: false,
          value: { panObj }
        });
        if (panObj["panRegion"] === "") {
          parent.notify("draw", {
            prop: "setClientTransDim",
            onPropertyChange: false,
            value: { isPreventDimension: null }
          });
        } else {
          this.setDestPointsForFlipState();
        }
      }
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.objColl = extend([], tempObjColl, [], true);
      parent.activeObj = extend({}, tempActiveObj, {}, true);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var flipObjColl = parent.objColl[i].flipObjColl;
        if (flipObjColl.length === 0) {
          flipObjColl.push(direction);
        } else if (flipObjColl[flipObjColl.length - 1] === direction) {
          flipObjColl.pop();
        } else {
          flipObjColl.push(direction);
        }
      }
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: direction.toLowerCase() } });
      var tempFilter = this.lowerContext.filter;
      this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.notify("shape", { prop: "iterateObjColl", onPropertyChange: false });
      var dir = direction.toLowerCase();
      if (dir === "horizontal" || dir === "vertical") {
        parent.notify("freehand-draw", {
          prop: "flipFHDColl",
          onPropertyChange: false,
          value: { value: dir }
        });
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
      } else {
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
      }
      this.lowerContext.filter = tempFilter;
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.updateCurrSelectionPoint(dir);
      parent.isUndoRedo = false;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      if (activeObjShape) {
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        parent.objColl.pop();
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
      }
      var obj = { collection: parent.rotateFlipColl };
      parent.notify("shape", {
        prop: "alignRotateFlipColl",
        onPropertyChange: false,
        value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj }
      });
      parent.rotateFlipColl = obj["collection"];
      if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
        parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
        this.isPreventSelect = true;
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
        this.isPreventSelect = false;
        parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
        this.prevZoomValue = parent.zoomSettings.zoomFactor;
      }
    };
    Transform2.prototype.updateFlipState = function(direction) {
      var degree = this.parent.transform.degree;
      if (direction === "horizontal") {
        if (degree % 90 === 0 && degree % 180 !== 0) {
          this.verticalFlip();
        } else {
          this.horizontalFlip();
        }
      } else if (direction === "vertical") {
        if (degree % 90 === 0 && degree % 180 !== 0) {
          this.horizontalFlip();
        } else {
          this.verticalFlip();
        }
      }
    };
    Transform2.prototype.horizontalFlip = function() {
      this.lowerContext.translate(this.lowerContext.canvas.width, 0);
      this.lowerContext.scale(-1, 1);
      this.upperContext.translate(this.upperContext.canvas.width, 0);
      this.upperContext.scale(-1, 1);
    };
    Transform2.prototype.verticalFlip = function() {
      this.lowerContext.translate(0, this.lowerContext.canvas.height);
      this.lowerContext.scale(1, -1);
      this.upperContext.translate(0, this.upperContext.canvas.height);
      this.upperContext.scale(1, -1);
    };
    Transform2.prototype.updateFlipColl = function(direction) {
      if (this.isPreventSelect) {
        return;
      }
      if (this.flipColl.length === 0 || this.flipColl[this.flipColl.length - 1] !== direction) {
        this.flipColl.push(direction);
      } else {
        this.flipColl.pop();
      }
      if (this.flipColl.length >= 4) {
        var lastFourItems = this.flipColl.slice(-4);
        if (lastFourItems[0] === "horizontal" && lastFourItems[1] === "vertical" && lastFourItems[2] === "horizontal" && lastFourItems[3] === "vertical" || lastFourItems[0] === "vertical" && lastFourItems[1] === "horizontal" && lastFourItems[2] === "vertical" && lastFourItems[3] === "horizontal") {
          this.flipColl.splice(-4);
        }
      }
    };
    Transform2.prototype.setDestPointsForFlipState = function() {
      var parent = this.parent;
      var panObj = { panRegion: "" };
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
      parent.notify("crop", {
        prop: "getCurrFlipState",
        onPropertyChange: false,
        value: { panObj }
      });
      if (panObj["panRegion"] !== "") {
        if (panObj["panRegion"] === "horizontal") {
          parent.img.destLeft = clientWidth - (destWidth + destLeft);
        } else if (panObj["panRegion"] === "vertical") {
          parent.img.destTop = clientHeight - (destHeight + destTop);
        } else {
          parent.img.destLeft = clientWidth - (destWidth + destLeft);
          parent.img.destTop = clientHeight - (destHeight + destTop);
        }
      }
    };
    Transform2.prototype.zoomAction = function(zoomFactor, zoomPoint, isResize, isPreventApply) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (isNullOrUndefined(isResize) && (parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor && zoomFactor > 0 || parent.zoomSettings.zoomFactor > parent.zoomSettings.minZoomFactor && zoomFactor < 0 && this.disableZoomOutBtn(true) || parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor && zoomFactor < 0)) {
          parent.notify("toolbar", { prop: "zoom-up-handler", onPropertyChange: false });
          return;
        }
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        var tempZoomFactor = zoomFactor;
        zoomFactor = tempZoomFactor > 0 ? 0.1 : -0.1;
        for (var i = 0; i < Math.round(Math.abs(tempZoomFactor / 0.1)); i++) {
          if (this.prevZoomValue === 1) {
            this.prevZoomValue += zoomFactor > 0 ? zoomFactor * 10 : zoomFactor * 10 / 10;
          } else if (this.prevZoomValue > 1) {
            this.prevZoomValue += zoomFactor * 10;
          } else if (this.prevZoomValue < 1) {
            this.prevZoomValue += zoomFactor * 10 / 10;
            var powerOften = Math.pow(10, 1);
            this.prevZoomValue = Math.round(this.prevZoomValue * powerOften) / powerOften;
          }
        }
        zoomFactor = tempZoomFactor;
        parent.setProperties({ zoomSettings: { zoomFactor: this.prevZoomValue } }, true);
        var splitWords = void 0;
        this.tempActiveObj = null;
        this.isShape = false;
        if (parent.activeObj.shape !== void 0) {
          if (parent.activeObj.shape === "shape") {
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          } else {
            splitWords = parent.activeObj.shape.split("-");
          }
        }
        if (splitWords !== void 0 && splitWords[0] === "crop") {
          this.tempActiveObj = extend({}, parent.activeObj, {}, true);
          parent.isCropTab = true;
        } else if (parent.activeObj.shape && splitWords[0] !== "crop") {
          this.isShape = true;
        }
        var obj = { zoomType: null };
        parent.notify("selection", { prop: "getZoomType", onPropertyChange: false, value: { obj } });
        if (isNullOrUndefined(zoomPoint)) {
          if (parent.isCropTab && this.tempActiveObj) {
            zoomPoint = {
              x: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2,
              y: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2
            };
          } else {
            zoomPoint = { x: parent.lowerCanvas.clientWidth / 2, y: parent.lowerCanvas.clientHeight / 2 };
          }
          if (obj["zoomType"] === "MouseWheel" || obj["zoomType"] === "Pinch") {
            zoomPoint = { x: parent.zoomSettings.zoomPoint.x, y: parent.zoomSettings.zoomPoint.y };
          }
        }
        var previousZoomFactor = parent.zoomSettings.zoomFactor - zoomFactor * 10;
        var zoomEventArgs = {
          zoomPoint,
          cancel: false,
          previousZoomFactor,
          currentZoomFactor: parent.zoomSettings.zoomFactor,
          zoomTrigger: obj["zoomType"]
        };
        if (!parent.isCropToolbar && parent.isZoomBtnClick) {
          parent.trigger("zooming", zoomEventArgs);
        }
        this.zoomEvent(zoomEventArgs, zoomFactor, isPreventApply);
      }
    };
    Transform2.prototype.zoomEvent = function(zoomEventArgs, zoomFact, isPreventApply) {
      var parent = this.parent;
      var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
      if (zoomEventArgs.cancel) {
        parent.isZoomBtnClick = false;
        return;
      }
      parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
      parent.notify("shape", {
        prop: "redrawActObj",
        onPropertyChange: false,
        value: { x: null, y: null, isMouseDown: true }
      });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var object = { canvasFilter: parent.canvasFilter };
      this.lowerContext.filter = object["canvasFilter"];
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var objColl = extend([], parent.objColl, [], true);
      if (!parent.isCropTab) {
        if (parent.transform.degree !== 0) {
          parent.notify("shape", { prop: "redrawActObj", onPropertyChange: false, value: { x: null, y: null, isMouseDown: null } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          var temp = parent.allowDownScale;
          parent.allowDownScale = false;
          this.rotatePan(true, true);
          parent.allowDownScale = temp;
        } else if (parent.transform.currFlipState !== "") {
          parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        }
        if (parent.transform.straighten === 0 && !this.isPreventSelect) {
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
        }
      }
      if (parent.transform.degree === 0) {
        this.drawZoomImgToCanvas(zoomFact, this.tempActiveObj);
        var panObj_1 = { panRegion: "" };
        parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj: panObj_1 } });
        if (panObj_1["panRegion"] !== "") {
          parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point: parent.panPoint.totalPannedPoint, isAdd: true } });
          objColl = extend([], parent.objColl, [], true);
          parent.objColl = [];
          var destLeft = parent.img.destLeft;
          var destTop = parent.img.destTop;
          this.setDestPointsForFlipState();
          this.rotatedFlip();
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
          parent.objColl = objColl;
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
          });
          if (parent.transform.straighten === 0 && !this.isPreventSelect) {
            parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
          }
        }
        if (zoomFactor <= minZoomFactor && !parent.isCropTab) {
          parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        }
      } else {
        if (parent.transform.straighten === 0 && !this.isPreventSelect) {
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
        }
        parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
        parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
        this.rotateZoom(zoomFact);
        var panObj_2 = { panRegion: "" };
        parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj: panObj_2 } });
        if (panObj_2["panRegion"] !== "") {
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
          });
          this.lowerContext.filter = temp;
        }
      }
      var powerOften = Math.pow(10, 1);
      if (zoomFactor <= minZoomFactor || Math.round(parent.transform.zoomFactor * powerOften) / powerOften === 2) {
        clearInterval(this.zoomBtnHold);
        this.zoomBtnHold = 0;
      }
      var panObj = { panRegion: "" };
      parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj } });
      if (panObj["panRegion"] === "") {
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
        });
        this.lowerContext.filter = temp;
      }
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (this.tempActiveObj) {
        parent.activeObj = extend({}, this.tempActiveObj, {}, true);
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        if (zoomFactor <= minZoomFactor) {
          parent.currSelectionPoint = null;
        }
      }
      parent.isUndoRedo = false;
      var zoomOut;
      zoomOut = document.querySelector("#" + parent.element.id + "_zoomOut");
      if (zoomOut && zoomFactor <= minZoomFactor) {
        zoomOut.classList.add("e-disabled");
        zoomOut.parentElement.classList.add("e-overlay");
      } else if (zoomOut) {
        zoomOut.classList.remove("e-disabled");
        zoomOut.parentElement.classList.remove("e-overlay");
      }
      var drawingShape = parent.drawingShape;
      this.autoEnablePan();
      parent.drawingShape = drawingShape;
      if (this.tempActiveObj) {
        parent.activeObj = extend({}, this.tempActiveObj, {}, true);
      }
      if (parent.activeObj.shape === "crop-custom") {
        parent.currObjType.isCustomCrop = true;
      }
      var panBtn = parent.element.querySelector(".e-img-pan .e-btn");
      if (panBtn && parent.togglePan) {
        panBtn.classList.add("e-selected-btn");
      } else if (panBtn) {
        panBtn.classList.remove("e-selected-btn");
      }
      if (this.isShape) {
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        parent.objColl.pop();
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
        parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      }
      parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
      parent.notify("selection", { prop: "setZoomType", onPropertyChange: false, value: { zoomType: "Toolbar" } });
      zoomEventArgs = { zoomPoint: zoomEventArgs.zoomPoint, previousZoomFactor: zoomEventArgs.previousZoomFactor, currentZoomFactor: zoomEventArgs.currentZoomFactor, zoomTrigger: zoomEventArgs.zoomTrigger };
      if (!parent.isCropToolbar && parent.isZoomBtnClick) {
        parent.isZoomBtnClick = false;
      }
      if (parent.drawingShape) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        parent.activeObj = activeObj;
        if (activeObj.activePoint.width > 0 || activeObj.activePoint.height > 0 || activeObj.pointColl && activeObj.pointColl.length > 0) {
          var zOrderElem = parent.element.querySelector("#" + parent.element.id + "_zOrderBtn");
          var dupElem = parent.element.querySelector("#" + parent.element.id + "_duplicate");
          var removeElem = parent.element.querySelector("#" + parent.element.id + "_remove");
          var editTextElem = parent.element.querySelector("#" + parent.element.id + "_editText");
          if (zOrderElem) {
            zOrderElem.classList.remove("e-disabled");
          }
          if (dupElem) {
            dupElem.classList.remove("e-disabled");
          }
          if (removeElem) {
            removeElem.classList.remove("e-disabled");
          }
          if (editTextElem) {
            editTextElem.classList.remove("e-disabled");
          }
        }
      }
    };
    Transform2.prototype.disableZoomOutBtn = function(isZoomOut) {
      var parent = this.parent;
      var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
      var isDisabled = false;
      var zoomOut;
      if (!isNullOrUndefined(isZoomOut)) {
        parent.transform.zoomFactor -= 0.1;
      }
      zoomOut = parent.element.querySelector("#" + parent.element.id + "_zoomOut");
      var destPoints = {
        destLeft: parent.img.destLeft,
        destTop: parent.img.destTop,
        destWidth: parent.img.destWidth,
        destHeight: parent.img.destHeight
      };
      if (parent.activeObj.shape) {
        var maxDimension = this.setZoomDimension(-0.1, parent.activeObj);
        if (!isNullOrUndefined(zoomOut)) {
          var actPoint = parent.activeObj.activePoint;
          if (parent.transform.straighten === 0) {
            if (parent.img.destLeft > actPoint.startX || parent.img.destTop > actPoint.startY || parent.img.destLeft + parent.img.destWidth < actPoint.endX || parent.img.destTop + parent.img.destHeight < actPoint.endY || zoomFactor === minZoomFactor) {
              zoomOut.classList.add("e-disabled");
              zoomOut.parentElement.classList.add("e-overlay");
              isDisabled = true;
            } else {
              zoomOut.classList.remove("e-disabled");
              zoomOut.parentElement.classList.remove("e-overlay");
              isDisabled = false;
            }
          } else {
            parent.img.destWidth = maxDimension.width;
            parent.img.destHeight = maxDimension.height;
            var obj = { isIntersect: null };
            parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
            parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
            if (obj["isIntersect"] || zoomFactor === minZoomFactor) {
              zoomOut.classList.add("e-disabled");
              zoomOut.parentElement.classList.add("e-overlay");
              isDisabled = true;
            } else {
              zoomOut.classList.remove("e-disabled");
              zoomOut.parentElement.classList.remove("e-overlay");
              isDisabled = false;
            }
          }
        }
      } else {
        this.setZoomDimension(-0.1, null);
      }
      if (!isNullOrUndefined(isZoomOut)) {
        parent.transform.zoomFactor += 0.1;
      }
      parent.img.destLeft = destPoints["destLeft"];
      parent.img.destTop = destPoints["destTop"];
      parent.img.destWidth = destPoints["destWidth"];
      parent.img.destHeight = destPoints["destHeight"];
      return isDisabled;
    };
    Transform2.prototype.drawZoomImgToCanvas = function(value, selectionObj) {
      var parent = this.parent;
      var powerOften = Math.pow(10, 1);
      var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
      if (zmFactor === 0.1 && value === -0.1 || zmFactor === 0 && value === -0.025) {
        parent.transform.zoomFactor = 0;
      } else {
        parent.transform.zoomFactor += value;
      }
      parent.transform[parent.isCropTab ? "cropZoomFactor" : "defaultZoomFactor"] = parent.transform.zoomFactor;
      var maxDimension = { width: 0, height: 0 };
      if (parent.isCropTab) {
        maxDimension = this.cropZoom(value, selectionObj);
      } else {
        maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
        maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
      }
      parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
      maxDimension.width = this.cropDimension.width;
      maxDimension.height = this.cropDimension.height;
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform2.prototype.rotatedFlip = function() {
      var parent = this.parent;
      this.isReverseFlip = true;
      var tempCurrFlipState = parent.transform.currFlipState;
      var tempFlipColl = this.flipColl;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      this.flipColl = [];
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: true, context: null, isPreventCircleCrop: null }
      });
      if (tempCurrFlipState === "" && parent.transform.currFlipState !== "") {
        tempCurrFlipState = parent.transform.currFlipState;
      }
      parent.transform.currFlipState = tempCurrFlipState;
      this.flipColl = tempFlipColl;
      parent.objColl = extend([], tempObjColl, [], true);
      this.lowerContext.filter = "none";
      parent.notify("shape", { prop: "iterateObjColl", onPropertyChange: false });
      this.lowerContext.filter = temp;
      if (tempActiveObj.activePoint.width !== 0) {
        parent.activeObj = extend({}, tempActiveObj, {}, true);
      }
      this.isReverseFlip = false;
    };
    Transform2.prototype.rotateZoom = function(value) {
      var parent = this.parent;
      var powerOften = Math.pow(10, 1);
      var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
      if (zmFactor === 0.1 && value === -0.1 || zmFactor === 0 && value === -0.025) {
        parent.transform.zoomFactor = 0;
      } else {
        parent.transform.zoomFactor += value;
      }
      if (parent.isCropTab) {
        parent.transform.cropZoomFactor = parent.transform.zoomFactor;
      } else {
        parent.transform.defaultZoomFactor = parent.transform.zoomFactor;
      }
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
      });
      parent.objColl = tempObjColl;
      parent.activeObj = tempActiveObj;
      var maxDimension = { width: this.cropDimension.width, height: this.cropDimension.height };
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform2.prototype.autoEnablePan = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor <= 0) {
        parent.togglePan = false;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
        parent.pan(false);
        this.disablePan = false;
      } else {
        parent.pan(!this.disablePan);
      }
    };
    Transform2.prototype.cropZoom = function(value, selectionObj) {
      var parent = this.parent;
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      var maxDimension = { width: 0, height: 0 };
      if (parent.img.srcLeft === 0 || parent.img.srcTop === 0) {
        if (isNullOrUndefined(selectionObj)) {
          maxDimension = this.setZoomDimension(value, null);
        } else {
          maxDimension = this.setZoomDimension(value, selectionObj);
        }
      } else {
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
          maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
        } else {
          maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        }
        maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
        maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      }
      parent.img.destLeft = destLeft - (maxDimension.width - parent.img.destWidth) / 2;
      parent.img.destTop = destTop - (maxDimension.height - parent.img.destHeight) / 2;
      destLeft = parent.img.destLeft;
      destTop = parent.img.destTop;
      if (selectionObj && parent.transform.straighten === 0) {
        if (parent.img.destLeft > selectionObj.activePoint.startX) {
          parent.img.destLeft = selectionObj.activePoint.startX;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.x -= destLeft - parent.img.destLeft;
          }
        }
        if (parent.img.destTop > selectionObj.activePoint.startY) {
          parent.img.destTop = selectionObj.activePoint.startY;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.y -= destTop - parent.img.destTop;
          }
        }
        if (parent.img.destLeft + maxDimension.width < selectionObj.activePoint.endX) {
          parent.img.destLeft = selectionObj.activePoint.endX - maxDimension.width;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.x -= destLeft - parent.img.destLeft;
          }
        }
        if (parent.img.destTop + maxDimension.height < selectionObj.activePoint.endY) {
          parent.img.destTop = selectionObj.activePoint.endY - maxDimension.height;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.y -= destTop - parent.img.destTop;
          }
        }
      }
      return maxDimension;
    };
    Transform2.prototype.setZoomDimension = function(value, selectionObj) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      var maxDimension = { width: 0, height: 0 };
      if (degree % 90 === 0 && degree % 180 !== 0) {
        maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
      } else {
        maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
      }
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.img.destLeft += (parent.img.destWidth - maxDimension.width) / 2;
      parent.img.destTop += (parent.img.destHeight - maxDimension.height) / 2;
      if (value < 0 && selectionObj) {
        var startX = selectionObj.activePoint.startX;
        var startY = selectionObj.activePoint.startY;
        var width = selectionObj.activePoint.width;
        var height = selectionObj.activePoint.height;
        var maxDestLeft = parent.img.destLeft + maxDimension.width;
        var maxDestTop = parent.img.destTop + maxDimension.height;
        if (parent.img.destLeft > startX) {
          parent.img.destLeft = startX;
        }
        if (parent.img.destTop > startY) {
          parent.img.destTop = startY;
        }
        if (maxDestLeft < startX + width) {
          parent.img.destLeft = startX + width - maxDimension.width;
        }
        if (maxDestTop < startY + height) {
          parent.img.destTop = startY + height - maxDimension.height;
        }
      } else if (value < 0 && isNullOrUndefined(selectionObj)) {
        if (parent.img.destLeft > 0) {
          parent.img.destLeft = 0;
        }
        if (parent.img.destTop > 0) {
          parent.img.destTop = 0;
        }
        if (parent.img.destLeft + maxDimension.width < parent.lowerCanvas.clientWidth) {
          parent.img.destLeft = parent.lowerCanvas.clientWidth - parent.img.destWidth;
        }
        if (parent.img.destTop + maxDimension.height < parent.lowerCanvas.clientHeight) {
          parent.img.destTop = parent.lowerCanvas.clientHeight - parent.img.destHeight;
        }
      }
      return maxDimension;
    };
    Transform2.prototype.drawPannedImage = function(xDiff, yDiff) {
      var parent = this.parent;
      var obj = { panDown: null };
      parent.notify("selection", { prop: "getPanDown", onPropertyChange: false, value: { obj } });
      var panEventArgs = { startPoint: obj["panDown"], endPoint: this.panMove, cancel: false };
      parent.trigger("panning", panEventArgs);
      if (panEventArgs.cancel) {
        return;
      }
      this.panEvent(xDiff, yDiff);
    };
    Transform2.prototype.panEvent = function(xDiff, yDiff, isPanMethod) {
      var parent = this.parent;
      var isObjCreated = false;
      if (parent.activeObj.shape && parent.activeObj.shape === "shape") {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (isNullOrUndefined(parent.activeObj.shape)) {
        isObjCreated = true;
        var actPoint = parent.activeObj.activePoint = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          endX: parent.img.destLeft + parent.img.destWidth,
          endY: parent.img.destTop + parent.img.destHeight
        };
        var startX = actPoint.startX;
        var startY = actPoint.startY;
        var endX = actPoint.endX;
        var endY = actPoint.endY;
        if (startX < 0) {
          actPoint.startX = 0;
        }
        if (startY < 0) {
          actPoint.startY = 0;
        }
        if (endX > parent.lowerCanvas.width) {
          actPoint.endX = parent.lowerCanvas.width;
        }
        if (endY > parent.lowerCanvas.height) {
          actPoint.endY = parent.lowerCanvas.height;
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        parent.activeObj.shape = "crop-custom";
        var obj = { strokeSettings: {} };
        parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj } });
        parent.activeObj.strokeSettings = obj["strokeSettings"];
        parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
          actPoint,
          obj: parent.activeObj,
          isMouseMove: null,
          x: null,
          y: null
        } });
        parent.isCropTab = true;
      }
      if (parent.transform.degree === 0) {
        var point = void 0;
        if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff) || isPanMethod) {
          if (isPanMethod) {
            point = this.updatePanPoints(xDiff, yDiff);
          } else {
            point = this.updatePanPoints();
          }
        } else {
          point = { x: xDiff, y: yDiff };
        }
        parent.panPoint.totalPannedPoint.x += point.x;
        parent.panPoint.totalPannedPoint.y += point.y;
        var tempSelectionObj = extend({}, parent.activeObj, {}, true);
        var temp = this.lowerContext.filter;
        this.drawPannImage(point, isObjCreated);
        this.lowerContext.filter = temp;
        this.tempPanMove = extend({}, this.panMove, {}, true);
        parent.activeObj = extend({}, tempSelectionObj, {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.shape) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
      } else {
        var tempFlipState = parent.transform.currFlipState;
        parent.isCropTab = true;
        if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff) || isPanMethod) {
          if (isPanMethod) {
            parent.panPoint.currentPannedPoint = this.updatePanPoints(xDiff, yDiff);
          } else {
            parent.panPoint.currentPannedPoint = this.updatePanPoints();
          }
        } else {
          parent.panPoint.currentPannedPoint = { x: xDiff, y: yDiff };
        }
        parent.transform.currFlipState = tempFlipState;
        this.rotatePan(null, null, isObjCreated);
        parent.isCropTab = false;
        this.tempPanMove = extend({}, this.panMove, {}, true);
      }
      if (isObjCreated) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.isCropTab = false;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      }
    };
    Transform2.prototype.drawPannImage = function(point, isObjCreated) {
      var parent = this.parent;
      var filter = this.lowerContext.filter;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      this.setDestPointsForFlipState();
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: true }
        });
      }
      this.lowerContext.filter = filter;
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
      });
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      var temp = this.lowerContext.filter;
      this.lowerContext.filter = "none";
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: {
          ctx: this.lowerContext,
          shape: "pan",
          pen: "pan",
          x: point.x,
          y: point.y,
          panRegion: ""
        }
      });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: true }
        });
      }
    };
    Transform2.prototype.resetZoom = function() {
      var parent = this.parent;
      if (parent.transform.defaultZoomFactor !== 0) {
        var isUndoRedo = parent.isUndoRedo;
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        this.transCurrObj = object["currObj"];
        this.transCurrObj.objColl = extend([], parent.objColl, null, true);
        this.transCurrObj.pointColl = extend({}, parent.pointColl, null, true);
        this.transCurrObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        this.transCurrObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.isUndoRedo = parent.isCropToolbar = true;
        var zmFactor = parent.transform.defaultZoomFactor;
        if (zmFactor > 0) {
          this.zoomAction(-zmFactor);
        } else {
          this.zoomAction(Math.abs(zmFactor));
        }
        parent.isCropToolbar = false;
        parent.isUndoRedo = isUndoRedo;
      }
    };
    Transform2.prototype.performTransformation = function(text) {
      var parent = this.parent;
      var tempZoomFactor = parent.transform.defaultZoomFactor;
      var isUndoRedo = parent.isUndoRedo;
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      this.resetZoom();
      this.updateTransform(text);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.objColl[i].flipObjColl.length > 0) {
          var flipObjColl = { collection: parent.objColl[i].flipObjColl };
          parent.notify("shape", {
            prop: "alignRotateFlipColl",
            onPropertyChange: false,
            value: { collection: flipObjColl["collection"], isRotateFlipCollection: null, obj: flipObjColl }
          });
          parent.objColl[i].flipObjColl = flipObjColl["collection"];
          if (parent.objColl[i].flipObjColl.length === 0) {
            parent.objColl[i].shapeFlip = "";
          }
        }
      }
      if (tempZoomFactor !== 0) {
        parent.isUndoRedo = true;
        this.zoomAction(tempZoomFactor);
        parent.isUndoRedo = isUndoRedo;
        var state = "";
        if (text === "rotateleft" || text === "rotateright") {
          state = "rotate";
        } else if (text === "horizontalflip" || text === "verticalflip") {
          state = "flip";
        }
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: state,
            previousObj: this.transCurrObj,
            previousObjColl: this.transCurrObj.objColl,
            previousPointColl: this.transCurrObj.pointColl,
            previousSelPointColl: this.transCurrObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        this.transCurrObj = null;
      }
    };
    Transform2.prototype.updateTransform = function(text) {
      switch (text.toLowerCase()) {
        case "rotateleft":
          this.rotateImage(-90);
          break;
        case "rotateright":
          this.rotateImage(90);
          break;
        case "horizontalflip":
          this.flipImage(Direction.Horizontal);
          break;
        case "verticalflip":
          this.flipImage(Direction.Vertical);
          break;
      }
    };
    Transform2.prototype.rotatePan = function(isCropSelection, isDefaultZoom, isObjCreated) {
      var parent = this.parent;
      this.isReverseRotate = true;
      var tempDegree = parent.transform.degree;
      var rotatePanActiveObj;
      var object = { selPointColl: null };
      if (parent.activeObj.activePoint && parent.activeObj.shape) {
        rotatePanActiveObj = extend({}, parent.activeObj, {}, true);
      }
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: object } });
      var cropSelPointColl = object["selPointColl"];
      parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: [] } } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      var initialDestLeft = parent.img.destLeft;
      var initialDestTop = parent.img.destTop;
      var intPan = parent.panPoint.totalPannedInternalPoint;
      if (parent.isCropTab) {
        parent.img.destLeft += intPan.x;
        parent.img.destTop += intPan.y;
      }
      parent.notify("crop", { prop: "updateRotatePan", onPropertyChange: false });
      if (parent.isCropTab) {
        parent.panPoint.totalPannedInternalPoint.x = parent.img.destLeft - initialDestLeft;
        parent.panPoint.totalPannedInternalPoint.y = parent.img.destTop - initialDestTop;
      }
      var temp = this.lowerContext.filter;
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: true, isRotatePan: true }
      });
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
      parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
      parent.img.destTop += parent.panPoint.currentPannedPoint.y;
      parent.panPoint.totalPannedClientPoint.x = parent.img.destLeft - destLeft;
      parent.panPoint.totalPannedClientPoint.y = parent.img.destTop - destTop;
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: cropSelPointColl } }
      });
      parent.transform.degree = tempDegree;
      this.lowerContext.filter = "none";
      if (isCropSelection) {
        if (isDefaultZoom) {
          parent.panPoint.totalPannedClientPoint.x = -parent.panPoint.totalPannedClientPoint.x;
          parent.panPoint.totalPannedClientPoint.y = -parent.panPoint.totalPannedClientPoint.y;
          parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
          parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
          parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
          parent.img.destTop += parent.panPoint.currentPannedPoint.y;
        } else {
          parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
        }
      }
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: {
          ctx: this.lowerContext,
          shape: "pan",
          pen: "pan",
          x: parent.panPoint.currentPannedPoint.x,
          y: parent.panPoint.currentPannedPoint.y,
          panRegion: ""
        }
      });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.activeObj = extend({}, rotatePanActiveObj, {}, true);
      if (parent.activeObj.activePoint) {
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: null
        } });
      }
      this.isReverseRotate = false;
    };
    Transform2.prototype.limitPan = function() {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var img = parent.img;
      if (parent.activeObj.activePoint) {
        if (img.destLeft > startX) {
          parent.img.destLeft = startX;
        }
        if (img.destTop > startY) {
          parent.img.destTop = startY;
        }
        if (img.destLeft + img.destWidth < endX) {
          parent.img.destLeft = endX - img.destWidth;
        }
        if (img.destTop + img.destHeight < endY) {
          parent.img.destTop = endY - img.destHeight;
        }
      }
    };
    Transform2.prototype.pan = function(value, x, y) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (value) {
          parent.togglePan = true;
          parent.notify("shape", {
            prop: "redrawActObj",
            onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: null }
          });
          parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
          parent.notify("selection", { prop: "setPanDown", onPropertyChange: false, value: { panDown: null } });
          if (x || y) {
            x = x ? x : 0;
            y = y ? y : 0;
            if (isNullOrUndefined(this.panMove)) {
              this.panMove = { x, y };
            }
            if (isNullOrUndefined(this.tempPanMove)) {
              this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
            }
            this.panEvent(x, y, true);
            this.tempPanMove = null;
          }
        } else {
          parent.togglePan = parent.currObjType.isCustomCrop = false;
          parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Transform2.prototype.zoom = function(zoomFactor, zoomPoint) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        var value = this.getCurrentZoomFactor(zoomFactor);
        if (isNullOrUndefined(zoomPoint)) {
          this.zoomAction(value, zoomPoint);
        } else {
          var type = value > 0 ? "zoomIn" : "zoomOut";
          var absValue = Math.abs(value) * 10;
          for (var i = 0; i < absValue; i++) {
            parent.notify("draw", {
              prop: "performPointZoom",
              onPropertyChange: false,
              value: { x: zoomPoint.x, y: zoomPoint.y, type, isResize: null }
            });
          }
        }
      }
    };
    Transform2.prototype.getCurrentZoomFactor = function(zoomFactor) {
      return zoomFactor >= 1 ? this.prevZoomValue < 1 ? zoomFactor - this.prevZoomValue : (zoomFactor - this.prevZoomValue) * 0.1 : zoomFactor - this.prevZoomValue;
    };
    Transform2.prototype.setCurrPanRegion = function(region, type, obj) {
      var panRegion = region;
      if (region === "") {
        panRegion = type === "horizontal" ? "horizontal" : type === "vertical" ? "vertical" : region;
      } else if (region === "horizontal") {
        panRegion = type === "horizontal" ? "horizontalVertical" : type === "vertical" ? "verticalHorizontal" : type === 90 ? "vertical" : type === -90 ? "horizontal" : region;
      } else if (region === "vertical") {
        panRegion = type === "horizontal" ? "horizontalVertical" : type === "vertical" ? "verticalHorizontal" : type === 90 ? "horizontal" : type === -90 ? "vertical" : region;
      } else {
        panRegion = type === "horizontal" ? "vertical" : type === "vertical" ? "horizontal" : region;
      }
      obj["panRegion"] = panRegion;
    };
    Transform2.prototype.rotate = function(degree, obj) {
      var parent = this.parent;
      var isRotate = false;
      if (!parent.disabled && parent.isImageLoaded && degree % 90 === 0) {
        this.rotateImage(degree);
      }
      obj["isRotate"] = isRotate;
    };
    Transform2.prototype.flip = function(direction) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        this.flipImage(direction);
      }
    };
    Transform2.prototype.update = function() {
      var parent = this.parent;
      var toolbarHeight = 0;
      var isFrameToolbar = false;
      var isActiveObj = false;
      var freehandObj = { bool: false };
      var straightenObj = { bool: parent.isStraightening };
      var cxtTbarHeight = 0;
      var ctToolbar = parent.element.querySelector("#" + parent.element.id + "_contextualToolbar");
      var ctWrapper = parent.element.querySelector(".e-contextual-toolbar-wrapper");
      var hdWrapper = parent.element.querySelector("#" + parent.element.id + "_headWrapper");
      if (parent.isImageLoaded) {
        var isCropSelection = false;
        var splitWords = void 0;
        if (Browser.isDevice) {
          if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (parent.currObjType.isCustomCrop) {
            isCropSelection = true;
          } else if (splitWords && splitWords[0] === "crop") {
            isCropSelection = true;
          }
        }
        var frameObj = { bool: null };
        parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObj } });
        if (!straightenObj["bool"] && (ctToolbar && !ctToolbar.parentElement.classList.contains("e-hide") || hdWrapper && !hdWrapper.parentElement.classList.contains("e-hide"))) {
          ctWrapper.classList.add("e-hide");
          if (!isCropSelection) {
            parent.okBtn(null, true);
          }
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: freehandObj } });
        if (freehandObj["bool"]) {
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        if (parent.activeObj.shape !== void 0) {
          isActiveObj = true;
          if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
            parent.notify("shape", {
              prop: "redrawActObj",
              onPropertyChange: false,
              value: { x: null, y: null, isMouseDown: null }
            });
            parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
          } else {
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
          }
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
      }
      var tempFilter = this.lowerContext.filter;
      var canvasWrapper = parent.element.querySelector("#" + parent.element.id + "_canvasWrapper");
      if (canvasWrapper) {
        canvasWrapper.style.width = parent.element.offsetWidth - 2 + "px";
      }
      parent.lowerCanvas.width = parent.upperCanvas.width = parent.element.offsetWidth - 2;
      if (parent.toolbarTemplate) {
        toolbarHeight = parent.element.querySelector("#" + parent.element.id + "_toolbarArea").clientHeight;
      } else if (parent.element.querySelector("#" + parent.element.id + "_toolbar")) {
        toolbarHeight = parent.element.querySelector("#" + parent.element.id + "_toolbar").clientHeight;
        if (toolbarHeight === 0 && parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1) {
          var obj = { toolbarHeight: 0 };
          parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj } });
          toolbarHeight = obj["toolbarHeight"];
        }
      }
      var ctxTbarArea = parent.element.querySelector("#" + parent.element.id + "_contextualToolbarArea");
      if (Browser.isDevice && straightenObj["bool"] && ctxTbarArea) {
        cxtTbarHeight = ctxTbarArea.clientHeight;
      }
      parent.notify("toolbar", { prop: "setToolbarHeight", value: { height: toolbarHeight } });
      if (Browser.isDevice) {
        if (canvasWrapper) {
          canvasWrapper.style.height = parent.element.offsetHeight - (2 * toolbarHeight + cxtTbarHeight) - 4 + "px";
        }
      } else {
        if (canvasWrapper) {
          canvasWrapper.style.height = parent.element.offsetHeight - toolbarHeight - 2 + "px";
        }
      }
      parent.lowerCanvas.height = parent.upperCanvas.height = parseFloat(canvasWrapper.style.height);
      this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      parent.canvasFilter = this.lowerContext.filter;
      parent.initialAdjustmentValue = this.lowerContext.filter;
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      if (parent.isImageLoaded) {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.lowerContext.filter = tempFilter;
        parent.initialAdjustmentValue = tempFilter;
        parent.canvasFilter = this.lowerContext.filter;
        if (parent.isImageLoaded) {
          showSpinner(parent.element);
          parent.element.style.opacity = "0.5";
        }
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (canvasWrapper) {
          canvasWrapper.style.width = parent.element.offsetWidth - 2 + "px";
          canvasWrapper.style.height = parent.element.offsetHeight + "px";
          var obj_1 = { toolbarHeight: 0 };
          parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj: obj_1 } });
          if (Browser.isDevice) {
            canvasWrapper.style.height = parseFloat(canvasWrapper.style.height) - 2 * obj_1["toolbarHeight"] - cxtTbarHeight - 4 + "px";
          } else {
            canvasWrapper.style.height = parseFloat(canvasWrapper.style.height) - obj_1["toolbarHeight"] - 2 + "px";
          }
        }
        parent.lowerCanvas.width = parent.upperCanvas.width = parseFloat(canvasWrapper.style.width);
        parent.lowerCanvas.height = parent.upperCanvas.height = parseFloat(canvasWrapper.style.height);
        this.lowerContext.filter = tempFilter;
        var obj = { width: 0, height: 0 };
        this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight, obj);
        var maxDimension = obj;
        if (straightenObj["bool"] && parent.transform.cropZoomFactor !== 0) {
          maxDimension.width += maxDimension.width * parent.transform.cropZoomFactor;
          maxDimension.height += maxDimension.height * parent.transform.cropZoomFactor;
        } else if (parent.transform.defaultZoomFactor > 0) {
          maxDimension.width += maxDimension.width * parent.transform.defaultZoomFactor;
          maxDimension.height += maxDimension.height * parent.transform.defaultZoomFactor;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "") {
          if (parent.transform.defaultZoomFactor > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
          }
          parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
        } else {
          parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
          parent.notify("draw", {
            prop: "updateCurrTransState",
            onPropertyChange: false,
            value: { type: "initial", isPreventDestination: null, isRotatePan: null }
          });
          var temp = this.lowerContext.filter;
          parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
          this.lowerContext.filter = temp;
          parent.notify("draw", {
            prop: "updateCurrTransState",
            onPropertyChange: false,
            value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
          });
        }
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
        var obj1 = { defToolbarItems: null };
        parent.notify("toolbar", { prop: "getDefToolbarItems", value: { obj: obj1 } });
        if (obj1["defToolbarItems"] && obj1["defToolbarItems"].length > 0 && document.getElementById(parent.element.id + "_toolbar")) {
          var toolbar_1 = getComponent(parent.element.id + "_toolbar", "toolbar");
          toolbar_1.refreshOverflow();
          if (ctWrapper && !straightenObj["bool"]) {
            ctWrapper.classList.add("e-hide");
          }
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (isActiveObj) {
          var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
          parent.objColl.pop();
          if (activeObj.activePoint.width !== 0 && activeObj.activePoint.height !== 0) {
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
            parent.objColl.push(activeObj);
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
            });
            activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
            parent.objColl.pop();
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
            if (straightenObj["bool"]) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj } });
            }
            if (parent.activeObj.shape === "rectangle" || parent.activeObj.shape === "ellipse" || parent.activeObj.shape === "text" || parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path" || parent.activeObj.shape === "image") {
              parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
            }
          }
        }
        if (freehandObj["bool"]) {
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
        }
        if (isFrameToolbar) {
          parent.notify("toolbar", { prop: "callFrameToolbar", onPropertyChange: false });
        } else if (parent.isResize) {
          parent.aspectWidth = Math.ceil(parent.img.destWidth);
          parent.aspectHeight = Math.ceil(parent.img.destHeight);
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        }
        if ((parent.transform.degree !== 0 || parent.transform.currFlipState !== "") && parent.transform.defaultZoomFactor > 0) {
          var totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, null, true);
          var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, null, true);
          var totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, null, true);
          this.zoomAction(0.1);
          this.zoomAction(-0.1);
          if (parent.transform.degree === 0) {
            parent.img.destLeft += totalPannedPoint.x;
            parent.img.destTop += totalPannedPoint.y;
            parent.panPoint.totalPannedPoint = totalPannedPoint;
            parent.notify("draw", { prop: "updateFlipPan", value: { tempSelectionObj: null } });
          } else {
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.panPoint.totalPannedClientPoint = totalPannedClientPoint;
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
            parent.isCropTab = true;
            this.rotatePan();
            parent.isCropTab = false;
          }
        } else if (parent.transform.degree !== 0 && parent.transform.cropZoomFactor > 0) {
          parent.transform.zoomFactor = 0;
          parent.transform.cropZoomFactor = null;
          parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
        }
      }
    };
    Transform2.prototype.calcMaxDimension = function(width, height, obj, isImgShape) {
      var object = { toolbarHeight: 0 };
      var parent = this.parent;
      parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj: object } });
      var canvasMaxWidth = isImgShape ? parent.element.clientWidth / 3 : parent.element.clientWidth;
      var canvasMaxHeight = isImgShape ? (parent.element.clientHeight - object["toolbarHeight"]) / 3 : parent.element.clientHeight - object["toolbarHeight"];
      canvasMaxHeight = Browser.isDevice ? canvasMaxHeight - object["toolbarHeight"] : canvasMaxHeight;
      if (Browser.isDevice && parent.isStraightening) {
        var cxtTbar = parent.element.querySelector("#" + parent.element.id + "_contextualToolbarArea");
        canvasMaxHeight -= cxtTbar ? cxtTbar.clientHeight : 0;
      }
      if (!isImgShape && parent.element.clientHeight === 0) {
        canvasMaxHeight = 0;
      }
      if (isNullOrUndefined(isImgShape)) {
        if (canvasMaxWidth > 30) {
          canvasMaxWidth -= 30;
        }
        if (canvasMaxHeight > 30) {
          canvasMaxHeight -= 30;
        }
      }
      var widthScale = canvasMaxWidth / width;
      var heightScale = canvasMaxHeight / height;
      var cssMaxWidth = Math.min(width, canvasMaxWidth);
      var cssMaxHeight = Math.min(height, canvasMaxHeight);
      if (widthScale < 1 && widthScale < heightScale) {
        cssMaxWidth = width * widthScale;
        cssMaxHeight = height * widthScale;
      } else if (heightScale < 1 && heightScale < widthScale) {
        cssMaxWidth = width * heightScale;
        cssMaxHeight = height * heightScale;
      }
      if (isNullOrUndefined(isImgShape)) {
        var cropObj = { bool: null };
        parent.notify("crop", {
          prop: "getPreventScaling",
          onPropertyChange: false,
          value: { obj: cropObj }
        });
        if (cropObj["bool"] && parent.cropObj.activeObj.activePoint && parent.cropObj.activeObj.activePoint.width !== 0 && parent.cropObj.activeObj.activePoint.height !== 0) {
          cssMaxWidth = parent.cropObj.activeObj.activePoint.width;
          cssMaxHeight = parent.cropObj.activeObj.activePoint.height;
        }
      }
      if (obj) {
        obj["width"] = cssMaxWidth;
        obj["height"] = cssMaxHeight;
      }
      return { width: cssMaxWidth, height: cssMaxHeight };
    };
    Transform2.prototype.updatePanPoints = function(x, y) {
      var parent = this.parent;
      var tempActObj = extend({}, parent.activeObj, {}, true);
      var tempDestLeft = parent.img.destLeft;
      var tempDestTop = parent.img.destTop;
      if (isNullOrUndefined(this.tempPanMove)) {
        this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
      }
      var xDiff = this.panMove.x - this.tempPanMove.x;
      var yDiff = this.panMove.y - this.tempPanMove.y;
      if (x || y) {
        xDiff = x;
        yDiff = y;
      }
      parent.img.destLeft += xDiff;
      parent.img.destTop += yDiff;
      this.limitPan();
      var obj = { bool: null };
      var object = { isIntersect: null };
      parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      parent.notify("draw", { prop: "isSelOutsideImg", onPropertyChange: false, value: { obj } });
      var count = 0;
      while (parent.transform.straighten !== 0 && (object["isIntersect"] || obj["bool"])) {
        count++;
        parent.img.destLeft = tempDestLeft;
        parent.img.destTop = tempDestTop;
        if (xDiff !== 0 && xDiff > 0) {
          xDiff -= 1;
        } else if (xDiff !== 0 && xDiff < 0) {
          xDiff += 1;
        }
        if (yDiff !== 0 && yDiff > 0) {
          yDiff -= 1;
        } else if (yDiff !== 0 && yDiff < 0) {
          yDiff += 1;
        }
        if (xDiff === 0 && yDiff === 0 || count === 200) {
          break;
        }
        parent.img.destLeft += xDiff;
        parent.img.destTop += yDiff;
        this.limitPan();
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
        parent.notify("draw", { prop: "isSelOutsideImg", onPropertyChange: false, value: { obj } });
      }
      parent.activeObj = tempActObj;
      return { x: parent.img.destLeft - tempDestLeft, y: parent.img.destTop - tempDestTop };
    };
    Transform2.prototype.resizeImage = function(width, height) {
      var parent = this.parent;
      var temp = true;
      var temp1 = true;
      parent.allowDownScale = false;
      parent.img.srcLeft = 0;
      parent.img.srcTop = 0;
      parent.isAspectRatio = true;
      var minimum = [];
      parent.img.srcWidth = parent.baseImgCanvas.width;
      parent.img.srcHeight = parent.baseImgCanvas.height;
      if (parent.resizeSrc && parent.resizeSrc.width !== 0 && parent.resizeSrc.height !== 0) {
        parent.img.srcLeft = parent.resizeSrc.startX;
        parent.img.srcTop = parent.resizeSrc.startY;
        parent.img.srcWidth = parent.resizeSrc.width;
        parent.img.srcHeight = parent.resizeSrc.height;
      }
      while ((width < parent.img.destWidth || height < parent.img.destHeight) && temp1) {
        this.zoomAction(-0.1, null, true, true);
        if (width > parent.img.destWidth || height > parent.img.destHeight) {
          while (width > parent.img.destWidth || height > parent.img.destHeight) {
            this.zoomAction(0.0125, null, true, true);
            temp1 = false;
            minimum.push(parent.img.destWidth);
          }
        }
      }
      while ((width > parent.img.destWidth || height > parent.img.destHeight) && temp1 && temp) {
        this.zoomAction(0.1, null, true, true);
        if (width < parent.img.destWidth || height < parent.img.destHeight) {
          while (width < parent.img.destWidth) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
            minimum.push(parent.img.destWidth);
          }
        }
      }
      var nearestNumber = minimum[0];
      var smallestDifference = Math.abs(parent.img.destWidth - nearestNumber);
      for (var _i = 0, minimum_1 = minimum; _i < minimum_1.length; _i++) {
        var num = minimum_1[_i];
        var difference = Math.abs(width - num);
        if (difference < smallestDifference) {
          nearestNumber = num;
          smallestDifference = difference;
        }
      }
      if (nearestNumber < width && temp) {
        this.zoomAction(-0.0125, null, true, true);
        temp = false;
      }
      if (nearestNumber > width && !temp) {
        this.zoomAction(0.0125, null, true, true);
        temp = false;
      }
      this.zoomAction(0.0125, null, true);
      parent.allowDownScale = true;
      this.zoomAction(-0.0125, null, true);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = extend({}, this.prevResizeCurrObj, {}, true);
      parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
        operation: "resize",
        previousObj: prevObj,
        previousObjColl: prevObj.objColl,
        previousPointColl: prevObj.pointColl,
        previousSelPointColl: prevObj.selPointColl,
        previousCropObj: prevCropObj,
        previousText: null,
        currentText: null,
        previousFilter: null,
        isCircleCrop: parent.isCircleCrop
      } });
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
    };
    Transform2.prototype.resizeCrop = function(width, height) {
      var parent = this.parent;
      var temp = true;
      var obj1 = { prevObj: parent.prevObj };
      parent.cropObj = extend({}, parent.prevCropObj, {}, true);
      parent.allowDownScale = false;
      parent.notify("toolbar", { prop: "getPrevObj", onPropertyChange: false, value: { obj: obj1 } });
      var activeObj = extend({}, obj1["prevObj"]["activeObj"], {}, true);
      obj1["prevObj"]["activeObj"] = extend({}, parent.activeObj, {}, true);
      parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj1["prevObj"] } });
      parent.objColl = extend([], obj1["prevObj"]["objColl"], [], true);
      parent.pointColl = extend([], obj1["prevObj"]["pointColl"], [], true);
      parent.transform.straighten = 0;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      if (parent.transform.straighten === 0 && !this.isPreventSelect) {
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
      }
      var tempwidth = width;
      var tempheight = height;
      var tempZoom = false;
      if (height >= width && height <= Math.ceil(parent.img.destHeight)) {
        while (height <= Math.ceil(parent.img.destHeight) && temp) {
          this.zoomAction(-0.1, null, true, true);
          if (width > parent.img.destWidth || height > parent.img.destHeight) {
            while (width > parent.img.destWidth || height > parent.img.destHeight) {
              this.zoomAction(0.0125, null, true, true);
              temp = false;
            }
          }
        }
      } else if (height <= width && width < parent.img.destWidth) {
        while (width < parent.img.destWidth && temp) {
          this.zoomAction(-0.1, null, true, true);
          if (width > parent.img.destWidth || height > parent.img.destHeight) {
            while (width > parent.img.destWidth || height > parent.img.destHeight) {
              this.zoomAction(0.0125, null, true, true);
              temp = false;
            }
          }
        }
      } else if (height >= width && height >= parent.img.destHeight) {
        while (height >= parent.img.destHeight && temp) {
          this.zoomAction(0.1, null, true, true);
        }
      } else if (width >= height && width >= parent.img.destWidth) {
        while (width >= parent.img.destWidth && temp) {
          this.zoomAction(0.1, null, true, true);
        }
        if (width < parent.img.destWidth && height < parent.img.destHeight) {
          while (width < parent.img.destWidth && height < parent.img.destHeight) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
          }
          this.zoomAction(0.0125, null, true, true);
        }
      } else if (height > parent.img.destHeight && width > parent.img.destWidth) {
        while (height > parent.img.destHeight && width > parent.img.destWidth && temp) {
          this.zoomAction(0.1, null, true, true);
        }
        if (width < parent.img.destWidth && height < parent.img.destHeight) {
          while (width < parent.img.destWidth && height < parent.img.destHeight) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
          }
          this.zoomAction(0.0125, null, true, true);
        }
      }
      this.resizeImg(activeObj, width, height);
      width = tempwidth;
      height = tempheight;
      if (height !== parent.img.destHeight || width !== parent.img.destWidth) {
        while (height > parent.img.destHeight || width > parent.img.destWidth) {
          this.zoomAction(0.0125, null, true, true);
          tempZoom = true;
        }
        if (tempZoom) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = false;
        }
      }
      if (height !== parent.img.destHeight || width !== parent.img.destWidth) {
        while (height < parent.img.destHeight || width < parent.img.destWidth) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = true;
        }
        if (tempZoom) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = false;
        }
      }
      obj1["prevObj"]["activeObj"] = extend({}, activeObj, {}, true);
      this.zoomAction(0.0125, null, true);
      parent.allowDownScale = this.preventDownScale ? false : true;
      parent.isCropTab = false;
      this.zoomAction(-0.0125, null, true);
      parent.aspectWidth = width;
      parent.aspectHeight = height;
    };
    Transform2.prototype.resizeImg = function(activeObj, width, height) {
      var parent = this.parent;
      var widthRatio = width / parent.img.destWidth;
      var heightRatio = height / parent.img.destHeight;
      if (activeObj.shape) {
        parent.currSelectionPoint = activeObj;
        parent.notify("crop", { prop: "setInitCrop", onPropertyChange: false, value: { bool: true } });
      } else if (parent.img.srcWidth === parent.baseImgCanvas.width && parent.img.srcHeight === parent.baseImgCanvas.height) {
        parent.currSelectionPoint = null;
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      if (isNullOrUndefined(parent.currSelectionPoint)) {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: {
            type: "custom",
            startX: parent.img.destLeft,
            startY: parent.img.destTop,
            width: parent.img.destWidth,
            height: parent.img.destHeight
          }
        });
      } else {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      width = parent.activeObj.activePoint.width * widthRatio;
      height = parent.activeObj.activePoint.height * heightRatio;
      var sx = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2 - width / 2;
      var sy = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2 - height / 2;
      var count = 0;
      while (Browser.isDevice && count < 500 && (sx < 0 || sy < 0 || sx + width > parent.img.destWidth || sy + height > parent.img.destHeight)) {
        count++;
        width -= 1;
        height -= 1;
        sx = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2 - width / 2;
        sy = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2 - height / 2;
      }
      parent.transform.defaultZoomFactor = 0;
      parent.notify("draw", { prop: "setResizeSelect", value: { bool: true } });
      parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
      parent.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type: "custom", startX: sx, startY: sy, width, height }
      });
      parent.notify("draw", { prop: "setResizeSelect", value: { bool: false } });
      if (parent.transform.straighten !== 0) {
        var obj = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        while (obj["arr"][0] || obj["arr"][1] || obj["arr"][2] || obj["arr"][3]) {
          this.zoomAction(0.0125, null, true);
          parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
          parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        }
      }
      parent.isCropToolbar = true;
      parent.crop();
      parent.isCropToolbar = false;
    };
    Transform2.prototype.updateResize = function() {
      var parent = this.parent;
      parent.prevCropObj = extend({}, parent.cropObj, {}, true);
      var currObject = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: currObject } });
      parent.prevObj = currObject["currObj"];
      if (parent.currSelectionPoint && parent.prevCropObj.activeObj.shape) {
        parent.prevObj.activeObj = extend({}, parent.prevCropObj.activeObj, {}, true);
      }
      parent.prevObj.objColl = extend([], parent.objColl, [], true);
      parent.prevObj.pointColl = extend([], parent.pointColl, [], true);
      parent.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      parent.prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      parent.resizeSrc = {
        startX: parent.img.srcLeft,
        startY: parent.img.srcTop,
        width: parent.img.srcWidth,
        height: parent.img.srcHeight
      };
    };
    Transform2.prototype.resize = function(width, height, isAspectRatio) {
      var parent = this.parent;
      parent.isResize = true;
      if (isNullOrUndefined(parent.prevCropObj) && isNullOrUndefined(parent.prevObj)) {
        parent.notify("transform", { prop: "updateResize", value: { bool: false } });
      }
      var aspectIcon = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
      var nonAspectIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
      if (aspectIcon && nonAspectIcon) {
        parent.notify("toolbar", { prop: "initResizeToolbar" });
        if (Browser.isDevice) {
          parent.notify("toolbar", { prop: "init-main-toolbar", value: { isApplyBtn: false, isDevice: true, isOkBtn: true, isResize: true } });
        }
      }
      var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
      var aspectHeight = aspectRatioHeight.value === "" ? aspectRatioHeight.placeholder : aspectRatioHeight.value;
      var resizeEventArgs = {
        cancel: false,
        previousWidth: Math.ceil(parent.img.destWidth),
        previousHeight: Math.ceil(parent.img.destHeight),
        width: Math.ceil(width),
        height: height && height !== 0 ? Math.ceil(height) : isAspectRatio ? Math.ceil(parseFloat(aspectHeight)) : Math.ceil(parent.img.destHeight),
        isAspectRatio: isAspectRatio ? isAspectRatio : false
      };
      parent.trigger("resizing", resizeEventArgs);
      if (!resizeEventArgs.cancel) {
        this.resizeEventHandler(resizeEventArgs);
      } else if (parent.aspectHeight && parent.aspectWidth) {
        parent.aspectHeight = resizeEventArgs.previousHeight;
        parent.aspectWidth = resizeEventArgs.previousWidth;
      }
    };
    Transform2.prototype.resizeEventHandler = function(args) {
      var parent = this.parent;
      var isRotate;
      var aspectRatioWidth = parent.element.querySelector("#" + parent.element.id + "_resizeWidth");
      var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
      var heightElem = parent.element.querySelector(".e-ie-toolbar-e-resize-height-input .e-textbox");
      var widthElem = parent.element.querySelector(".e-ie-toolbar-e-resize-width-input .e-textbox");
      if (args.isAspectRatio) {
        if (this.resizedImgAngle == null || this.resizedImgAngle !== parent.transform.degree) {
          this.resizedImgAngle = parent.transform.degree;
          isRotate = true;
        }
        if (isRotate) {
          parent.notify("transform", { prop: "resizeImage", value: { width: args.width, height: 0 } });
          var originalWidth2 = parent.img.destWidth;
          var originalHeight2 = parent.img.destHeight;
          var aspectRatioWidthValue = void 0;
          aspectRatioWidthValue = parseFloat(aspectRatioWidth.value === "" ? aspectRatioWidth.placeholder : aspectRatioWidth.value);
          if (aspectRatioHeight) {
            var value = aspectRatioWidthValue / (originalWidth2 / originalHeight2);
            var height = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
            getComponent(aspectRatioHeight, "numerictextbox").value = height;
            aspectRatioHeight.value = height.toString() + " px";
            parent.aspectHeight = height;
            if (aspectRatioWidth && aspectRatioWidth.value === "") {
              var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value === "" ? aspectRatioHeight.placeholder : aspectRatioHeight.value);
              value = aspectRatioHeightValue / (originalHeight2 / originalWidth2);
              var width = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
              getComponent(aspectRatioWidth, "numerictextbox").value = width;
              aspectRatioWidth.value = width.toString() + " px";
              parent.aspectWidth = width;
            }
          } else if (heightElem) {
            var value = aspectRatioWidthValue / (originalWidth2 / originalHeight2);
            var height = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
            heightElem.value = height.toString();
            parent.aspectHeight = height;
            if (widthElem && widthElem.value === "") {
              var aspectRatioHeightValue = parseFloat(heightElem.value === "" ? heightElem.placeholder : heightElem.value);
              value = aspectRatioHeightValue / (originalHeight2 / originalWidth2);
              var width = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
              widthElem.value = width.toString();
              parent.aspectWidth = width;
            }
          }
        } else {
          parent.notify("transform", { prop: "resizeImage", value: { width: args.width, height: null } });
        }
      } else {
        if (this.resizedImgAngle !== null && this.resizedImgAngle !== parent.transform.degree) {
          this.resizedImgAngle = parent.transform.degree;
          isRotate = true;
        }
        if (isRotate) {
          parent.notify("transform", { prop: "setPreventDownScale", value: { bool: true } });
          parent.notify("transform", { prop: "resizeCrop", value: { width: args.width, height: args.height } });
          parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
          parent.okBtn(null, true);
          parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
          parent.resizeSrc = {
            startX: parent.img.srcLeft,
            startY: parent.img.srcTop,
            width: parent.img.srcWidth,
            height: parent.img.srcHeight
          };
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
          parent.notify("transform", { prop: "setPreventDownScale", value: { bool: false } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          parent.notify("transform", { prop: "resizeCrop", value: { width: args.width, height: args.height } });
        }
      }
      this.resizedImgAngle = parent.transform.degree;
    };
    Transform2.prototype.straightenImage = function(degree) {
      var parent = this.parent;
      if (parent.toolbar && parent.toolbar.length === 0) {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      parent.notify("toolbar", { prop: "performCropTransformClick", value: { shape: null } });
      parent.setStraighten(degree);
      parent.okBtn();
    };
    return Transform2;
  }()
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/undo-redo.js
var UndoRedo = (
  /** @class */
  function() {
    function UndoRedo2(parent) {
      this.undoRedoStep = 0;
      this.undoRedoColl = [];
      this.appliedUndoRedoColl = [];
      this.tempUndoRedoColl = [];
      this.tempUndoRedoStep = 0;
      this.isPreventing = false;
      this.parent = parent;
      this.addEventListener();
    }
    UndoRedo2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    UndoRedo2.prototype.addEventListener = function() {
      this.parent.on("undo-redo", this.undoRedo, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    UndoRedo2.prototype.removeEventListener = function() {
      this.parent.off("undo-redo", this.undoRedo);
      this.parent.off("destroyed", this.destroy);
    };
    UndoRedo2.prototype.initializeUrPvtProp = function() {
      if (this.parent.lowerCanvas) {
        this.lowerContext = this.parent.lowerCanvas.getContext("2d");
      }
      if (this.parent.upperCanvas) {
        this.upperContext = this.parent.upperCanvas.getContext("2d");
      }
    };
    UndoRedo2.prototype.undoRedo = function(args) {
      this.initializeUrPvtProp();
      switch (args.prop) {
        case "updateUndoRedoColl":
          this.updateUrc(args.value["operation"], args.value["previousObj"], args.value["previousObjColl"], args.value["previousPointColl"], args.value["previousSelPointColl"], args.value["previousCropObj"], args.value["previousText"], args.value["currentText"], args.value["previousFilter"], args.value["isCircleCrop"]);
          break;
        case "refreshUrc":
          this.refreshUrc(args.value["bool"]);
          break;
        case "updateCurrUrc":
          this.updateCurrUrc(args.value["type"], args.value["isCancel"]);
          break;
        case "call-undo":
          this.callUndo();
          break;
        case "call-redo":
          this.callRedo();
          break;
        case "undo":
          this.undo();
          break;
        case "redo":
          this.redo();
          break;
        case "updateUrObj":
          this.updateUrObj(args.value["objColl"], args.value["operation"]);
          break;
        case "updateUndoRedo":
          this.updateUndoRedo(args.value ? args.value["operation"] : null);
          break;
        case "getAppliedUndoRedoColl":
          args.value["obj"]["appliedUndoRedoColl"] = this.appliedUndoRedoColl;
          break;
        case "getUndoRedoStep":
          args.value["obj"]["undoRedoStep"] = this.undoRedoStep;
          break;
        case "setUndoRedoStep":
          this.undoRedoStep = args.value["step"];
          break;
        case "undoDefault":
          this.undoDefault(args.value["obj"]);
          break;
        case "setPreventUR":
          this.isPreventing = args.value["bool"];
          break;
        case "updateUndoRedoStack":
          if (args.value && args.value["isPenDraw"]) {
            this.updateUndoRedoStack(args.value["isPenDraw"]);
          } else {
            this.updateUndoRedoStack();
          }
          break;
        case "reset":
          this.reset();
          break;
      }
    };
    UndoRedo2.prototype.getModuleName = function() {
      return "undo-redo";
    };
    UndoRedo2.prototype.reset = function() {
      this.tempCurrSelPoint = null;
      this.undoRedoStep = 0;
      this.undoRedoColl = [];
      this.appliedUndoRedoColl = [];
      this.tempActObj = null;
      this.tempUndoRedoColl = [];
      this.tempUndoRedoStep = 0;
      this.isPreventing = false;
    };
    UndoRedo2.prototype.refreshUrc = function(refreshToolbar) {
      var parent = this.parent;
      refreshToolbar = refreshToolbar ? refreshToolbar : false;
      if (refreshToolbar) {
        parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: true } });
        this.tempUndoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        this.tempUndoRedoStep = this.undoRedoStep;
      }
      parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      this.undoRedoColl = this.undoRedoColl.slice(0, this.undoRedoStep);
      this.appliedUndoRedoColl = this.appliedUndoRedoColl.slice(0, this.undoRedoStep);
      parent.isUndoRedo = parent.currObjType.isUndoAction = false;
      parent.notify("toolbar", { prop: "enable-disable-btns" });
    };
    UndoRedo2.prototype.updateCurrUrc = function(type, isCancel) {
      var parent = this.parent;
      if (parent.isResize || this.isPreventing || parent.noPushUndo) {
        return;
      }
      parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      if (type === "ok") {
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: false } });
        var collection = this.tempUndoRedoColl.length > 0 ? extend([], this.tempUndoRedoColl, [], true) : extend([], this.undoRedoColl, [], true);
        var prevObj = this.undoRedoColl[this.undoRedoColl.length - 1];
        var appliedURColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
        var prevTransform = prevObj ? extend({}, prevObj.previousObj, {}, true) : null;
        if (isNullOrUndefined(appliedURColl)) {
          if (this.undoRedoColl[0]) {
            prevObj.previousCropObj = collection[0].previousCropObj;
            prevObj.previousObj = collection[0].previousObj;
            prevObj.previousObjColl = collection[0].previousObjColl;
            prevObj.previousPointColl = collection[0].previousPointColl;
            prevObj.previousText = collection[0].previousText;
          }
        } else if (prevObj.operation !== "imageHFlip" && prevObj.operation !== "imageVFlip") {
          prevObj.previousCropObj = appliedURColl.currentCropObj;
          prevObj.previousObj = appliedURColl.currentObj;
          prevObj.previousObjColl = appliedURColl.currentObjColl;
          prevObj.previousPointColl = appliedURColl.currentPointColl;
          prevObj.previousText = appliedURColl.currentText;
          if (prevObj.operation === "frame" && prevObj.previousObj && prevTransform) {
            prevObj.previousObj.defaultZoom = prevTransform.defaultZoom;
            prevObj.previousObj.zoomFactor = prevTransform.zoomFactor;
            prevObj.previousObj.cropZoom = prevTransform.cropZoom;
          }
        }
        if (prevObj) {
          if (prevObj.operation !== "imageHFlip" && prevObj.operation !== "imageVFlip") {
            var obj = this.getZeroZoomObjPointValue(prevObj.currentObjColl, prevObj.currentPointColl);
            prevObj.currentObjColl = obj["obj"];
            prevObj.currentPointColl = obj["point"];
            var adjObj = { adjustmentLevel: null };
            parent.notify("filter", { prop: "getAdjustmentLevel", onPropertyChange: false, value: { obj: adjObj } });
            prevObj.currentObj.adjustmentLevel = extend({}, adjObj["adjustmentLevel"], {}, true);
            parent.notify("filter", { prop: "setTempAdjVal" });
            prevObj.currentObj.currentFilter = parent.currentFilter;
          }
          this.appliedUndoRedoColl.push(prevObj);
        }
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
      } else if (this.tempUndoRedoColl.length > 0) {
        this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoStep = this.tempUndoRedoStep;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
      }
      var lastObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
      var lastPrevObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 2];
      if (this.appliedUndoRedoColl.length > 16) {
        this.appliedUndoRedoColl.splice(0, 1);
      } else if (!isCancel && lastObj && lastPrevObj) {
        if ((lastObj.operation === "shapeTransform" && lastPrevObj.operation === "shapeTransform" || lastObj.operation === "shapeInsert" && lastPrevObj.operation === "shapeInsert") && JSON.stringify(lastObj.currentObjColl) === JSON.stringify(lastPrevObj.currentObjColl) || lastObj.operation === "freehand-draw" && lastPrevObj.operation === "freehand-draw" && JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl) || lastObj.operation === "freehanddrawCustomized" && lastPrevObj.operation === "freehanddrawCustomized" && JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl)) {
          this.appliedUndoRedoColl.splice(this.appliedUndoRedoColl.length - 1, 1);
        }
      }
      this.undoRedoColl = [];
      this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
      if (type === "ok") {
        this.undoRedoStep = this.undoRedoColl.length;
        parent.notify("toolbar", { prop: "enable-disable-btns" });
      }
      if (parent.transform.zoomFactor > 0) {
        parent.togglePan = true;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      }
    };
    UndoRedo2.prototype.cancelCropSelection = function() {
      var parent = this.parent;
      var isCropSelection = false;
      var splitWords;
      if (parent.activeObj.shape) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (parent.currObjType.isCustomCrop || splitWords && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection) {
        parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
      }
      if (this.tempUndoRedoColl.length !== 0 || this.tempUndoRedoStep !== 0) {
        this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoStep = this.tempUndoRedoStep;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
        parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      }
    };
    UndoRedo2.prototype.refreshToolbarActions = function() {
      var parent = this.parent;
      if (parent.activeObj.shape) {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "shapes",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      } else {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    UndoRedo2.prototype.applyCurrentChanges = function() {
      var parent = this.parent;
      parent.currObjType.isFiltered = false;
      if (parent.transform.zoomFactor === 0) {
        parent.togglePan = false;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
      }
      if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
        parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
      }
      if (parent.togglePen) {
        parent.togglePen = false;
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      }
      if (this.appliedUndoRedoColl.length > 0) {
        this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
      }
    };
    UndoRedo2.prototype.callUndo = function() {
      this.applyCurrentChanges();
      this.undo();
    };
    UndoRedo2.prototype.callRedo = function() {
      this.applyCurrentChanges();
      this.redo();
    };
    UndoRedo2.prototype.undo = function() {
      var parent = this.parent;
      this.cancelCropSelection();
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: false } });
      if (!parent.disabled && parent.isImageLoaded) {
        if (this.undoRedoStep > 0) {
          this.refreshToolbarActions();
          if (parent.activeObj.activePoint && parent.activeObj.activePoint.width !== 0) {
            this.tempActObj = parent.activeObj;
          }
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.undoRedoStep--;
          parent.notify("toolbar", { prop: "enable-disable-btns" });
          if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
            parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          }
          parent.isUndoRedo = true;
          var obj = this.undoRedoColl[this.undoRedoStep];
          if (this.undoRedoColl.length === this.undoRedoStep) {
            parent.currObjType.isUndoAction = false;
          } else {
            parent.currObjType.isUndoAction = true;
          }
          if (obj.operation !== "textAreaCustomization" && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            parent.textArea.style.display = "none";
          }
          parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: true } });
          var activeObj = void 0;
          parent.cropObj = extend({}, obj.previousCropObj, {}, true);
          parent.afterCropActions = obj.previousObj.afterCropActions;
          this.lowerContext.filter = obj.previousObj.filter;
          parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.previousObj.adjustmentLevel } });
          parent.notify("filter", { prop: "setTempAdjVal" });
          parent.currentFilter = obj.previousObj.currentFilter;
          parent.notify("filter", { prop: "setTempFilVal" });
          parent.canvasFilter = this.lowerContext.filter;
          parent.initialAdjustmentValue = this.lowerContext.filter;
          parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
          switch (obj.operation) {
            case "shapeTransform":
            case "brightness":
            case "contrast":
            case "hue":
            case "saturation":
            case "opacity":
            case "blur":
            case "exposure":
            case "default":
            case "chrome":
            case "cold":
            case "warm":
            case "grayscale":
            case "blackandwhite":
            case "sepia":
            case "invert":
            case "sharpen":
            case "imageRotate":
            case "shapeInsert":
              this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
              break;
            case "freehanddraw":
            case "freehand-draw":
              this.updateFreehandDraw(obj.previousPointColl, obj.previousSelPointColl);
              parent.notify("freehand-draw", {
                prop: "setCurrentFreehandDrawIndex",
                value: { value: parent.pointColl.length }
              });
              break;
            case "freehanddrawCustomized":
              this.updateFreehandDrawCustomized(obj.previousObjColl, obj.previousPointColl);
              break;
            case "deleteFreehandDrawing":
            case "deleteObj":
              this.updateDelete(obj.operation, obj.previousObjColl, obj.previousPointColl, obj.previousSelPointColl);
              break;
            case "textAreaCustomization":
              this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
              this.updateTextAreaCustomization(activeObj, obj.previousObjColl);
              break;
            case "text":
              this.updateText(obj.previousObjColl, true);
              break;
            case "frame":
              parent.transform.zoomFactor = parent.transform.defaultZoomFactor = obj.previousObj.defaultZoom;
              parent.setProperties({ zoomSettings: { zoomFactor: obj.previousObj.zoomFactor } }, true);
              parent.notify("transform", {
                prop: "setPreviousZoomValue",
                onPropertyChange: false,
                value: { previousZoomValue: parent.zoomSettings.zoomFactor }
              });
              extend(parent.frameObj, obj.previousObj.frameObj);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
              break;
            case "imageHFlip":
              this.imageFlip("horizontal", obj.previousObjColl);
              break;
            case "imageVFlip":
              this.imageFlip("vertical", obj.previousObjColl);
              break;
            default:
              this.undoDefault(obj, true);
              parent.notify("filter", { prop: "set-adjustment", value: { operation: obj.operation } });
              parent.notify("filter", { prop: "update-filter", value: { operation: obj.operation, filter: obj.filter } });
              break;
          }
          if (obj.operation === "crop") {
            if (obj.previousObj.currSelectionPoint) {
              parent.currSelectionPoint = extend({}, obj.previousObj.currSelectionPoint, {}, true);
              if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
              }
            }
            parent.updateCropTransformItems();
            parent.notify("draw", {
              prop: "select",
              onPropertyChange: false,
              value: { type: "custom", startX: null, startY: null, width: null, height: null }
            });
            if (parent.isCircleCrop) {
              parent.isCircleCrop = false;
              this.tempCurrSelPoint = extend({}, parent.currSelectionPoint, {}, true);
              parent.currSelectionPoint = null;
            }
            parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isUndoRedo: true } });
            parent.currObjType.isActiveObj = false;
            if (parent.transform.straighten !== 0) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            }
          } else if (obj.operation === "resize" && parent.cropObj && parent.cropObj.activeObj) {
            parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
          }
          if (this.undoRedoColl[this.undoRedoStep - 1] && this.undoRedoColl[this.undoRedoStep - 1].isCircleCrop) {
            parent.isCircleCrop = true;
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          this.endUndoRedo(obj.operation, true);
        }
      }
    };
    UndoRedo2.prototype.redo = function() {
      var parent = this.parent;
      this.cancelCropSelection();
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: false } });
      if (!parent.disabled && parent.isImageLoaded) {
        if (this.undoRedoStep < this.appliedUndoRedoColl.length) {
          this.refreshToolbarActions();
          this.undoRedoStep++;
          parent.notify("toolbar", { prop: "enable-disable-btns" });
          parent.isUndoRedo = true;
          var obj = this.undoRedoColl[this.undoRedoStep - 1];
          if (this.undoRedoColl.length === this.undoRedoStep) {
            parent.currObjType.isUndoAction = false;
          } else {
            parent.currObjType.isUndoAction = true;
          }
          if (obj.operation !== "textAreaCustomization" && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            parent.textArea.style.display = "none";
          }
          parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: true } });
          parent.cropObj = extend({}, obj.currentCropObj, {}, true);
          parent.afterCropActions = obj.currentObj.afterCropActions;
          this.lowerContext.filter = obj.currentObj.filter;
          if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
            parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          }
          parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.currentObj.adjustmentLevel } });
          parent.notify("filter", { prop: "setTempAdjVal" });
          parent.currentFilter = obj.currentObj.currentFilter;
          parent.notify("filter", { prop: "setTempFilVal" });
          parent.canvasFilter = this.lowerContext.filter;
          parent.initialAdjustmentValue = this.lowerContext.filter;
          parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
          var activeObj = void 0;
          switch (obj.operation) {
            case "shapeTransform":
            case "brightness":
            case "contrast":
            case "hue":
            case "saturation":
            case "opacity":
            case "blur":
            case "exposure":
            case "default":
            case "chrome":
            case "cold":
            case "warm":
            case "grayscale":
            case "blackandwhite":
            case "sepia":
            case "invert":
            case "sharpen":
            case "imageRotate":
            case "shapeInsert":
              this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
              break;
            case "freehanddraw":
            case "freehand-draw":
              this.updateFreehandDraw(obj.currentPointColl, obj.currentSelPointColl);
              parent.notify("freehand-draw", {
                prop: "setCurrentFreehandDrawIndex",
                value: { value: parent.pointColl.length }
              });
              break;
            case "freehanddrawCustomized":
              this.updateFreehandDrawCustomized(obj.currentObjColl, obj.currentPointColl);
              break;
            case "deleteFreehandDrawing":
            case "deleteObj":
              this.updateDelete(obj.operation, obj.currentObjColl, obj.currentPointColl, obj.currentSelPointColl);
              break;
            case "textAreaCustomization":
              this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
              this.updateTextAreaCustomization(activeObj, obj.currentObjColl);
              break;
            case "text":
              this.updateText(obj.currentObjColl, false);
              break;
            case "frame":
              extend(parent.frameObj, obj.currentObj.frameObj);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
              break;
            case "imageHFlip":
              this.imageFlip("horizontal", obj.currentObjColl);
              break;
            case "imageVFlip":
              this.imageFlip("vertical", obj.currentObjColl);
              break;
            default:
              parent.objColl = [];
              parent.pointColl = [];
              parent.freehandCounter = 0;
              parent.notify("freehand-draw", {
                prop: "setSelPointColl",
                onPropertyChange: false,
                value: { obj: { selPointColl: [] } }
              });
              parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj.currentObj, isUndoRedo: true } });
              parent.img.destLeft = obj.currentObj.destPoints.startX;
              parent.img.destTop = obj.currentObj.destPoints.startY;
              activeObj = extend({}, parent.activeObj, {}, true);
              parent.objColl = extend([], obj.currentObjColl, [], true);
              parent.pointColl = extend([], obj.currentPointColl, [], true);
              parent.freehandCounter = parent.pointColl.length;
              parent.notify("freehand-draw", {
                prop: "setSelPointColl",
                onPropertyChange: false,
                value: { obj: { selPointColl: extend([], obj.currentSelPointColl, [], true) } }
              });
              parent.transform.straighten = 0;
              this.lowerContext.filter = "none";
              parent.notify("shape", {
                prop: "drawAnnotations",
                onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
              });
              this.lowerContext.filter = obj.currentObj.filter;
              parent.prevStraightenedDegree = parent.transform.straighten;
              parent.activeObj = activeObj;
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
              }
              parent.notify("filter", { prop: "set-adjustment", value: { operation: obj.operation } });
              parent.notify("filter", { prop: "update-filter", value: { operation: obj.operation } });
              break;
          }
          if (obj.operation === "crop" && obj.isCircleCrop) {
            parent.isCircleCrop = true;
            parent.currSelectionPoint = extend({}, this.tempCurrSelPoint, {}, true);
            this.tempCurrSelPoint = null;
          }
          if (obj.operation === "crop" && !obj.isCircleCrop) {
            parent.isCircleCrop = false;
          }
          if (obj.operation === "crop" && obj.currentObj.currSelectionPoint) {
            parent.currSelectionPoint = extend({}, obj.currentObj.currSelectionPoint, {}, true);
            parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: parent.currSelectionPoint } });
          }
          if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
            parent.currSelectionPoint = null;
          }
          if (obj.operation === "resize" && parent.cropObj && parent.cropObj.activeObj) {
            parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
          }
          this.endUndoRedo(obj.operation, false);
        }
      }
    };
    UndoRedo2.prototype.imageFlip = function(type, objColl) {
      var parent = this.parent;
      this.shapeTransform(objColl, null);
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var _a = parent.activeObj, shape = _a.shape, isHorImageFlip = _a.isHorImageFlip, isVerImageFlip = _a.isVerImageFlip;
      parent.objColl.pop();
      if (shape && shape === "image") {
        if (type === "horizontal") {
          if (isNullOrUndefined(isHorImageFlip) && isVerImageFlip) {
            parent.activeObj.isHorImageFlip = true;
            parent.activeObj.isVerImageFlip = null;
            parent.horizontalFlip(this.upperContext, true);
          } else {
            if (isNullOrUndefined(isHorImageFlip) || !isHorImageFlip) {
              parent.activeObj.isHorImageFlip = true;
            } else {
              parent.activeObj.isHorImageFlip = null;
            }
            parent.horizontalFlip(this.upperContext, true);
          }
        } else if (type === "vertical") {
          if (isNullOrUndefined(isVerImageFlip) && isHorImageFlip) {
            parent.activeObj.isVerImageFlip = true;
            parent.activeObj.isHorImageFlip = null;
            parent.verticalFlip(this.upperContext, true);
          } else {
            if (isNullOrUndefined(isVerImageFlip) || !isVerImageFlip) {
              parent.activeObj.isVerImageFlip = true;
            } else {
              parent.activeObj.isVerImageFlip = null;
            }
            parent.verticalFlip(this.upperContext, true);
          }
        }
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      } else {
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true } });
      }
    };
    UndoRedo2.prototype.shapeTransform = function(objColl, pointColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      if (pointColl) {
        parent.pointColl = extend([], pointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateFreehandDraw = function(pointColl, selPointColl) {
      var parent = this.parent;
      parent.pointColl = pointColl;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl } }
      });
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateFreehandDrawCustomized = function(objColl, pointColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      parent.pointColl = pointColl;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateDelete = function(operation, objColl, pointColl, selPointColl) {
      var parent = this.parent;
      if (operation === "deleteFreehandDrawing") {
        parent.pointColl = pointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl } }
        });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      } else if (operation === "deleteObj") {
        parent.objColl = objColl;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateTextAreaCustomization = function(activeObj, objColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      for (var i = 0, len = objColl.length; i < len; i++) {
        if (this.tempActObj) {
          if (this.tempActObj.currIndex === objColl[i].currIndex) {
            activeObj = extend({}, objColl[i], {}, true);
            parent.objColl.splice(i, 1);
            break;
          }
        } else {
          activeObj = extend({}, objColl[objColl.length - 1], {}, true);
          parent.objColl.splice(i, 1);
          break;
        }
      }
      if (activeObj) {
        this.updateTextBox(activeObj);
      }
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
      }
    };
    UndoRedo2.prototype.updateText = function(objColl, allowActiveObj) {
      var parent = this.parent;
      if (this.tempActObj) {
        parent.activeObj = extend({}, this.tempActObj, {}, true);
      }
      if (objColl.length === 0 && parent.objColl.length === 1) {
        this.tempActObj = extend({}, parent.objColl[0], {}, true);
      } else {
        for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
          if (parent.objColl[i] && isNullOrUndefined(objColl[i])) {
            this.tempActObj = extend({}, parent.objColl[i], {}, true);
            break;
          }
          if (objColl[i].currIndex !== parent.objColl[i].currIndex) {
            this.tempActObj = extend({}, parent.objColl[i], {}, true);
            break;
          }
        }
      }
      if (allowActiveObj) {
        parent.activeObj = extend({}, this.tempActObj, {}, true);
      }
      parent.objColl = extend([], objColl, [], true);
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: true }
      });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateTextBox = function(obj) {
      var parent = this.parent;
      this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      var textArea = parent.textArea;
      textArea.style.display = "block";
      textArea.style.fontFamily = obj.textSettings.fontFamily;
      textArea.style.fontSize = obj.textSettings.fontSize + "px";
      textArea.style.color = obj.strokeSettings.strokeColor;
      textArea.style.fontWeight = obj.textSettings.bold ? "bold" : "normal";
      textArea.style.fontStyle = obj.textSettings.italic ? "italic" : "normal";
      textArea.style.border = "2px solid " + parent.themeColl[parent.theme]["primaryColor"];
      textArea.value = obj.keyHistory;
      parent.activeObj = extend({}, obj, {}, true);
      parent.notify("shape", {
        prop: "updateFontStyles",
        onPropertyChange: false,
        value: { isTextBox: null }
      });
      parent.textArea.style.width = parent.activeObj.activePoint.width + "px";
    };
    UndoRedo2.prototype.undoDefault = function(obj, isUndoRedo) {
      this.lowerContext.filter = obj.previousObj.filter;
      var parent = this.parent;
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: [] } }
      });
      parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj.previousObj, isUndoRedo } });
      parent.prevStraightenedDegree = parent.transform.straighten;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.img.destLeft = obj.previousObj.destPoints.startX;
      parent.img.destTop = obj.previousObj.destPoints.startY;
      var activeObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = extend([], obj.previousObjColl, [], true);
      parent.pointColl = extend([], obj.previousPointColl, [], true);
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: extend([], obj.previousSelPointColl, [], true) } }
      });
      parent.transform.straighten = 0;
      this.lowerContext.filter = "none";
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = obj.previousObj.filter;
      parent.activeObj = activeObj;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      }
    };
    UndoRedo2.prototype.endUndoRedo = function(operation, isUndo) {
      var parent = this.parent;
      var frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) && JSON.stringify(parent.frameObj) !== JSON.stringify(frameObj)) {
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true } });
      }
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      if (parent.isCircleCrop && (isUndo && operation !== "crop" || !isUndo)) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      if (parent.transform.zoomFactor > 0) {
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      }
      parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: false } });
      if (parent.activeObj.shape && parent.activeObj.shape.split("-")[0] === "crop") {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: true,
          isCropping: true,
          isZooming: null,
          cType: null
        } });
      } else {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
      parent.notify("toolbar", { prop: "enable-disable-btns" });
      if (document.getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        document.getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
      parent.notify("toolbar", { prop: "enable-disable-btns" });
      if (parent.transform.degree !== 0) {
        parent.notify("transform", {
          prop: "drawPannedImage",
          onPropertyChange: false,
          value: { xDiff: 0, yDiff: 0 }
        });
      }
      parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      parent.currObjType.isCustomCrop = false;
    };
    UndoRedo2.prototype.updateUrc = function(operation, previousObj, previousObjColl, previousPointColl, previousSelPointColl, previousCropObj, previousText, currentText, previousFilter, isCircleCrop) {
      var parent = this.parent;
      if (parent.isResize || this.isPreventing) {
        return;
      }
      var obj = { isInitialLoaded: false };
      if (parent.currObjType.isUndoAction) {
        this.refreshUrc(true);
      }
      parent.notify("draw", { prop: "isInitialLoaded", onPropertyChange: false, value: { object: obj } });
      if (!obj["isInitialLoaded"] && parent.allowUndoRedo) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var currentObj = object["currObj"];
        currentObj.objColl = extend([], parent.objColl, [], true);
        currentObj.pointColl = extend([], parent.pointColl, [], true);
        currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (operation === "crop") {
          currentObj.currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
        } else if (operation === "frame") {
          previousObj.destPoints = {
            startX: parent.frameDestPoints.destLeft,
            startY: parent.frameDestPoints.destTop,
            width: parent.frameDestPoints.destWidth,
            height: parent.frameDestPoints.destHeight
          };
          currentObj.destPoints = {
            startX: parent.frameDestPoints.destLeft,
            startY: parent.frameDestPoints.destTop,
            width: parent.frameDestPoints.destWidth,
            height: parent.frameDestPoints.destHeight
          };
          if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
            previousObj.defaultZoom = currentObj.defaultZoom = parent.tempFrameZoomLevel;
          }
        } else if ((operation === "imageHFlip" || operation === "imageVFlip") && this.appliedUndoRedoColl.length > 0) {
          var index = previousObjColl[previousObjColl.length - 1].currIndex;
          previousObjColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentObjColl;
          if (index) {
            for (var i = 0, len = previousObjColl.length; i < len; i++) {
              if (previousObjColl[i].currIndex === index) {
                var actObj = extend({}, previousObjColl[i], {}, true);
                previousObjColl.splice(i, 1);
                previousObjColl.push(actObj);
                break;
              }
            }
          }
        }
        this.undoRedoColl.push({
          operation,
          previousObj,
          currentObj,
          previousObjColl,
          currentObjColl: currentObj.objColl,
          previousPointColl,
          currentPointColl: currentObj.pointColl,
          previousSelPointColl,
          currentSelPointColl: currentObj.selPointColl,
          previousCropObj,
          currentCropObj: extend({}, parent.cropObj, {}, true),
          previousText,
          currentText,
          filter: previousFilter,
          isCircleCrop
        });
        parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
      }
    };
    UndoRedo2.prototype.updateUrObj = function(objColl, operation) {
      var parent = this.parent;
      if (parent.allowUndoRedo) {
        if (parent.currObjType.isUndoAction && !parent.isShapeDrawing) {
          this.refreshUrc(true);
        }
        if (isNullOrUndefined(parent.activeObj.imageRatio)) {
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        parent.objColl.push(parent.activeObj);
        var cropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var obj = object["currObj"];
        obj.objColl = extend([], parent.objColl, [], true);
        obj.pointColl = extend([], parent.pointColl, [], true);
        obj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        obj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        var oper = operation ? operation : "shapeTransform";
        this.undoRedoColl.push({
          operation: oper,
          previousObj: obj,
          currentObj: obj,
          previousObjColl: objColl,
          currentObjColl: obj.objColl,
          previousPointColl: obj.pointColl,
          currentPointColl: obj.pointColl,
          previousSelPointColl: obj.selPointColl,
          currentSelPointColl: obj.selPointColl,
          previousCropObj: cropObj,
          currentCropObj: cropObj
        });
        parent.notify("selection", {
          prop: "redrawShape",
          onPropertyChange: false,
          value: { obj: parent.objColl[parent.objColl.length - 1] }
        });
      }
    };
    UndoRedo2.prototype.updateUndoRedo = function(operation) {
      var parent = this.parent;
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isNullOrUndefined(parent.activeObj.imageRatio)) {
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      }
      parent.objColl.push(parent.activeObj);
      var oper = operation ? operation : "shapeTransform";
      this.updateUrc(oper, prevObj, prevObj.objColl, prevObj.pointColl, prevObj.selPointColl, prevCropObj);
      parent.objColl.pop();
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "shapes",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "main",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
    };
    UndoRedo2.prototype.getZeroZoomObjPointValue = function(obj, point) {
      var parent = this.parent;
      this.updateObjColl();
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var currentObj = object["currObj"];
      currentObj.objColl = extend([], parent.objColl, [], true);
      currentObj.pointColl = extend([], parent.pointColl, [], true);
      currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var cropDimensionObj = { cropDimension: null };
      parent.notify("transform", { prop: "getCropDimension", onPropertyChange: false, value: { obj: cropDimensionObj } });
      var getZeroZoomObjColl = extend([], parent.objColl, [], true);
      var getZeroZoomPointColl = extend([], parent.pointColl, [], true);
      var arrowObj = { arrowDimension: null };
      this.parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: arrowObj } });
      var tempArrowObj = extend({}, arrowObj["arrowDimension"], {}, true);
      if (parent.transform.zoomFactor > 0 && (obj.length > 0 || point.length > 0)) {
        if (obj.length > 0) {
          for (var i = 0; i < obj.length; i++) {
            if (obj[i].currIndex) {
              continue;
            } else {
              obj[i].currIndex = "shape_" + (i + 1);
            }
          }
        }
        parent.objColl = obj;
        parent.pointColl = point;
        var isUndoRedo = parent.isUndoRedo;
        var isCropTab = parent.isCropTab;
        if (parent.transform.zoomFactor !== 0) {
          parent.isUndoRedo = true;
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: true }
          });
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
          parent.isCropTab = true;
          var zoomSettings = extend({}, parent.zoomSettings, null, true);
          if (parent.transform.zoomFactor > 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: null }
            });
          } else {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: Math.abs(parent.transform.zoomFactor), zoomPoint: null, isResize: null }
            });
          }
          parent.zoomSettings = zoomSettings;
          parent.isCropTab = isCropTab;
          parent.isUndoRedo = isUndoRedo;
          getZeroZoomObjColl = extend([], parent.objColl, [], true);
          getZeroZoomPointColl = extend([], parent.pointColl, [], true);
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.notify("transform", {
            prop: "setCropDimension",
            onPropertyChange: false,
            value: { width: cropDimensionObj["cropDimension"]["width"], height: cropDimensionObj["cropDimension"]["height"] }
          });
          var maxDimension = { width: cropDimensionObj["cropDimension"]["width"], height: cropDimensionObj["cropDimension"]["height"] };
          maxDimension.width += maxDimension.width * currentObj.defaultZoom;
          maxDimension.height += maxDimension.height * currentObj.defaultZoom;
          parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
          parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: currentObj } });
          parent.img.destLeft = currentObj.destPoints.startX;
          parent.img.destTop = currentObj.destPoints.startY;
          parent.panPoint.totalPannedPoint = currentObj.totalPannedPoint;
          parent.panPoint.totalPannedClientPoint = currentObj.totalPannedClientPoint;
          parent.panPoint.totalPannedInternalPoint = currentObj.totalPannedInternalPoint;
          parent.objColl = extend([], currentObj.objColl, [], true);
          parent.pointColl = extend([], currentObj.pointColl, [], true);
          parent.freehandCounter = parent.pointColl.length;
          parent.notify("draw", { prop: "setArrowDimension", onPropertyChange: false, value: { arrowDimension: tempArrowObj } });
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: extend([], currentObj.selPointColl, [], true) } }
          });
          this.lowerContext.filter = "none";
          parent.transform.straighten = 0;
          this.applyImgTranform();
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
          });
          parent.notify("freehand-draw", { prop: "updateFHDCurPts", onPropertyChange: false });
          this.lowerContext.filter = currentObj.filter;
          if (parent.transform.degree !== 0) {
            parent.notify("transform", {
              prop: "drawPannedImage",
              onPropertyChange: false,
              value: { xDiff: 0, yDiff: 0 }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
        }
      }
      return { obj: getZeroZoomObjColl, point: getZeroZoomPointColl };
    };
    UndoRedo2.prototype.updateObjColl = function() {
      var parent = this.parent;
      for (var i = 0; i < parent.objColl.length; i++) {
        var obj = parent.objColl[i];
        if (obj.shape === "line" || obj.shape === "arrow") {
          if (obj.activePoint.width < 0) {
            obj.activePoint.width = Math.abs(obj.activePoint.width);
          }
          if (obj.activePoint.height < 0) {
            obj.activePoint.height = Math.abs(obj.activePoint.height);
          }
        }
      }
    };
    UndoRedo2.prototype.applyImgTranform = function() {
      var parent = this.parent;
      var obj = extend({}, parent.activeObj, {}, true);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.objColl[i].shape === "image") {
          parent.activeObj = extend({}, parent.objColl[i], {}, true);
          var ctx = parent.objColl[i].imageCanvas.getContext("2d");
          parent.notify("selection", { prop: "applyTransformToImg", onPropertyChange: false, value: { ctx } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("selection", { prop: "setImageClarity", onPropertyChange: false, value: { bool: true } });
        }
      }
      parent.activeObj = obj;
    };
    UndoRedo2.prototype.updateUndoRedoStack = function(isPenDraw) {
      var parent = this.parent;
      if (parent.activeObj.currIndex && parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0 || parent.activeObj.pointColl && parent.activeObj.pointColl.length > 0 || isPenDraw) {
        var isTextArea = parent.textArea.style.display === "none" ? false : true;
        var temp = parent.noPushUndo;
        parent.noPushUndo = false;
        parent.isUndoRedoStack = true;
        if (isPenDraw) {
          var tempTogglePen = parent.togglePen;
          var obj = { freehandDrawSelectedId: null };
          parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
          parent.okBtn();
          parent.noPushUndo = temp;
          if (obj["freehandDrawSelectedId"]) {
            parent.selectShape(obj["freehandDrawSelectedId"]);
          } else {
            parent.freeHandDraw(true);
          }
          parent.togglePen = tempTogglePen;
        } else if (parent.activeObj.currIndex) {
          var shapeId = parent.activeObj.currIndex;
          parent.okBtn();
          parent.noPushUndo = temp;
          parent.selectShape(shapeId);
          if (parent.drawingShape) {
            parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: parent.drawingShape.toLowerCase() } });
          }
          if (isTextArea) {
            parent.enableTextEditing();
          }
        }
        parent.isUndoRedoStack = false;
      }
    };
    return UndoRedo2;
  }()
);

// node_modules/@syncfusion/ej2-inputs/src/input/input.js
var CLASSNAMES2 = {
  RTL: "e-rtl",
  DISABLE: "e-disabled",
  INPUT: "e-input",
  TEXTAREA: "e-multi-line-input",
  INPUTGROUP: "e-input-group",
  FLOATINPUT: "e-float-input",
  FLOATLINE: "e-float-line",
  FLOATTEXT: "e-float-text",
  FLOATTEXTCONTENT: "e-float-text-content",
  CLEARICON: "e-clear-icon",
  CLEARICONHIDE: "e-clear-icon-hide",
  LABELTOP: "e-label-top",
  LABELBOTTOM: "e-label-bottom",
  NOFLOATLABEL: "e-no-float-label",
  INPUTCUSTOMTAG: "e-input-custom-tag",
  FLOATCUSTOMTAG: "e-float-custom-tag"
};
var containerAttributes = ["title", "style", "class"];
var TEXTBOX_FOCUS = "e-input-focus";
var Input;
(function(Input2) {
  var privateInputObj = {
    container: null,
    buttons: [],
    clearButton: null
  };
  var floatType;
  var isBindClearAction = true;
  function createInput(args, internalCreateElement) {
    args.element.__eventHandlers = {};
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var inputObject = { container: null, buttons: [], clearButton: null };
    floatType = args.floatLabelType;
    isBindClearAction = args.bindClearAction;
    if (isNullOrUndefined(args.floatLabelType) || args.floatLabelType === "Never") {
      inputObject.container = createInputContainer(args, CLASSNAMES2.INPUTGROUP, CLASSNAMES2.INPUTCUSTOMTAG, "span", makeElement);
      args.element.parentNode.insertBefore(inputObject.container, args.element);
      addClass([args.element], CLASSNAMES2.INPUT);
      inputObject.container.appendChild(args.element);
    } else {
      createFloatingInput(args, inputObject, makeElement);
    }
    bindInitialEvent(args);
    if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.showClearButton) && args.properties.showClearButton) {
      setClearButton(args.properties.showClearButton, args.element, inputObject, true, makeElement);
      inputObject.clearButton.setAttribute("role", "button");
      if (inputObject.container.classList.contains(CLASSNAMES2.FLOATINPUT)) {
        addClass([inputObject.container], CLASSNAMES2.INPUTGROUP);
      }
    }
    if (!isNullOrUndefined(args.buttons)) {
      for (var i = 0; i < args.buttons.length; i++) {
        inputObject.buttons.push(appendSpan(args.buttons[i], inputObject.container, makeElement));
      }
    }
    if (!isNullOrUndefined(args.element) && args.element.tagName === "TEXTAREA") {
      addClass([inputObject.container], CLASSNAMES2.TEXTAREA);
    }
    validateInputType(inputObject.container, args.element);
    inputObject = setPropertyValue(args, inputObject);
    createSpanElement(inputObject.container, makeElement);
    privateInputObj = inputObject;
    return inputObject;
  }
  Input2.createInput = createInput;
  function bindFocusEventHandler(args) {
    var parent = getParentNode(args.element);
    if (parent.classList.contains("e-input-group") || parent.classList.contains("e-outline") || parent.classList.contains("e-filled")) {
      parent.classList.add("e-input-focus");
    }
    if (args.floatLabelType !== "Never") {
      setTimeout(function() {
        Input2.calculateWidth(args.element, parent);
      }, 80);
    }
  }
  function bindBlurEventHandler(args) {
    var parent = getParentNode(args.element);
    if (parent.classList.contains("e-input-group") || parent.classList.contains("e-outline") || parent.classList.contains("e-filled")) {
      parent.classList.remove("e-input-focus");
    }
    if (args.floatLabelType !== "Never") {
      setTimeout(function() {
        Input2.calculateWidth(args.element, parent);
      }, 80);
    }
  }
  function bindInputEventHandler(args) {
    checkInputValue(args.floatLabelType, args.element);
  }
  function bindInitialEvent(args) {
    checkInputValue(args.floatLabelType, args.element);
    var focusHandler2 = function() {
      return bindFocusEventHandler(args);
    };
    var blurHandler2 = function() {
      return bindBlurEventHandler(args);
    };
    var inputHandler2 = function() {
      return bindInputEventHandler(args);
    };
    args.element.addEventListener("focus", focusHandler2);
    args.element.addEventListener("blur", blurHandler2);
    args.element.addEventListener("input", inputHandler2);
    args.element.__eventHandlers["inputFocusHandler"] = { focusHandler: focusHandler2 };
    args.element.__eventHandlers["inputBlurHandler"] = { blurHandler: blurHandler2 };
    args.element.__eventHandlers["inputHandler"] = { inputHandler: inputHandler2 };
  }
  Input2.bindInitialEvent = bindInitialEvent;
  function unbindInitialEvent(args) {
    if (!isNullOrUndefined(args.element)) {
      if (!isNullOrUndefined(args.element.__eventHandlers)) {
        if (!isNullOrUndefined(args.element.__eventHandlers["inputFocusHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["inputBlurHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["inputHandler"])) {
          var focusHandler_1 = args.element.__eventHandlers["inputFocusHandler"].focusHandler;
          var blurHandler_1 = args.element.__eventHandlers["inputBlurHandler"].blurHandler;
          var inputHandler_1 = args.element.__eventHandlers["inputHandler"].inputHandler;
          args.element.removeEventListener("focus", focusHandler_1);
          args.element.removeEventListener("blur", blurHandler_1);
          args.element.removeEventListener("input", inputHandler_1);
          delete args.element.__eventHandlers["inputFocusHandler"];
          delete args.element.__eventHandlers["inputBlurHandler"];
          delete args.element.__eventHandlers["inputHandler"];
        }
      }
    }
  }
  function checkInputValue(floatLabelType, inputElement) {
    var inputValue = inputElement.value;
    var inputParent = inputElement.parentElement;
    var grandParent = inputParent && inputParent.parentElement;
    if (inputValue !== "" && !isNullOrUndefined(inputValue)) {
      if (inputParent && inputParent.classList.contains("e-input-group")) {
        inputParent.classList.add("e-valid-input");
      } else if (grandParent && grandParent.classList.contains("e-input-group")) {
        grandParent.classList.add("e-valid-input");
      }
    } else if (floatLabelType !== "Always") {
      if (inputParent && inputParent.classList.contains("e-input-group")) {
        inputParent.classList.remove("e-valid-input");
      } else if (grandParent && grandParent.classList.contains("e-input-group")) {
        grandParent.classList.remove("e-valid-input");
      }
    }
  }
  function _focusFn() {
    var label = getParentNode(this).getElementsByClassName("e-float-text")[0];
    if (!isNullOrUndefined(label)) {
      addClass([label], CLASSNAMES2.LABELTOP);
      if (label.classList.contains(CLASSNAMES2.LABELBOTTOM)) {
        removeClass([label], CLASSNAMES2.LABELBOTTOM);
      }
    }
  }
  function _blurFn() {
    var parent = getParentNode(this);
    if (parent.getElementsByTagName("textarea")[0] ? parent.getElementsByTagName("textarea")[0].value === "" : parent.getElementsByTagName("input")[0].value === "") {
      var label = parent.getElementsByClassName("e-float-text")[0];
      if (!isNullOrUndefined(label)) {
        if (label.classList.contains(CLASSNAMES2.LABELTOP)) {
          removeClass([label], CLASSNAMES2.LABELTOP);
        }
        addClass([label], CLASSNAMES2.LABELBOTTOM);
      }
    }
  }
  function wireFloatingEvents(element2) {
    element2.addEventListener("focus", _focusFn);
    element2.addEventListener("blur", _blurFn);
  }
  Input2.wireFloatingEvents = wireFloatingEvents;
  function unwireFloatingEvents(element2) {
    if (!isNullOrUndefined(element2)) {
      element2.removeEventListener("focus", _focusFn);
      element2.removeEventListener("blur", _blurFn);
    }
  }
  function inputEventHandler(args) {
    validateLabel(args.element, args.floatLabelType);
  }
  function blurEventHandler(args) {
    validateLabel(args.element, args.floatLabelType);
  }
  function createFloatingInput(args, inputObject, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    if (args.floatLabelType === "Auto") {
      wireFloatingEvents(args.element);
    }
    if (isNullOrUndefined(inputObject.container)) {
      inputObject.container = createInputContainer(args, CLASSNAMES2.FLOATINPUT, CLASSNAMES2.FLOATCUSTOMTAG, "div", makeElement);
      inputObject.container.classList.add(CLASSNAMES2.INPUTGROUP);
      if (args.element.parentNode) {
        args.element.parentNode.insertBefore(inputObject.container, args.element);
      }
    } else {
      if (!isNullOrUndefined(args.customTag)) {
        inputObject.container.classList.add(CLASSNAMES2.FLOATCUSTOMTAG);
      }
      inputObject.container.classList.add(CLASSNAMES2.FLOATINPUT);
    }
    var floatLinelement = makeElement("span", { className: CLASSNAMES2.FLOATLINE });
    var floatLabelElement = makeElement("label", { className: CLASSNAMES2.FLOATTEXT });
    if (!isNullOrUndefined(args.element.id) && args.element.id !== "") {
      floatLabelElement.id = "label_" + args.element.id.replace(/ /g, "_");
      attributes(args.element, { "aria-labelledby": floatLabelElement.id });
    }
    if (!isNullOrUndefined(args.element.placeholder) && args.element.placeholder !== "") {
      floatLabelElement.innerText = encodePlaceHolder(args.element.placeholder);
      args.element.removeAttribute("placeholder");
    }
    if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.placeholder) && args.properties.placeholder !== "") {
      floatLabelElement.innerText = encodePlaceHolder(args.properties.placeholder);
    }
    if (!floatLabelElement.innerText) {
      inputObject.container.classList.add(CLASSNAMES2.NOFLOATLABEL);
    }
    if (inputObject.container.classList.contains("e-float-icon-left")) {
      var inputWrap = inputObject.container.querySelector(".e-input-in-wrap");
      inputWrap.appendChild(args.element);
      inputWrap.appendChild(floatLinelement);
      inputWrap.appendChild(floatLabelElement);
    } else {
      inputObject.container.appendChild(args.element);
      inputObject.container.appendChild(floatLinelement);
      inputObject.container.appendChild(floatLabelElement);
    }
    updateLabelState(args.element.value, floatLabelElement);
    if (args.floatLabelType === "Always") {
      if (floatLabelElement.classList.contains(CLASSNAMES2.LABELBOTTOM)) {
        removeClass([floatLabelElement], CLASSNAMES2.LABELBOTTOM);
      }
      addClass([floatLabelElement], CLASSNAMES2.LABELTOP);
    }
    if (args.floatLabelType === "Auto") {
      var inputFloatHandler = function() {
        return inputEventHandler(args);
      };
      var blurFloatHandler = function() {
        return blurEventHandler(args);
      };
      args.element.addEventListener("input", inputFloatHandler);
      args.element.addEventListener("blur", blurFloatHandler);
      args.element.__eventHandlers["floatInputHandler"] = { inputFloatHandler };
      args.element.__eventHandlers["floatBlurHandler"] = { blurFloatHandler };
    } else {
      unWireFloatLabelEvents(args);
    }
    if (!isNullOrUndefined(args.element.getAttribute("id"))) {
      floatLabelElement.setAttribute("for", args.element.getAttribute("id"));
    }
  }
  function unWireFloatLabelEvents(args) {
    if (!isNullOrUndefined(args.element) && !isNullOrUndefined(args.element.__eventHandlers) && !isNullOrUndefined(args.element.__eventHandlers["floatInputHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["floatBlurHandler"])) {
      var inputFloatHandler = args.element.__eventHandlers["floatInputHandler"].inputFloatHandler;
      var blurFloatHandler = args.element.__eventHandlers["floatBlurHandler"].blurFloatHandler;
      args.element.removeEventListener("input", inputFloatHandler);
      args.element.removeEventListener("blur", blurFloatHandler);
      delete args.element.__eventHandlers["floatInputHandler"];
      delete args.element.__eventHandlers["floatBlurHandler"];
    }
  }
  function checkFloatLabelType(type, container) {
    if (type === "Always" && container.classList.contains("e-outline")) {
      container.classList.add("e-valid-input");
    }
  }
  function setPropertyValue(args, inputObject) {
    if (!isNullOrUndefined(args.properties)) {
      for (var _i = 0, _a = Object.keys(args.properties); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            setCssClass(args.properties.cssClass, [inputObject.container]);
            checkFloatLabelType(args.floatLabelType, inputObject.container);
            break;
          case "enabled":
            setEnabled(args.properties.enabled, args.element, args.floatLabelType, inputObject.container);
            break;
          case "enableRtl":
            setEnableRtl(args.properties.enableRtl, [inputObject.container]);
            break;
          case "placeholder":
            setPlaceholder(args.properties.placeholder, args.element);
            break;
          case "readonly":
            setReadonly(args.properties.readonly, args.element);
            break;
        }
      }
    }
    return inputObject;
  }
  function updateIconState(value, button, readonly) {
    if (!isNullOrUndefined(button)) {
      if (value && !readonly) {
        removeClass([button], CLASSNAMES2.CLEARICONHIDE);
      } else {
        addClass([button], CLASSNAMES2.CLEARICONHIDE);
      }
    }
  }
  function updateLabelState(value, label, element2) {
    if (element2 === void 0) {
      element2 = null;
    }
    if (value) {
      addClass([label], CLASSNAMES2.LABELTOP);
      if (label.classList.contains(CLASSNAMES2.LABELBOTTOM)) {
        removeClass([label], CLASSNAMES2.LABELBOTTOM);
      }
    } else {
      var isNotFocused = element2 != null ? element2 !== document.activeElement : true;
      if (isNotFocused) {
        if (label.classList.contains(CLASSNAMES2.LABELTOP)) {
          removeClass([label], CLASSNAMES2.LABELTOP);
        }
        addClass([label], CLASSNAMES2.LABELBOTTOM);
      }
    }
  }
  function getParentNode(element2) {
    var parentNode = isNullOrUndefined(element2.parentNode) ? element2 : element2.parentNode;
    if (parentNode && parentNode.classList.contains("e-input-in-wrap")) {
      parentNode = parentNode.parentNode;
    }
    return parentNode;
  }
  function createClearButton(element2, inputObject, initial, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = makeElement("span", { className: CLASSNAMES2.CLEARICON });
    var container = inputObject.container;
    if (!isNullOrUndefined(initial)) {
      container.appendChild(button);
    } else {
      var baseElement = inputObject.container.classList.contains(CLASSNAMES2.FLOATINPUT) ? inputObject.container.querySelector("." + CLASSNAMES2.FLOATTEXT) : element2;
      baseElement.insertAdjacentElement("afterend", button);
    }
    addClass([button], CLASSNAMES2.CLEARICONHIDE);
    wireClearBtnEvents(element2, button, container);
    button.setAttribute("aria-label", "close");
    return button;
  }
  function clickHandler(event, element2, button) {
    if (!(element2.classList.contains(CLASSNAMES2.DISABLE) || element2.readOnly)) {
      event.preventDefault();
      if (element2 !== document.activeElement) {
        element2.focus();
      }
      element2.value = "";
      addClass([button], CLASSNAMES2.CLEARICONHIDE);
    }
  }
  function inputHandler(element2, button) {
    updateIconState(element2.value, button);
  }
  function focusHandler(element2, button) {
    updateIconState(element2.value, button, element2.readOnly);
  }
  function blurHandler(element2, button) {
    setTimeout(function() {
      if (!isNullOrUndefined(button)) {
        addClass([button], CLASSNAMES2.CLEARICONHIDE);
        button = !isNullOrUndefined(element2) && element2.classList.contains("e-combobox") ? null : button;
      }
    }, 200);
  }
  function wireClearBtnEvents(element2, button, container) {
    if (isBindClearAction === void 0 || isBindClearAction) {
      var clickHandlerEvent = function(e) {
        return clickHandler(e, element2, button);
      };
      button.addEventListener("click", clickHandlerEvent);
      element2.__eventHandlers["clearClickHandler"] = { clickHandlerEvent };
    }
    var inputHandlerEvent = function() {
      return inputHandler(element2, button);
    };
    var focusHandlerEvent = function() {
      return focusHandler(element2, button);
    };
    var blurHandlerEvent = function() {
      return blurHandler(element2, button);
    };
    element2.addEventListener("input", inputHandlerEvent);
    element2.addEventListener("focus", focusHandlerEvent);
    element2.addEventListener("blur", blurHandlerEvent);
    element2.__eventHandlers["clearInputHandler"] = { inputHandlerEvent };
    element2.__eventHandlers["clearFocusHandler"] = { focusHandlerEvent };
    element2.__eventHandlers["clearBlurHandler"] = { blurHandlerEvent };
  }
  Input2.wireClearBtnEvents = wireClearBtnEvents;
  function unWireClearBtnEvents(element2, button) {
    if (!isNullOrUndefined(element2) && !isNullOrUndefined(element2.__eventHandlers)) {
      if (!isNullOrUndefined(element2.__eventHandlers["clearClickHandler"])) {
        var clickHandlerEvent = element2.__eventHandlers["clearClickHandler"].clickHandlerEvent;
        if (isBindClearAction === void 0 || isBindClearAction) {
          if (!isNullOrUndefined(button)) {
            button.removeEventListener("click", clickHandlerEvent);
          }
        }
        delete element2.__eventHandlers["clearClickHandler"];
      }
      if (!isNullOrUndefined(element2.__eventHandlers["clearInputHandler"]) && !isNullOrUndefined(element2.__eventHandlers["clearFocusHandler"]) && !isNullOrUndefined(element2.__eventHandlers["clearBlurHandler"])) {
        var inputHandlerEvent = element2.__eventHandlers["clearInputHandler"].inputHandlerEvent;
        var focusHandlerEvent = element2.__eventHandlers["clearFocusHandler"].focusHandlerEvent;
        var blurHandlerEvent = element2.__eventHandlers["clearBlurHandler"].blurHandlerEvent;
        element2.removeEventListener("input", inputHandlerEvent);
        element2.removeEventListener("focus", focusHandlerEvent);
        element2.removeEventListener("blur", blurHandlerEvent);
        delete element2.__eventHandlers["clearInputHandler"];
        delete element2.__eventHandlers["clearFocusHandler"];
        delete element2.__eventHandlers["clearBlurHandler"];
      }
    }
  }
  function destroy3(args, button) {
    if (button === void 0) {
      button = null;
    }
    unbindInitialEvent(args);
    if (args.floatLabelType === "Auto") {
      unWireFloatLabelEvents(args);
    }
    if (args.properties.showClearButton) {
      unWireClearBtnEvents(args.element, button);
    }
    if (!isNullOrUndefined(args.buttons)) {
      _internalRipple(false, null, args.buttons);
    }
    unwireFloatingEvents(args.element);
    if (!isNullOrUndefined(args.element)) {
      delete args.element.__eventHandlers;
      if (args.element.classList.contains(CLASSNAMES2.INPUT)) {
        args.element.classList.remove(CLASSNAMES2.INPUT);
      }
    }
    privateInputObj = null;
  }
  Input2.destroy = destroy3;
  function validateLabel(element2, floatLabelType) {
    var parent = getParentNode(element2);
    if (parent.classList.contains(CLASSNAMES2.FLOATINPUT) && floatLabelType === "Auto") {
      var label = getParentNode(element2).getElementsByClassName("e-float-text")[0];
      updateLabelState(element2.value, label, element2);
    }
  }
  function createInputContainer(args, className, tagClass, tag, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var container;
    if (!isNullOrUndefined(args.customTag)) {
      container = makeElement(args.customTag, { className });
      container.classList.add(tagClass);
    } else {
      container = makeElement(tag, { className });
    }
    container.classList.add("e-control-wrapper");
    return container;
  }
  function encodePlaceHolder(placeholder) {
    var result = "";
    if (!isNullOrUndefined(placeholder) && placeholder !== "") {
      var spanEle = document.createElement("span");
      spanEle.innerHTML = '<input  placeholder="' + placeholder + '"/>';
      var hiddenInput = spanEle.children[0];
      result = hiddenInput.placeholder;
    }
    return result;
  }
  function setValue3(value, element2, floatLabelType, clearButton) {
    element2.value = value;
    if (floatLabelType !== "Never") {
      calculateWidth(element2, element2.parentElement);
    }
    if (!isNullOrUndefined(floatLabelType) && floatLabelType === "Auto") {
      validateLabel(element2, floatLabelType);
    }
    if (!isNullOrUndefined(clearButton) && clearButton) {
      var parentElement = getParentNode(element2);
      if (!isNullOrUndefined(parentElement)) {
        var button = parentElement.getElementsByClassName(CLASSNAMES2.CLEARICON)[0];
        if (!isNullOrUndefined(button)) {
          if (element2.value && !isNullOrUndefined(parentElement) && parentElement.classList.contains("e-input-focus")) {
            removeClass([button], CLASSNAMES2.CLEARICONHIDE);
          } else {
            addClass([button], CLASSNAMES2.CLEARICONHIDE);
          }
        }
      }
    }
    checkInputValue(floatLabelType, element2);
  }
  Input2.setValue = setValue3;
  function setCssClass(cssClass2, elements, oldClass) {
    if (!isNullOrUndefined(oldClass) && oldClass !== "") {
      removeClass(elements, oldClass.split(" "));
    }
    if (!isNullOrUndefined(cssClass2) && cssClass2 !== "") {
      addClass(elements, cssClass2.split(" "));
    }
  }
  Input2.setCssClass = setCssClass;
  function calculateWidth(element2, container, moduleName) {
    if (moduleName !== "multiselect" && !_isElementVisible(element2)) {
      return;
    }
    var elementWidth = moduleName === "multiselect" ? element2 : element2.clientWidth - parseInt(getComputedStyle(element2, null).getPropertyValue("padding-left"), 10);
    if (!isNullOrUndefined(container) && !isNullOrUndefined(container.getElementsByClassName("e-float-text-content")[0])) {
      if (container.getElementsByClassName("e-float-text-content")[0].classList.contains("e-float-text-overflow")) {
        container.getElementsByClassName("e-float-text-content")[0].classList.remove("e-float-text-overflow");
      }
      if (elementWidth < container.getElementsByClassName("e-float-text-content")[0].clientWidth || elementWidth === container.getElementsByClassName("e-float-text-content")[0].clientWidth) {
        container.getElementsByClassName("e-float-text-content")[0].classList.add("e-float-text-overflow");
      }
    }
  }
  Input2.calculateWidth = calculateWidth;
  function setWidth2(width, container) {
    if (typeof width === "number") {
      container.style.width = formatUnit(width);
    } else if (typeof width === "string") {
      container.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
    }
    calculateWidth(container.firstChild, container);
  }
  Input2.setWidth = setWidth2;
  function setPlaceholder(placeholder, element2) {
    placeholder = encodePlaceHolder(placeholder);
    var parentElement = getParentNode(element2);
    if (parentElement.classList.contains(CLASSNAMES2.FLOATINPUT)) {
      if (!isNullOrUndefined(placeholder) && placeholder !== "") {
        var floatTextContent = parentElement.getElementsByClassName("e-float-text-content")[0];
        if (floatTextContent && floatTextContent.children[0]) {
          floatTextContent.children[0].textContent = placeholder;
        } else {
          parentElement.getElementsByClassName(CLASSNAMES2.FLOATTEXT)[0].textContent = placeholder;
        }
        parentElement.classList.remove(CLASSNAMES2.NOFLOATLABEL);
        element2.removeAttribute("placeholder");
      } else {
        parentElement.classList.add(CLASSNAMES2.NOFLOATLABEL);
        var floatTextContent = parentElement.getElementsByClassName("e-float-text-content")[0];
        if (floatTextContent) {
          floatTextContent.children[0].textContent = "";
        } else {
          parentElement.getElementsByClassName(CLASSNAMES2.FLOATTEXT)[0].textContent = "";
        }
      }
    } else {
      if (!isNullOrUndefined(placeholder) && placeholder !== "") {
        attributes(element2, { "placeholder": placeholder });
      } else {
        element2.removeAttribute("placeholder");
      }
    }
  }
  Input2.setPlaceholder = setPlaceholder;
  function setReadonly(isReadonly, element2, floatLabelType) {
    if (isReadonly) {
      attributes(element2, { readonly: "" });
    } else {
      element2.removeAttribute("readonly");
    }
    if (!isNullOrUndefined(floatLabelType)) {
      validateLabel(element2, floatLabelType);
    }
  }
  Input2.setReadonly = setReadonly;
  function setEnableRtl(isRtl, elements) {
    if (isRtl) {
      addClass(elements, CLASSNAMES2.RTL);
    } else {
      removeClass(elements, CLASSNAMES2.RTL);
    }
  }
  Input2.setEnableRtl = setEnableRtl;
  function setEnabled(isEnable, element2, floatLabelType, inputContainer) {
    var disabledAttrs = { "disabled": "", "aria-disabled": "true" };
    var considerWrapper = isNullOrUndefined(inputContainer) ? false : true;
    if (isEnable) {
      element2.classList.remove(CLASSNAMES2.DISABLE);
      removeAttributes(disabledAttrs, element2);
      if (considerWrapper) {
        removeClass([inputContainer], CLASSNAMES2.DISABLE);
      }
    } else {
      element2.classList.add(CLASSNAMES2.DISABLE);
      addAttributes(disabledAttrs, element2);
      if (considerWrapper) {
        addClass([inputContainer], CLASSNAMES2.DISABLE);
      }
    }
    if (!isNullOrUndefined(floatLabelType)) {
      validateLabel(element2, floatLabelType);
    }
  }
  Input2.setEnabled = setEnabled;
  function setClearButton(isClear, element2, inputObject, initial, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    if (isClear) {
      inputObject.clearButton = createClearButton(element2, inputObject, initial, makeElement);
    } else {
      remove(inputObject.clearButton);
      inputObject.clearButton = null;
    }
  }
  Input2.setClearButton = setClearButton;
  function removeAttributes(attrs, element2) {
    for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
      var key = _a[_i];
      var parentElement = getParentNode(element2);
      if (key === "disabled") {
        element2.classList.remove(CLASSNAMES2.DISABLE);
      }
      if (key === "disabled" && parentElement.classList.contains(CLASSNAMES2.INPUTGROUP)) {
        parentElement.classList.remove(CLASSNAMES2.DISABLE);
      }
      if (key === "placeholder" && parentElement.classList.contains(CLASSNAMES2.FLOATINPUT)) {
        parentElement.getElementsByClassName(CLASSNAMES2.FLOATTEXT)[0].textContent = "";
      } else {
        element2.removeAttribute(key);
      }
    }
  }
  Input2.removeAttributes = removeAttributes;
  function addAttributes(attrs, element2) {
    for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
      var key = _a[_i];
      var parentElement = getParentNode(element2);
      if (key === "disabled") {
        element2.classList.add(CLASSNAMES2.DISABLE);
      }
      if (key === "disabled" && parentElement.classList.contains(CLASSNAMES2.INPUTGROUP)) {
        parentElement.classList.add(CLASSNAMES2.DISABLE);
      }
      if (key === "placeholder" && parentElement.classList.contains(CLASSNAMES2.FLOATINPUT)) {
        parentElement.getElementsByClassName(CLASSNAMES2.FLOATTEXT)[0].textContent = attrs["" + key];
      } else {
        element2.setAttribute(key, attrs["" + key]);
      }
    }
  }
  Input2.addAttributes = addAttributes;
  function removeFloating(input) {
    var container = input.container;
    if (!isNullOrUndefined(container) && container.classList.contains(CLASSNAMES2.FLOATINPUT)) {
      var inputEle = container.querySelector("textarea") ? container.querySelector("textarea") : container.querySelector("input");
      var placeholder = container.querySelector("." + CLASSNAMES2.FLOATTEXT).textContent;
      var clearButton = container.querySelector(".e-clear-icon") !== null;
      detach(container.querySelector("." + CLASSNAMES2.FLOATLINE));
      detach(container.querySelector("." + CLASSNAMES2.FLOATTEXT));
      classList(container, [CLASSNAMES2.INPUTGROUP], [CLASSNAMES2.FLOATINPUT]);
      unwireFloatingEvents(inputEle);
      attributes(inputEle, { "placeholder": placeholder });
      inputEle.classList.add(CLASSNAMES2.INPUT);
      if (!clearButton && inputEle.tagName === "INPUT") {
        inputEle.removeAttribute("required");
      }
    }
  }
  Input2.removeFloating = removeFloating;
  function addFloating(input, type, placeholder, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var container = closest(input, "." + CLASSNAMES2.INPUTGROUP);
    floatType = type;
    var customTag = container.tagName;
    customTag = customTag !== "DIV" && customTag !== "SPAN" ? customTag : null;
    var args = {
      element: input,
      floatLabelType: type,
      customTag,
      properties: { placeholder }
    };
    if (type !== "Never") {
      var iconEle = container.querySelector(".e-clear-icon");
      var inputObj = { container };
      input.classList.remove(CLASSNAMES2.INPUT);
      createFloatingInput(args, inputObj, makeElement);
      createSpanElement(inputObj.container, makeElement);
      calculateWidth(args.element, inputObj.container);
      var isPrependIcon = container.classList.contains("e-float-icon-left");
      if (isNullOrUndefined(iconEle)) {
        if (isPrependIcon) {
          var inputWrap = container.querySelector(".e-input-in-wrap");
          iconEle = inputWrap.querySelector(".e-input-group-icon");
        } else {
          iconEle = container.querySelector(".e-input-group-icon");
        }
      }
      if (isNullOrUndefined(iconEle)) {
        if (isPrependIcon) {
          iconEle = container.querySelector(".e-input-group-icon");
        }
      } else {
        var floatLine = container.querySelector("." + CLASSNAMES2.FLOATLINE);
        var floatText = container.querySelector("." + CLASSNAMES2.FLOATTEXT);
        var wrapper = isPrependIcon ? container.querySelector(".e-input-in-wrap") : container;
        wrapper.insertBefore(input, iconEle);
        wrapper.insertBefore(floatLine, iconEle);
        wrapper.insertBefore(floatText, iconEle);
      }
    } else {
      unWireFloatLabelEvents(args);
    }
    checkFloatLabelType(type, input.parentElement);
  }
  Input2.addFloating = addFloating;
  function createSpanElement(inputObject, makeElement) {
    if (inputObject.classList.contains("e-outline") && inputObject.getElementsByClassName("e-float-text")[0]) {
      var labelSpanElement = makeElement("span", { className: CLASSNAMES2.FLOATTEXTCONTENT });
      labelSpanElement.innerHTML = inputObject.getElementsByClassName("e-float-text")[0].innerHTML;
      inputObject.getElementsByClassName("e-float-text")[0].innerHTML = "";
      inputObject.getElementsByClassName("e-float-text")[0].appendChild(labelSpanElement);
    }
  }
  Input2.createSpanElement = createSpanElement;
  function setRipple(isRipple, inputObj) {
    for (var i = 0; i < inputObj.length; i++) {
      _internalRipple(isRipple, inputObj[parseInt(i.toString(), 10)].container);
    }
  }
  Input2.setRipple = setRipple;
  function _internalRipple(isRipple, container, button) {
    var argsButton = [];
    argsButton.push(button);
    var buttons = isNullOrUndefined(button) ? container.querySelectorAll(".e-input-group-icon") : argsButton;
    if (isRipple && buttons.length > 0) {
      for (var index = 0; index < buttons.length; index++) {
        buttons[parseInt(index.toString(), 10)].addEventListener("mousedown", _onMouseDownRipple, false);
        buttons[parseInt(index.toString(), 10)].addEventListener("mouseup", _onMouseUpRipple, false);
      }
    } else if (buttons.length > 0) {
      for (var index = 0; index < buttons.length; index++) {
        buttons[parseInt(index.toString(), 10)].removeEventListener("mousedown", _onMouseDownRipple, this);
        buttons[parseInt(index.toString(), 10)].removeEventListener("mouseup", _onMouseUpRipple, this);
      }
    }
  }
  function _onMouseRipple(container, button) {
    if (!container.classList.contains("e-disabled") && !container.querySelector("input").readOnly) {
      button.classList.add("e-input-btn-ripple");
    }
  }
  function _isElementVisible(element2) {
    if (!element2) {
      return false;
    }
    var currentElement = element2;
    while (currentElement && currentElement !== document.body) {
      var style = window.getComputedStyle(currentElement);
      if (style.display === "none") {
        return false;
      }
      currentElement = currentElement.parentElement;
    }
    return true;
  }
  function _onMouseDownRipple() {
    var ele = this;
    var parentEle = this.parentElement;
    while (!parentEle.classList.contains("e-input-group")) {
      parentEle = parentEle.parentElement;
    }
    _onMouseRipple(parentEle, ele);
  }
  function _onMouseUpRipple() {
    var ele = this;
    setTimeout(function() {
      ele.classList.remove("e-input-btn-ripple");
    }, 500);
  }
  function createIconEle(iconClass, makeElement) {
    var button = makeElement("span", { className: iconClass });
    button.classList.add("e-input-group-icon");
    return button;
  }
  function addIcon(position, icons, container, input, internalCreate) {
    var result = typeof icons === "string" ? icons.split(",") : icons;
    if (position.toLowerCase() === "append") {
      for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
        var icon = result_1[_i];
        appendSpan(icon, container, internalCreate);
      }
    } else {
      for (var _a = 0, result_2 = result; _a < result_2.length; _a++) {
        var icon = result_2[_a];
        prependSpan(icon, container, input, internalCreate);
      }
    }
    if (container.getElementsByClassName("e-input-group-icon")[0] && container.getElementsByClassName("e-float-text-overflow")[0]) {
      container.getElementsByClassName("e-float-text-overflow")[0].classList.add("e-icon");
    }
  }
  Input2.addIcon = addIcon;
  function prependSpan(iconClass, container, inputElement, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = createIconEle(iconClass, makeElement);
    container.classList.add("e-float-icon-left");
    var innerWrapper = container.querySelector(".e-input-in-wrap");
    if (isNullOrUndefined(innerWrapper)) {
      innerWrapper = makeElement("span", { className: "e-input-in-wrap" });
      inputElement.parentNode.insertBefore(innerWrapper, inputElement);
      var result = container.querySelectorAll(inputElement.tagName + " ~ *");
      innerWrapper.appendChild(inputElement);
      for (var i = 0; i < result.length; i++) {
        var element2 = result[parseInt(i.toString(), 10)];
        var parentElement = innerWrapper.parentElement;
        if (!element2.classList.contains("e-float-line") || !(parentElement && parentElement.classList.contains("e-filled")) && parentElement) {
          innerWrapper.appendChild(element2);
        }
      }
    }
    innerWrapper.parentNode.insertBefore(button, innerWrapper);
    _internalRipple(true, container, button);
    return button;
  }
  Input2.prependSpan = prependSpan;
  function appendSpan(iconClass, container, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = createIconEle(iconClass, makeElement);
    var wrap = container.classList.contains("e-float-icon-left") ? container.querySelector(".e-input-in-wrap") : container;
    wrap.appendChild(button);
    _internalRipple(true, container, button);
    return button;
  }
  Input2.appendSpan = appendSpan;
  function validateInputType(containerElement2, input) {
    if (input.type === "hidden") {
      containerElement2.classList.add("e-hidden");
    } else if (containerElement2.classList.contains("e-hidden")) {
      containerElement2.classList.remove("e-hidden");
    }
  }
  Input2.validateInputType = validateInputType;
  function updateHTMLAttributesToElement(htmlAttributes, element2) {
    if (!isNullOrUndefined(htmlAttributes)) {
      for (var _i = 0, _a = Object.keys(htmlAttributes); _i < _a.length; _i++) {
        var key = _a[_i];
        if (containerAttributes.indexOf(key) < 0) {
          element2.setAttribute(key, htmlAttributes["" + key]);
        }
      }
    }
  }
  Input2.updateHTMLAttributesToElement = updateHTMLAttributesToElement;
  function updateCssClass(newClass, oldClass, container) {
    setCssClass(getInputValidClassList(newClass), [container], getInputValidClassList(oldClass));
  }
  Input2.updateCssClass = updateCssClass;
  function getInputValidClassList(inputClassName) {
    var result = inputClassName;
    if (!isNullOrUndefined(inputClassName) && inputClassName !== "") {
      result = inputClassName.replace(/\s+/g, " ").trim();
    }
    return result;
  }
  Input2.getInputValidClassList = getInputValidClassList;
  function updateHTMLAttributesToWrapper(htmlAttributes, container) {
    if (!isNullOrUndefined(htmlAttributes)) {
      for (var _i = 0, _a = Object.keys(htmlAttributes); _i < _a.length; _i++) {
        var key = _a[_i];
        if (containerAttributes.indexOf(key) > -1) {
          if (key === "class") {
            var updatedClassValues = this.getInputValidClassList(htmlAttributes["" + key]);
            if (updatedClassValues !== "") {
              addClass([container], updatedClassValues.split(" "));
            }
          } else if (key === "style") {
            var setStyle = container.getAttribute(key);
            setStyle = !isNullOrUndefined(setStyle) ? setStyle + htmlAttributes["" + key] : htmlAttributes["" + key];
            container.setAttribute(key, setStyle);
          } else {
            container.setAttribute(key, htmlAttributes["" + key]);
          }
        }
      }
    }
  }
  Input2.updateHTMLAttributesToWrapper = updateHTMLAttributesToWrapper;
  function isBlank(inputString) {
    return !inputString || /^\s*$/.test(inputString);
  }
  Input2.isBlank = isBlank;
})(Input || (Input = {}));

// node_modules/@syncfusion/ej2-inputs/src/numerictextbox/numerictextbox.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ROOT3 = "e-control-wrapper e-numeric";
var SPINICON = "e-input-group-icon";
var SPINUP = "e-spin-up";
var SPINDOWN = "e-spin-down";
var ERROR = "e-error";
var INCREMENT = "increment";
var DECREMENT = "decrement";
var INTREGEXP = new RegExp("^(-)?(\\d*)$");
var DECIMALSEPARATOR = ".";
var COMPONENT = "e-numerictextbox";
var CONTROL = "e-control";
var NUMERIC_FOCUS = "e-input-focus";
var HIDDENELEMENT = "e-numeric-hidden";
var wrapperAttributes = ["title", "style", "class"];
var selectionTimeOut = 0;
var NumericTextBox = (
  /** @class */
  function(_super) {
    __extends11(NumericTextBox2, _super);
    function NumericTextBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.preventChange = false;
      _this.isDynamicChange = false;
      _this.numericOptions = options;
      return _this;
    }
    NumericTextBox2.prototype.preRender = function() {
      this.isPrevFocused = false;
      this.decimalSeparator = ".";
      this.intRegExp = new RegExp("/^(-)?(d*)$/");
      this.isCalled = false;
      var ejInstance = getValue("ej2_instances", this.element);
      this.cloneElement = this.element.cloneNode(true);
      removeClass([this.cloneElement], [CONTROL, COMPONENT, "e-lib"]);
      this.angularTagName = null;
      this.formEle = closest(this.element, "form");
      if (this.element.tagName === "EJS-NUMERICTEXTBOX") {
        this.angularTagName = this.element.tagName;
        var input = this.createElement("input");
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (attributeName !== "id" && attributeName !== "class") {
            input.setAttribute(this.element.attributes[index].nodeName, this.element.attributes[index].nodeValue);
            input.innerHTML = this.element.innerHTML;
          } else if (attributeName === "class") {
            input.setAttribute(attributeName, this.element.className.split(" ").filter(function(item) {
              return item.indexOf("ng-") !== 0;
            }).join(" "));
          }
        }
        if (this.element.hasAttribute("name")) {
          this.element.removeAttribute("name");
        }
        this.element.classList.remove("e-control", "e-numerictextbox");
        this.element.appendChild(input);
        this.element = input;
        setValue("ej2_instances", ejInstance, this.element);
      }
      attributes(this.element, { "role": "spinbutton", "tabindex": "0", "autocomplete": "off" });
      var localeText = {
        incrementTitle: "Increment value",
        decrementTitle: "Decrement value",
        placeholder: this.placeholder
      };
      this.l10n = new L10n("numerictextbox", localeText, this.locale);
      if (this.l10n.getConstant("placeholder") !== "") {
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      if (!this.element.hasAttribute("id")) {
        this.element.setAttribute("id", getUniqueID("numerictextbox"));
      }
      this.isValidState = true;
      this.inputStyle = null;
      this.inputName = null;
      this.cultureInfo = {};
      this.initCultureInfo();
      this.initCultureFunc();
      this.prevValue = this.value;
      this.updateHTMLAttrToElement();
      this.checkAttributes(false);
      if (this.formEle) {
        this.inputEleValue = this.value;
      }
      this.validateMinMax();
      this.validateStep();
      if (this.placeholder === null) {
        this.updatePlaceholder();
      }
    };
    NumericTextBox2.prototype.render = function() {
      if (this.element.tagName.toLowerCase() === "input") {
        this.createWrapper();
        if (this.showSpinButton) {
          this.spinBtnCreation();
        }
        this.setElementWidth(this.width);
        if (!this.container.classList.contains("e-input-group")) {
          this.container.classList.add("e-input-group");
        }
        this.changeValue(this.value === null || isNaN(this.value) ? null : this.strictMode ? this.trimValue(this.value) : this.value);
        this.wireEvents();
        if (this.value !== null && !isNaN(this.value)) {
          if (this.decimals) {
            this.setProperties({ value: this.roundNumber(this.value, this.decimals) }, true);
          }
        }
        if (this.element.getAttribute("value") || this.value) {
          this.element.setAttribute("value", this.element.value);
          this.hiddenInput.setAttribute("value", this.hiddenInput.value);
        }
        this.elementPrevValue = this.element.value;
        if (this.element.hasAttribute("data-val")) {
          this.element.setAttribute("data-val", "false");
        }
        if (!this.element.hasAttribute("aria-labelledby") && !this.element.hasAttribute("placeholder")) {
          this.element.setAttribute("aria-label", "numerictextbox");
        }
        if (!isNullOrUndefined(closest(this.element, "fieldset")) && closest(this.element, "fieldset").disabled) {
          this.enabled = false;
        }
        this.renderComplete();
      }
    };
    NumericTextBox2.prototype.checkAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["value", "min", "max", "step", "disabled", "readonly", "style", "name", "placeholder"];
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(prop))) {
          switch (prop) {
            case "disabled":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["enabled"] === void 0 || isDynamic) {
                var enabled = this.element.getAttribute(prop) === "disabled" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.element.getAttribute(prop) === "readonly" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "value":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["value"] === void 0 || isDynamic) {
                var setNumber = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                this.setProperties(setValue(prop, setNumber, {}), !isDynamic);
              }
              break;
            case "min":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["min"] === void 0 || isDynamic) {
                var minValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (minValue !== null && !isNaN(minValue)) {
                  this.setProperties(setValue(prop, minValue, {}), !isDynamic);
                }
              }
              break;
            case "max":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["max"] === void 0 || isDynamic) {
                var maxValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (maxValue !== null && !isNaN(maxValue)) {
                  this.setProperties(setValue(prop, maxValue, {}), !isDynamic);
                }
              }
              break;
            case "step":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["step"] === void 0 || isDynamic) {
                var stepValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (stepValue !== null && !isNaN(stepValue)) {
                  this.setProperties(setValue(prop, stepValue, {}), !isDynamic);
                }
              }
              break;
            case "style":
              this.inputStyle = this.element.getAttribute(prop);
              break;
            case "name":
              this.inputName = this.element.getAttribute(prop);
              break;
            default:
              {
                var value = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (value !== null && !isNaN(value) || prop === "value") {
                  this.setProperties(setValue(prop, value, {}), true);
                }
              }
              break;
          }
        }
      }
    };
    NumericTextBox2.prototype.updatePlaceholder = function() {
      this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
    };
    NumericTextBox2.prototype.initCultureFunc = function() {
      this.instance = new Internationalization(this.locale);
    };
    NumericTextBox2.prototype.initCultureInfo = function() {
      this.cultureInfo.format = this.format;
      if (getValue("currency", this) !== null) {
        setValue("currency", this.currency, this.cultureInfo);
        this.setProperties({ currencyCode: this.currency }, true);
      }
    };
    NumericTextBox2.prototype.createWrapper = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = this.getNumericValidClassList(this.cssClass);
      }
      var inputObj = Input.createInput({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: {
          readonly: this.readonly,
          placeholder: this.placeholder,
          cssClass: updatedCssClassValue,
          enableRtl: this.enableRtl,
          showClearButton: this.showClearButton,
          enabled: this.enabled
        }
      }, this.createElement);
      this.inputWrapper = inputObj;
      this.container = inputObj.container;
      this.container.setAttribute("class", ROOT3 + " " + this.container.getAttribute("class"));
      this.updateHTMLAttrToWrapper();
      if (this.readonly) {
        attributes(this.element, { "aria-readonly": "true" });
      }
      this.hiddenInput = this.createElement("input", { attrs: {
        type: "text",
        "validateHidden": "true",
        "aria-label": "hidden",
        "class": HIDDENELEMENT
      } });
      this.inputName = this.inputName !== null ? this.inputName : this.element.id;
      this.element.removeAttribute("name");
      if (this.isAngular && this.angularTagName === "EJS-NUMERICTEXTBOX" && this.cloneElement.id.length > 0) {
        attributes(this.hiddenInput, { "name": this.cloneElement.id });
      } else {
        attributes(this.hiddenInput, { "name": this.inputName });
      }
      this.container.insertBefore(this.hiddenInput, this.container.childNodes[1]);
      this.updateDataAttribute(false);
      if (this.inputStyle !== null) {
        attributes(this.container, { "style": this.inputStyle });
      }
    };
    NumericTextBox2.prototype.updateDataAttribute = function(isDynamic) {
      var attr = {};
      if (!isDynamic) {
        for (var a = 0; a < this.element.attributes.length; a++) {
          attr[this.element.attributes[a].name] = this.element.getAttribute(this.element.attributes[a].name);
        }
      } else {
        attr = this.htmlAttributes;
      }
      for (var _i = 0, _a = Object.keys(attr); _i < _a.length; _i++) {
        var key = _a[_i];
        if (key.indexOf("data") === 0) {
          this.hiddenInput.setAttribute(key, attr["" + key]);
        }
      }
    };
    NumericTextBox2.prototype.updateHTMLAttrToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttributes.indexOf(pro) < 0) {
            this.element.setAttribute(pro, this.htmlAttributes["" + pro]);
          }
        }
      }
    };
    NumericTextBox2.prototype.updateCssClass = function(newClass, oldClass) {
      Input.setCssClass(this.getNumericValidClassList(newClass), [this.container], this.getNumericValidClassList(oldClass));
    };
    NumericTextBox2.prototype.getNumericValidClassList = function(numericClassName) {
      var result = numericClassName;
      if (!isNullOrUndefined(numericClassName) && numericClassName !== "") {
        result = numericClassName.replace(/\s+/g, " ").trim();
      }
      return result;
    };
    NumericTextBox2.prototype.updateHTMLAttrToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttributes.indexOf(pro) > -1) {
            if (pro === "class") {
              var updatedClassValue = this.getNumericValidClassList(this.htmlAttributes["" + pro]);
              if (updatedClassValue !== "") {
                addClass([this.container], updatedClassValue.split(" "));
              }
            } else if (pro === "style") {
              var numericStyle = this.container.getAttribute(pro);
              numericStyle = !isNullOrUndefined(numericStyle) ? numericStyle + this.htmlAttributes["" + pro] : this.htmlAttributes["" + pro];
              this.container.setAttribute(pro, numericStyle);
            } else {
              this.container.setAttribute(pro, this.htmlAttributes["" + pro]);
            }
          }
        }
      }
    };
    NumericTextBox2.prototype.setElementWidth = function(width) {
      if (!isNullOrUndefined(width)) {
        if (typeof width === "number") {
          this.container.style.width = formatUnit(width);
        } else if (typeof width === "string") {
          this.container.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
        }
      }
    };
    NumericTextBox2.prototype.spinBtnCreation = function() {
      this.spinDown = Input.appendSpan(SPINICON + " " + SPINDOWN, this.container, this.createElement);
      attributes(this.spinDown, {
        "title": this.l10n.getConstant("decrementTitle")
      });
      this.spinUp = Input.appendSpan(SPINICON + " " + SPINUP, this.container, this.createElement);
      attributes(this.spinUp, {
        "title": this.l10n.getConstant("incrementTitle")
      });
      this.wireSpinBtnEvents();
    };
    NumericTextBox2.prototype.validateMinMax = function() {
      if (!(typeof this.min === "number" && !isNaN(this.min))) {
        this.setProperties({ min: -Number.MAX_VALUE }, true);
      }
      if (!(typeof this.max === "number" && !isNaN(this.max))) {
        this.setProperties({ max: Number.MAX_VALUE }, true);
      }
      if (this.decimals !== null) {
        if (this.min !== -Number.MAX_VALUE) {
          this.setProperties({ min: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.min)) }, true);
        }
        if (this.max !== Number.MAX_VALUE) {
          this.setProperties({ max: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.max)) }, true);
        }
      }
      this.setProperties({ min: this.min > this.max ? this.max : this.min }, true);
      if (this.min !== -Number.MAX_VALUE) {
        attributes(this.element, { "aria-valuemin": this.min.toString() });
      }
      if (this.max !== Number.MAX_VALUE) {
        attributes(this.element, { "aria-valuemax": this.max.toString() });
      }
    };
    NumericTextBox2.prototype.formattedValue = function(decimals, value) {
      return this.instance.getNumberFormat({
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals,
        useGrouping: false
      })(value);
    };
    NumericTextBox2.prototype.validateStep = function() {
      if (this.decimals !== null) {
        this.setProperties({ step: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.step)) }, true);
      }
    };
    NumericTextBox2.prototype.action = function(operation, event) {
      this.isInteract = true;
      var value = this.isFocused ? this.instance.getNumberParser({ format: "n" })(this.element.value) : this.value;
      this.changeValue(this.performAction(value, this.step, operation));
      this.raiseChangeEvent(event);
    };
    NumericTextBox2.prototype.checkErrorClass = function() {
      if (this.isValidState) {
        removeClass([this.container], ERROR);
      } else {
        addClass([this.container], ERROR);
      }
      attributes(this.element, { "aria-invalid": this.isValidState ? "false" : "true" });
    };
    NumericTextBox2.prototype.bindClearEvent = function() {
      if (this.showClearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler, this);
      }
    };
    NumericTextBox2.prototype.resetHandler = function(e) {
      e.preventDefault();
      if (!this.inputWrapper.clearButton.classList.contains("e-clear-icon-hide") || this.inputWrapper.container.classList.contains("e-static-clear")) {
        this.clear(e);
      }
      this.isInteract = true;
      this.raiseChangeEvent(e);
    };
    NumericTextBox2.prototype.clear = function(event) {
      this.setProperties({ value: null }, true);
      this.setElementValue("");
      this.hiddenInput.value = "";
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = document.createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.resetFormHandler = function() {
      if (this.element.tagName === "EJS-NUMERICTEXTBOX") {
        this.updateValue(null);
      } else {
        this.updateValue(this.inputEleValue);
      }
    };
    NumericTextBox2.prototype.setSpinButton = function() {
      if (!isNullOrUndefined(this.spinDown)) {
        attributes(this.spinDown, {
          "title": this.l10n.getConstant("decrementTitle"),
          "aria-label": this.l10n.getConstant("decrementTitle")
        });
      }
      if (!isNullOrUndefined(this.spinUp)) {
        attributes(this.spinUp, {
          "title": this.l10n.getConstant("incrementTitle"),
          "aria-label": this.l10n.getConstant("incrementTitle")
        });
      }
    };
    NumericTextBox2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "blur", this.focusOutHandler, this);
      EventHandler.add(this.element, "keydown", this.keyDownHandler, this);
      EventHandler.add(this.element, "keyup", this.keyUpHandler, this);
      EventHandler.add(this.element, "input", this.inputHandler, this);
      EventHandler.add(this.element, "keypress", this.keyPressHandler, this);
      EventHandler.add(this.element, "change", this.changeHandler, this);
      EventHandler.add(this.element, "paste", this.pasteHandler, this);
      if (this.enabled) {
        this.bindClearEvent();
        if (this.formEle) {
          EventHandler.add(this.formEle, "reset", this.resetFormHandler, this);
        }
      }
    };
    NumericTextBox2.prototype.wireSpinBtnEvents = function() {
      EventHandler.add(this.spinUp, Browser.touchStartEvent, this.mouseDownOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchStartEvent, this.mouseDownOnSpinner, this);
      EventHandler.add(this.spinUp, Browser.touchEndEvent, this.mouseUpOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchEndEvent, this.mouseUpOnSpinner, this);
      EventHandler.add(this.spinUp, Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
    };
    NumericTextBox2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "blur", this.focusOutHandler);
      EventHandler.remove(this.element, "keyup", this.keyUpHandler);
      EventHandler.remove(this.element, "input", this.inputHandler);
      EventHandler.remove(this.element, "keydown", this.keyDownHandler);
      EventHandler.remove(this.element, "keypress", this.keyPressHandler);
      EventHandler.remove(this.element, "change", this.changeHandler);
      EventHandler.remove(this.element, "paste", this.pasteHandler);
      if (this.formEle) {
        EventHandler.remove(this.formEle, "reset", this.resetFormHandler);
      }
    };
    NumericTextBox2.prototype.unwireSpinBtnEvents = function() {
      EventHandler.remove(this.spinUp, Browser.touchStartEvent, this.mouseDownOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchStartEvent, this.mouseDownOnSpinner);
      EventHandler.remove(this.spinUp, Browser.touchEndEvent, this.mouseUpOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchEndEvent, this.mouseUpOnSpinner);
      EventHandler.remove(this.spinUp, Browser.touchMoveEvent, this.touchMoveOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchMoveEvent, this.touchMoveOnSpinner);
    };
    NumericTextBox2.prototype.changeHandler = function(event) {
      event.stopPropagation();
      if (!this.element.value.length) {
        this.setProperties({ value: null }, true);
      }
      var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
      this.updateValue(parsedInput, event);
    };
    NumericTextBox2.prototype.raiseChangeEvent = function(event) {
      this.inputValue = isNullOrUndefined(this.inputValue) || isNaN(this.inputValue) ? null : this.inputValue;
      if (this.prevValue !== this.value || this.prevValue !== this.inputValue) {
        var eventArgs = {};
        this.changeEventArgs = {
          value: this.value,
          previousValue: this.prevValue,
          isInteracted: this.isInteract,
          isInteraction: this.isInteract,
          event
        };
        if (event) {
          this.changeEventArgs.event = event;
        }
        if (this.changeEventArgs.event === void 0) {
          this.changeEventArgs.isInteracted = false;
          this.changeEventArgs.isInteraction = false;
        }
        merge(eventArgs, this.changeEventArgs);
        this.prevValue = this.value;
        this.isInteract = false;
        this.elementPrevValue = this.element.value;
        this.preventChange = false;
        this.trigger("change", eventArgs);
      }
    };
    NumericTextBox2.prototype.pasteHandler = function() {
      var _this = this;
      if (!this.enabled || this.readonly) {
        return;
      }
      var beforeUpdate = this.element.value;
      setTimeout(function() {
        if (!_this.numericRegex().test(_this.element.value)) {
          _this.setElementValue(beforeUpdate);
        }
      });
    };
    NumericTextBox2.prototype.preventHandler = function() {
      var _this = this;
      var iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
      setTimeout(function() {
        if (_this.element.selectionStart > 0) {
          var currentPos = _this.element.selectionStart;
          var prevPos = _this.element.selectionStart - 1;
          var start = 0;
          var valArray = _this.element.value.split("");
          var numericObject = getNumericObject(_this.locale);
          var decimalSeparator = getValue("decimal", numericObject);
          var ignoreKeyCode = decimalSeparator.charCodeAt(0);
          if (_this.element.value[prevPos] === " " && _this.element.selectionStart > 0 && !iOS) {
            if (isNullOrUndefined(_this.prevVal)) {
              _this.element.value = _this.element.value.trim();
            } else if (prevPos !== 0) {
              _this.element.value = _this.prevVal;
            } else if (prevPos === 0) {
              _this.element.value = _this.element.value.trim();
            }
            _this.element.setSelectionRange(prevPos, prevPos);
          } else if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1])) && _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) !== 45) {
            if (valArray.indexOf(_this.element.value[_this.element.selectionStart - 1]) !== valArray.lastIndexOf(_this.element.value[_this.element.selectionStart - 1]) && _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) === ignoreKeyCode || _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) !== ignoreKeyCode) {
              _this.element.value = _this.element.value.substring(0, prevPos) + _this.element.value.substring(currentPos, _this.element.value.length);
              _this.element.setSelectionRange(prevPos, prevPos);
              if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1])) && _this.element.selectionStart > 0 && _this.element.value.length) {
                _this.preventHandler();
              }
            }
          } else if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 2])) && _this.element.selectionStart > 1 && _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) !== 45) {
            if (valArray.indexOf(_this.element.value[_this.element.selectionStart - 2]) !== valArray.lastIndexOf(_this.element.value[_this.element.selectionStart - 2]) && _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) === ignoreKeyCode || _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) !== ignoreKeyCode) {
              _this.element.setSelectionRange(prevPos, prevPos);
              _this.nextEle = _this.element.value[_this.element.selectionStart];
              _this.cursorPosChanged = true;
              _this.preventHandler();
            }
          }
          if (_this.cursorPosChanged === true && _this.element.value[_this.element.selectionStart] === _this.nextEle && isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1]))) {
            _this.element.setSelectionRange(_this.element.selectionStart + 1, _this.element.selectionStart + 1);
            _this.cursorPosChanged = false;
            _this.nextEle = null;
          }
          if (_this.element.value.trim() === "") {
            _this.element.setSelectionRange(start, start);
          }
          if (_this.element.selectionStart > 0) {
            if (_this.element.value[_this.element.selectionStart - 1].charCodeAt(0) === 45 && _this.element.selectionStart > 1) {
              if (!isNullOrUndefined(_this.prevVal)) {
                _this.element.value = _this.prevVal;
              }
              _this.element.setSelectionRange(_this.element.selectionStart, _this.element.selectionStart);
            }
            if (_this.element.value[_this.element.selectionStart - 1] === decimalSeparator && _this.decimals === 0 && _this.validateDecimalOnType) {
              _this.element.value = _this.element.value.substring(0, prevPos) + _this.element.value.substring(currentPos, _this.element.value.length);
            }
          }
          _this.prevVal = _this.element.value;
        }
      });
    };
    NumericTextBox2.prototype.keyUpHandler = function() {
      if (!this.enabled || this.readonly) {
        return;
      }
      var iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
      if (!iOS && Browser.isDevice) {
        this.preventHandler();
      }
      var parseValue = this.instance.getNumberParser({ format: "n" })(this.element.value);
      parseValue = parseValue === null || isNaN(parseValue) ? null : parseValue;
      this.hiddenInput.value = parseValue || parseValue === 0 ? parseValue.toString() : null;
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = document.createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.inputHandler = function(event) {
      var numerictextboxObj = this;
      if (!this.enabled || this.readonly) {
        return;
      }
      var iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
      var fireFox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      if ((fireFox || iOS) && Browser.isDevice) {
        this.preventHandler();
      }
      if (this.isAngular && this.element.value !== getValue("decimal", getNumericObject(this.locale)) && this.element.value !== getValue("minusSign", getNumericObject(this.locale))) {
        var parsedValue = this.instance.getNumberParser({ format: "n" })(this.element.value);
        parsedValue = isNaN(parsedValue) ? null : parsedValue;
        numerictextboxObj.localChange({ value: parsedValue });
        this.preventChange = true;
      }
      if (this.isVue) {
        var current = this.instance.getNumberParser({ format: "n" })(this.element.value);
        var previous = this.instance.getNumberParser({ format: "n" })(this.elementPrevValue);
        var nonZeroRegex = new RegExp("[^0-9]+$");
        if (nonZeroRegex.test(this.element.value) || (this.elementPrevValue.indexOf(".") !== -1 || this.elementPrevValue.indexOf("-") !== -1) && this.element.value[this.element.value.length - 1] === "0") {
          current = this.value;
        }
        var eventArgs = {
          event,
          value: current === null || isNaN(current) ? null : current,
          previousValue: previous === null || isNaN(previous) ? null : previous
        };
        this.preventChange = true;
        this.elementPrevValue = this.element.value;
        this.trigger("input", eventArgs);
      }
    };
    NumericTextBox2.prototype.keyDownHandler = function(event) {
      if (!this.readonly) {
        switch (event.keyCode) {
          case 38:
            event.preventDefault();
            this.action(INCREMENT, event);
            break;
          case 40:
            event.preventDefault();
            this.action(DECREMENT, event);
            break;
          default:
            break;
        }
      }
    };
    NumericTextBox2.prototype.performAction = function(value, step, operation) {
      if (value === null || isNaN(value)) {
        value = 0;
      }
      var updatedValue = operation === INCREMENT ? value + step : value - step;
      updatedValue = this.correctRounding(value, step, updatedValue);
      return this.strictMode ? this.trimValue(updatedValue) : updatedValue;
    };
    NumericTextBox2.prototype.correctRounding = function(value, step, result) {
      var floatExp = new RegExp("[,.](.*)");
      var floatValue = floatExp.test(value.toString());
      var floatStep = floatExp.test(step.toString());
      if (floatValue || floatStep) {
        var valueCount = floatValue ? floatExp.exec(value.toString())[0].length : 0;
        var stepCount = floatStep ? floatExp.exec(step.toString())[0].length : 0;
        var max = Math.max(valueCount, stepCount);
        return value = this.roundValue(result, max);
      }
      return result;
    };
    NumericTextBox2.prototype.roundValue = function(result, precision) {
      precision = precision || 0;
      var divide = Math.pow(10, precision);
      return result *= divide, result = Math.round(result) / divide;
    };
    NumericTextBox2.prototype.updateValue = function(value, event) {
      if (event) {
        this.isInteract = true;
      }
      if (value !== null && !isNaN(value)) {
        if (this.decimals) {
          value = this.roundNumber(value, this.decimals);
        }
      }
      this.inputValue = value;
      this.changeValue(value === null || isNaN(value) ? null : this.strictMode ? this.trimValue(value) : value);
      if (!this.isDynamicChange) {
        this.raiseChangeEvent(event);
      }
    };
    NumericTextBox2.prototype.updateCurrency = function(prop, propVal) {
      setValue(prop, propVal, this.cultureInfo);
      this.updateValue(this.value);
    };
    NumericTextBox2.prototype.changeValue = function(value) {
      if (!(value || value === 0)) {
        value = null;
        this.setProperties({ value }, true);
      } else {
        var numberOfDecimals = this.getNumberOfDecimals(value);
        this.setProperties({ value: this.roundNumber(value, numberOfDecimals) }, true);
      }
      this.modifyText();
      if (!this.strictMode) {
        this.validateState();
      }
    };
    NumericTextBox2.prototype.modifyText = function() {
      if (this.value || this.value === 0) {
        var value = this.formatNumber();
        var elementValue = this.isFocused ? value : this.instance.getNumberFormat(this.cultureInfo)(this.value);
        this.setElementValue(elementValue);
        attributes(this.element, { "aria-valuenow": value });
        this.hiddenInput.value = this.value.toString();
        if (this.value !== null && this.serverDecimalSeparator) {
          this.hiddenInput.value = this.hiddenInput.value.replace(".", this.serverDecimalSeparator);
        }
      } else {
        this.setElementValue("");
        this.element.removeAttribute("aria-valuenow");
        this.hiddenInput.value = null;
      }
    };
    NumericTextBox2.prototype.setElementValue = function(val, element2) {
      Input.setValue(val, element2 ? element2 : this.element, this.floatLabelType, this.showClearButton);
    };
    NumericTextBox2.prototype.validateState = function() {
      this.isValidState = true;
      if (this.value || this.value === 0) {
        this.isValidState = !(this.value > this.max || this.value < this.min);
      }
      this.checkErrorClass();
    };
    NumericTextBox2.prototype.getNumberOfDecimals = function(value) {
      var numberOfDecimals;
      var EXPREGEXP = new RegExp("[eE][-+]?([0-9]+)");
      var valueString = value.toString();
      if (EXPREGEXP.test(valueString)) {
        var result = EXPREGEXP.exec(valueString);
        if (!isNullOrUndefined(result)) {
          valueString = value.toFixed(Math.min(parseInt(result[1], 10), 20));
        }
      }
      var decimalPart = valueString.split(".")[1];
      numberOfDecimals = !decimalPart || !decimalPart.length ? 0 : decimalPart.length;
      if (this.decimals !== null) {
        numberOfDecimals = numberOfDecimals < this.decimals ? numberOfDecimals : this.decimals;
      }
      return numberOfDecimals;
    };
    NumericTextBox2.prototype.formatNumber = function() {
      var numberOfDecimals = this.getNumberOfDecimals(this.value);
      return this.instance.getNumberFormat({
        maximumFractionDigits: numberOfDecimals,
        minimumFractionDigits: numberOfDecimals,
        useGrouping: false
      })(this.value);
    };
    NumericTextBox2.prototype.trimValue = function(value) {
      if (value > this.max) {
        return this.max;
      }
      if (value < this.min) {
        return this.min;
      }
      return value;
    };
    NumericTextBox2.prototype.roundNumber = function(value, precision) {
      var result = value;
      var decimals = precision || 0;
      var result1 = result.toString().split("e");
      result = Math.round(Number(result1[0] + "e" + (result1[1] ? Number(result1[1]) + decimals : decimals)));
      var result2 = result.toString().split("e");
      result = Number(result2[0] + "e" + (result2[1] ? Number(result2[1]) - decimals : -decimals));
      return Number(result.toFixed(decimals));
    };
    NumericTextBox2.prototype.cancelEvent = function(event) {
      event.preventDefault();
      return false;
    };
    NumericTextBox2.prototype.keyPressHandler = function(event) {
      if (!this.enabled || this.readonly) {
        return true;
      }
      if (!Browser.isDevice && Browser.info.version === "11.0" && event.keyCode === 13) {
        var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
        this.updateValue(parsedInput, event);
        return true;
      }
      if (event.which === 0 || event.metaKey || event.ctrlKey || event.keyCode === 8 || event.keyCode === 13) {
        return true;
      }
      var currentChar = String.fromCharCode(event.which);
      var decimalSeparator = getValue("decimal", getNumericObject(this.locale));
      var isAlterNumPadDecimalChar = event.code === "NumpadDecimal" && currentChar !== decimalSeparator;
      if (isAlterNumPadDecimalChar) {
        currentChar = decimalSeparator;
      }
      var text = this.element.value;
      text = text.substring(0, this.element.selectionStart) + currentChar + text.substring(this.element.selectionEnd);
      if (!this.numericRegex().test(text)) {
        event.preventDefault();
        event.stopPropagation();
        return false;
      } else {
        if (isAlterNumPadDecimalChar) {
          var start = this.element.selectionStart + 1;
          this.element.value = text;
          this.element.setSelectionRange(start, start);
          event.preventDefault();
          event.stopPropagation();
        }
        return true;
      }
    };
    NumericTextBox2.prototype.numericRegex = function() {
      var numericObject = getNumericObject(this.locale);
      var decimalSeparator = getValue("decimal", numericObject);
      var fractionRule = "*";
      if (decimalSeparator === DECIMALSEPARATOR) {
        decimalSeparator = "\\" + decimalSeparator;
      }
      if (this.decimals === 0 && this.validateDecimalOnType) {
        return INTREGEXP;
      }
      if (this.decimals && this.validateDecimalOnType) {
        fractionRule = "{0," + this.decimals + "}";
      }
      return new RegExp("^(-)?(((\\d+(" + decimalSeparator + "\\d" + fractionRule + ")?)|(" + decimalSeparator + "\\d" + fractionRule + ")))?$");
    };
    NumericTextBox2.prototype.mouseWheel = function(event) {
      event.preventDefault();
      var delta;
      var rawEvent = event;
      if (rawEvent.wheelDelta) {
        delta = rawEvent.wheelDelta / 120;
      } else if (rawEvent.detail) {
        delta = -rawEvent.detail / 3;
      }
      if (delta > 0) {
        this.action(INCREMENT, event);
      } else if (delta < 0) {
        this.action(DECREMENT, event);
      }
      this.cancelEvent(event);
    };
    NumericTextBox2.prototype.focusHandler = function(event) {
      var _this = this;
      clearTimeout(selectionTimeOut);
      this.focusEventArgs = { event, value: this.value, container: this.container };
      this.trigger("focus", this.focusEventArgs);
      if (!this.enabled || this.readonly) {
        return;
      }
      this.isFocused = true;
      removeClass([this.container], ERROR);
      this.prevValue = this.value;
      if (this.value || this.value === 0) {
        var formatValue_1 = this.formatNumber();
        this.setElementValue(formatValue_1);
        if (!this.isPrevFocused) {
          if (!Browser.isDevice && Browser.info.version === "11.0") {
            this.element.setSelectionRange(0, formatValue_1.length);
          } else {
            var delay = Browser.isDevice && Browser.isIos ? 600 : 0;
            selectionTimeOut = setTimeout(function() {
              _this.element.setSelectionRange(0, formatValue_1.length);
            }, delay);
          }
        }
      }
      if (!Browser.isDevice) {
        EventHandler.add(this.element, "mousewheel DOMMouseScroll", this.mouseWheel, this);
      }
    };
    NumericTextBox2.prototype.focusOutHandler = function(event) {
      var _this = this;
      this.blurEventArgs = { event, value: this.value, container: this.container };
      this.trigger("blur", this.blurEventArgs);
      if (!this.enabled || this.readonly) {
        return;
      }
      if (this.isPrevFocused) {
        event.preventDefault();
        if (Browser.isDevice) {
          var value_1 = this.element.value;
          this.element.focus();
          this.isPrevFocused = false;
          var ele_1 = this.element;
          setTimeout(function() {
            _this.setElementValue(value_1, ele_1);
          }, 200);
        }
      } else {
        this.isFocused = false;
        if (!this.element.value.length) {
          this.setProperties({ value: null }, true);
        }
        var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
        this.updateValue(parsedInput);
        if (!Browser.isDevice) {
          EventHandler.remove(this.element, "mousewheel DOMMouseScroll", this.mouseWheel);
        }
      }
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var focusEvent = document.createEvent("FocusEvent");
        focusEvent.initEvent("focusout", false, true);
        element2.dispatchEvent(focusEvent);
      }
    };
    NumericTextBox2.prototype.mouseDownOnSpinner = function(event) {
      var _this = this;
      if (this.isFocused) {
        this.isPrevFocused = true;
        event.preventDefault();
      }
      if (!this.getElementData(event)) {
        return;
      }
      this.getElementData(event);
      var target = event.currentTarget;
      var action = target.classList.contains(SPINUP) ? INCREMENT : DECREMENT;
      EventHandler.add(target, "mouseleave", this.mouseUpClick, this);
      this.timeOut = setInterval(function() {
        _this.isCalled = true;
        _this.action(action, event);
      }, 150);
      EventHandler.add(document, "mouseup", this.mouseUpClick, this);
    };
    NumericTextBox2.prototype.touchMoveOnSpinner = function(event) {
      var target;
      if (event.type === "touchmove") {
        var touchEvent = event.touches;
        target = touchEvent.length && document.elementFromPoint(touchEvent[0].pageX, touchEvent[0].pageY);
      } else {
        target = document.elementFromPoint(event.clientX, event.clientY);
      }
      if (!target.classList.contains(SPINICON)) {
        clearInterval(this.timeOut);
      }
    };
    NumericTextBox2.prototype.mouseUpOnSpinner = function(event) {
      this.prevValue = this.value;
      if (this.isPrevFocused) {
        this.element.focus();
        if (!Browser.isDevice) {
          this.isPrevFocused = false;
        }
      }
      if (!Browser.isDevice) {
        event.preventDefault();
      }
      if (!this.getElementData(event)) {
        return;
      }
      var target = event.currentTarget;
      var action = target.classList.contains(SPINUP) ? INCREMENT : DECREMENT;
      EventHandler.remove(target, "mouseleave", this.mouseUpClick);
      if (!this.isCalled) {
        this.action(action, event);
      }
      this.isCalled = false;
      EventHandler.remove(document, "mouseup", this.mouseUpClick);
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = document.createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.getElementData = function(event) {
      if (event.which && event.which === 3 || event.button && event.button === 2 || !this.enabled || this.readonly) {
        return false;
      }
      clearInterval(this.timeOut);
      return true;
    };
    NumericTextBox2.prototype.floatLabelTypeUpdate = function() {
      Input.removeFloating(this.inputWrapper);
      var hiddenInput = this.hiddenInput;
      this.hiddenInput.remove();
      Input.addFloating(this.element, this.floatLabelType, this.placeholder, this.createElement);
      this.container.insertBefore(hiddenInput, this.container.childNodes[1]);
    };
    NumericTextBox2.prototype.mouseUpClick = function(event) {
      event.stopPropagation();
      clearInterval(this.timeOut);
      this.isCalled = false;
      if (this.spinUp) {
        EventHandler.remove(this.spinUp, "mouseleave", this.mouseUpClick);
      }
      if (this.spinDown) {
        EventHandler.remove(this.spinDown, "mouseleave", this.mouseUpClick);
      }
    };
    NumericTextBox2.prototype.increment = function(step) {
      if (step === void 0) {
        step = this.step;
      }
      this.isInteract = false;
      this.changeValue(this.performAction(this.value, step, INCREMENT));
      this.raiseChangeEvent();
    };
    NumericTextBox2.prototype.decrement = function(step) {
      if (step === void 0) {
        step = this.step;
      }
      this.isInteract = false;
      this.changeValue(this.performAction(this.value, step, DECREMENT));
      this.raiseChangeEvent();
    };
    NumericTextBox2.prototype.destroy = function() {
      this.unwireEvents();
      if (this.showClearButton) {
        this.clearButton = document.getElementsByClassName("e-clear-icon")[0];
      }
      detach(this.hiddenInput);
      if (this.showSpinButton) {
        this.unwireSpinBtnEvents();
        detach(this.spinUp);
        detach(this.spinDown);
      }
      var attrArray = [
        "aria-labelledby",
        "role",
        "autocomplete",
        "aria-readonly",
        "aria-disabled",
        "autocapitalize",
        "spellcheck",
        "aria-autocomplete",
        "tabindex",
        "aria-valuemin",
        "aria-valuemax",
        "aria-valuenow",
        "aria-invalid"
      ];
      for (var i = 0; i < attrArray.length; i++) {
        this.element.removeAttribute(attrArray[i]);
      }
      this.element.classList.remove("e-input");
      this.container.insertAdjacentElement("afterend", this.element);
      detach(this.container);
      this.spinUp = null;
      this.spinDown = null;
      this.container = null;
      this.hiddenInput = null;
      this.changeEventArgs = null;
      this.blurEventArgs = null;
      this.focusEventArgs = null;
      this.inputWrapper = null;
      Input.destroy({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      _super.prototype.destroy.call(this);
    };
    NumericTextBox2.prototype.getText = function() {
      return this.element.value;
    };
    NumericTextBox2.prototype.focusIn = function() {
      if (document.activeElement !== this.element && this.enabled) {
        this.element.focus();
        addClass([this.container], [NUMERIC_FOCUS]);
      }
    };
    NumericTextBox2.prototype.focusOut = function() {
      if (document.activeElement === this.element && this.enabled) {
        this.element.blur();
        removeClass([this.container], [NUMERIC_FOCUS]);
      }
    };
    NumericTextBox2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    NumericTextBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            this.setElementWidth(newProp.width);
            Input.calculateWidth(this.element, this.container);
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "enabled":
            Input.setEnabled(newProp.enabled, this.element);
            this.bindClearEvent();
            break;
          case "enableRtl":
            Input.setEnableRtl(newProp.enableRtl, [this.container]);
            break;
          case "readonly":
            Input.setReadonly(newProp.readonly, this.element);
            if (this.readonly) {
              attributes(this.element, { "aria-readonly": "true" });
            } else {
              this.element.removeAttribute("aria-readonly");
            }
            break;
          case "htmlAttributes":
            this.updateHTMLAttrToElement();
            this.updateHTMLAttrToWrapper();
            this.updateDataAttribute(true);
            this.checkAttributes(true);
            Input.validateInputType(this.container, this.element);
            break;
          case "placeholder":
            Input.setPlaceholder(newProp.placeholder, this.element);
            Input.calculateWidth(this.element, this.container);
            break;
          case "step":
            this.step = newProp.step;
            this.validateStep();
            break;
          case "showSpinButton":
            this.updateSpinButton(newProp);
            break;
          case "showClearButton":
            this.updateClearButton(newProp);
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            this.floatLabelTypeUpdate();
            break;
          case "value":
            this.isDynamicChange = (this.isAngular || this.isVue) && this.preventChange;
            this.updateValue(newProp.value);
            if (this.isDynamicChange) {
              this.preventChange = false;
              this.isDynamicChange = false;
            }
            break;
          case "min":
          case "max":
            setValue(prop, getValue(prop, newProp), this);
            this.validateMinMax();
            this.updateValue(this.value);
            break;
          case "strictMode":
            this.strictMode = newProp.strictMode;
            this.updateValue(this.value);
            this.validateState();
            break;
          case "locale":
            this.initCultureFunc();
            this.l10n.setLocale(this.locale);
            this.setSpinButton();
            this.updatePlaceholder();
            Input.setPlaceholder(this.placeholder, this.element);
            this.updateValue(this.value);
            break;
          case "currency":
            {
              var propVal = getValue(prop, newProp);
              this.setProperties({ currencyCode: propVal }, true);
              this.updateCurrency(prop, propVal);
            }
            break;
          case "currencyCode":
            {
              var propValue = getValue(prop, newProp);
              this.setProperties({ currency: propValue }, true);
              this.updateCurrency("currency", propValue);
            }
            break;
          case "format":
            setValue(prop, getValue(prop, newProp), this);
            this.initCultureInfo();
            this.updateValue(this.value);
            break;
          case "decimals":
            this.decimals = newProp.decimals;
            this.updateValue(this.value);
        }
      }
    };
    NumericTextBox2.prototype.updateClearButton = function(newProp) {
      Input.setClearButton(newProp.showClearButton, this.element, this.inputWrapper, void 0, this.createElement);
      this.bindClearEvent();
    };
    NumericTextBox2.prototype.updateSpinButton = function(newProp) {
      if (newProp.showSpinButton) {
        this.spinBtnCreation();
      } else {
        detach(this.spinUp);
        detach(this.spinDown);
      }
    };
    NumericTextBox2.prototype.getModuleName = function() {
      return "numerictextbox";
    };
    __decorate12([
      Property("")
    ], NumericTextBox2.prototype, "cssClass", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "value", void 0);
    __decorate12([
      Property(-Number.MAX_VALUE)
    ], NumericTextBox2.prototype, "min", void 0);
    __decorate12([
      Property(Number.MAX_VALUE)
    ], NumericTextBox2.prototype, "max", void 0);
    __decorate12([
      Property(1)
    ], NumericTextBox2.prototype, "step", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "width", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "placeholder", void 0);
    __decorate12([
      Property({})
    ], NumericTextBox2.prototype, "htmlAttributes", void 0);
    __decorate12([
      Property(true)
    ], NumericTextBox2.prototype, "showSpinButton", void 0);
    __decorate12([
      Property(false)
    ], NumericTextBox2.prototype, "readonly", void 0);
    __decorate12([
      Property(true)
    ], NumericTextBox2.prototype, "enabled", void 0);
    __decorate12([
      Property(false)
    ], NumericTextBox2.prototype, "showClearButton", void 0);
    __decorate12([
      Property(false)
    ], NumericTextBox2.prototype, "enablePersistence", void 0);
    __decorate12([
      Property("n2")
    ], NumericTextBox2.prototype, "format", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "decimals", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "currency", void 0);
    __decorate12([
      Property(null)
    ], NumericTextBox2.prototype, "currencyCode", void 0);
    __decorate12([
      Property(true)
    ], NumericTextBox2.prototype, "strictMode", void 0);
    __decorate12([
      Property(false)
    ], NumericTextBox2.prototype, "validateDecimalOnType", void 0);
    __decorate12([
      Property("Never")
    ], NumericTextBox2.prototype, "floatLabelType", void 0);
    __decorate12([
      Event()
    ], NumericTextBox2.prototype, "created", void 0);
    __decorate12([
      Event()
    ], NumericTextBox2.prototype, "destroyed", void 0);
    __decorate12([
      Event()
    ], NumericTextBox2.prototype, "change", void 0);
    __decorate12([
      Event()
    ], NumericTextBox2.prototype, "focus", void 0);
    __decorate12([
      Event()
    ], NumericTextBox2.prototype, "blur", void 0);
    NumericTextBox2 = __decorate12([
      NotifyPropertyChanges
    ], NumericTextBox2);
    return NumericTextBox2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/maskedtextbox/base/mask-base.js
var ERROR2 = "e-error";
var INPUTGROUP = "e-input-group";
var FLOATINPUT = "e-float-input";
var TOPLABEL = "e-label-top";
var BOTTOMLABEL = "e-label-bottom";
var regularExpressions = {
  "0": "[0-9]",
  "9": "[0-9 ]",
  "#": "[0-9 +-]",
  "L": "[A-Za-z]",
  "?": "[A-Za-z ]",
  "&": "[^ ]+",
  "C": "[^]+",
  "A": "[A-Za-z0-9]",
  "a": "[A-Za-z0-9 ]"
};
function createMask() {
  attributes(this.element, {
    "role": "textbox",
    "autocomplete": "off",
    "autocapitalize": "off",
    "spellcheck": "false",
    "aria-live": "assertive"
  });
  if (this.mask) {
    var splitMask = this.mask.split("]");
    for (var i = 0; i < splitMask.length; i++) {
      if (splitMask[i][splitMask[i].length - 1] === "\\") {
        splitMask[i] = splitMask[i] + "]";
        var splitInnerMask = splitMask[i].split("[");
        for (var j = 0; j < splitInnerMask.length; j++) {
          if (splitInnerMask[j][splitInnerMask[j].length - 1] === "\\") {
            splitInnerMask[j] = splitInnerMask[j] + "[";
          }
          pushIntoRegExpCollec.call(this, splitInnerMask[j]);
        }
      } else {
        var splitInnerMask = splitMask[i].split("[");
        if (splitInnerMask.length > 1) {
          var chkSpace = false;
          for (var j = 0; j < splitInnerMask.length; j++) {
            if (splitInnerMask[j] === "\\") {
              this.customRegExpCollec.push("[");
              this.hiddenMask += splitInnerMask[j] + "[";
            } else if (splitInnerMask[j] === "") {
              chkSpace = true;
            } else if (splitInnerMask[j] !== "" && chkSpace || j === splitInnerMask.length - 1) {
              this.customRegExpCollec.push("[" + splitInnerMask[j] + "]");
              this.hiddenMask += this.promptChar;
              chkSpace = false;
            } else {
              pushIntoRegExpCollec.call(this, splitInnerMask[j]);
            }
          }
        } else {
          pushIntoRegExpCollec.call(this, splitInnerMask[0]);
        }
      }
    }
    this.escapeMaskValue = this.hiddenMask;
    this.promptMask = this.hiddenMask.replace(/[09?LCAa#&]/g, this.promptChar);
    if (!isNullOrUndefined(this.customCharacters)) {
      for (var i = 0; i < this.promptMask.length; i++) {
        if (!isNullOrUndefined(this.customCharacters[this.promptMask[i]])) {
          this.promptMask = this.promptMask.replace(new RegExp(this.promptMask[i], "g"), this.promptChar);
        }
      }
    }
    var escapeNumber = 0;
    if (this.hiddenMask.match(new RegExp(/\\/))) {
      for (var i = 0; i < this.hiddenMask.length; i++) {
        var j = 0;
        if (i >= 1) {
          j = i;
        }
        escapeNumber = this.hiddenMask.length - this.promptMask.length;
        j = j - escapeNumber;
        if (i > 0 && this.hiddenMask[i - 1] !== "\\" && (this.hiddenMask[i] === ">" || this.hiddenMask[i] === "<" || this.hiddenMask[i] === "|")) {
          this.promptMask = this.promptMask.substring(0, j) + this.promptMask.substring(i + 1 - escapeNumber, this.promptMask.length);
          this.escapeMaskValue = this.escapeMaskValue.substring(0, j) + this.escapeMaskValue.substring(i + 1 - escapeNumber, this.escapeMaskValue.length);
        }
        if (this.hiddenMask[i] === "\\") {
          this.promptMask = this.promptMask.substring(0, j) + this.hiddenMask[i + 1] + this.promptMask.substring(i + 2 - escapeNumber, this.promptMask.length);
          this.escapeMaskValue = this.escapeMaskValue.substring(0, j) + this.escapeMaskValue[i + 1] + this.escapeMaskValue.substring(i + 2 - escapeNumber, this.escapeMaskValue.length);
        }
      }
    } else {
      this.promptMask = this.promptMask.replace(/[>|<]/g, "");
      this.escapeMaskValue = this.hiddenMask.replace(/[>|<]/g, "");
    }
    attributes(this.element, { "aria-invalid": "false" });
  }
}
function applyMask() {
  setElementValue.call(this, this.promptMask);
  setMaskValue.call(this, this.value);
}
function wireEvents2() {
  EventHandler.add(this.element, "keydown", maskInputKeyDownHandler, this);
  EventHandler.add(this.element, "keypress", maskInputKeyPressHandler, this);
  EventHandler.add(this.element, "keyup", maskInputKeyUpHandler, this);
  EventHandler.add(this.element, "input", maskInputHandler, this);
  EventHandler.add(this.element, "focus", maskInputFocusHandler, this);
  EventHandler.add(this.element, "blur", maskInputBlurHandler, this);
  EventHandler.add(this.element, "paste", maskInputPasteHandler, this);
  EventHandler.add(this.element, "cut", maskInputCutHandler, this);
  EventHandler.add(this.element, "drop", maskInputDropHandler, this);
  EventHandler.add(this.element, "mousedown", maskInputMouseDownHandler, this);
  EventHandler.add(this.element, "mouseup", maskInputMouseUpHandler, this);
  if (this.enabled) {
    bindClearEvent.call(this);
    if (this.formElement) {
      EventHandler.add(this.formElement, "reset", resetFormHandler, this);
    }
  }
}
function unwireEvents() {
  EventHandler.remove(this.element, "keydown", maskInputKeyDownHandler);
  EventHandler.remove(this.element, "keypress", maskInputKeyPressHandler);
  EventHandler.remove(this.element, "keyup", maskInputKeyUpHandler);
  EventHandler.remove(this.element, "input", maskInputHandler);
  EventHandler.remove(this.element, "focus", maskInputFocusHandler);
  EventHandler.remove(this.element, "blur", maskInputBlurHandler);
  EventHandler.remove(this.element, "paste", maskInputPasteHandler);
  EventHandler.remove(this.element, "cut", maskInputCutHandler);
  EventHandler.remove(this.element, "drop", maskInputDropHandler);
  EventHandler.remove(this.element, "mousedown", maskInputMouseDownHandler);
  EventHandler.remove(this.element, "mouseup", maskInputMouseUpHandler);
  if (this.formElement) {
    EventHandler.remove(this.formElement, "reset", resetFormHandler);
  }
}
function bindClearEvent() {
  if (this.showClearButton) {
    EventHandler.add(this.inputObj.clearButton, "mousedown touchstart", resetHandler, this);
  }
}
function resetHandler(e) {
  e.preventDefault();
  if (!this.inputObj.clearButton.classList.contains("e-clear-icon-hide") || this.inputObj.container.classList.contains("e-static-clear")) {
    clear.call(this, e);
    this.value = "";
  }
}
function clear(event) {
  var value = this.element.value;
  setElementValue.call(this, this.promptMask);
  this.redoCollec.unshift({
    value: this.promptMask,
    startIndex: this.element.selectionStart,
    endIndex: this.element.selectionEnd
  });
  triggerMaskChangeEvent.call(this, event, value);
  this.element.setSelectionRange(0, 0);
}
function resetFormHandler() {
  if (this.element.tagName === "EJS-MASKEDTEXTBOX") {
    setElementValue.call(this, this.promptMask);
  } else {
    this.value = this.initInputValue;
  }
}
function unstrippedValue(element2) {
  return element2.value;
}
function strippedValue(element2, maskValues) {
  var value = "";
  var k = 0;
  var checkMask = false;
  var maskValue = !isNullOrUndefined(maskValues) ? maskValues : !isNullOrUndefined(element2) && !isNullOrUndefined(this) ? element2.value : maskValues;
  if (maskValue !== this.promptMask) {
    for (var i = 0; i < this.customRegExpCollec.length; i++) {
      if (checkMask) {
        checkMask = false;
      }
      if (this.customRegExpCollec[k] === ">" || this.customRegExpCollec[k] === "<" || this.customRegExpCollec[k] === "|" || this.customRegExpCollec[k] === "\\") {
        --i;
        checkMask = true;
      }
      if (!checkMask) {
        if (maskValue[i] !== this.promptChar && (!isNullOrUndefined(this.customRegExpCollec[k]) && (this._callPasteHandler || !isNullOrUndefined(this.regExpCollec[this.customRegExpCollec[k]]) || this.customRegExpCollec[k].length > 2 && this.customRegExpCollec[k][0] === "[" && this.customRegExpCollec[k][this.customRegExpCollec[k].length - 1] === "]" || !isNullOrUndefined(this.customCharacters) && !isNullOrUndefined(this.customCharacters[this.customRegExpCollec[k]]))) && maskValue !== "") {
          value += maskValue[i];
        }
      }
      ++k;
    }
  }
  if (this.mask === null || this.mask === "" && this.value !== void 0) {
    value = maskValue;
  }
  return value;
}
function pushIntoRegExpCollec(value) {
  for (var k = 0; k < value.length; k++) {
    this.hiddenMask += value[k];
    if (value[k] !== "\\") {
      this.customRegExpCollec.push(value[k]);
    }
  }
}
function maskInputMouseDownHandler() {
  this.isClicked = true;
}
function maskInputMouseUpHandler() {
  this.isClicked = false;
}
function maskInputFocusHandler(event) {
  var _this = this;
  var inputElement = this.element;
  var startIndex = 0;
  var modelValue = strippedValue.call(this, inputElement);
  var toAllowForward = false;
  var toAllowBackward = false;
  var eventArgs = {
    selectionStart: inputElement.selectionStart,
    event,
    value: this.value,
    maskedValue: inputElement.value,
    container: !isNullOrUndefined(this.inputObj) ? this.inputObj.container : this.inputObj,
    selectionEnd: inputElement.selectionEnd
  };
  if (!this.isClicked) {
    triggerFocus.call(this, eventArgs, inputElement);
  }
  if (this.mask) {
    if (!(!(modelValue === null || modelValue === "") || this.floatLabelType === "Always" || this.placeholder === null || this.placeholder === "")) {
      inputElement.value = this.promptMask;
    }
    setTimeout(function() {
      if (inputElement.selectionStart === _this.promptMask.length || inputElement.value[inputElement.selectionStart] === _this.promptChar) {
        toAllowForward = true;
      } else {
        for (var i = inputElement.selectionStart; i < _this.promptMask.length; i++) {
          if (inputElement.value[i] !== _this.promptChar) {
            if (inputElement.value[i] !== _this.promptMask[i]) {
              toAllowForward = false;
              break;
            }
          } else {
            toAllowForward = true;
            break;
          }
        }
      }
    });
    setTimeout(function() {
      var backSelectionStart = inputElement.selectionStart - 1;
      if (backSelectionStart === _this.promptMask.length - 1 || inputElement.value[backSelectionStart] === _this.promptChar) {
        toAllowBackward = true;
      } else {
        for (var i = backSelectionStart; i >= 0; i--) {
          if (inputElement.value[i] !== _this.promptChar) {
            if (inputElement.value[i] !== _this.promptMask[i]) {
              toAllowBackward = false;
              break;
            }
          } else {
            toAllowBackward = true;
            break;
          }
        }
      }
    });
    if (this.isClicked || this.floatLabelType !== "Always" && ((modelValue === null || modelValue === "") && (this.placeholder !== null && this.placeholder !== ""))) {
      for (startIndex = 0; startIndex < this.promptMask.length; startIndex++) {
        if (inputElement.value[startIndex] === this.promptChar) {
          setTimeout(function() {
            if (toAllowForward || toAllowBackward) {
              inputElement.selectionEnd = startIndex;
              inputElement.selectionStart = startIndex;
            }
            eventArgs = {
              selectionStart: inputElement.selectionStart,
              event,
              value: _this.value,
              maskedValue: inputElement.value,
              container: !isNullOrUndefined(_this.inputObj) ? _this.inputObj.container : _this.inputObj,
              selectionEnd: inputElement.selectionEnd
            };
            triggerFocus.call(_this, eventArgs, inputElement);
          }, 110);
          break;
        }
      }
      if (isNullOrUndefined(inputElement.value.match(escapeRegExp(this.promptChar)))) {
        eventArgs = {
          selectionStart: inputElement.selectionStart,
          event,
          value: this.value,
          maskedValue: inputElement.value,
          container: !isNullOrUndefined(this.inputObj) ? this.inputObj.container : this.inputObj,
          selectionEnd: inputElement.selectionEnd
        };
        triggerFocus.call(this, eventArgs, inputElement);
      }
      this.isClicked = false;
    }
  }
}
function triggerFocus(eventArgs, inputElement) {
  this.trigger("focus", eventArgs, function(eventArgs2) {
    inputElement.selectionStart = eventArgs2.selectionStart;
    inputElement.selectionEnd = eventArgs2.selectionEnd;
  });
}
function escapeRegExp(text) {
  return !isNullOrUndefined(text) ? text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : text;
}
function maskInputBlurHandler(event) {
  this.blurEventArgs = {
    event,
    value: this.value,
    maskedValue: this.element.value,
    container: !isNullOrUndefined(this.inputObj) ? this.inputObj.container : this.inputObj
  };
  this.trigger("blur", this.blurEventArgs);
  if (this.mask) {
    this.isFocus = false;
    if (this.placeholder && this.element.value === this.promptMask && this.floatLabelType !== "Always") {
      setElementValue.call(this, "");
      var labelElement = this.element.parentNode.querySelector(".e-float-text");
      if (this.floatLabelType === "Auto" && !isNullOrUndefined(labelElement) && labelElement.classList.contains(TOPLABEL)) {
        removeClass([labelElement], TOPLABEL);
      }
    }
  }
}
function maskInputPasteHandler(event) {
  var _this = this;
  if (this.mask && !this.readonly) {
    var sIndex_1 = this.element.selectionStart;
    var eIndex_1 = this.element.selectionEnd;
    var oldValue_1 = this.element.value;
    setElementValue.call(this, "");
    this._callPasteHandler = true;
    setTimeout(function() {
      var value = _this.element.value.replace(/ /g, "");
      if (_this.redoCollec.length > 0 && _this.redoCollec[0].value === _this.element.value) {
        value = strippedValue.call(_this, _this.element);
      }
      setElementValue.call(_this, oldValue_1);
      _this.element.selectionStart = sIndex_1;
      _this.element.selectionEnd = eIndex_1;
      var i = 0;
      _this.maskKeyPress = true;
      do {
        validateValue.call(_this, value[i], false, null);
        ++i;
      } while (i < value.length);
      _this.maskKeyPress = false;
      _this._callPasteHandler = false;
      if (_this.element.value === oldValue_1) {
        var i_1 = 0;
        _this.maskKeyPress = true;
        do {
          validateValue.call(_this, value[i_1], false, null);
          ++i_1;
        } while (i_1 < value.length);
        _this.maskKeyPress = false;
      } else {
        triggerMaskChangeEvent.call(_this, event, oldValue_1);
      }
    }, 1);
  }
}
function maskInputCutHandler(event) {
  var _this = this;
  if (this.mask && !this.readonly) {
    var preValue_1 = this.element.value;
    var sIndex_2 = this.element.selectionStart;
    var eIndex = this.element.selectionEnd;
    this.undoCollec.push({ value: this.element.value, startIndex: this.element.selectionStart, endIndex: this.element.selectionEnd });
    var value_1 = this.element.value.substring(0, sIndex_2) + this.promptMask.substring(sIndex_2, eIndex) + this.element.value.substring(eIndex);
    setTimeout(function() {
      setElementValue.call(_this, value_1);
      _this.element.selectionStart = _this.element.selectionEnd = sIndex_2;
      if (_this.element.value !== preValue_1) {
        triggerMaskChangeEvent.call(_this, event, null);
      }
    }, 0);
  }
}
function maskInputDropHandler(event) {
  event.preventDefault();
}
function maskInputHandler(event) {
  if (Browser.isIE === true && this.element.value === "" && this.floatLabelType === "Never") {
    return;
  }
  var eventArgs = { ctrlKey: false, keyCode: 229 };
  extend(event, eventArgs);
  if (this.mask) {
    if (this.element.value === "") {
      this.redoCollec.unshift({
        value: this.promptMask,
        startIndex: this.element.selectionStart,
        endIndex: this.element.selectionEnd
      });
    }
    if (this.element.value.length === 1) {
      this.element.value = this.element.value + this.promptMask;
      this.element.setSelectionRange(1, 1);
    }
    if (!this._callPasteHandler) {
      removeMaskInputValues.call(this, event);
    }
    if (this.element.value.length > this.promptMask.length) {
      var startIndex = this.element.selectionStart;
      var addedValues = this.element.value.length - this.promptMask.length;
      var value = this.element.value.substring(startIndex - addedValues, startIndex);
      this.maskKeyPress = false;
      var i = 0;
      do {
        validateValue.call(this, value[i], event.ctrlKey, event);
        ++i;
      } while (i < value.length);
      if (this.element.value !== this.preEleVal) {
        triggerMaskChangeEvent.call(this, event, null);
      }
    }
    var val = strippedValue.call(this, this.element);
    this.prevValue = val;
    this.value = val;
    if (val === "") {
      setElementValue.call(this, this.promptMask);
      this.element.setSelectionRange(0, 0);
    }
  }
}
function maskInputKeyDownHandler(event) {
  if (this.mask && !this.readonly) {
    if (event.keyCode !== 229) {
      if (event.ctrlKey && (event.keyCode === 89 || event.keyCode === 90)) {
        event.preventDefault();
      }
      removeMaskInputValues.call(this, event);
    }
    var startValue = this.element.value;
    if (event.ctrlKey && (event.keyCode === 89 || event.keyCode === 90)) {
      var collec = void 0;
      if (event.keyCode === 90 && this.undoCollec.length > 0 && startValue !== this.undoCollec[this.undoCollec.length - 1].value) {
        collec = this.undoCollec[this.undoCollec.length - 1];
        this.redoCollec.unshift({
          value: this.element.value,
          startIndex: this.element.selectionStart,
          endIndex: this.element.selectionEnd
        });
        setElementValue.call(this, collec.value);
        this.element.selectionStart = collec.startIndex;
        this.element.selectionEnd = collec.endIndex;
        this.undoCollec.splice(this.undoCollec.length - 1, 1);
      } else if (event.keyCode === 89 && this.redoCollec.length > 0 && startValue !== this.redoCollec[0].value) {
        collec = this.redoCollec[0];
        this.undoCollec.push({
          value: this.element.value,
          startIndex: this.element.selectionStart,
          endIndex: this.element.selectionEnd
        });
        setElementValue.call(this, collec.value);
        this.element.selectionStart = collec.startIndex;
        this.element.selectionEnd = collec.endIndex;
        this.redoCollec.splice(0, 1);
      }
    }
  }
}
function mobileRemoveFunction() {
  var collec;
  var sIndex = this.element.selectionStart;
  var eIndex = this.element.selectionEnd;
  if (this.redoCollec.length > 0) {
    collec = this.redoCollec[0];
    setElementValue.call(this, collec.value);
    if (collec.startIndex - sIndex === 1) {
      this.element.selectionStart = collec.startIndex;
      this.element.selectionEnd = collec.endIndex;
    } else {
      this.element.selectionStart = sIndex + 1;
      this.element.selectionEnd = eIndex + 1;
    }
  } else {
    setElementValue.call(this, this.promptMask);
    this.element.selectionStart = this.element.selectionEnd = sIndex;
  }
}
function autoFillMaskInputValues(isRemove, oldEventVal, event) {
  if (event.type === "input") {
    isRemove = false;
    oldEventVal = this.element.value;
    setElementValue.call(this, this.promptMask);
    setMaskValue.call(this, oldEventVal);
  }
  return isRemove;
}
function removeMaskInputValues(event) {
  var isRemove = false;
  var oldEventVal;
  var isDeleted = false;
  if (this.element.value.length < this.promptMask.length) {
    isRemove = true;
    oldEventVal = this.element.value;
    isRemove = autoFillMaskInputValues.call(this, isRemove, oldEventVal, event);
    mobileRemoveFunction.call(this);
  }
  if (this.element.value.length >= this.promptMask.length && event.type === "input") {
    isRemove = autoFillMaskInputValues.call(this, isRemove, oldEventVal, event);
  }
  var initStartIndex = this.element.selectionStart;
  var initEndIndex = this.element.selectionEnd;
  var startIndex = this.element.selectionStart;
  var endIndex = this.element.selectionEnd;
  var maskValue = this.hiddenMask.replace(/[>|\\<]/g, "");
  var curMask = maskValue[startIndex - 1];
  var deleteEndIndex = this.element.selectionEnd;
  if (isRemove || event.keyCode === 8 || event.keyCode === 46) {
    this.undoCollec.push({ value: this.element.value, startIndex: this.element.selectionStart, endIndex });
    var multipleDel = false;
    var preValue = this.element.value;
    if (startIndex > 0 || (event.keyCode === 8 || event.keyCode === 46) && startIndex < this.element.value.length && this.element.selectionEnd - startIndex !== this.element.value.length) {
      var index = startIndex;
      if (startIndex !== endIndex) {
        startIndex = endIndex;
        if (event.keyCode === 46) {
          multipleDel = true;
        }
      } else if (event.keyCode === 46) {
        ++index;
      } else {
        --index;
      }
      for (var k = startIndex; event.keyCode === 8 || isRemove || multipleDel ? k > index : k < index; event.keyCode === 8 || isRemove || multipleDel ? k-- : k++) {
        for (var i = startIndex; event.keyCode === 8 || isRemove || multipleDel ? i > 0 : i < this.element.value.length; event.keyCode === 8 || isRemove || multipleDel ? i-- : i++) {
          var sIndex = void 0;
          if ((event.keyCode === 8 || multipleDel) && (initStartIndex !== initEndIndex && initStartIndex !== startIndex || initStartIndex === initEndIndex) || isRemove) {
            curMask = maskValue[i - 1];
            sIndex = startIndex - 1;
          } else {
            curMask = maskValue[i];
            sIndex = startIndex;
            ++startIndex;
          }
          var oldValue = this.element.value[sIndex];
          if (isNullOrUndefined(this.regExpCollec["" + curMask]) && (!isNullOrUndefined(this.customCharacters) && isNullOrUndefined(this.customCharacters["" + curMask])) && (this.hiddenMask[sIndex] !== this.promptChar && this.customRegExpCollec[sIndex][0] !== "[" && this.customRegExpCollec[sIndex][this.customRegExpCollec[sIndex].length - 1] !== "]") || this.promptMask[sIndex] !== this.promptChar && isNullOrUndefined(this.customCharacters)) {
            this.element.selectionStart = this.element.selectionEnd = sIndex;
            event.preventDefault();
            if (event.keyCode === 46 && !multipleDel) {
              ++this.element.selectionStart;
            }
          } else {
            var value = this.element.value;
            var prompt_1 = this.promptChar;
            var elementValue = value.substring(0, sIndex) + prompt_1 + value.substring(startIndex, value.length);
            setElementValue.call(this, elementValue);
            event.preventDefault();
            if (event.keyCode === 46 && !multipleDel) {
              sIndex++;
            }
            this.element.selectionStart = this.element.selectionEnd = sIndex;
            isDeleted = true;
          }
          startIndex = this.element.selectionStart;
          if (!isDeleted && event.keyCode === 8 || multipleDel || !isDeleted && !(event.keyCode === 46)) {
            sIndex = startIndex - 1;
          } else {
            sIndex = startIndex;
            isDeleted = false;
          }
          oldValue = this.element.value[sIndex];
          if (initStartIndex !== initEndIndex && this.element.selectionStart === initStartIndex || this.promptMask[sIndex] === this.promptChar || oldValue !== this.promptMask[sIndex] && this.promptMask[sIndex] !== this.promptChar && !isNullOrUndefined(this.customCharacters)) {
            break;
          }
        }
      }
    }
    if (event.keyCode === 46 && multipleDel && isDeleted) {
      this.element.selectionStart = this.element.selectionEnd = deleteEndIndex;
    }
    if (this.element.selectionStart === 0 && this.element.selectionEnd === this.element.value.length) {
      setElementValue.call(this, this.promptMask);
      event.preventDefault();
      this.element.selectionStart = this.element.selectionEnd = startIndex;
    }
    this.redoCollec.unshift({
      value: this.element.value,
      startIndex: this.element.selectionStart,
      endIndex: this.element.selectionEnd
    });
    if (this.element.value !== preValue) {
      triggerMaskChangeEvent.call(this, event, oldEventVal);
    }
  }
}
function maskInputKeyPressHandler(event) {
  if (this.mask && !this.readonly) {
    var oldValue = this.element.value;
    if (!(event.ctrlKey || event.metaKey) || (event.ctrlKey || event.metaKey) && event.code !== "KeyA" && event.code !== "KeyY" && event.code !== "KeyZ" && event.code !== "KeyX" && event.code !== "KeyC" && event.code !== "KeyV") {
      this.maskKeyPress = true;
      var key = event.key;
      if (key === "Spacebar") {
        key = String.fromCharCode(event.keyCode);
      }
      if (!key) {
        this.isIosInvalid = true;
        validateValue.call(this, String.fromCharCode(event.keyCode), event.ctrlKey, event);
        event.preventDefault();
        this.isIosInvalid = false;
      } else if (key && key.length === 1) {
        validateValue.call(this, key, event.ctrlKey, event);
        event.preventDefault();
      }
      if (event.keyCode === 32 && key === " " && this.promptChar === " ") {
        this.element.selectionStart = this.element.selectionEnd = this.element.selectionStart - key.length;
      }
    }
    if (this.element.value !== oldValue) {
      triggerMaskChangeEvent.call(this, event, oldValue);
    }
  }
}
function triggerMaskChangeEvent(event, oldValue) {
  var prevOnChange = this.isProtectedOnChange;
  if (!isNullOrUndefined(this.changeEventArgs) && !this.isInitial) {
    var eventArgs = {};
    this.changeEventArgs = { value: this.element.value, maskedValue: this.element.value, isInteraction: false, isInteracted: false };
    if (this.mask) {
      this.changeEventArgs.value = strippedValue.call(this, this.element);
    }
    if (!isNullOrUndefined(event)) {
      this.changeEventArgs.isInteracted = true;
      this.changeEventArgs.isInteraction = true;
      this.changeEventArgs.event = event;
    }
    this.isProtectedOnChange = true;
    this.value = this.changeEventArgs.value;
    this.isProtectedOnChange = prevOnChange;
    merge(eventArgs, this.changeEventArgs);
    if (this.isAngular && this.preventChange) {
      this.preventChange = false;
    } else {
      this.trigger("change", eventArgs);
    }
  }
  this.preEleVal = this.element.value;
  this.prevValue = strippedValue.call(this, this.element);
}
function maskInputKeyUpHandler(event) {
  if (this.mask && !this.readonly) {
    var collec = void 0;
    if (!this.maskKeyPress && event.keyCode === 229) {
      var oldEventVal = void 0;
      if (this.element.value.length === 1) {
        this.element.value = this.element.value + this.promptMask;
        this.element.setSelectionRange(1, 1);
      }
      if (this.element.value.length > this.promptMask.length) {
        var startIndex = this.element.selectionStart;
        var addedValues = this.element.value.length - this.promptMask.length;
        var val_1 = this.element.value.substring(startIndex - addedValues, startIndex);
        if (this.undoCollec.length > 0) {
          collec = this.undoCollec[this.undoCollec.length - 1];
          var startIndex_1 = this.element.selectionStart;
          oldEventVal = collec.value;
          var oldVal = collec.value.substring(startIndex_1 - addedValues, startIndex_1);
          collec = this.redoCollec[0];
          val_1 = val_1.trim();
          var isSpace = Browser.isAndroid && val_1 === "";
          if (!isSpace && oldVal !== val_1 && collec.value.substring(startIndex_1 - addedValues, startIndex_1) !== val_1) {
            validateValue.call(this, val_1, event.ctrlKey, event);
          } else if (isSpace) {
            preventUnsupportedValues.call(this, event, startIndex_1 - 1, this.element.selectionEnd - 1, val_1, event.ctrlKey, false);
          }
        } else {
          oldEventVal = this.promptMask;
          validateValue.call(this, val_1, event.ctrlKey, event);
        }
        this.maskKeyPress = false;
        triggerMaskChangeEvent.call(this, event, oldEventVal);
      }
    } else {
      removeMaskError.call(this);
    }
    var val = strippedValue.call(this, this.element);
    if (!(this.element.selectionStart === 0 && this.promptMask === this.element.value && val === "") || val === "" && this.value !== val) {
      this.prevValue = val;
      this.value = val;
    }
  } else {
    triggerMaskChangeEvent.call(this, event);
  }
  if (this.element.selectionStart === 0 && this.element.selectionEnd === 0) {
    var temp_1 = this.element;
    setTimeout(function() {
      temp_1.setSelectionRange(0, 0);
    }, 0);
  }
}
function mobileSwipeCheck(key) {
  if (key.length > 1 && this.promptMask.length + key.length < this.element.value.length) {
    var elementValue = this.redoCollec[0].value.substring(0, this.redoCollec[0].startIndex) + key + this.redoCollec[0].value.substring(this.redoCollec[0].startIndex, this.redoCollec[0].value.length);
    setElementValue.call(this, elementValue);
    this.element.selectionStart = this.element.selectionEnd = this.redoCollec[0].startIndex + key.length;
  }
  this.element.selectionStart = this.element.selectionStart - key.length;
  this.element.selectionEnd = this.element.selectionEnd - key.length;
}
function mobileValidation(key) {
  if (!this.maskKeyPress) {
    mobileSwipeCheck.call(this, key);
  }
}
function validateValue(key, isCtrlKey, event) {
  mobileValidation.call(this, key);
  if (isNullOrUndefined(this) || isNullOrUndefined(key)) {
    return;
  }
  var startIndex = this.element.selectionStart;
  var initStartIndex = startIndex;
  var curMask;
  var allowText = false;
  var value = this.element.value;
  var eventOldVal;
  var prevSupport = false;
  var isEqualVal = false;
  for (var k = 0; k < key.length; k++) {
    var keyValue = key[k];
    startIndex = this.element.selectionStart;
    if (!this.maskKeyPress && initStartIndex === startIndex) {
      startIndex = startIndex + k;
    }
    if (!this.maskKeyPress || startIndex < this.promptMask.length) {
      for (var i = startIndex; i < this.promptMask.length; i++) {
        var maskValue = this.escapeMaskValue;
        curMask = maskValue[startIndex];
        if (this.hiddenMask[startIndex] === "\\" && this.hiddenMask[startIndex + 1] === key) {
          isEqualVal = true;
        }
        if (isNullOrUndefined(this.regExpCollec["" + curMask]) && (isNullOrUndefined(this.customCharacters) || !isNullOrUndefined(this.customCharacters) && isNullOrUndefined(this.customCharacters["" + curMask])) && (this.hiddenMask[startIndex] !== this.promptChar && this.customRegExpCollec[startIndex][0] !== "[" && this.customRegExpCollec[startIndex][this.customRegExpCollec[startIndex].length - 1] !== "]") || this.promptMask[startIndex] !== this.promptChar && isNullOrUndefined(this.customCharacters) || this.promptChar === curMask && this.escapeMaskValue === this.mask) {
          this.element.selectionStart = this.element.selectionEnd = startIndex + 1;
          startIndex = this.element.selectionStart;
          curMask = this.hiddenMask[startIndex];
        }
      }
      if (!isNullOrUndefined(this.customCharacters) && !isNullOrUndefined(this.customCharacters["" + curMask])) {
        var customValStr = this.customCharacters["" + curMask];
        var customValArr = customValStr.split(",");
        for (var i = 0; i < customValArr.length; i++) {
          if (keyValue.match(new RegExp("[" + customValArr[i] + "]"))) {
            allowText = true;
            break;
          }
        }
      } else if (!isNullOrUndefined(this.regExpCollec["" + curMask]) && keyValue.match(new RegExp(this.regExpCollec["" + curMask])) && this.promptMask[startIndex] === this.promptChar) {
        allowText = true;
      } else if (this.promptMask[startIndex] === this.promptChar && this.customRegExpCollec[startIndex][0] === "[" && this.customRegExpCollec[startIndex][this.customRegExpCollec[startIndex].length - 1] === "]" && keyValue.match(new RegExp(this.customRegExpCollec[startIndex]))) {
        allowText = true;
      }
      if ((!this.maskKeyPress || startIndex < this.hiddenMask.length) && allowText) {
        if (k === 0) {
          if (this.maskKeyPress) {
            this.undoCollec.push({ value, startIndex, endIndex: startIndex });
          } else {
            var sIndex = this.element.selectionStart;
            var eIndex = this.element.selectionEnd;
            if (this.redoCollec.length > 0) {
              eventOldVal = this.redoCollec[0].value;
              setElementValue.call(this, eventOldVal);
              this.undoCollec.push(this.redoCollec[0]);
            } else {
              this.undoCollec.push({ value: this.promptMask, startIndex, endIndex: startIndex });
              eventOldVal = this.promptMask;
              setElementValue.call(this, eventOldVal);
            }
            this.element.selectionStart = sIndex;
            this.element.selectionEnd = eIndex;
          }
        }
        startIndex = this.element.selectionStart;
        applySupportedValues.call(this, event, startIndex, keyValue, eventOldVal, isEqualVal);
        prevSupport = true;
        if (k === key.length - 1) {
          this.redoCollec.unshift({
            value: this.element.value,
            startIndex: this.element.selectionStart,
            endIndex: this.element.selectionEnd
          });
        }
        allowText = false;
      } else {
        startIndex = this.element.selectionStart;
        preventUnsupportedValues.call(this, event, startIndex, initStartIndex, key, isCtrlKey, prevSupport);
      }
      if (k === key.length - 1 && !allowText) {
        if (!Browser.isAndroid || Browser.isAndroid && startIndex < this.promptMask.length) {
          this.redoCollec.unshift({
            value: this.element.value,
            startIndex: this.element.selectionStart,
            endIndex: this.element.selectionEnd
          });
        }
      }
    } else {
      if (key.length === 1 && !isCtrlKey && !isNullOrUndefined(event)) {
        addMaskErrorClass.call(this);
      }
    }
  }
}
function applySupportedValues(event, startIndex, keyValue, eventOldVal, isEqualVal) {
  if (this.hiddenMask.length > this.promptMask.length) {
    keyValue = changeToLowerUpperCase.call(this, keyValue, this.element.value);
  }
  if (!isEqualVal) {
    var value = this.element.value;
    var elementValue = value.substring(0, startIndex) + keyValue + value.substring(startIndex + 1, value.length);
    setElementValue.call(this, elementValue);
    this.element.selectionStart = this.element.selectionEnd = startIndex + 1;
  }
}
function preventUnsupportedValues(event, sIdx, idx, key, ctrl, chkSupport) {
  if (!this.maskKeyPress) {
    var value = this.element.value;
    if (sIdx >= this.promptMask.length) {
      setElementValue.call(this, value.substring(0, sIdx));
    } else {
      if (idx === sIdx) {
        setElementValue.call(this, value.substring(0, sIdx) + value.substring(sIdx + 1, value.length));
      } else {
        if (this.promptMask.length === this.element.value.length) {
          setElementValue.call(this, value.substring(0, sIdx) + value.substring(sIdx, value.length));
        } else {
          setElementValue.call(this, value.substring(0, idx) + value.substring(idx + 1, value.length));
        }
      }
      this.element.selectionStart = this.element.selectionEnd = chkSupport || this.element.value[idx] !== this.promptChar ? sIdx : idx;
    }
    addMaskErrorClass.call(this);
  }
  if (key.length === 1 && !ctrl && !isNullOrUndefined(event)) {
    addMaskErrorClass.call(this);
  }
}
function addMaskErrorClass() {
  var _this = this;
  var parentElement = this.element.parentNode;
  var timer = 200;
  if (parentElement.classList.contains(INPUTGROUP) || parentElement.classList.contains(FLOATINPUT)) {
    addClass([parentElement], ERROR2);
  } else {
    addClass([this.element], ERROR2);
  }
  if (this.isIosInvalid === true) {
    timer = 400;
  }
  attributes(this.element, { "aria-invalid": "true" });
  setTimeout(function() {
    if (!_this.maskKeyPress) {
      removeMaskError.call(_this);
    }
  }, timer);
}
function removeMaskError() {
  var parentElement = this.element.parentNode;
  if (!isNullOrUndefined(parentElement)) {
    removeClass([parentElement], ERROR2);
  }
  removeClass([this.element], ERROR2);
  attributes(this.element, { "aria-invalid": "false" });
}
function changeToLowerUpperCase(key, value) {
  var promptMask;
  var i;
  var curVal = value;
  var caseCount = 0;
  for (i = 0; i < this.hiddenMask.length; i++) {
    if (this.hiddenMask[i] === "\\") {
      promptMask = curVal.substring(0, i) + "\\" + curVal.substring(i, curVal.length);
    }
    if (this.hiddenMask[i] === ">" || this.hiddenMask[i] === "<" || this.hiddenMask[i] === "|") {
      if (this.hiddenMask[i] !== curVal[i]) {
        promptMask = curVal.substring(0, i) + this.hiddenMask[i] + curVal.substring(i, curVal.length);
      }
      ++caseCount;
    }
    if (promptMask) {
      if (promptMask[i] === this.promptChar && i > this.element.selectionStart || this.element.value.indexOf(this.promptChar) < 0 && this.element.selectionStart + caseCount === i) {
        caseCount = 0;
        break;
      }
      curVal = promptMask;
    }
  }
  while (i >= 0 && promptMask) {
    if (i === 0 || promptMask[i - 1] !== "\\") {
      if (promptMask[i] === ">") {
        key = key.toUpperCase();
        break;
      } else if (promptMask[i] === "<") {
        key = key.toLowerCase();
        break;
      } else if (promptMask[i] === "|") {
        break;
      }
    }
    --i;
  }
  return key;
}
function setMaskValue(val) {
  if (this.mask && val !== void 0 && (this.prevValue === void 0 || this.prevValue !== val)) {
    this.maskKeyPress = true;
    setElementValue.call(this, this.promptMask);
    if (val !== "" && !(val === null && this.floatLabelType === "Never" && this.placeholder)) {
      this.element.selectionStart = 0;
      this.element.selectionEnd = 0;
    }
    if (val !== null) {
      for (var i = 0; i < val.length; i++) {
        validateValue.call(this, val[i], false, null);
      }
    }
    var newVal = strippedValue.call(this, this.element);
    this.prevValue = newVal;
    this.value = newVal;
    triggerMaskChangeEvent.call(this, null, null);
    this.maskKeyPress = false;
    var labelElement = this.element.parentNode.querySelector(".e-float-text");
    if (this.element.value === this.promptMask && this.floatLabelType === "Auto" && this.placeholder && !isNullOrUndefined(labelElement) && labelElement.classList.contains(TOPLABEL) && !this.isFocus) {
      removeClass([labelElement], TOPLABEL);
      addClass([labelElement], BOTTOMLABEL);
      setElementValue.call(this, "");
    }
  }
  if (this.mask === null || this.mask === "" && this.value !== void 0) {
    setElementValue.call(this, this.value);
  }
}
function setElementValue(val, element2) {
  if (!this.isFocus && this.floatLabelType === "Auto" && this.placeholder && isNullOrUndefined(this.value)) {
    val = "";
  }
  var value = strippedValue.call(this, element2 ? element2 : this.element, val);
  if (value === null || value === "") {
    Input.setValue(val, element2 ? element2 : this.element, this.floatLabelType, false);
    if (this.showClearButton) {
      this.inputObj.clearButton.classList.add("e-clear-icon-hide");
    }
  } else {
    Input.setValue(val, element2 ? element2 : this.element, this.floatLabelType, this.showClearButton);
  }
}
var MaskUndo = (
  /** @class */
  /* @__PURE__ */ function() {
    function MaskUndo2() {
    }
    return MaskUndo2;
  }()
);
var maskUndo = new MaskUndo();

// node_modules/@syncfusion/ej2-inputs/src/maskedtextbox/maskedtextbox/maskedtextbox.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ROOT4 = "e-control-wrapper e-mask";
var INPUT = "e-input";
var COMPONENT2 = "e-maskedtextbox";
var CONTROL2 = "e-control";
var MASKINPUT_FOCUS = "e-input-focus";
var wrapperAttr = ["title", "style", "class"];
var MaskedTextBox = (
  /** @class */
  function(_super) {
    __extends12(MaskedTextBox2, _super);
    function MaskedTextBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.initInputValue = "";
      _this.preventChange = false;
      _this.isClicked = false;
      _this.maskOptions = options;
      return _this;
    }
    MaskedTextBox2.prototype.getModuleName = function() {
      return "maskedtextbox";
    };
    MaskedTextBox2.prototype.preRender = function() {
      this.promptMask = "";
      this.hiddenMask = "";
      this.escapeMaskValue = "";
      this.regExpCollec = regularExpressions;
      this.customRegExpCollec = [];
      this.undoCollec = [];
      this.redoCollec = [];
      this.changeEventArgs = {};
      this.focusEventArgs = {};
      this.blurEventArgs = {};
      this.maskKeyPress = false;
      this.isFocus = false;
      this.isInitial = false;
      this.isIosInvalid = false;
      var ejInstance = getValue("ej2_instances", this.element);
      this.cloneElement = this.element.cloneNode(true);
      removeClass([this.cloneElement], [CONTROL2, COMPONENT2, "e-lib"]);
      this.angularTagName = null;
      this.formElement = closest(this.element, "form");
      if (this.element.tagName === "EJS-MASKEDTEXTBOX") {
        this.angularTagName = this.element.tagName;
        var input = this.createElement("input");
        for (var i = 0; i < this.element.attributes.length; i++) {
          input.setAttribute(this.element.attributes[i].nodeName, this.element.attributes[i].nodeValue);
          input.innerHTML = this.element.innerHTML;
        }
        if (this.element.hasAttribute("id")) {
          this.element.removeAttribute("id");
        }
        if (this.element.hasAttribute("name")) {
          this.element.removeAttribute("name");
        }
        this.element.classList.remove("e-control", "e-maskedtextbox");
        this.element.classList.add("e-mask-container");
        this.element.appendChild(input);
        this.element = input;
        setValue("ej2_instances", ejInstance, this.element);
      }
      this.updateHTMLAttrToElement();
      this.checkHtmlAttributes(false);
      if (this.formElement) {
        this.initInputValue = this.value;
      }
    };
    MaskedTextBox2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    MaskedTextBox2.prototype.render = function() {
      if (this.element.tagName.toLowerCase() === "input") {
        if (this.floatLabelType === "Never") {
          addClass([this.element], INPUT);
        }
        this.createWrapper();
        this.updateHTMLAttrToWrapper();
        if (this.element.name === "") {
          this.element.setAttribute("name", this.element.id);
        }
        this.isInitial = true;
        this.resetMaskedTextBox();
        this.isInitial = false;
        this.setMaskPlaceholder(true, false);
        this.setWidth(this.width);
        this.preEleVal = this.element.value;
        if (!Browser.isDevice && (Browser.info.version === "11.0" || Browser.info.name === "edge")) {
          this.element.blur();
        }
        if (Browser.isDevice && Browser.isIos) {
          this.element.blur();
        }
        if (this.element.getAttribute("value") || this.value) {
          this.element.setAttribute("value", this.element.value);
        }
        if (!isNullOrUndefined(closest(this.element, "fieldset")) && closest(this.element, "fieldset").disabled) {
          this.enabled = false;
        }
        if (!this.element.hasAttribute("aria-labelledby") && !this.element.hasAttribute("placeholder")) {
          this.element.setAttribute("aria-label", "maskedtextbox");
        }
        this.renderComplete();
      }
    };
    MaskedTextBox2.prototype.updateHTMLAttrToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttr.indexOf(key) < 0) {
            this.element.setAttribute(key, this.htmlAttributes["" + key]);
          }
        }
      }
    };
    MaskedTextBox2.prototype.updateCssClass = function(newClass, oldClass) {
      Input.setCssClass(this.getValidClassList(newClass), [this.inputObj.container], this.getValidClassList(oldClass));
    };
    MaskedTextBox2.prototype.getValidClassList = function(maskClassName) {
      var result = maskClassName;
      if (!isNullOrUndefined(maskClassName) && maskClassName !== "") {
        result = maskClassName.replace(/\s+/g, " ").trim();
      }
      return result;
    };
    MaskedTextBox2.prototype.updateHTMLAttrToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var key = _a[_i];
          if (wrapperAttr.indexOf(key) > -1) {
            if (key === "class") {
              var updatedClassValues = this.htmlAttributes["" + key].replace(/\s+/g, " ").trim();
              if (updatedClassValues !== "") {
                addClass([this.inputObj.container], updatedClassValues.split(" "));
              }
            } else if (key === "style") {
              var maskStyle = this.inputObj.container.getAttribute(key);
              maskStyle = !isNullOrUndefined(maskStyle) ? maskStyle + this.htmlAttributes["" + key] : this.htmlAttributes["" + key];
              this.inputObj.container.setAttribute(key, maskStyle);
            } else {
              this.inputObj.container.setAttribute(key, this.htmlAttributes["" + key]);
            }
          }
        }
      }
    };
    MaskedTextBox2.prototype.resetMaskedTextBox = function() {
      this.promptMask = "";
      this.hiddenMask = "";
      this.escapeMaskValue = "";
      this.customRegExpCollec = [];
      this.undoCollec = [];
      this.redoCollec = [];
      if (this.promptChar.length > 1) {
        this.promptChar = this.promptChar[0];
      }
      createMask.call(this);
      applyMask.call(this);
      if (this.mask === null || this.mask === "" && this.value !== void 0) {
        setElementValue.call(this, this.value);
      }
      var val = strippedValue.call(this, this.element);
      this.prevValue = val;
      this.value = val;
      if (!this.isInitial) {
        unwireEvents.call(this);
      }
      wireEvents2.call(this);
    };
    MaskedTextBox2.prototype.setMaskPlaceholder = function(setVal, dynamicPlaceholder) {
      if (dynamicPlaceholder || this.placeholder) {
        Input.setPlaceholder(this.placeholder, this.element);
        if (this.element.value === this.promptMask && setVal && this.floatLabelType !== "Always" || this.element.value === this.promptMask && this.floatLabelType === "Never") {
          setElementValue.call(this, "");
        }
      }
    };
    MaskedTextBox2.prototype.setWidth = function(width) {
      if (!isNullOrUndefined(width)) {
        if (typeof width === "number") {
          this.inputObj.container.style.width = formatUnit(width);
          this.element.style.width = formatUnit(width);
        } else if (typeof width === "string") {
          var elementWidth = width.match(/px|%|em/) ? width : formatUnit(width);
          this.inputObj.container.style.width = elementWidth;
          this.element.style.width = elementWidth;
        }
      }
    };
    MaskedTextBox2.prototype.checkHtmlAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["placeholder", "disabled", "value", "readonly"];
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var key = attributes_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(key))) {
          switch (key) {
            case "placeholder":
              if (isNullOrUndefined(this.maskOptions) || this.maskOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "disabled":
              if (isNullOrUndefined(this.maskOptions) || this.maskOptions["enabled"] === void 0 || isDynamic) {
                var isEnabled = this.element.getAttribute(key) === "disabled" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? false : true;
                this.setProperties({ enabled: isEnabled }, !isDynamic);
              }
              break;
            case "value":
              if (isNullOrUndefined(this.maskOptions) || this.maskOptions["value"] === void 0 || isDynamic) {
                this.setProperties({ value: this.element.value }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.maskOptions) || this.maskOptions["readonly"] === void 0 || isDynamic) {
                var isReadonly = this.element.getAttribute(key) === "readonly" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? true : false;
                this.setProperties({ readonly: isReadonly }, !isDynamic);
              }
              break;
          }
        }
      }
    };
    MaskedTextBox2.prototype.createWrapper = function() {
      var updatedCssClassValues = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValues = this.getValidClassList(this.cssClass);
      }
      this.inputObj = Input.createInput({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: {
          enableRtl: this.enableRtl,
          cssClass: updatedCssClassValues,
          enabled: this.enabled,
          readonly: this.readonly,
          placeholder: this.placeholder,
          showClearButton: this.showClearButton
        }
      }, this.createElement);
      this.inputObj.container.setAttribute("class", ROOT4 + " " + this.inputObj.container.getAttribute("class"));
    };
    MaskedTextBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            setMaskValue.call(this, this.value);
            if (this.placeholder && !this.isFocus) {
              this.setMaskPlaceholder(false, false);
            }
            if (this.value === "" && oldProp.value != null) {
              this.element.selectionStart = 0;
              this.element.selectionEnd = 0;
            }
            break;
          case "placeholder":
            this.setMaskPlaceholder(true, true);
            break;
          case "width":
            this.setWidth(newProp.width);
            Input.calculateWidth(this.element, this.inputObj.container);
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "enabled":
            Input.setEnabled(newProp.enabled, this.element, this.floatLabelType, this.inputObj.container);
            break;
          case "readonly":
            Input.setReadonly(newProp.readonly, this.element);
            break;
          case "enableRtl":
            Input.setEnableRtl(newProp.enableRtl, [this.inputObj.container]);
            break;
          case "customCharacters":
            this.customCharacters = newProp.customCharacters;
            this.resetMaskedTextBox();
            break;
          case "showClearButton":
            Input.setClearButton(newProp.showClearButton, this.element, this.inputObj, void 0, this.createElement);
            bindClearEvent.call(this);
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            Input.removeFloating(this.inputObj);
            Input.addFloating(this.element, this.floatLabelType, this.placeholder, this.createElement);
            break;
          case "htmlAttributes":
            this.updateHTMLAttrToElement();
            this.updateHTMLAttrToWrapper();
            this.checkHtmlAttributes(true);
            break;
          case "mask":
            {
              var strippedValue_1 = this.value;
              this.mask = newProp.mask;
              this.updateValue(strippedValue_1);
            }
            break;
          case "promptChar": {
            if (newProp.promptChar.length > 1) {
              newProp.promptChar = newProp.promptChar[0];
            }
            if (newProp.promptChar) {
              this.promptChar = newProp.promptChar;
            } else {
              this.promptChar = "_";
            }
            var value = this.element.value.replace(new RegExp("[" + oldProp.promptChar + "]", "g"), this.promptChar);
            if (this.promptMask === this.element.value) {
              value = this.promptMask.replace(new RegExp("[" + oldProp.promptChar + "]", "g"), this.promptChar);
            }
            this.promptMask = this.promptMask.replace(new RegExp("[" + oldProp.promptChar + "]", "g"), this.promptChar);
            this.undoCollec = this.redoCollec = [];
            setElementValue.call(this, value);
            break;
          }
        }
      }
      this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
    };
    MaskedTextBox2.prototype.updateValue = function(strippedVal) {
      this.resetMaskedTextBox();
      setMaskValue.call(this, strippedVal);
    };
    MaskedTextBox2.prototype.getMaskedValue = function() {
      return unstrippedValue.call(this, this.element);
    };
    MaskedTextBox2.prototype.focusIn = function() {
      if (document.activeElement !== this.element && this.enabled) {
        this.isFocus = true;
        this.element.focus();
        addClass([this.inputObj.container], [MASKINPUT_FOCUS]);
      }
    };
    MaskedTextBox2.prototype.focusOut = function() {
      if (document.activeElement === this.element && this.enabled) {
        this.isFocus = false;
        this.element.blur();
        removeClass([this.inputObj.container], [MASKINPUT_FOCUS]);
      }
    };
    MaskedTextBox2.prototype.destroy = function() {
      unwireEvents.call(this);
      if (this.showClearButton) {
        this.clearButton = document.getElementsByClassName("e-clear-icon")[0];
      }
      var attrArray = [
        "aria-labelledby",
        "role",
        "autocomplete",
        "aria-readonly",
        "aria-disabled",
        "autocapitalize",
        "spellcheck",
        "aria-autocomplete",
        "aria-live",
        "aria-invalid"
      ];
      for (var i = 0; i < attrArray.length; i++) {
        this.element.removeAttribute(attrArray[i]);
      }
      this.element.classList.remove("e-input");
      if (this.inputObj) {
        this.inputObj.container.insertAdjacentElement("afterend", this.element);
        detach(this.inputObj.container);
      }
      this.blurEventArgs = null;
      Input.destroy({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      this.changeEventArgs = null;
      this.inputObj = null;
      _super.prototype.destroy.call(this);
    };
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "cssClass", void 0);
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "width", void 0);
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "placeholder", void 0);
    __decorate13([
      Property("Never")
    ], MaskedTextBox2.prototype, "floatLabelType", void 0);
    __decorate13([
      Property({})
    ], MaskedTextBox2.prototype, "htmlAttributes", void 0);
    __decorate13([
      Property(true)
    ], MaskedTextBox2.prototype, "enabled", void 0);
    __decorate13([
      Property(false)
    ], MaskedTextBox2.prototype, "readonly", void 0);
    __decorate13([
      Property(false)
    ], MaskedTextBox2.prototype, "showClearButton", void 0);
    __decorate13([
      Property(false)
    ], MaskedTextBox2.prototype, "enablePersistence", void 0);
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "mask", void 0);
    __decorate13([
      Property("_")
    ], MaskedTextBox2.prototype, "promptChar", void 0);
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "value", void 0);
    __decorate13([
      Property(null)
    ], MaskedTextBox2.prototype, "customCharacters", void 0);
    __decorate13([
      Event()
    ], MaskedTextBox2.prototype, "created", void 0);
    __decorate13([
      Event()
    ], MaskedTextBox2.prototype, "destroyed", void 0);
    __decorate13([
      Event()
    ], MaskedTextBox2.prototype, "change", void 0);
    __decorate13([
      Event()
    ], MaskedTextBox2.prototype, "focus", void 0);
    __decorate13([
      Event()
    ], MaskedTextBox2.prototype, "blur", void 0);
    MaskedTextBox2 = __decorate13([
      NotifyPropertyChanges
    ], MaskedTextBox2);
    return MaskedTextBox2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/slider/slider.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TicksData = (
  /** @class */
  function(_super) {
    __extends13(TicksData2, _super);
    function TicksData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate14([
      Property("None")
    ], TicksData2.prototype, "placement", void 0);
    __decorate14([
      Property(10)
    ], TicksData2.prototype, "largeStep", void 0);
    __decorate14([
      Property(1)
    ], TicksData2.prototype, "smallStep", void 0);
    __decorate14([
      Property(false)
    ], TicksData2.prototype, "showSmallTicks", void 0);
    __decorate14([
      Property(null)
    ], TicksData2.prototype, "format", void 0);
    return TicksData2;
  }(ChildProperty)
);
var ColorRangeData = (
  /** @class */
  function(_super) {
    __extends13(ColorRangeData2, _super);
    function ColorRangeData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate14([
      Property(null)
    ], ColorRangeData2.prototype, "color", void 0);
    __decorate14([
      Property(null)
    ], ColorRangeData2.prototype, "start", void 0);
    __decorate14([
      Property(null)
    ], ColorRangeData2.prototype, "end", void 0);
    return ColorRangeData2;
  }(ChildProperty)
);
var LimitData = (
  /** @class */
  function(_super) {
    __extends13(LimitData2, _super);
    function LimitData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate14([
      Property(false)
    ], LimitData2.prototype, "enabled", void 0);
    __decorate14([
      Property(null)
    ], LimitData2.prototype, "minStart", void 0);
    __decorate14([
      Property(null)
    ], LimitData2.prototype, "minEnd", void 0);
    __decorate14([
      Property(null)
    ], LimitData2.prototype, "maxStart", void 0);
    __decorate14([
      Property(null)
    ], LimitData2.prototype, "maxEnd", void 0);
    __decorate14([
      Property(false)
    ], LimitData2.prototype, "startHandleFixed", void 0);
    __decorate14([
      Property(false)
    ], LimitData2.prototype, "endHandleFixed", void 0);
    return LimitData2;
  }(ChildProperty)
);
var TooltipData = (
  /** @class */
  function(_super) {
    __extends13(TooltipData2, _super);
    function TooltipData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate14([
      Property("")
    ], TooltipData2.prototype, "cssClass", void 0);
    __decorate14([
      Property("Before")
    ], TooltipData2.prototype, "placement", void 0);
    __decorate14([
      Property("Focus")
    ], TooltipData2.prototype, "showOn", void 0);
    __decorate14([
      Property(false)
    ], TooltipData2.prototype, "isVisible", void 0);
    __decorate14([
      Property(null)
    ], TooltipData2.prototype, "format", void 0);
    return TooltipData2;
  }(ChildProperty)
);
var bootstrapTooltipOffset = 6;
var bootstrap4TooltipOffset = 3;
var classNames2 = {
  root: "e-slider",
  rtl: "e-rtl",
  sliderHiddenInput: "e-slider-input",
  controlWrapper: "e-control-wrapper",
  sliderHandle: "e-handle",
  rangeBar: "e-range",
  sliderButton: "e-slider-button",
  firstButton: "e-first-button",
  secondButton: "e-second-button",
  scale: "e-scale",
  tick: "e-tick",
  large: "e-large",
  tickValue: "e-tick-value",
  sliderTooltip: "e-slider-tooltip",
  sliderHover: "e-slider-hover",
  sliderFirstHandle: "e-handle-first",
  sliderSecondHandle: "e-handle-second",
  sliderDisabled: "e-disabled",
  sliderContainer: "e-slider-container",
  horizontalTooltipBefore: "e-slider-horizontal-before",
  horizontalTooltipAfter: "e-slider-horizontal-after",
  verticalTooltipBefore: "e-slider-vertical-before",
  verticalTooltipAfter: "e-slider-vertical-after",
  materialTooltip: "e-material-tooltip",
  materialTooltipOpen: "e-material-tooltip-open",
  materialTooltipActive: "e-tooltip-active",
  materialSlider: "e-material-slider",
  sliderTrack: "e-slider-track",
  sliderHorizantalColor: "e-slider-horizantal-color",
  sliderVerticalColor: "e-slider-vertical-color",
  sliderHandleFocused: "e-handle-focused",
  verticalSlider: "e-vertical",
  horizontalSlider: "e-horizontal",
  sliderHandleStart: "e-handle-start",
  sliderTooltipStart: "e-material-tooltip-start",
  sliderTabHandle: "e-tab-handle",
  sliderButtonIcon: "e-button-icon",
  sliderSmallSize: "e-small-size",
  sliderTickPosition: "e-tick-pos",
  sliderFirstTick: "e-first-tick",
  sliderLastTick: "e-last-tick",
  sliderButtonClass: "e-slider-btn",
  sliderTooltipWrapper: "e-tooltip-wrap",
  sliderTabTrack: "e-tab-track",
  sliderTabRange: "e-tab-range",
  sliderActiveHandle: "e-handle-active",
  sliderMaterialHandle: "e-material-handle",
  sliderMaterialRange: "e-material-range",
  sliderMaterialDefault: "e-material-default",
  materialTooltipShow: "e-material-tooltip-show",
  materialTooltipHide: "e-material-tooltip-hide",
  readonly: "e-read-only",
  limits: "e-limits",
  limitBarDefault: "e-limit-bar",
  limitBarFirst: "e-limit-first",
  limitBarSecond: "e-limit-second",
  dragHorizontal: "e-drag-horizontal",
  dragVertical: "e-drag-vertical"
};
var Slider = (
  /** @class */
  function(_super) {
    __extends13(Slider2, _super);
    function Slider2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.horDir = "left";
      _this.verDir = "bottom";
      _this.transition = {
        handle: "left .4s cubic-bezier(.25, .8, .25, 1), right .4s cubic-bezier(.25, .8, .25, 1), top .4s cubic-bezier(.25, .8, .25, 1) , bottom .4s cubic-bezier(.25, .8, .25, 1)",
        rangeBar: "all .4s cubic-bezier(.25, .8, .25, 1)"
      };
      _this.transitionOnMaterialTooltip = {
        handle: "left 1ms ease-out, right 1ms ease-out, bottom 1ms ease-out, top 1ms ease-out",
        rangeBar: "left 1ms ease-out, right 1ms ease-out, bottom 1ms ease-out, width 1ms ease-out, height 1ms ease-out"
      };
      _this.scaleTransform = "transform .4s cubic-bezier(.25, .8, .25, 1)";
      _this.customAriaText = null;
      _this.drag = true;
      _this.isDragComplete = false;
      _this.initialTooltip = true;
      return _this;
    }
    Slider2.prototype.preRender = function() {
      var localeText = { incrementTitle: "Increase", decrementTitle: "Decrease" };
      this.l10n = new L10n("slider", localeText, this.locale);
      this.isElementFocused = false;
      this.tickElementCollection = [];
      this.tooltipFormatInfo = {};
      this.ticksFormatInfo = {};
      this.initCultureInfo();
      this.initCultureFunc();
      this.formChecker();
    };
    Slider2.prototype.formChecker = function() {
      var formElement = closest(this.element, "form");
      if (formElement) {
        this.isForm = true;
        if (!isNullOrUndefined(this.formResetValue)) {
          this.setProperties({ "value": this.formResetValue }, true);
        }
        this.formResetValue = this.value;
        if (this.type === "Range" && (isNullOrUndefined(this.formResetValue) || typeof this.formResetValue !== "object")) {
          this.formResetValue = [parseFloat(formatUnit(this.min)), parseFloat(formatUnit(this.max))];
        } else if (isNullOrUndefined(this.formResetValue)) {
          this.formResetValue = parseFloat(formatUnit(this.min));
        }
        this.formElement = formElement;
      } else {
        this.isForm = false;
      }
    };
    Slider2.prototype.initCultureFunc = function() {
      this.internationalization = new Internationalization(this.locale);
    };
    Slider2.prototype.initCultureInfo = function() {
      this.tooltipFormatInfo.format = !isNullOrUndefined(this.tooltip.format) ? this.tooltip.format : null;
      this.ticksFormatInfo.format = !isNullOrUndefined(this.ticks.format) ? this.ticks.format : null;
    };
    Slider2.prototype.formatString = function(value, formatInfo) {
      var formatValue = null;
      var formatString = null;
      if (value || value === 0) {
        formatValue = this.formatNumber(value);
        var numberOfDecimals = this.numberOfDecimals(value);
        formatString = this.internationalization.getNumberFormat(formatInfo)(this.makeRoundNumber(value, numberOfDecimals));
      }
      return { elementVal: formatValue, formatString };
    };
    Slider2.prototype.formatNumber = function(value) {
      var numberOfDecimals = this.numberOfDecimals(value);
      return this.internationalization.getNumberFormat({
        maximumFractionDigits: numberOfDecimals,
        minimumFractionDigits: numberOfDecimals,
        useGrouping: false
      })(value);
    };
    Slider2.prototype.numberOfDecimals = function(value) {
      var decimalPart = value.toString().split(".")[1];
      var numberOfDecimals = !decimalPart || !decimalPart.length ? 0 : decimalPart.length;
      return numberOfDecimals;
    };
    Slider2.prototype.makeRoundNumber = function(value, precision) {
      var decimals = precision || 0;
      return Number(value.toFixed(decimals));
    };
    Slider2.prototype.fractionalToInteger = function(value) {
      value = this.numberOfDecimals(value) === 0 ? Number(value).toFixed(this.noOfDecimals) : value;
      var tens = 1;
      for (var i = 0; i < this.noOfDecimals; i++) {
        tens *= 10;
      }
      value = Number((value * tens).toFixed(0));
      return value;
    };
    Slider2.prototype.render = function() {
      var _this = this;
      this.initialize();
      this.initRender();
      this.wireEvents();
      this.setZindex();
      this.renderComplete();
      if (this.element.tagName === "EJS-SLIDER") {
        if (this.getTheme(this.sliderContainer) === "none") {
          setTimeout(function() {
            _this.refresh();
          }, 0);
        }
      }
    };
    Slider2.prototype.initialize = function() {
      addClass([this.element], classNames2.root);
      this.setCSSClass();
    };
    Slider2.prototype.setElementWidth = function(width) {
      if (!isNullOrUndefined(width) && !isNullOrUndefined(this.sliderContainer)) {
        if (typeof width === "number") {
          this.sliderContainer.style.width = formatUnit(width);
        } else if (typeof width === "string") {
          this.sliderContainer.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
        }
      }
    };
    Slider2.prototype.setCSSClass = function(oldCSSClass) {
      if (oldCSSClass) {
        removeClass([this.element], oldCSSClass.split(" "));
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
      }
    };
    Slider2.prototype.setEnabled = function() {
      if (!this.enabled) {
        addClass([this.sliderContainer], [classNames2.sliderDisabled]);
        if (this.tooltip.isVisible && this.tooltipElement && this.tooltip.showOn === "Always") {
          this.tooltipElement.classList.add(classNames2.sliderDisabled);
        }
        this.unwireEvents();
      } else {
        removeClass([this.sliderContainer], [classNames2.sliderDisabled]);
        if (this.tooltip.isVisible && this.tooltipElement && this.tooltip.showOn === "Always") {
          this.tooltipElement.classList.remove(classNames2.sliderDisabled);
        }
        this.wireEvents();
      }
    };
    Slider2.prototype.getTheme = function(container) {
      var theme = window.getComputedStyle(container, ":after").getPropertyValue("content");
      return theme.replace(/['"]+/g, "");
    };
    Slider2.prototype.initRender = function() {
      this.sliderContainer = this.createElement("div", { className: classNames2.sliderContainer + " " + classNames2.controlWrapper });
      this.element.parentNode.insertBefore(this.sliderContainer, this.element);
      this.sliderContainer.appendChild(this.element);
      this.sliderTrack = this.createElement("div", { className: classNames2.sliderTrack });
      this.element.appendChild(this.sliderTrack);
      this.setElementWidth(this.width);
      this.element.tabIndex = -1;
      this.getThemeInitialization();
      this.setHandler();
      this.createRangeBar();
      if (this.limits.enabled) {
        this.createLimitBar();
      }
      this.setOrientClass();
      this.hiddenInput = this.createElement("input", {
        attrs: {
          type: "hidden",
          value: isNullOrUndefined(this.value) ? isNullOrUndefined(this.min) ? "0" : this.min.toString() : this.value.toString(),
          name: this.element.getAttribute("name") || this.element.getAttribute("id") || "_" + (Math.random() * 1e3).toFixed(0) + "slider",
          class: classNames2.sliderHiddenInput
        }
      });
      this.hiddenInput.tabIndex = -1;
      this.sliderContainer.appendChild(this.hiddenInput);
      if (this.showButtons) {
        this.setButtons();
      }
      this.setEnableRTL();
      if (this.type === "Range") {
        this.rangeValueUpdate();
      } else {
        this.value = isNullOrUndefined(this.value) ? isNullOrUndefined(this.min) ? 0 : parseFloat(formatUnit(this.min.toString())) : this.value;
      }
      this.previousVal = this.type !== "Range" ? this.checkHandleValue(parseFloat(formatUnit(this.value.toString()))) : [
        this.checkHandleValue(parseFloat(formatUnit(this.value[0].toString()))),
        this.checkHandleValue(parseFloat(formatUnit(this.value[1].toString())))
      ];
      this.previousChanged = this.previousVal;
      if (!isNullOrUndefined(this.element.hasAttribute("name"))) {
        this.element.removeAttribute("name");
      }
      this.setValue();
      if (this.limits.enabled) {
        this.setLimitBar();
      }
      if (this.ticks.placement !== "None") {
        this.renderScale();
      }
      if (this.tooltip.isVisible) {
        this.renderTooltip();
      }
      if (!this.enabled) {
        addClass([this.sliderContainer], [classNames2.sliderDisabled]);
      } else {
        removeClass([this.sliderContainer], [classNames2.sliderDisabled]);
      }
      if (this.readonly) {
        addClass([this.sliderContainer], [classNames2.readonly]);
      } else {
        removeClass([this.sliderContainer], [classNames2.readonly]);
      }
    };
    Slider2.prototype.getThemeInitialization = function() {
      this.isMaterial = this.getTheme(this.sliderContainer) === "material" || this.getTheme(this.sliderContainer) === "material-dark";
      this.isMaterial3 = this.getTheme(this.sliderContainer) === "Material3" || this.getTheme(this.sliderContainer) === "Material3-dark";
      this.isBootstrap = this.getTheme(this.sliderContainer) === "bootstrap" || this.getTheme(this.sliderContainer) === "bootstrap-dark";
      this.isBootstrap4 = this.getTheme(this.sliderContainer) === "bootstrap4";
      this.isTailwind = this.getTheme(this.sliderContainer) === "tailwind" || this.getTheme(this.sliderContainer) === "tailwind-dark";
      this.isBootstrap5 = this.getTheme(this.sliderContainer) === "bootstrap5";
      this.isFluent = this.getTheme(this.sliderContainer) === "FluentUI";
      this.isFluent2 = this.getTheme(this.sliderContainer) === "fluent2";
      this.isMaterialTooltip = (this.isMaterial || this.isMaterial3) && this.type !== "Range" && this.tooltip.isVisible;
    };
    Slider2.prototype.createRangeBar = function() {
      if (this.type !== "Default") {
        this.rangeBar = this.createElement("div", { attrs: { class: classNames2.rangeBar } });
        this.element.appendChild(this.rangeBar);
        if (this.drag && this.type === "Range") {
          if (this.orientation === "Horizontal") {
            this.rangeBar.classList.add(classNames2.dragHorizontal);
          } else {
            this.rangeBar.classList.add(classNames2.dragVertical);
          }
        }
      }
    };
    Slider2.prototype.createLimitBar = function() {
      var firstElementClassName = this.type !== "Range" ? classNames2.limitBarDefault : classNames2.limitBarFirst;
      firstElementClassName += " " + classNames2.limits;
      this.limitBarFirst = this.createElement("div", {
        attrs: { class: firstElementClassName }
      });
      this.element.appendChild(this.limitBarFirst);
      if (this.type === "Range") {
        this.limitBarSecond = this.createElement("div", {
          attrs: {
            class: classNames2.limitBarSecond + " " + classNames2.limits
          }
        });
        this.element.appendChild(this.limitBarSecond);
      }
    };
    Slider2.prototype.setOrientClass = function() {
      if (this.orientation !== "Vertical") {
        this.sliderContainer.classList.remove(classNames2.verticalSlider);
        this.sliderContainer.classList.add(classNames2.horizontalSlider);
        this.firstHandle.setAttribute("aria-orientation", "horizontal");
        if (this.type === "Range") {
          this.secondHandle.setAttribute("aria-orientation", "horizontal");
        }
      } else {
        this.sliderContainer.classList.remove(classNames2.horizontalSlider);
        this.sliderContainer.classList.add(classNames2.verticalSlider);
        this.firstHandle.setAttribute("aria-orientation", "vertical");
        if (this.type === "Range") {
          this.secondHandle.setAttribute("aria-orientation", "vertical");
        }
      }
    };
    Slider2.prototype.setAriaAttributes = function(element2) {
      var _this = this;
      var min = this.min;
      var max = this.max;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        min = this.customValues[0];
        max = this.customValues[this.customValues.length - 1];
      }
      if (this.type !== "Range") {
        attributes(element2, {
          "aria-valuemin": isNullOrUndefined(min) ? "0" : min.toString(),
          "aria-valuemax": isNullOrUndefined(max) ? "100" : max.toString()
        });
      } else {
        var range = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? [
          [min.toString(), this.customValues[this.value[1]].toString()],
          [this.customValues[this.value[0]].toString(), max.toString()]
        ] : [[min.toString(), this.value[1].toString()], [this.value[0].toString(), max.toString()]];
        range.forEach(function(range2, index) {
          var element3 = index === 0 ? _this.firstHandle : _this.secondHandle;
          if (element3) {
            attributes(element3, {
              "aria-valuemin": range2[0],
              "aria-valuemax": range2[1]
            });
          }
        });
      }
    };
    Slider2.prototype.createSecondHandle = function() {
      this.secondHandle = this.createElement("div", {
        attrs: {
          class: classNames2.sliderHandle,
          "role": "slider",
          tabIndex: "0",
          "aria-label": "slider"
        }
      });
      this.secondHandle.classList.add(classNames2.sliderSecondHandle);
      this.element.appendChild(this.secondHandle);
    };
    Slider2.prototype.createFirstHandle = function() {
      this.firstHandle = this.createElement("div", {
        attrs: {
          class: classNames2.sliderHandle,
          "role": "slider",
          tabIndex: "0",
          "aria-label": "slider"
        }
      });
      this.firstHandle.classList.add(classNames2.sliderFirstHandle);
      this.element.appendChild(this.firstHandle);
      if (this.isMaterialTooltip) {
        this.materialHandle = this.createElement("div", {
          attrs: {
            class: classNames2.sliderHandle + " " + classNames2.sliderMaterialHandle
          }
        });
        this.element.appendChild(this.materialHandle);
      }
    };
    Slider2.prototype.wireFirstHandleEvt = function(destroy3) {
      if (!destroy3) {
        EventHandler.add(this.firstHandle, "mousedown touchstart", this.handleFocus, this);
        EventHandler.add(this.firstHandle, "transitionend", this.transitionEnd, this);
        EventHandler.add(this.firstHandle, "mouseenter touchenter", this.handleOver, this);
        EventHandler.add(this.firstHandle, "mouseleave touchend", this.handleLeave, this);
      } else {
        EventHandler.remove(this.firstHandle, "mousedown touchstart", this.handleFocus);
        EventHandler.remove(this.firstHandle, "transitionend", this.transitionEnd);
        EventHandler.remove(this.firstHandle, "mouseenter touchenter", this.handleOver);
        EventHandler.remove(this.firstHandle, "mouseleave touchend", this.handleLeave);
      }
    };
    Slider2.prototype.wireSecondHandleEvt = function(destroy3) {
      if (!destroy3) {
        EventHandler.add(this.secondHandle, "mousedown touchstart", this.handleFocus, this);
        EventHandler.add(this.secondHandle, "transitionend", this.transitionEnd, this);
        EventHandler.add(this.secondHandle, "mouseenter touchenter", this.handleOver, this);
        EventHandler.add(this.secondHandle, "mouseleave touchend", this.handleLeave, this);
      } else {
        EventHandler.remove(this.secondHandle, "mousedown touchstart", this.handleFocus);
        EventHandler.remove(this.secondHandle, "transitionend", this.transitionEnd);
        EventHandler.remove(this.secondHandle, "mouseenter touchenter", this.handleOver);
        EventHandler.remove(this.secondHandle, "mouseleave touchend", this.handleLeave);
      }
    };
    Slider2.prototype.handleStart = function() {
      if (this.type !== "Range") {
        this.firstHandle.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames2.sliderHandleStart);
        if (this.isMaterialTooltip) {
          this.materialHandle.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames2.sliderHandleStart);
          if (this.tooltipElement) {
            this.tooltipElement.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames2.sliderTooltipStart);
          }
        }
      }
    };
    Slider2.prototype.transitionEnd = function(e) {
      if (e.propertyName !== "transform") {
        this.handleStart();
        if (!this.enableAnimation) {
          this.getHandle().style.transition = "none";
        }
        if (this.type !== "Default") {
          this.rangeBar.style.transition = "none";
        }
        if ((this.isMaterial || this.isMaterial3) && this.tooltip.isVisible && this.type === "Default") {
          this.tooltipElement.style.transition = this.transition.handle;
        }
        this.tooltipToggle(this.getHandle());
        this.closeTooltip();
      }
    };
    Slider2.prototype.handleFocusOut = function() {
      if (this.firstHandle.classList.contains(classNames2.sliderHandleFocused)) {
        this.firstHandle.classList.remove(classNames2.sliderHandleFocused);
      }
      if (this.type === "Range") {
        if (this.secondHandle.classList.contains(classNames2.sliderHandleFocused)) {
          this.secondHandle.classList.remove(classNames2.sliderHandleFocused);
        }
      }
    };
    Slider2.prototype.handleFocus = function(e) {
      this.focusSliderElement();
      this.sliderBarClick(e);
      if (e.currentTarget === this.firstHandle) {
        this.firstHandle.classList.add(classNames2.sliderHandleFocused);
        this.firstHandle.classList.add(classNames2.sliderTabHandle);
      } else {
        this.secondHandle.classList.add(classNames2.sliderHandleFocused);
        this.secondHandle.classList.add(classNames2.sliderTabHandle);
      }
      EventHandler.add(document, "mousemove touchmove", this.sliderBarMove, this);
      EventHandler.add(document, "mouseup touchend", this.sliderBarUp, this);
    };
    Slider2.prototype.handleOver = function(e) {
      if (this.tooltip.isVisible && this.tooltip.showOn === "Hover") {
        this.tooltipToggle(e.currentTarget);
      }
      if (this.type === "Default") {
        this.tooltipToggle(this.getHandle());
      }
    };
    Slider2.prototype.handleLeave = function(e) {
      if (this.tooltip.isVisible && this.tooltip.showOn === "Hover" && !e.currentTarget.classList.contains(classNames2.sliderHandleFocused) && !e.currentTarget.classList.contains(classNames2.sliderTabHandle)) {
        this.closeTooltip();
      }
    };
    Slider2.prototype.setHandler = function() {
      this.createFirstHandle();
      if (this.type === "Range") {
        this.createSecondHandle();
      }
    };
    Slider2.prototype.setEnableRTL = function() {
      if (this.enableRtl && this.orientation !== "Vertical") {
        addClass([this.sliderContainer], classNames2.rtl);
      } else {
        removeClass([this.sliderContainer], classNames2.rtl);
      }
      var preDir = this.orientation !== "Vertical" ? this.horDir : this.verDir;
      if (this.enableRtl) {
        this.horDir = "right";
        this.verDir = "bottom";
      } else {
        this.horDir = "left";
        this.verDir = "bottom";
      }
      var currDir = this.orientation !== "Vertical" ? this.horDir : this.verDir;
      if (preDir !== currDir) {
        if (this.orientation === "Horizontal") {
          setStyleAttribute(this.firstHandle, { "right": "", "left": "auto" });
          if (this.type === "Range") {
            setStyleAttribute(this.secondHandle, { "top": "", "left": "auto" });
          }
        }
      }
      this.setBarColor();
    };
    Slider2.prototype.tooltipValue = function() {
      var _this = this;
      var text;
      var args = {
        value: this.value,
        text: ""
      };
      if (this.initialTooltip) {
        this.initialTooltip = false;
        this.setTooltipContent();
        args.text = text = typeof this.tooltipObj.content === "function" ? this.tooltipObj.content() : this.tooltipObj.content;
        this.trigger("tooltipChange", args, function(observedArgs) {
          _this.addTooltipClass(observedArgs.text);
          if (text !== observedArgs.text) {
            _this.customAriaText = observedArgs.text;
            if (_this.enableHtmlSanitizer) {
              observedArgs.text = SanitizeHtmlHelper.sanitize(observedArgs.text.toString());
            } else {
              observedArgs.text = observedArgs.text.toString();
            }
            var contentTemp = function() {
              return observedArgs.text;
            };
            _this.tooltipObj.content = initializeCSPTemplate(contentTemp);
            _this.setAriaAttrValue(_this.firstHandle);
            if (_this.type === "Range") {
              _this.setAriaAttrValue(_this.secondHandle);
            }
          }
        });
        if (this.isMaterialTooltip) {
          this.setPreviousVal("change", this.value);
        }
      }
    };
    Slider2.prototype.setTooltipContent = function() {
      var content = this.formatContent(this.tooltipFormatInfo, false);
      var contentTemp = function() {
        return content;
      };
      this.tooltipObj.content = initializeCSPTemplate(contentTemp);
    };
    Slider2.prototype.formatContent = function(formatInfo, ariaContent) {
      var content = "";
      var handle1 = this.handleVal1;
      var handle2 = this.handleVal2;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        handle1 = this.customValues[this.handleVal1];
        handle2 = this.customValues[this.handleVal2];
      }
      if (!ariaContent) {
        if (this.type === "Range") {
          if (this.enableRtl && this.orientation !== "Vertical") {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle2, formatInfo).formatString + " - " + this.formatString(handle1, formatInfo).formatString : handle2.toString() + " - " + handle1.toString();
          } else {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle1, formatInfo).formatString + " - " + this.formatString(handle2, formatInfo).formatString : handle1.toString() + " - " + handle2.toString();
          }
        } else {
          if (!isNullOrUndefined(handle1)) {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle1, formatInfo).formatString : handle1.toString();
          }
        }
        return content;
      } else {
        if (this.type === "Range") {
          if (this.enableRtl && this.orientation !== "Vertical") {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle2, formatInfo).elementVal + " - " + this.formatString(handle1, formatInfo).elementVal : handle2.toString() + " - " + handle1.toString();
          } else {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle1, formatInfo).elementVal + " - " + this.formatString(handle2, formatInfo).elementVal : handle1.toString() + " - " + handle2.toString();
          }
        } else {
          if (!isNullOrUndefined(handle1)) {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle1, formatInfo).elementVal : handle1.toString();
          }
        }
        return content;
      }
    };
    Slider2.prototype.addTooltipClass = function(content) {
      if (this.isMaterialTooltip) {
        var count = content.toString().length;
        if (!this.tooltipElement) {
          var cssClass2 = count > 4 ? classNames2.sliderMaterialRange : classNames2.sliderMaterialDefault;
          this.tooltipObj.cssClass = classNames2.sliderTooltip + " " + cssClass2;
        } else {
          var cssClass2 = count > 4 ? { oldCss: classNames2.sliderMaterialDefault, newCss: classNames2.sliderMaterialRange } : { oldCss: classNames2.sliderMaterialRange, newCss: classNames2.sliderMaterialDefault };
          this.tooltipElement.classList.remove(cssClass2.oldCss);
          if (!this.tooltipElement.classList.contains(cssClass2.newCss)) {
            this.tooltipElement.classList.add(cssClass2.newCss);
            this.tooltipElement.style.transform = count > 4 ? "scale(1)" : this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
          }
        }
      }
    };
    Slider2.prototype.tooltipPlacement = function() {
      return this.orientation === "Horizontal" ? this.tooltip.placement === "Before" ? "TopCenter" : "BottomCenter" : this.tooltip.placement === "Before" ? "LeftCenter" : "RightCenter";
    };
    Slider2.prototype.tooltipBeforeOpen = function(args) {
      this.tooltipElement = args.element;
      if (this.tooltip.cssClass) {
        addClass([this.tooltipElement], this.tooltip.cssClass.split(" ").filter(function(css) {
          return css;
        }));
      }
      args.target.removeAttribute("aria-describedby");
      if (this.isMaterialTooltip) {
        this.tooltipElement.firstElementChild.classList.add(classNames2.materialTooltipHide);
        this.handleStart();
        this.setTooltipTransform();
      }
    };
    Slider2.prototype.tooltipCollision = function(position) {
      if (this.isBootstrap || this.isBootstrap4 || (this.isMaterial || this.isMaterial3) && !this.isMaterialTooltip) {
        var tooltipOffsetValue = this.isBootstrap4 ? bootstrap4TooltipOffset : bootstrapTooltipOffset;
        switch (position) {
          case "TopCenter":
            this.tooltipObj.setProperties({ "offsetY": -tooltipOffsetValue }, false);
            break;
          case "BottomCenter":
            this.tooltipObj.setProperties({ "offsetY": tooltipOffsetValue }, false);
            break;
          case "LeftCenter":
            this.tooltipObj.setProperties({ "offsetX": -tooltipOffsetValue }, false);
            break;
          case "RightCenter":
            this.tooltipObj.setProperties({ "offsetX": tooltipOffsetValue }, false);
            break;
        }
      }
    };
    Slider2.prototype.materialTooltipEventCallBack = function(event) {
      this.sliderBarClick(event);
      EventHandler.add(document, "mousemove touchmove", this.sliderBarMove, this);
      EventHandler.add(document, "mouseup touchend", this.sliderBarUp, this);
    };
    Slider2.prototype.wireMaterialTooltipEvent = function(destroy3) {
      if (this.isMaterialTooltip) {
        if (!destroy3) {
          EventHandler.add(this.tooltipElement, "mousedown touchstart", this.materialTooltipEventCallBack, this);
        } else {
          EventHandler.remove(this.tooltipElement, "mousedown touchstart", this.materialTooltipEventCallBack);
        }
      }
    };
    Slider2.prototype.tooltipPositionCalculation = function(position) {
      var cssClass2;
      switch (position) {
        case "TopCenter":
          cssClass2 = classNames2.horizontalTooltipBefore;
          break;
        case "BottomCenter":
          cssClass2 = classNames2.horizontalTooltipAfter;
          break;
        case "LeftCenter":
          cssClass2 = classNames2.verticalTooltipBefore;
          break;
        case "RightCenter":
          cssClass2 = classNames2.verticalTooltipAfter;
          break;
      }
      return cssClass2;
    };
    Slider2.prototype.getTooltipTransformProperties = function(className) {
      var transformProperties;
      if (this.tooltipElement) {
        var position = this.orientation === "Horizontal" ? this.tooltipElement.clientHeight + 14 - this.tooltipElement.clientHeight / 2 : this.tooltipElement.clientWidth + 14 - this.tooltipElement.clientWidth / 2;
        transformProperties = this.orientation === "Horizontal" ? className === classNames2.horizontalTooltipBefore ? { rotate: "rotate(45deg)", translate: "translateY(" + position + "px)" } : { rotate: "rotate(225deg)", translate: "translateY(" + -position + "px)" } : className === classNames2.verticalTooltipBefore ? { rotate: "rotate(-45deg)", translate: "translateX(" + position + "px)" } : { rotate: "rotate(-225deg)", translate: "translateX(" + -position + "px)" };
      }
      return transformProperties;
    };
    Slider2.prototype.openMaterialTooltip = function() {
      var _this = this;
      if (this.isMaterialTooltip) {
        this.refreshTooltip(this.firstHandle);
        var tooltipContentElement = this.tooltipElement.firstElementChild;
        tooltipContentElement.classList.remove(classNames2.materialTooltipHide);
        tooltipContentElement.classList.add(classNames2.materialTooltipShow);
        this.firstHandle.style.cursor = "default";
        this.tooltipElement.style.transition = this.scaleTransform;
        this.tooltipElement.classList.add(classNames2.materialTooltipOpen);
        this.materialHandle.style.transform = "scale(0)";
        if (tooltipContentElement.innerText.length > 4) {
          this.tooltipElement.style.transform = "scale(1)";
        } else {
          this.tooltipElement.style.transform = this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
        }
        if (this.type === "Default") {
          setTimeout(function() {
            if (_this.tooltipElement) {
              _this.tooltipElement.style.transition = _this.transition.handle;
            }
          }, 2500);
        } else {
          setTimeout(function() {
            if (_this.tooltipElement) {
              _this.tooltipElement.style.transition = "none";
            }
          }, 2500);
        }
      }
    };
    Slider2.prototype.closeMaterialTooltip = function() {
      var _this = this;
      if (this.isMaterialTooltip) {
        var tooltipContentElement = this.tooltipElement.firstElementChild;
        this.tooltipElement.style.transition = this.scaleTransform;
        tooltipContentElement.classList.remove(classNames2.materialTooltipShow);
        tooltipContentElement.classList.add(classNames2.materialTooltipHide);
        this.firstHandle.style.cursor = "-webkit-grab";
        this.firstHandle.style.cursor = "grab";
        if (this.materialHandle) {
          this.materialHandle.style.transform = "scale(1)";
        }
        this.tooltipElement.classList.remove(classNames2.materialTooltipOpen);
        this.setTooltipTransform();
        this.tooltipTarget = void 0;
        setTimeout(function() {
          if (_this.tooltipElement) {
            _this.tooltipElement.style.transition = "none";
          }
        }, 2500);
      }
    };
    Slider2.prototype.checkTooltipPosition = function(args) {
      var tooltipClass = this.tooltipPositionCalculation(args.collidedPosition);
      if (this.tooltipCollidedPosition === void 0 || this.tooltipCollidedPosition !== args.collidedPosition || !args.element.classList.contains(tooltipClass)) {
        if (this.isMaterialTooltip) {
          if (tooltipClass !== void 0) {
            args.element.classList.remove(this.previousTooltipClass);
            args.element.classList.add(tooltipClass);
            this.previousTooltipClass = tooltipClass;
          }
          if (args.element.style.transform && args.element.classList.contains(classNames2.materialTooltipOpen) && args.element.firstElementChild.innerText.length <= 4) {
            args.element.style.transform = this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
          }
        }
        this.tooltipCollidedPosition = args.collidedPosition;
      }
      if (this.isMaterialTooltip && this.tooltipElement && this.tooltipElement.style.transform.indexOf("translate") !== -1) {
        this.setTooltipTransform();
      }
    };
    Slider2.prototype.setTooltipTransform = function() {
      var transformProperties = this.getTooltipTransformProperties(this.previousTooltipClass);
      if (isNullOrUndefined(this.tooltipElement)) {
        return;
      }
      if (this.tooltipElement.firstElementChild.innerText.length > 4) {
        this.tooltipElement.style.transform = transformProperties.translate + " scale(0.01)";
      } else {
        this.tooltipElement.style.transform = transformProperties.translate + " " + transformProperties.rotate + " scale(0.01)";
      }
    };
    Slider2.prototype.renderTooltip = function() {
      this.tooltipObj = new Tooltip({
        showTipPointer: this.isBootstrap || this.isMaterial || this.isMaterial3 || this.isBootstrap4 || this.isTailwind || this.isBootstrap5 || this.isFluent || this.isFluent2,
        cssClass: classNames2.sliderTooltip,
        height: this.isMaterial || this.isMaterial3 ? 30 : "auto",
        animation: { open: { effect: "None" }, close: { effect: "FadeOut", duration: 500 } },
        opensOn: "Custom",
        beforeOpen: this.tooltipBeforeOpen.bind(this),
        beforeCollision: this.checkTooltipPosition.bind(this),
        beforeClose: this.tooltipBeforeClose.bind(this),
        enableHtmlSanitizer: this.enableHtmlSanitizer
      });
      this.tooltipObj.appendTo(this.firstHandle);
      this.initializeTooltipProps();
    };
    Slider2.prototype.initializeTooltipProps = function() {
      var tooltipShowOn = this.tooltip.showOn === "Auto" ? "Hover" : this.tooltip.showOn;
      this.setProperties({ tooltip: { showOn: tooltipShowOn } }, true);
      this.tooltipObj.position = this.tooltipPlacement();
      this.tooltipCollision(this.tooltipObj.position);
      [this.firstHandle, this.rangeBar, this.secondHandle].forEach(function(handle) {
        if (!isNullOrUndefined(handle)) {
          handle.style.transition = "none";
        }
      });
      if (this.isMaterialTooltip) {
        this.sliderContainer.classList.add(classNames2.materialSlider);
        this.tooltipValue();
        this.tooltipObj.animation.close.effect = "None";
        this.tooltipObj.open(this.firstHandle);
      }
    };
    Slider2.prototype.tooltipBeforeClose = function() {
      this.tooltipElement = void 0;
      this.tooltipCollidedPosition = void 0;
    };
    Slider2.prototype.setButtons = function() {
      this.firstBtn = this.createElement("div", { className: classNames2.sliderButton + " " + classNames2.firstButton });
      this.firstBtn.appendChild(this.createElement("span", { className: classNames2.sliderButtonIcon }));
      if (this.isTailwind) {
        this.firstBtn.querySelector("span").classList.add("e-icons");
      }
      this.firstBtn.tabIndex = -1;
      this.secondBtn = this.createElement("div", { className: classNames2.sliderButton + " " + classNames2.secondButton });
      this.secondBtn.appendChild(this.createElement("span", { className: classNames2.sliderButtonIcon }));
      if (this.isTailwind) {
        this.secondBtn.querySelector("span").classList.add("e-icons");
      }
      this.secondBtn.tabIndex = -1;
      this.sliderContainer.classList.add(classNames2.sliderButtonClass);
      this.sliderContainer.appendChild(this.firstBtn);
      this.sliderContainer.appendChild(this.secondBtn);
      this.sliderContainer.appendChild(this.element);
      this.buttonTitle();
    };
    Slider2.prototype.buttonTitle = function() {
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      this.l10n.setLocale(this.locale);
      var decrementTitle = this.l10n.getConstant("decrementTitle");
      var incrementTitle = this.l10n.getConstant("incrementTitle");
      attributes(enabledRTL ? this.secondBtn : this.firstBtn, { "aria-label": decrementTitle, title: decrementTitle });
      attributes(enabledRTL ? this.firstBtn : this.secondBtn, { "aria-label": incrementTitle, title: incrementTitle });
    };
    Slider2.prototype.buttonFocusOut = function() {
      if (this.isMaterial || this.isMaterial3) {
        this.getHandle().classList.remove("e-large-thumb-size");
      }
    };
    Slider2.prototype.repeatButton = function(args) {
      var hVal = this.handleValueUpdate();
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      var value;
      if (args.target.parentElement.classList.contains(classNames2.firstButton) || args.target.classList.contains(classNames2.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        }
      } else if (args.target.parentElement.classList.contains(classNames2.secondButton) || args.target.classList.contains(classNames2.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        }
      }
      if (this.limits.enabled) {
        value = this.getLimitCorrectedValues(value);
      }
      if (value >= this.min && value <= this.max) {
        this.changeHandleValue(value);
        this.tooltipToggle(this.getHandle());
      }
    };
    Slider2.prototype.repeatHandlerMouse = function(args) {
      args.preventDefault();
      if (args.type === "mousedown" || args.type === "touchstart") {
        this.buttonClick(args);
        this.repeatInterval = setInterval(this.repeatButton.bind(this), 180, args);
      }
    };
    Slider2.prototype.materialChange = function() {
      if (!this.getHandle().classList.contains("e-large-thumb-size")) {
        this.getHandle().classList.add("e-large-thumb-size");
      }
    };
    Slider2.prototype.focusHandle = function() {
      if (!this.getHandle().classList.contains(classNames2.sliderTabHandle)) {
        this.getHandle().classList.add(classNames2.sliderTabHandle);
      }
    };
    Slider2.prototype.repeatHandlerUp = function(e) {
      this.changeEvent("changed", e);
      this.closeTooltip();
      clearInterval(this.repeatInterval);
      this.getHandle().focus();
    };
    Slider2.prototype.customTickCounter = function(bigNum) {
      var tickCount = 4;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        if (bigNum > 4) {
          tickCount = 3;
        }
        if (bigNum > 7) {
          tickCount = 2;
        }
        if (bigNum > 14) {
          tickCount = 1;
        }
        if (bigNum > 28) {
          tickCount = 0;
        }
      }
      return tickCount;
    };
    Slider2.prototype.renderScale = function() {
      var orien = this.orientation === "Vertical" ? "v" : "h";
      this.noOfDecimals = this.numberOfDecimals(this.step);
      this.ul = this.createElement("ul", {
        className: classNames2.scale + " e-" + orien + "-scale " + classNames2.tick + "-" + this.ticks.placement.toLowerCase(),
        attrs: { role: "presentation", tabIndex: "-1", "aria-hidden": "true" }
      });
      this.ul.style.zIndex = "-1";
      if (Browser.isAndroid && orien === "h") {
        this.ul.classList.add(classNames2.sliderTickPosition);
      }
      var smallStep = this.ticks.smallStep;
      if (!this.ticks.showSmallTicks) {
        if (this.ticks.largeStep > 0) {
          smallStep = this.ticks.largeStep;
        } else {
          smallStep = parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min));
        }
      } else if (smallStep <= 0) {
        smallStep = parseFloat(formatUnit(this.step));
      }
      var min = this.fractionalToInteger(this.min);
      var max = this.fractionalToInteger(this.max);
      var steps = this.fractionalToInteger(smallStep);
      var bigNum = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 && this.customValues.length - 1;
      var customStep = this.customTickCounter(bigNum);
      var count = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? bigNum * customStep + bigNum : Math.abs((max - min) / steps);
      this.element.appendChild(this.ul);
      var li;
      var start = parseFloat(this.min.toString());
      if (orien === "v") {
        start = parseFloat(this.max.toString());
      }
      var left = 0;
      var islargeTick;
      var tickWidth = 100 / count;
      if (tickWidth === Infinity) {
        tickWidth = 5;
      }
      for (var i = 0, y = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? this.customValues.length - 1 : 0, k = 0; i <= count; i++) {
        li = this.createElement("li", {
          attrs: {
            class: classNames2.tick,
            role: "presentation",
            tabIndex: "-1",
            "aria-hidden": "true"
          }
        });
        if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
          islargeTick = i % (customStep + 1) === 0;
          if (islargeTick) {
            if (orien === "h") {
              start = this.customValues[k];
              k++;
            } else {
              start = this.customValues[y];
              y--;
            }
            li.setAttribute("title", start.toString());
          }
        } else {
          li.setAttribute("title", start.toString());
          if (this.numberOfDecimals(this.max) === 0 && this.numberOfDecimals(this.min) === 0 && this.numberOfDecimals(this.step) === 0) {
            if (orien === "h") {
              islargeTick = (start - parseFloat(this.min.toString())) % this.ticks.largeStep === 0 ? true : false;
            } else {
              islargeTick = Math.abs(start - parseFloat(this.max.toString())) % this.ticks.largeStep === 0 ? true : false;
            }
          } else {
            var largestep = this.fractionalToInteger(this.ticks.largeStep);
            var startValue = this.fractionalToInteger(start);
            if (orien === "h") {
              islargeTick = (startValue - min) % largestep === 0 ? true : false;
            } else {
              islargeTick = Math.abs(startValue - parseFloat(max.toString())) % largestep === 0 ? true : false;
            }
          }
        }
        if (islargeTick) {
          li.classList.add(classNames2.large);
        }
        if (orien === "h") {
          li.style.width = tickWidth + "%";
        } else {
          li.style.height = tickWidth + "%";
        }
        var repeat = islargeTick ? this.ticks.placement === "Both" ? 2 : 1 : 0;
        if (islargeTick) {
          for (var j = 0; j < repeat; j++) {
            this.createTick(li, start, tickWidth);
          }
        } else if (isNullOrUndefined(this.customValues)) {
          this.formatTicksValue(li, start);
        }
        this.ul.appendChild(li);
        this.tickElementCollection.push(li);
        var decimalPoints = void 0;
        if (isNullOrUndefined(this.customValues)) {
          if (this.numberOfDecimals(smallStep) > this.numberOfDecimals(start)) {
            decimalPoints = this.numberOfDecimals(smallStep);
          } else {
            decimalPoints = this.numberOfDecimals(start);
          }
          if (orien === "h") {
            start = this.makeRoundNumber(start + smallStep, decimalPoints);
          } else {
            if (this.min > this.max) {
              start = this.makeRoundNumber(start + smallStep, decimalPoints);
            } else {
              start = this.makeRoundNumber(start - smallStep, decimalPoints);
            }
          }
          left = this.makeRoundNumber(left + smallStep, decimalPoints);
        }
      }
      this.ticksAlignment(orien, tickWidth);
    };
    Slider2.prototype.ticksAlignment = function(orien, tickWidth, triggerEvent) {
      if (triggerEvent === void 0) {
        triggerEvent = true;
      }
      this.firstChild = this.ul.firstElementChild;
      this.lastChild = this.ul.lastElementChild;
      this.firstChild.classList.add(classNames2.sliderFirstTick);
      this.lastChild.classList.add(classNames2.sliderLastTick);
      this.sliderContainer.classList.add(classNames2.scale + "-" + this.ticks.placement.toLowerCase());
      if (orien === "h") {
        this.firstChild.style.width = tickWidth / 2 + "%";
        this.lastChild.style.width = tickWidth / 2 + "%";
      } else {
        this.firstChild.style.height = tickWidth / 2 + "%";
        this.lastChild.style.height = tickWidth / 2 + "%";
      }
      var eventArgs = { ticksWrapper: this.ul, tickElements: this.tickElementCollection };
      if (triggerEvent) {
        this.trigger("renderedTicks", eventArgs);
      }
      this.scaleAlignment();
    };
    Slider2.prototype.createTick = function(li, start, tickWidth) {
      var span = this.createElement("span", {
        className: classNames2.tickValue + " " + classNames2.tick + "-" + this.ticks.placement.toLowerCase(),
        attrs: { role: "presentation", tabIndex: "-1", "aria-hidden": "true" }
      });
      li.appendChild(span);
      if (isNullOrUndefined(this.customValues)) {
        this.formatTicksValue(li, start, span);
      } else {
        if (this.enableHtmlSanitizer) {
          span.innerHTML = SanitizeHtmlHelper.sanitize(start.toString());
        } else {
          span.innerHTML = start.toString();
        }
      }
    };
    Slider2.prototype.formatTicksValue = function(li, start, spanElement) {
      var _this = this;
      var tickText = this.formatNumber(start);
      var text = !isNullOrUndefined(this.ticks) && !isNullOrUndefined(this.ticks.format) ? this.formatString(start, this.ticksFormatInfo).formatString : tickText;
      var eventArgs = { value: start, text, tickElement: li };
      this.trigger("renderingTicks", eventArgs, function(observedArgs) {
        li.setAttribute("title", observedArgs.text.toString());
        if (spanElement) {
          if (_this.enableHtmlSanitizer) {
            spanElement.innerHTML = SanitizeHtmlHelper.sanitize(observedArgs.text.toString());
          } else {
            spanElement.innerHTML = observedArgs.text.toString();
          }
        }
      });
    };
    Slider2.prototype.scaleAlignment = function() {
      this.tickValuePosition();
      if (this.orientation === "Vertical") {
        if (this.element.getBoundingClientRect().width <= 15) {
          this.sliderContainer.classList.add(classNames2.sliderSmallSize);
        } else {
          this.sliderContainer.classList.remove(classNames2.sliderSmallSize);
        }
      } else {
        if (this.element.getBoundingClientRect().height <= 15) {
          this.sliderContainer.classList.add(classNames2.sliderSmallSize);
        } else {
          this.sliderContainer.classList.remove(classNames2.sliderSmallSize);
        }
      }
    };
    Slider2.prototype.tickValuePosition = function() {
      this.firstChild = this.element.querySelector("ul").children[0];
      var first = this.firstChild.getBoundingClientRect();
      var firstChild;
      var otherChild;
      var smallStep = this.ticks.smallStep;
      var count = Math.abs(parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min))) / smallStep;
      if (this.firstChild.children.length > 0) {
        firstChild = this.firstChild.children[0].getBoundingClientRect();
      }
      var tickElements = [this.sliderContainer.querySelectorAll("." + classNames2.tick + "." + classNames2.large + " ." + classNames2.tickValue)];
      var other;
      if (this.ticks.placement === "Both") {
        other = [].slice.call(tickElements[0], 2);
      } else {
        other = [].slice.call(tickElements[0], 1);
      }
      var tickWidth = this.orientation === "Vertical" ? first.height * 2 : first.width * 2;
      for (var i = 0; i < this.firstChild.children.length; i++) {
        if (this.orientation === "Vertical") {
          this.firstChild.children[i].style.top = -(firstChild.height / 2) + "px";
        } else {
          if (!this.enableRtl) {
            this.firstChild.children[i].style.left = -(firstChild.width / 2) + "px";
          } else {
            this.firstChild.children[i].style.left = (tickWidth - this.firstChild.children[i].getBoundingClientRect().width) / 2 + "px";
          }
        }
      }
      for (var i = 0; i < other.length; i++) {
        otherChild = other[i].getBoundingClientRect();
        if (this.orientation === "Vertical") {
          setStyleAttribute(other[i], { top: (tickWidth - otherChild.height) / 2 + "px" });
        } else {
          setStyleAttribute(other[i], { left: (tickWidth - otherChild.width) / 2 + "px" });
        }
      }
      if (this.enableRtl && this.lastChild.children.length && count !== 0) {
        this.lastChild.children[0].style.left = -(this.lastChild.getBoundingClientRect().width / 2) + "px";
        if (this.ticks.placement === "Both") {
          this.lastChild.children[1].style.left = -(this.lastChild.getBoundingClientRect().width / 2) + "px";
        }
      }
      if (count === 0) {
        if (this.orientation === "Horizontal") {
          if (!this.enableRtl) {
            this.firstChild.classList.remove(classNames2.sliderLastTick);
            this.firstChild.style.left = this.firstHandle.style.left;
          } else {
            this.firstChild.classList.remove(classNames2.sliderLastTick);
            this.firstChild.style.right = this.firstHandle.style.right;
            this.firstChild.children[0].style.left = this.firstChild.getBoundingClientRect().width / 2 + 2 + "px";
            if (this.ticks.placement === "Both") {
              this.firstChild.children[1].style.left = this.firstChild.getBoundingClientRect().width / 2 + 2 + "px";
            }
          }
        }
        if (this.orientation === "Vertical") {
          this.firstChild.classList.remove(classNames2.sliderLastTick);
        }
      }
    };
    Slider2.prototype.setAriaAttrValue = function(element2) {
      var ariaValueText;
      var isTickFormatted = !isNullOrUndefined(this.ticks) && !isNullOrUndefined(this.ticks.format) ? true : false;
      var text = !isTickFormatted ? this.formatContent(this.ticksFormatInfo, false) : this.formatContent(this.tooltipFormatInfo, false);
      var valuenow = isTickFormatted ? this.formatContent(this.ticksFormatInfo, true) : this.formatContent(this.tooltipFormatInfo, true);
      text = !this.customAriaText ? text : this.customAriaText;
      if (text.split(" - ").length === 2) {
        ariaValueText = text.split(" - ");
      } else {
        ariaValueText = [text, text];
      }
      this.setAriaAttributes(element2);
      if (this.type !== "Range") {
        attributes(element2, { "aria-valuenow": valuenow, "aria-valuetext": text });
      } else {
        if (!this.enableRtl) {
          if (element2 === this.firstHandle) {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[0], "aria-valuetext": ariaValueText[0] });
          } else {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[1], "aria-valuetext": ariaValueText[1] });
          }
        } else {
          if (element2 === this.firstHandle) {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[1], "aria-valuetext": ariaValueText[1] });
          } else {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[0], "aria-valuetext": ariaValueText[0] });
          }
        }
      }
    };
    Slider2.prototype.handleValueUpdate = function() {
      var hVal;
      if (this.type === "Range") {
        if (this.activeHandle === 1) {
          hVal = this.handleVal1;
        } else {
          hVal = this.handleVal2;
        }
      } else {
        hVal = this.handleVal1;
      }
      return hVal;
    };
    Slider2.prototype.getLimitCorrectedValues = function(value) {
      if (this.type === "MinRange" || this.type === "Default") {
        value = this.getLimitValueAndPosition(value, this.limits.minStart, this.limits.minEnd)[0];
      } else {
        if (this.activeHandle === 1) {
          value = this.getLimitValueAndPosition(value, this.limits.minStart, this.limits.minEnd)[0];
        } else {
          value = this.getLimitValueAndPosition(value, this.limits.maxStart, this.limits.maxEnd)[0];
        }
      }
      return value;
    };
    Slider2.prototype.focusSliderElement = function() {
      if (!this.isElementFocused) {
        this.element.focus();
        this.isElementFocused = true;
      }
    };
    Slider2.prototype.buttonClick = function(args) {
      this.focusSliderElement();
      var value;
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      var hVal = this.handleValueUpdate();
      if (args.keyCode === 40 || args.keyCode === 37 || args.currentTarget.classList.contains(classNames2.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        }
      } else if (args.keyCode === 38 || args.keyCode === 39 || args.currentTarget.classList.contains(classNames2.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        }
      } else if (args.keyCode === 33 || args.currentTarget.classList.contains(classNames2.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), true);
        }
      } else if (args.keyCode === 34 || args.currentTarget.classList.contains(classNames2.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), false);
        }
      } else if (args.keyCode === 36) {
        value = parseFloat(this.min < this.max ? this.min.toString() : this.max.toString());
      } else if (args.keyCode === 35) {
        value = parseFloat(this.min < this.max ? this.max.toString() : this.min.toString());
      }
      if (this.limits.enabled) {
        value = this.getLimitCorrectedValues(value);
      }
      this.changeHandleValue(value);
      if ((this.isMaterial || this.isMaterial3) && !this.tooltip.isVisible && !this.getHandle().classList.contains(classNames2.sliderTabHandle)) {
        this.materialChange();
      }
      this.tooltipToggle(this.getHandle());
      this.getHandle().focus();
      this.focusHandle();
      if (args.currentTarget.classList.contains(classNames2.firstButton)) {
        EventHandler.add(this.firstBtn, "mouseup touchend", this.buttonUp, this);
      }
      if (args.currentTarget.classList.contains(classNames2.secondButton)) {
        EventHandler.add(this.secondBtn, "mouseup touchend", this.buttonUp, this);
      }
    };
    Slider2.prototype.tooltipToggle = function(target) {
      if (this.isMaterialTooltip) {
        if (!this.tooltipElement.classList.contains(classNames2.materialTooltipOpen)) {
          this.openMaterialTooltip();
        } else {
          this.refreshTooltip(this.firstHandle);
        }
      } else {
        if (!this.tooltipElement) {
          this.openTooltip(target);
        } else {
          this.refreshTooltip(target);
        }
      }
    };
    Slider2.prototype.buttonUp = function(args) {
      if (args.currentTarget.classList.contains(classNames2.firstButton)) {
        EventHandler.remove(this.firstBtn, "mouseup touchend", this.buttonUp);
      }
      if (args.currentTarget.classList.contains(classNames2.secondButton)) {
        EventHandler.remove(this.secondBtn, "mouseup touchend", this.buttonUp);
      }
    };
    Slider2.prototype.setRangeBar = function() {
      if (this.orientation === "Horizontal" && !isNullOrUndefined(this.rangeBar)) {
        if (this.type === "MinRange") {
          if (this.enableRtl) {
            this.rangeBar.style.right = "0px";
          } else {
            this.rangeBar.style.left = "0px";
          }
          setStyleAttribute(this.rangeBar, { "width": isNullOrUndefined(this.handlePos1) ? 0 : this.handlePos1 + "px" });
        } else {
          if (this.enableRtl) {
            this.rangeBar.style.right = this.handlePos1 + "px";
          } else {
            this.rangeBar.style.left = this.handlePos1 + "px";
          }
          setStyleAttribute(this.rangeBar, { "width": this.handlePos2 - this.handlePos1 + "px" });
        }
      } else if (!isNullOrUndefined(this.rangeBar)) {
        if (this.type === "MinRange") {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos1 + "px" : "0px";
          setStyleAttribute(this.rangeBar, { "height": isNullOrUndefined(this.handlePos1) ? 0 : this.min > this.max ? this.element.clientHeight - this.handlePos1 + "px" : this.handlePos1 + "px" });
        } else {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos2 + "px" : this.handlePos1 + "px";
          setStyleAttribute(this.rangeBar, { "height": this.min > this.max ? this.handlePos1 - this.handlePos2 + "px" : this.handlePos2 - this.handlePos1 + "px" });
        }
      }
    };
    Slider2.prototype.checkValidValueAndPos = function(value) {
      value = this.checkHandleValue(value);
      value = this.checkHandlePosition(value);
      return value;
    };
    Slider2.prototype.setLimitBarPositions = function(fromMinPostion, fromMaxpostion, toMinPostion, toMaxpostion) {
      if (this.orientation === "Horizontal") {
        if (!this.enableRtl) {
          this.limitBarFirst.style.left = fromMinPostion + "px";
          this.limitBarFirst.style.width = fromMaxpostion - fromMinPostion + "px";
        } else {
          this.limitBarFirst.style.right = fromMinPostion + "px";
          this.limitBarFirst.style.width = fromMaxpostion - fromMinPostion + "px";
        }
      } else {
        this.limitBarFirst.style.bottom = (this.min < this.max ? fromMinPostion : fromMaxpostion) + "px";
        this.limitBarFirst.style.height = (this.min < this.max ? fromMaxpostion - fromMinPostion : fromMinPostion - fromMaxpostion) + "px";
      }
      if (this.type === "Range") {
        if (this.orientation === "Horizontal") {
          if (!this.enableRtl) {
            this.limitBarSecond.style.left = toMinPostion + "px";
            this.limitBarSecond.style.width = toMaxpostion - toMinPostion + "px";
          } else {
            this.limitBarSecond.style.right = toMinPostion + "px";
            this.limitBarSecond.style.width = toMaxpostion - toMinPostion + "px";
          }
        } else {
          this.limitBarSecond.style.bottom = (this.min < this.max ? toMinPostion : toMaxpostion) + "px";
          this.limitBarSecond.style.height = (this.min < this.max ? toMaxpostion - toMinPostion : toMinPostion - toMaxpostion) + "px";
        }
      }
    };
    Slider2.prototype.setLimitBar = function() {
      if (this.type === "Default" || this.type === "MinRange") {
        var fromPosition = this.getLimitValueAndPosition(this.limits.minStart, this.limits.minStart, this.limits.minEnd, true)[0];
        fromPosition = this.checkValidValueAndPos(fromPosition);
        var toPosition = this.getLimitValueAndPosition(this.limits.minEnd, this.limits.minStart, this.limits.minEnd, true)[0];
        toPosition = this.checkValidValueAndPos(toPosition);
        this.setLimitBarPositions(fromPosition, toPosition);
      } else if (this.type === "Range") {
        var fromMinPostion = this.getLimitValueAndPosition(this.limits.minStart, this.limits.minStart, this.limits.minEnd, true)[0];
        fromMinPostion = this.checkValidValueAndPos(fromMinPostion);
        var fromMaxpostion = this.getLimitValueAndPosition(this.limits.minEnd, this.limits.minStart, this.limits.minEnd, true)[0];
        fromMaxpostion = this.checkValidValueAndPos(fromMaxpostion);
        var toMinPostion = this.getLimitValueAndPosition(this.limits.maxStart, this.limits.maxStart, this.limits.maxEnd, true)[0];
        toMinPostion = this.checkValidValueAndPos(toMinPostion);
        var toMaxpostion = this.getLimitValueAndPosition(this.limits.maxEnd, this.limits.maxStart, this.limits.maxEnd, true)[0];
        toMaxpostion = this.checkValidValueAndPos(toMaxpostion);
        this.setLimitBarPositions(fromMinPostion, fromMaxpostion, toMinPostion, toMaxpostion);
      }
    };
    Slider2.prototype.getLimitValueAndPosition = function(currentValue, minValue, maxValue, limitBar) {
      if (isNullOrUndefined(minValue)) {
        minValue = this.min < this.max ? this.min : this.max;
        if (isNullOrUndefined(currentValue) && limitBar) {
          currentValue = minValue;
        }
      }
      if (isNullOrUndefined(maxValue)) {
        maxValue = this.min < this.max ? this.max : this.min;
        if (isNullOrUndefined(currentValue) && limitBar) {
          currentValue = maxValue;
        }
      }
      if (currentValue < minValue) {
        currentValue = minValue;
      }
      if (currentValue > maxValue) {
        currentValue = maxValue;
      }
      return [currentValue, this.checkHandlePosition(currentValue)];
    };
    Slider2.prototype.setValue = function() {
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        this.min = 0;
        this.max = this.customValues.length - 1;
        this.setBarColor();
      }
      this.setAriaAttributes(this.firstHandle);
      this.handleVal1 = isNullOrUndefined(this.value) ? this.checkHandleValue(parseFloat(this.min.toString())) : this.checkHandleValue(parseFloat(this.value.toString()));
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.preHandlePos1 = this.handlePos1;
      if (isNullOrUndefined(this.activeHandle)) {
        this.activeHandle = this.type === "Range" ? 2 : 1;
      }
      if (this.type === "Default" || this.type === "MinRange") {
        if (this.limits.enabled) {
          var values = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
          this.handleVal1 = values[0];
          this.handlePos1 = values[1];
          this.preHandlePos1 = this.handlePos1;
        }
        this.setHandlePosition(null);
        this.handleStart();
        this.value = this.handleVal1;
        this.setAriaAttrValue(this.firstHandle);
        this.changeEvent("changed", null);
      } else {
        this.validateRangeValue();
      }
      if (this.type !== "Default") {
        this.setRangeBar();
      }
      if (this.limits.enabled) {
        this.setLimitBar();
      }
    };
    Slider2.prototype.rangeValueUpdate = function() {
      if (this.value === null || typeof this.value !== "object") {
        this.value = [parseFloat(formatUnit(this.min)), parseFloat(formatUnit(this.max))];
      }
    };
    Slider2.prototype.validateRangeValue = function() {
      this.rangeValueUpdate();
      this.setRangeValue();
    };
    Slider2.prototype.modifyZindex = function() {
      if (this.type === "Range" && !isNullOrUndefined(this.firstHandle) && !isNullOrUndefined(this.secondHandle)) {
        if (this.activeHandle === 1) {
          this.firstHandle.style.zIndex = this.zIndex + 4 + "";
          this.secondHandle.style.zIndex = this.zIndex + 3 + "";
        } else {
          this.firstHandle.style.zIndex = this.zIndex + 3 + "";
          this.secondHandle.style.zIndex = this.zIndex + 4 + "";
        }
      } else if (this.isMaterialTooltip && this.tooltipElement) {
        this.tooltipElement.style.zIndex = getZindexPartial(this.element) + "";
      }
    };
    Slider2.prototype.setHandlePosition = function(event) {
      var _this = this;
      var handle;
      var pos = this.activeHandle === 1 ? this.handlePos1 : this.handlePos2;
      if (this.isMaterialTooltip) {
        handle = [this.firstHandle, this.materialHandle];
      } else {
        handle = [this.getHandle()];
      }
      this.handleStart();
      handle.forEach(function(handle2) {
        if (isNullOrUndefined(handle2)) {
          return;
        }
        if (_this.orientation === "Horizontal") {
          if (_this.enableRtl) {
            handle2.style.right = pos + "px";
          } else {
            handle2.style.left = pos + "px";
          }
        } else {
          handle2.style.bottom = pos + "px";
        }
      });
      this.changeEvent("change", event);
    };
    Slider2.prototype.getHandle = function() {
      return this.activeHandle === 1 ? this.firstHandle : this.secondHandle;
    };
    Slider2.prototype.setRangeValue = function() {
      this.updateRangeValue();
      this.activeHandle = 1;
      this.setHandlePosition(null);
      this.activeHandle = 2;
      this.setHandlePosition(null);
      this.activeHandle = 1;
    };
    Slider2.prototype.changeEvent = function(eventName, e) {
      var previous = eventName === "change" ? this.previousVal : this.previousChanged;
      if (this.type !== "Range") {
        this.setProperties({ "value": this.handleVal1 }, true);
        if (previous !== this.value && (!this.isMaterialTooltip || !this.initialTooltip)) {
          this.trigger(eventName, this.changeEventArgs(eventName, e));
          this.initialTooltip = true;
          this.setPreviousVal(eventName, this.value);
        }
        this.setAriaAttrValue(this.firstHandle);
      } else {
        var value = this.value = [this.handleVal1, this.handleVal2];
        this.setProperties({ "value": value }, true);
        if (previous.length === this.value.length && this.value[0] !== previous[0] || this.value[1] !== previous[1]) {
          this.initialTooltip = false;
          this.trigger(eventName, this.changeEventArgs(eventName, e));
          this.initialTooltip = true;
          this.setPreviousVal(eventName, this.value);
        }
        this.setAriaAttrValue(this.getHandle());
      }
      this.hiddenInput.value = this.value.toString();
    };
    Slider2.prototype.changeEventArgs = function(eventName, e) {
      var eventArgs;
      if (this.tooltip.isVisible && this.tooltipObj && this.initialTooltip) {
        this.tooltipValue();
        eventArgs = {
          value: this.value,
          previousValue: eventName === "change" ? this.previousVal : this.previousChanged,
          action: eventName,
          text: typeof this.tooltipObj.content === "function" ? this.tooltipObj.content() : this.tooltipObj.content,
          isInteracted: isNullOrUndefined(e) ? false : true
        };
      } else {
        eventArgs = {
          value: this.value,
          previousValue: eventName === "change" ? this.previousVal : this.previousChanged,
          action: eventName,
          text: isNullOrUndefined(this.ticksFormatInfo.format) ? this.value.toString() : this.type !== "Range" ? this.formatString(this.value, this.ticksFormatInfo).formatString : this.formatString(this.value[0], this.ticksFormatInfo).formatString + " - " + this.formatString(this.value[1], this.ticksFormatInfo).formatString,
          isInteracted: isNullOrUndefined(e) ? false : true
        };
      }
      return eventArgs;
    };
    Slider2.prototype.setPreviousVal = function(eventName, value) {
      if (eventName === "change") {
        this.previousVal = value;
      } else {
        this.previousChanged = value;
      }
    };
    Slider2.prototype.updateRangeValue = function() {
      var values = this.value.toString().split(",").map(Number);
      if (this.enableRtl && this.orientation !== "Vertical" || this.rtl) {
        this.value = [values[1], values[0]];
      } else {
        this.value = [values[0], values[1]];
      }
      if (this.enableRtl && this.orientation !== "Vertical") {
        this.handleVal1 = this.checkHandleValue(this.value[1]);
        this.handleVal2 = this.checkHandleValue(this.value[0]);
      } else {
        this.handleVal1 = this.checkHandleValue(this.value[0]);
        this.handleVal2 = this.checkHandleValue(this.value[1]);
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.handlePos2 = this.checkHandlePosition(this.handleVal2);
      if (this.min < this.max && this.handlePos1 > this.handlePos2) {
        this.handlePos1 = this.handlePos2;
        this.handleVal1 = this.handleVal2;
      }
      if (this.min > this.max && this.handlePos1 < this.handlePos2) {
        this.handlePos2 = this.handlePos1;
        this.handleVal2 = this.handleVal1;
      }
      this.preHandlePos1 = this.handlePos1;
      this.preHandlePos2 = this.handlePos2;
      if (this.limits.enabled) {
        this.activeHandle = 1;
        var values_1 = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
        this.handleVal1 = values_1[0];
        this.handlePos1 = values_1[1];
        this.preHandlePos1 = this.handlePos1;
        this.activeHandle = 2;
        values_1 = this.getLimitValueAndPosition(this.handleVal2, this.limits.maxStart, this.limits.maxEnd);
        this.handleVal2 = values_1[0];
        this.handlePos2 = values_1[1];
        this.preHandlePos2 = this.handlePos2;
      }
    };
    Slider2.prototype.checkHandlePosition = function(value) {
      var pos;
      value = 100 * (value - parseFloat(formatUnit(this.min))) / (parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min)));
      if (this.orientation === "Horizontal") {
        pos = this.element.getBoundingClientRect().width * (value / 100);
      } else {
        pos = this.element.getBoundingClientRect().height * (value / 100);
      }
      if (parseFloat(formatUnit(this.max)) === parseFloat(formatUnit(this.min))) {
        if (this.orientation === "Horizontal") {
          pos = this.element.getBoundingClientRect().width;
        } else {
          pos = this.element.getBoundingClientRect().height;
        }
      }
      return pos;
    };
    Slider2.prototype.checkHandleValue = function(value) {
      if (this.min === this.max) {
        return parseFloat(formatUnit(this.max));
      }
      var handle = this.tempStartEnd();
      if (value < handle.start) {
        value = handle.start;
      } else if (value > handle.end) {
        value = handle.end;
      }
      return value;
    };
    Slider2.prototype.reposition = function() {
      var _this = this;
      if (!isNullOrUndefined(this.firstHandle)) {
        this.firstHandle.style.transition = "none";
      }
      if (this.type !== "Default" && !isNullOrUndefined(this.rangeBar)) {
        this.rangeBar.style.transition = "none";
      }
      if (this.type === "Range" && !isNullOrUndefined(this.secondHandle)) {
        this.secondHandle.style.transition = "none";
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      if (this.handleVal2) {
        this.handlePos2 = this.checkHandlePosition(this.handleVal2);
      }
      if (this.orientation === "Horizontal") {
        if (this.enableRtl) {
          this.firstHandle.style.right = this.handlePos1 + "px";
        } else {
          this.firstHandle.style.left = this.handlePos1 + "px";
        }
        if (this.isMaterialTooltip && !isNullOrUndefined(this.materialHandle)) {
          if (this.enableRtl) {
            this.materialHandle.style.right = this.handlePos1 + "px";
          } else {
            this.materialHandle.style.left = this.handlePos1 + "px";
          }
        }
        if (this.type === "MinRange" && !isNullOrUndefined(this.rangeBar)) {
          if (this.enableRtl) {
            this.rangeBar.style.right = "0px";
          } else {
            this.rangeBar.style.left = "0px";
          }
          setStyleAttribute(this.rangeBar, { "width": isNullOrUndefined(this.handlePos1) ? 0 : this.handlePos1 + "px" });
        } else if (this.type === "Range" && !isNullOrUndefined(this.secondHandle) && !isNullOrUndefined(this.rangeBar)) {
          if (this.enableRtl) {
            this.secondHandle.style.right = this.handlePos2 + "px";
            this.rangeBar.style.right = this.handlePos1 + "px";
          } else {
            this.secondHandle.style.left = this.handlePos2 + "px";
            this.rangeBar.style.left = this.handlePos1 + "px";
          }
          setStyleAttribute(this.rangeBar, { "width": this.handlePos2 - this.handlePos1 + "px" });
        }
      } else {
        this.firstHandle.style.bottom = this.handlePos1 + "px";
        if (this.isMaterialTooltip) {
          this.materialHandle.style.bottom = this.handlePos1 + "px";
        }
        if (this.type === "MinRange") {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos1 + "px" : "0px";
          setStyleAttribute(this.rangeBar, { "height": isNullOrUndefined(this.handlePos1) ? 0 : this.min > this.max ? this.element.clientHeight - this.handlePos1 + "px" : this.handlePos1 + "px" });
        } else if (this.type === "Range") {
          this.secondHandle.style.bottom = this.handlePos2 + "px";
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos2 + "px" : this.handlePos1 + "px";
          setStyleAttribute(this.rangeBar, { "height": this.min > this.max ? this.handlePos1 - this.handlePos2 + "px" : this.handlePos2 - this.handlePos1 + "px" });
        }
      }
      if (this.limits.enabled) {
        this.setLimitBar();
      }
      if (this.ticks.placement !== "None" && this.ul) {
        this.removeElement(this.ul);
        this.ul = void 0;
        this.renderScale();
      }
      this.handleStart();
      if (!this.tooltip.isVisible) {
        setTimeout(function() {
          if (!isNullOrUndefined(_this.firstHandle)) {
            _this.firstHandle.style.transition = _this.scaleTransform;
          }
          if (_this.type === "Range" && !isNullOrUndefined(_this.secondHandle)) {
            _this.secondHandle.style.transition = _this.scaleTransform;
          }
        });
      }
      this.refreshTooltip(this.tooltipTarget);
      this.setBarColor();
    };
    Slider2.prototype.changeHandleValue = function(value) {
      var position = null;
      if (this.activeHandle === 1) {
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          this.handleVal1 = this.checkHandleValue(value);
          this.handlePos1 = this.checkHandlePosition(this.handleVal1);
          if (this.type === "Range" && (this.handlePos1 > this.handlePos2 && this.min < this.max || this.handlePos1 < this.handlePos2 && this.min > this.max)) {
            this.handlePos1 = this.handlePos2;
            this.handleVal1 = this.handleVal2;
          }
          if (this.handlePos1 !== this.preHandlePos1) {
            position = this.preHandlePos1 = this.handlePos1;
          }
        }
        this.modifyZindex();
      } else {
        if (!(this.limits.enabled && this.limits.endHandleFixed)) {
          this.handleVal2 = this.checkHandleValue(value);
          this.handlePos2 = this.checkHandlePosition(this.handleVal2);
          if (this.type === "Range" && (this.handlePos2 < this.handlePos1 && this.min < this.max || this.handlePos2 > this.handlePos1 && this.min > this.max)) {
            this.handlePos2 = this.handlePos1;
            this.handleVal2 = this.handleVal1;
          }
          if (this.handlePos2 !== this.preHandlePos2) {
            position = this.preHandlePos2 = this.handlePos2;
          }
        }
        this.modifyZindex();
      }
      if (position !== null) {
        if (this.type !== "Default") {
          this.setRangeBar();
        }
        this.setHandlePosition(null);
      }
    };
    Slider2.prototype.tempStartEnd = function() {
      if (this.min > this.max) {
        return {
          start: this.max,
          end: this.min
        };
      } else {
        return {
          start: this.min,
          end: this.max
        };
      }
    };
    Slider2.prototype.xyToPosition = function(position) {
      var pos;
      if (this.min === this.max) {
        return 100;
      }
      if (this.orientation === "Horizontal") {
        var left = position.x - this.element.getBoundingClientRect().left;
        var num = this.element.offsetWidth / 100;
        this.val = left / num;
      } else {
        var top_1 = position.y - this.element.getBoundingClientRect().top;
        var num = this.element.offsetHeight / 100;
        this.val = 100 - top_1 / num;
      }
      var val = this.stepValueCalculation(this.val);
      if (val < 0) {
        val = 0;
      } else if (val > 100) {
        val = 100;
      }
      if (this.enableRtl && this.orientation !== "Vertical") {
        val = 100 - val;
      }
      if (this.orientation === "Horizontal") {
        pos = this.element.getBoundingClientRect().width * (val / 100);
      } else {
        pos = this.element.getBoundingClientRect().height * (val / 100);
      }
      return pos;
    };
    Slider2.prototype.stepValueCalculation = function(value) {
      if (this.step === 0) {
        this.step = 1;
      }
      var percentStep = parseFloat(formatUnit(this.step)) / ((parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min))) / 100);
      var remain = value % Math.abs(percentStep);
      if (remain !== 0) {
        if (percentStep / 2 > remain) {
          value -= remain;
        } else {
          value += Math.abs(percentStep) - remain;
        }
      }
      return value;
    };
    Slider2.prototype.add = function(a, b, addition) {
      var precision;
      var x = Math.pow(10, precision || 3);
      var val;
      if (addition) {
        val = (Math.round(a * x) + Math.round(b * x)) / x;
      } else {
        val = (Math.round(a * x) - Math.round(b * x)) / x;
      }
      return val;
    };
    Slider2.prototype.positionToValue = function(pos) {
      var val;
      var diff = parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min));
      if (this.orientation === "Horizontal") {
        val = pos / this.element.getBoundingClientRect().width * diff;
      } else {
        val = pos / this.element.getBoundingClientRect().height * diff;
      }
      var total = this.add(val, parseFloat(this.min.toString()), true);
      return total;
    };
    Slider2.prototype.sliderBarClick = function(evt) {
      evt.preventDefault();
      var pos;
      if (evt.type === "mousedown" || evt.type === "mouseup" || evt.type === "click") {
        pos = { x: evt.clientX, y: evt.clientY };
      } else if (evt.type === "touchend" || evt.type === "touchstart") {
        pos = { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
      }
      var handlepos = this.xyToPosition(pos);
      var handleVal = this.positionToValue(handlepos);
      if (this.type === "Range" && (this.min < this.max && this.handlePos2 - handlepos < handlepos - this.handlePos1 || this.min > this.max && this.handlePos1 - handlepos > handlepos - this.handlePos2)) {
        this.activeHandle = 2;
        if (!(this.limits.enabled && this.limits.endHandleFixed)) {
          if (this.limits.enabled) {
            var value = this.getLimitValueAndPosition(handleVal, this.limits.maxStart, this.limits.maxEnd);
            handleVal = value[0];
            handlepos = value[1];
          }
          this.secondHandle.classList.add(classNames2.sliderActiveHandle);
          this.handlePos2 = this.preHandlePos2 = handlepos;
          this.handleVal2 = handleVal;
        }
        this.modifyZindex();
        this.secondHandle.focus();
      } else {
        this.activeHandle = 1;
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          if (this.limits.enabled) {
            var value = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
            handleVal = value[0];
            handlepos = value[1];
          }
          this.firstHandle.classList.add(classNames2.sliderActiveHandle);
          this.handlePos1 = this.preHandlePos1 = handlepos;
          this.handleVal1 = handleVal;
        }
        this.modifyZindex();
        this.firstHandle.focus();
      }
      if (this.isMaterialTooltip) {
        this.tooltipElement.classList.add(classNames2.materialTooltipActive);
      }
      var focusedElement = this.element.querySelector("." + classNames2.sliderTabHandle);
      if (focusedElement && this.getHandle() !== focusedElement) {
        focusedElement.classList.remove(classNames2.sliderTabHandle);
      }
      var handle = this.activeHandle === 1 ? this.firstHandle : this.secondHandle;
      var behindElement;
      if ((evt.type === "click" || evt.type === "mousedown") && evt.target === handle) {
        var eventX = evt.clientX, eventY = evt.clientY;
        behindElement = document.elementFromPoint(eventX, eventY);
      }
      if (evt.target === handle && behindElement !== handle) {
        if ((this.isMaterial || this.isMaterial3) && !this.tooltip.isVisible && !this.getHandle().classList.contains(classNames2.sliderTabHandle)) {
          this.materialChange();
        }
        this.sliderBarUp(evt);
        this.tooltipToggle(this.getHandle());
        return;
      }
      if (!this.checkRepeatedValue(handleVal)) {
        return;
      }
      var transition = (this.isMaterial || this.isMaterial3) && this.tooltip.isVisible ? this.transitionOnMaterialTooltip : this.transition;
      this.getHandle().style.transition = transition.handle;
      if (this.type !== "Default") {
        this.rangeBar.style.transition = transition.rangeBar;
      }
      this.setHandlePosition(evt);
      if (this.isMaterialTooltip) {
        this.initialTooltip = false;
      }
      if (evt.target !== handle) {
        this.changeEvent("changed", evt);
      }
      if (this.type !== "Default") {
        this.setRangeBar();
      }
    };
    Slider2.prototype.handleValueAdjust = function(handleValue, assignValue, handleNumber) {
      if (handleNumber === 1) {
        this.handleVal1 = assignValue;
        this.handleVal2 = this.handleVal1 + this.minDiff;
      } else if (handleNumber === 2) {
        this.handleVal2 = assignValue;
        this.handleVal1 = this.handleVal2 - this.minDiff;
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.handlePos2 = this.checkHandlePosition(this.handleVal2);
    };
    Slider2.prototype.dragRangeBarMove = function(event) {
      var _a, _b;
      if (event.type !== "touchmove") {
        event.preventDefault();
      }
      this.rangeBarDragged = true;
      var pos;
      this.rangeBar.style.transition = "none";
      this.firstHandle.style.transition = "none";
      this.secondHandle.style.transition = "none";
      var xPostion;
      var yPostion;
      if (event.type === "mousemove") {
        _a = [event.clientX, event.clientY], xPostion = _a[0], yPostion = _a[1];
      } else {
        _b = [event.changedTouches[0].clientX, event.changedTouches[0].clientY], xPostion = _b[0], yPostion = _b[1];
      }
      if (!(this.limits.enabled && this.limits.startHandleFixed) && !(this.limits.enabled && this.limits.endHandleFixed)) {
        if (!this.enableRtl) {
          pos = { x: xPostion - this.firstPartRemain, y: yPostion + this.secondPartRemain };
        } else {
          pos = { x: xPostion + this.secondPartRemain, y: yPostion + this.secondPartRemain };
        }
        if (this.min > this.max) {
          this.handlePos2 = this.xyToPosition(pos);
          this.handleVal2 = this.positionToValue(this.handlePos2);
        } else {
          this.handlePos1 = this.xyToPosition(pos);
          this.handleVal1 = this.positionToValue(this.handlePos1);
        }
        if (!this.enableRtl) {
          pos = { x: xPostion + this.secondPartRemain, y: yPostion - this.firstPartRemain };
        } else {
          pos = { x: xPostion - this.firstPartRemain, y: yPostion - this.firstPartRemain };
        }
        if (this.min > this.max) {
          this.handlePos1 = this.xyToPosition(pos);
          this.handleVal1 = this.positionToValue(this.handlePos1);
        } else {
          this.handlePos2 = this.xyToPosition(pos);
          this.handleVal2 = this.positionToValue(this.handlePos2);
        }
        if (this.limits.enabled) {
          var value = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
          this.handleVal1 = value[0];
          this.handlePos1 = value[1];
          if (this.handleVal1 === this.limits.minEnd) {
            this.handleValueAdjust(this.handleVal1, this.limits.minEnd, 1);
          }
          if (this.handleVal1 === this.limits.minStart) {
            this.handleValueAdjust(this.handleVal1, this.limits.minStart, 1);
          }
          value = this.getLimitValueAndPosition(this.handleVal2, this.limits.maxStart, this.limits.maxEnd);
          this.handleVal2 = value[0];
          this.handlePos2 = value[1];
          if (this.handleVal2 === this.limits.maxStart) {
            this.handleValueAdjust(this.handleVal2, this.limits.maxStart, 2);
          }
          if (this.handleVal2 === this.limits.maxEnd) {
            this.handleValueAdjust(this.handleVal2, this.limits.maxEnd, 2);
          }
        }
        if (this.handleVal2 === (this.min > this.max ? this.min : this.max)) {
          this.handleValueAdjust(this.handleVal2, this.min > this.max ? this.min : this.max, 2);
        }
        if (this.handleVal1 === (this.min > this.max ? this.max : this.min)) {
          this.handleValueAdjust(this.handleVal1, this.min > this.max ? this.max : this.min, 1);
        }
      }
      this.activeHandle = 1;
      this.setHandlePosition(event);
      this.activeHandle = 2;
      this.setHandlePosition(event);
      this.tooltipToggle(this.rangeBar);
      this.setRangeBar();
    };
    Slider2.prototype.sliderBarUp = function(event) {
      this.changeEvent("changed", event);
      this.handleFocusOut();
      this.firstHandle.classList.remove(classNames2.sliderActiveHandle);
      if (this.type === "Range") {
        this.initialTooltip = false;
        this.secondHandle.classList.remove(classNames2.sliderActiveHandle);
      }
      this.closeTooltip();
      if (this.isMaterial || this.isMaterial3) {
        this.getHandle().classList.remove("e-large-thumb-size");
        if (this.isMaterialTooltip) {
          this.tooltipElement.classList.remove(classNames2.materialTooltipActive);
        }
      }
      EventHandler.remove(document, "mousemove touchmove", this.sliderBarMove);
      EventHandler.remove(document, "mouseup touchend", this.sliderBarUp);
    };
    Slider2.prototype.sliderBarMove = function(evt) {
      if (evt.type !== "touchmove") {
        evt.preventDefault();
      }
      var pos;
      if (evt.type === "mousemove") {
        pos = { x: evt.clientX, y: evt.clientY };
      } else {
        pos = { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
      }
      var handlepos = this.xyToPosition(pos);
      var handleVal = this.positionToValue(handlepos);
      handlepos = Math.round(handlepos);
      if (this.type !== "Range" && this.activeHandle === 1) {
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          if (this.limits.enabled) {
            var valueAndPostion = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
            handlepos = valueAndPostion[1];
            handleVal = valueAndPostion[0];
          }
          this.handlePos1 = handlepos;
          this.handleVal1 = handleVal;
        }
        this.firstHandle.classList.add(classNames2.sliderActiveHandle);
      }
      if (this.type === "Range") {
        if (this.activeHandle === 1) {
          this.firstHandle.classList.add(classNames2.sliderActiveHandle);
          if (!(this.limits.enabled && this.limits.startHandleFixed)) {
            if (this.min < this.max && handlepos > this.handlePos2 || this.min > this.max && handlepos < this.handlePos2) {
              handlepos = this.handlePos2;
              handleVal = this.handleVal2;
            }
            if (handlepos !== this.preHandlePos1) {
              if (this.limits.enabled) {
                var value = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
                handleVal = value[0];
                handlepos = value[1];
              }
              this.handlePos1 = this.preHandlePos1 = handlepos;
              this.handleVal1 = handleVal;
              this.activeHandle = 1;
            }
          }
        } else if (this.activeHandle === 2) {
          this.secondHandle.classList.add(classNames2.sliderActiveHandle);
          if (!(this.limits.enabled && this.limits.endHandleFixed)) {
            if (this.min < this.max && handlepos < this.handlePos1 || this.min > this.max && handlepos > this.handlePos1) {
              handlepos = this.handlePos1;
              handleVal = this.handleVal1;
            }
            if (handlepos !== this.preHandlePos2) {
              if (this.limits.enabled) {
                var value = this.getLimitValueAndPosition(handleVal, this.limits.maxStart, this.limits.maxEnd);
                handleVal = value[0];
                handlepos = value[1];
              }
              this.handlePos2 = this.preHandlePos2 = handlepos;
              this.handleVal2 = handleVal;
              this.activeHandle = 2;
            }
          }
        }
      }
      if (!this.checkRepeatedValue(handleVal)) {
        return;
      }
      this.getHandle().style.transition = this.scaleTransform;
      if (this.type !== "Default") {
        this.rangeBar.style.transition = "none";
      }
      this.setHandlePosition(evt);
      if ((this.isMaterial || this.isMaterial3) && !this.tooltip.isVisible && !this.getHandle().classList.contains(classNames2.sliderTabHandle)) {
        this.materialChange();
      }
      this.tooltipToggle(this.getHandle());
      if (this.type !== "Default") {
        this.setRangeBar();
      }
    };
    Slider2.prototype.dragRangeBarUp = function(event) {
      if (!this.rangeBarDragged) {
        this.focusSliderElement();
        this.sliderBarClick(event);
      } else {
        this.isDragComplete = true;
      }
      this.changeEvent("changed", event);
      this.closeTooltip();
      EventHandler.remove(document, "mousemove touchmove", this.dragRangeBarMove);
      EventHandler.remove(document, "mouseup touchend", this.dragRangeBarUp);
      this.rangeBarDragged = false;
    };
    Slider2.prototype.checkRepeatedValue = function(currentValue) {
      if (this.type === "Range") {
        var previousVal = this.enableRtl && this.orientation !== "Vertical" ? this.activeHandle === 1 ? this.previousVal[1] : this.previousVal[0] : this.activeHandle === 1 ? this.previousVal[0] : this.previousVal[1];
        if (currentValue === previousVal) {
          return 0;
        }
      } else {
        if (currentValue === this.previousVal) {
          return 0;
        }
      }
      return 1;
    };
    Slider2.prototype.refreshTooltip = function(target) {
      if (this.tooltip.isVisible && this.tooltipObj) {
        this.tooltipValue();
        if (target) {
          this.tooltipObj.refresh(target);
          this.tooltipTarget = target;
        }
      }
    };
    Slider2.prototype.openTooltip = function(target) {
      if (this.tooltip.isVisible && this.tooltipObj && !this.isMaterialTooltip) {
        this.tooltipValue();
        this.tooltipObj.open(target);
        this.tooltipTarget = target;
      }
    };
    Slider2.prototype.closeTooltip = function() {
      if (this.tooltip.isVisible && this.tooltipObj && this.tooltip.showOn !== "Always" && !this.isMaterialTooltip) {
        this.tooltipValue();
        this.tooltipObj.close();
        this.tooltipTarget = void 0;
      }
    };
    Slider2.prototype.keyDown = function(event) {
      switch (event.keyCode) {
        case 37:
        case 38:
        case 39:
        case 40:
        case 33:
        case 34:
        case 36:
        case 35:
          event.preventDefault();
          this.buttonClick(event);
          break;
      }
    };
    Slider2.prototype.wireButtonEvt = function(destroy3) {
      if (!destroy3) {
        EventHandler.add(this.firstBtn, "mouseleave touchleave", this.buttonFocusOut, this);
        EventHandler.add(this.secondBtn, "mouseleave touchleave", this.buttonFocusOut, this);
        EventHandler.add(this.firstBtn, "mousedown touchstart", this.repeatHandlerMouse, this);
        EventHandler.add(this.firstBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp, this);
        EventHandler.add(this.secondBtn, "mousedown touchstart", this.repeatHandlerMouse, this);
        EventHandler.add(this.secondBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp, this);
        EventHandler.add(this.firstBtn, "focusout", this.sliderFocusOut, this);
        EventHandler.add(this.secondBtn, "focusout", this.sliderFocusOut, this);
      } else {
        EventHandler.remove(this.firstBtn, "mouseleave touchleave", this.buttonFocusOut);
        EventHandler.remove(this.secondBtn, "mouseleave touchleave", this.buttonFocusOut);
        EventHandler.remove(this.firstBtn, "mousedown touchstart", this.repeatHandlerMouse);
        EventHandler.remove(this.firstBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp);
        EventHandler.remove(this.secondBtn, "mousedown touchstart", this.repeatHandlerMouse);
        EventHandler.remove(this.secondBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp);
        EventHandler.remove(this.firstBtn, "focusout", this.sliderFocusOut);
        EventHandler.remove(this.secondBtn, "focusout", this.sliderFocusOut);
      }
    };
    Slider2.prototype.rangeBarMousedown = function(event) {
      var _a, _b;
      event.preventDefault();
      this.focusSliderElement();
      if (this.type === "Range" && this.drag && event.target === this.rangeBar) {
        var xPostion = void 0;
        var yPostion = void 0;
        if (event.type === "mousedown") {
          _a = [event.clientX, event.clientY], xPostion = _a[0], yPostion = _a[1];
        } else if (event.type === "touchstart") {
          _b = [event.changedTouches[0].clientX, event.changedTouches[0].clientY], xPostion = _b[0], yPostion = _b[1];
        }
        if (this.orientation === "Horizontal") {
          this.firstPartRemain = xPostion - this.rangeBar.getBoundingClientRect().left;
          this.secondPartRemain = this.rangeBar.getBoundingClientRect().right - xPostion;
        } else {
          this.firstPartRemain = yPostion - this.rangeBar.getBoundingClientRect().top;
          this.secondPartRemain = this.rangeBar.getBoundingClientRect().bottom - yPostion;
        }
        this.minDiff = this.handleVal2 - this.handleVal1;
        this.tooltipToggle(this.rangeBar);
        var focusedElement = this.element.querySelector("." + classNames2.sliderTabHandle);
        if (focusedElement) {
          focusedElement.classList.remove(classNames2.sliderTabHandle);
        }
        EventHandler.add(document, "mousemove touchmove", this.dragRangeBarMove, this);
        EventHandler.add(document, "mouseup touchend", this.dragRangeBarUp, this);
      }
    };
    Slider2.prototype.elementClick = function(event) {
      if (this.isDragComplete) {
        this.isDragComplete = false;
        return;
      }
      event.preventDefault();
      this.focusSliderElement();
      this.sliderBarClick(event);
      this.focusHandle();
    };
    Slider2.prototype.wireEvents = function() {
      this.onresize = this.reposition.bind(this);
      window.addEventListener("resize", this.onresize);
      if (this.enabled && !this.readonly) {
        EventHandler.add(this.element, "click", this.elementClick, this);
        if (this.type === "Range" && this.drag) {
          EventHandler.add(this.rangeBar, "mousedown touchstart", this.rangeBarMousedown, this);
        }
        EventHandler.add(this.sliderContainer, "keydown", this.keyDown, this);
        EventHandler.add(this.sliderContainer, "keyup", this.keyUp, this);
        EventHandler.add(this.element, "focusout", this.sliderFocusOut, this);
        EventHandler.add(this.sliderContainer, "mouseover mouseout touchstart touchend", this.hover, this);
        this.wireFirstHandleEvt(false);
        if (this.type === "Range") {
          this.wireSecondHandleEvt(false);
        }
        if (this.showButtons) {
          this.wireButtonEvt(false);
        }
        this.wireMaterialTooltipEvent(false);
        if (this.isForm) {
          EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
        }
      }
    };
    Slider2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "click", this.elementClick);
      if (this.type === "Range" && this.drag) {
        EventHandler.remove(this.rangeBar, "mousedown touchstart", this.rangeBarMousedown);
      }
      EventHandler.remove(this.sliderContainer, "keydown", this.keyDown);
      EventHandler.remove(this.sliderContainer, "keyup", this.keyUp);
      EventHandler.remove(this.element, "focusout", this.sliderFocusOut);
      EventHandler.remove(this.sliderContainer, "mouseover mouseout touchstart touchend", this.hover);
      this.wireFirstHandleEvt(true);
      if (this.type === "Range") {
        this.wireSecondHandleEvt(true);
      }
      if (this.showButtons) {
        this.wireButtonEvt(true);
      }
      this.wireMaterialTooltipEvent(true);
      EventHandler.remove(this.element, "reset", this.formResetHandler);
    };
    Slider2.prototype.formResetHandler = function() {
      this.setProperties({ "value": this.formResetValue }, true);
      this.setValue();
    };
    Slider2.prototype.keyUp = function(event) {
      if (event.keyCode === 9 && event.target.classList.contains(classNames2.sliderHandle)) {
        this.focusSliderElement();
        if (!event.target.classList.contains(classNames2.sliderTabHandle)) {
          if (this.element.querySelector("." + classNames2.sliderTabHandle)) {
            this.element.querySelector("." + classNames2.sliderTabHandle).classList.remove(classNames2.sliderTabHandle);
          }
          event.target.classList.add(classNames2.sliderTabHandle);
          var parentElement = event.target.parentElement;
          if (parentElement === this.element) {
            parentElement.querySelector("." + classNames2.sliderTrack).classList.add(classNames2.sliderTabTrack);
            if (this.type === "Range" || this.type === "MinRange") {
              parentElement.querySelector("." + classNames2.rangeBar).classList.add(classNames2.sliderTabRange);
            }
          }
          if (this.type === "Range") {
            var previousSibling = event.target.previousSibling;
            if (previousSibling && previousSibling.classList.contains(classNames2.sliderHandle)) {
              this.activeHandle = 2;
            } else {
              this.activeHandle = 1;
            }
          }
          this.getHandle().focus();
          this.tooltipToggle(this.getHandle());
        }
      }
      this.closeTooltip();
      this.changeEvent("changed", event);
    };
    Slider2.prototype.hover = function(event) {
      if (!isNullOrUndefined(event)) {
        if (event.type === "mouseover" || event.type === "touchmove" || event.type === "mousemove" || event.type === "pointermove" || event.type === "touchstart") {
          this.sliderContainer.classList.add(classNames2.sliderHover);
        } else {
          this.sliderContainer.classList.remove(classNames2.sliderHover);
          var curTarget = event.currentTarget;
          if (this.tooltip.isVisible && this.tooltip.showOn !== "Always" && this.tooltipObj && this.isMaterialTooltip && !curTarget.classList.contains(classNames2.sliderHandleFocused) && !curTarget.classList.contains(classNames2.sliderTabHandle)) {
            this.closeMaterialTooltip();
          }
        }
      }
    };
    Slider2.prototype.sliderFocusOut = function(event) {
      if (event.relatedTarget !== this.secondHandle && event.relatedTarget !== this.firstHandle && event.relatedTarget !== this.element && event.relatedTarget !== this.firstBtn && event.relatedTarget !== this.secondBtn) {
        this.closeMaterialTooltip();
        this.closeTooltip();
        if (this.element.querySelector("." + classNames2.sliderTabHandle)) {
          this.element.querySelector("." + classNames2.sliderTabHandle).classList.remove(classNames2.sliderTabHandle);
        }
        if (this.element.querySelector("." + classNames2.sliderTabTrack)) {
          this.element.querySelector("." + classNames2.sliderTabTrack).classList.remove(classNames2.sliderTabTrack);
          if ((this.type === "Range" || this.type === "MinRange") && this.element.querySelector("." + classNames2.sliderTabRange)) {
            this.element.querySelector("." + classNames2.sliderTabRange).classList.remove(classNames2.sliderTabRange);
          }
        }
        this.hiddenInput.focus();
        this.hiddenInput.blur();
        this.isElementFocused = false;
      }
    };
    Slider2.prototype.removeElement = function(element2) {
      if (element2.parentNode) {
        element2.parentNode.removeChild(element2);
      }
    };
    Slider2.prototype.changeSliderType = function(type, args) {
      if (this.isMaterialTooltip && this.materialHandle) {
        this.sliderContainer.classList.remove(classNames2.materialSlider);
        this.removeElement(this.materialHandle);
        this.materialHandle = void 0;
      }
      this.removeElement(this.firstHandle);
      this.firstHandle = void 0;
      if (type !== "Default") {
        if (type === "Range") {
          this.removeElement(this.secondHandle);
          this.secondHandle = void 0;
        }
        this.removeElement(this.rangeBar);
        this.rangeBar = void 0;
      }
      if (this.tooltip.isVisible && !isNullOrUndefined(this.tooltipObj)) {
        this.tooltipObj.destroy();
        this.tooltipElement = void 0;
        this.tooltipCollidedPosition = void 0;
      }
      if (this.limits.enabled) {
        if (type === "MinRange" || type === "Default") {
          if (!isNullOrUndefined(this.limitBarFirst)) {
            this.removeElement(this.limitBarFirst);
            this.limitBarFirst = void 0;
          }
        } else {
          if (!isNullOrUndefined(this.limitBarSecond)) {
            this.removeElement(this.limitBarSecond);
            this.limitBarSecond = void 0;
          }
        }
      }
      this.activeHandle = 1;
      this.getThemeInitialization();
      if (this.type === "Range") {
        this.rangeValueUpdate();
      }
      this.createRangeBar();
      if (this.limits.enabled) {
        this.createLimitBar();
      }
      this.setHandler();
      this.setOrientClass();
      this.wireFirstHandleEvt(false);
      if (this.type === "Range") {
        this.wireSecondHandleEvt(false);
      }
      this.setValue();
      if (this.tooltip.isVisible) {
        this.renderTooltip();
        this.wireMaterialTooltipEvent(false);
      }
      this.setBarColor();
      if (args !== "tooltip") {
        this.updateConfig();
      }
      if (this.readonly) {
        this.sliderContainer.classList.remove(classNames2.readonly);
        this.setReadOnly();
      }
    };
    Slider2.prototype.changeRtl = function() {
      if (!this.enableRtl && this.type === "Range") {
        this.value = [this.handleVal2, this.handleVal1];
      }
      this.updateConfig();
      if (this.tooltip.isVisible) {
        this.tooltipObj.refresh(this.firstHandle);
      }
      if (this.showButtons) {
        var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
        attributes(enabledRTL ? this.secondBtn : this.firstBtn, { "aria-label": "Decrease", title: "Decrease" });
        attributes(enabledRTL ? this.firstBtn : this.secondBtn, { "aria-label": "Increase", title: "Increase" });
      }
    };
    Slider2.prototype.changeOrientation = function() {
      this.changeSliderType(this.type, "null");
    };
    Slider2.prototype.updateConfig = function() {
      this.setEnableRTL();
      this.setValue();
      if (this.tooltip.isVisible) {
        this.refreshTooltip(this.tooltipTarget);
      }
      if (this.ticks.placement !== "None") {
        if (this.ul) {
          this.removeElement(this.ul);
          this.ul = void 0;
          this.renderScale();
        }
      }
      this.limitsPropertyChange();
    };
    Slider2.prototype.limitsPropertyChange = function() {
      if (this.limits.enabled) {
        if (isNullOrUndefined(this.limitBarFirst) && this.type !== "Range") {
          this.createLimitBar();
        }
        if (isNullOrUndefined(this.limitBarFirst) && isNullOrUndefined(this.limitBarSecond) && this.type === "Range") {
          this.createLimitBar();
        }
        this.setLimitBar();
        this.setValue();
      } else {
        if (!isNullOrUndefined(this.limitBarFirst)) {
          detach(this.limitBarFirst);
        }
        if (!isNullOrUndefined(this.limitBarSecond)) {
          detach(this.limitBarSecond);
        }
      }
    };
    Slider2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    Slider2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unwireEvents();
      window.removeEventListener("resize", this.onresize);
      removeClass([this.sliderContainer], [classNames2.sliderDisabled]);
      this.firstHandle.removeAttribute("aria-orientation");
      if (this.type === "Range") {
        this.secondHandle.removeAttribute("aria-orientation");
      }
      if (this.sliderContainer.parentNode) {
        this.sliderContainer.parentNode.insertBefore(this.element, this.sliderContainer);
      }
      detach(this.sliderContainer);
      if (this.tooltip.isVisible) {
        this.tooltipObj.destroy();
      }
      this.element.innerHTML = "";
      this.hiddenInput = null;
      this.sliderContainer = null;
      this.sliderTrack = null;
      this.rangeBar = null;
      this.firstHandle = null;
      this.secondHandle = null;
      this.tickElementCollection = null;
      this.ul = null;
      this.firstBtn = null;
      this.secondBtn = null;
      this.materialHandle = null;
      this.tooltipObj = null;
      this.tooltipTarget = null;
      this.limitBarFirst = null;
      this.limitBarSecond = null;
      this.firstChild = null;
      this.lastChild = null;
      this.tooltipElement = null;
    };
    Slider2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
          case "value":
            if (newProp && oldProp) {
              var value = isNullOrUndefined(newProp.value) ? this.type === "Range" ? [this.min, this.max] : this.min : newProp.value;
              this.setProperties({ "value": value }, true);
              if (!isNullOrUndefined(oldProp.value) && oldProp.value.toString() !== value.toString()) {
                this.setValue();
                this.refreshTooltip(this.tooltipTarget);
                if (this.type === "Range") {
                  if (isNullOrUndefined(newProp.value) || oldProp.value[1] === value[1]) {
                    this.activeHandle = 1;
                  } else {
                    this.activeHandle = 2;
                  }
                }
              }
            }
            break;
          case "min":
          case "step":
          case "max":
            this.setMinMaxValue();
            break;
          case "tooltip":
            if (!isNullOrUndefined(newProp.tooltip) && !isNullOrUndefined(oldProp.tooltip)) {
              this.initialTooltip = true;
              this.setTooltip(prop);
              if (!this.showButtons) {
                this.wireEvents();
              }
            }
            break;
          case "type":
            if (!isNullOrUndefined(oldProp) && Object.keys(oldProp).length && !isNullOrUndefined(oldProp.type)) {
              this.changeSliderType(oldProp.type, prop);
              this.setZindex();
            }
            break;
          case "enableRtl":
            if (oldProp.enableRtl !== newProp.enableRtl && this.orientation !== "Vertical") {
              this.rtl = oldProp.enableRtl;
              this.changeRtl();
            }
            break;
          case "limits":
            this.limitsPropertyChange();
            break;
          case "orientation":
            this.changeOrientation();
            break;
          case "ticks":
            if (!isNullOrUndefined(this.sliderContainer.querySelector("." + classNames2.scale))) {
              detach(this.ul);
              Array.prototype.forEach.call(this.sliderContainer.classList, function(className) {
                if (className.match(/e-scale-/)) {
                  _this.sliderContainer.classList.remove(className);
                }
              });
            }
            if (this.ticks.placement !== "None") {
              this.renderScale();
              this.setZindex();
            }
            break;
          case "locale":
            if (this.showButtons) {
              this.buttonTitle();
            }
            break;
          case "showButtons":
            if (newProp.showButtons) {
              this.setButtons();
              this.reposition();
              if (this.enabled && !this.readonly) {
                this.wireButtonEvt(false);
              }
            } else {
              if (this.firstBtn && this.secondBtn) {
                this.sliderContainer.removeChild(this.firstBtn);
                this.sliderContainer.removeChild(this.secondBtn);
                this.sliderContainer.classList.remove(classNames2.sliderButtonClass);
                this.firstBtn = void 0;
                this.secondBtn = void 0;
                this.reposition();
              }
            }
            break;
          case "enabled":
            this.setEnabled();
            break;
          case "readonly":
            this.setReadOnly();
            break;
          case "customValues":
            this.setValue();
            this.reposition();
            break;
          case "colorRange":
            this.reposition();
            break;
          case "width":
            this.setElementWidth(newProp.width);
            this.setMinMaxValue();
            if (this.limits) {
              this.limitsPropertyChange();
            }
            break;
        }
      }
    };
    Slider2.prototype.setReadOnly = function() {
      if (this.readonly) {
        this.unwireEvents();
        this.sliderContainer.classList.add(classNames2.readonly);
      } else {
        this.wireEvents();
        this.sliderContainer.classList.remove(classNames2.readonly);
      }
    };
    Slider2.prototype.setMinMaxValue = function() {
      var _this = this;
      this.setValue();
      this.refreshTooltip(this.tooltipTarget);
      if (!isNullOrUndefined(this.sliderContainer.querySelector("." + classNames2.scale))) {
        if (this.ul) {
          detach(this.ul);
          Array.prototype.forEach.call(this.sliderContainer.classList, function(className) {
            if (className.match(/e-scale-/)) {
              _this.sliderContainer.classList.remove(className);
            }
          });
        }
      }
      if (this.ticks.placement !== "None") {
        this.renderScale();
        this.setZindex();
      }
    };
    Slider2.prototype.setZindex = function() {
      this.zIndex = 6;
      if (!isNullOrUndefined(this.ticks) && this.ticks.placement !== "None" && !isNullOrUndefined(this.ul) && !isNullOrUndefined(this.element)) {
        this.ul.style.zIndex = this.zIndex + -7 + "";
        this.element.style.zIndex = this.zIndex + 2 + "";
      }
      if (!this.isMaterial && !this.isMaterial3 && !isNullOrUndefined(this.ticks) && this.ticks.placement === "Both") {
        this.element.style.zIndex = this.zIndex + 2 + "";
      }
      if (!isNullOrUndefined(this.firstHandle)) {
        this.firstHandle.style.zIndex = this.zIndex + 3 + "";
      }
      if (this.type === "Range" && !isNullOrUndefined(this.secondHandle)) {
        this.secondHandle.style.zIndex = this.zIndex + 4 + "";
      }
    };
    Slider2.prototype.setTooltip = function(args) {
      this.changeSliderType(this.type, args);
    };
    Slider2.prototype.setBarColor = function() {
      var trackPosition;
      var trackClassName;
      var child = this.sliderTrack.lastElementChild;
      while (child) {
        this.sliderTrack.removeChild(child);
        child = this.sliderTrack.lastElementChild;
      }
      for (var i = 0; i < this.colorRange.length; i++) {
        if (!isNullOrUndefined(this.colorRange[i].start) && !isNullOrUndefined(this.colorRange[i].end)) {
          if (this.colorRange[i].end > this.colorRange[i].start) {
            if (this.colorRange[i].start < this.min) {
              this.colorRange[i].start = this.min;
            }
            if (this.colorRange[i].end > this.max) {
              this.colorRange[i].end = this.max;
            }
            var startingPosition = this.checkHandlePosition(this.colorRange[i].start);
            var endPosition = this.checkHandlePosition(this.colorRange[i].end);
            var trackContainer = this.createElement("div");
            trackContainer.style.backgroundColor = this.colorRange[i].color;
            trackContainer.style.border = "1px solid " + this.colorRange[i].color;
            if (this.orientation === "Horizontal") {
              trackClassName = classNames2.sliderHorizantalColor;
              if (this.enableRtl) {
                if (isNullOrUndefined(this.customValues)) {
                  trackPosition = this.checkHandlePosition(this.max) - this.checkHandlePosition(this.colorRange[i].end);
                } else {
                  trackPosition = this.checkHandlePosition(this.customValues.length - this.colorRange[i].end - 1);
                }
              } else {
                trackPosition = this.checkHandlePosition(this.colorRange[i].start);
              }
              trackContainer.style.width = endPosition - startingPosition + "px";
              trackContainer.style.left = trackPosition + "px";
            } else {
              trackClassName = classNames2.sliderVerticalColor;
              trackPosition = this.checkHandlePosition(this.colorRange[i].start);
              trackContainer.style.height = endPosition - startingPosition + "px";
              trackContainer.style.bottom = trackPosition + "px";
            }
            trackContainer.classList.add(trackClassName);
            this.sliderTrack.appendChild(trackContainer);
          }
        }
      }
    };
    Slider2.prototype.getModuleName = function() {
      return "slider";
    };
    __decorate14([
      Property(null)
    ], Slider2.prototype, "value", void 0);
    __decorate14([
      Property(null)
    ], Slider2.prototype, "customValues", void 0);
    __decorate14([
      Property(1)
    ], Slider2.prototype, "step", void 0);
    __decorate14([
      Property(null)
    ], Slider2.prototype, "width", void 0);
    __decorate14([
      Property(0)
    ], Slider2.prototype, "min", void 0);
    __decorate14([
      Property(100)
    ], Slider2.prototype, "max", void 0);
    __decorate14([
      Property(false)
    ], Slider2.prototype, "readonly", void 0);
    __decorate14([
      Property("Default")
    ], Slider2.prototype, "type", void 0);
    __decorate14([
      Collection([{}], ColorRangeData)
    ], Slider2.prototype, "colorRange", void 0);
    __decorate14([
      Complex({}, TicksData)
    ], Slider2.prototype, "ticks", void 0);
    __decorate14([
      Complex({}, LimitData)
    ], Slider2.prototype, "limits", void 0);
    __decorate14([
      Property(true)
    ], Slider2.prototype, "enabled", void 0);
    __decorate14([
      Complex({}, TooltipData)
    ], Slider2.prototype, "tooltip", void 0);
    __decorate14([
      Property(false)
    ], Slider2.prototype, "showButtons", void 0);
    __decorate14([
      Property(true)
    ], Slider2.prototype, "enableAnimation", void 0);
    __decorate14([
      Property("Horizontal")
    ], Slider2.prototype, "orientation", void 0);
    __decorate14([
      Property("")
    ], Slider2.prototype, "cssClass", void 0);
    __decorate14([
      Property(true)
    ], Slider2.prototype, "enableHtmlSanitizer", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "created", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "change", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "changed", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "renderingTicks", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "renderedTicks", void 0);
    __decorate14([
      Event()
    ], Slider2.prototype, "tooltipChange", void 0);
    Slider2 = __decorate14([
      NotifyPropertyChanges
    ], Slider2);
    return Slider2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/form-validator/form-validator.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var regex = {
  /* eslint-disable no-useless-escape */
  EMAIL: new RegExp("^[A-Za-z0-9._%+-]{1,}@[A-Za-z0-9._%+-]{1,}([.]{1}[a-zA-Z0-9]{2,}|[.]{1}[a-zA-Z0-9]{2,4}[.]{1}[a-zA-Z0-9]{2,4})$"),
  /* eslint-disable-next-line security/detect-unsafe-regex */
  URL: /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/m,
  DATE_ISO: new RegExp("^([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$"),
  DIGITS: new RegExp("^[0-9]*$"),
  PHONE: new RegExp("^[+]?[0-9]{9,13}$"),
  CREDITCARD: new RegExp("^\\d{13,16}$")
  /* eslint-enable no-useless-escape */
};
var ErrorOption;
(function(ErrorOption2) {
  ErrorOption2[ErrorOption2["Message"] = 0] = "Message";
  ErrorOption2[ErrorOption2["Label"] = 1] = "Label";
})(ErrorOption || (ErrorOption = {}));
var FormValidator = (
  /** @class */
  function(_super) {
    __extends14(FormValidator2, _super);
    function FormValidator2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.validated = [];
      _this.errorRules = [];
      _this.allowSubmit = false;
      _this.required = "required";
      _this.infoElement = null;
      _this.inputElement = null;
      _this.selectQuery = "input:not([type=reset]):not([type=button]), select, textarea";
      _this.localyMessage = {};
      _this.defaultMessages = {
        required: "This field is required.",
        email: "Please enter a valid email address.",
        url: "Please enter a valid URL.",
        date: "Please enter a valid date.",
        dateIso: "Please enter a valid date ( ISO ).",
        creditcard: "Please enter valid card number",
        number: "Please enter a valid number.",
        digits: "Please enter only digits.",
        maxLength: "Please enter no more than {0} characters.",
        minLength: "Please enter at least {0} characters.",
        rangeLength: "Please enter a value between {0} and {1} characters long.",
        range: "Please enter a value between {0} and {1}.",
        max: "Please enter a value less than or equal to {0}.",
        min: "Please enter a value greater than or equal to {0}.",
        regex: "Please enter a correct value.",
        tel: "Please enter a valid phone number.",
        pattern: "Please enter a correct pattern value.",
        equalTo: "Please enter the valid match text"
      };
      if (typeof _this.rules === "undefined") {
        _this.rules = {};
      }
      _this.l10n = new L10n("formValidator", _this.defaultMessages, _this.locale);
      if (_this.locale) {
        _this.localeFunc();
      }
      onIntlChange.on("notifyExternalChange", _this.afterLocalization, _this);
      element2 = typeof element2 === "string" ? select(element2, document) : element2;
      if (_this.element != null) {
        _this.element.setAttribute("novalidate", "");
        _this.inputElements = selectAll(_this.selectQuery, _this.element);
        _this.createHTML5Rules();
        _this.wireEvents();
      } else {
        return void 0;
      }
      return _this;
    }
    FormValidator_1 = FormValidator2;
    FormValidator2.prototype.addRules = function(name, rules) {
      if (name) {
        if (this.rules.hasOwnProperty(name)) {
          extend(this.rules["" + name], rules, {});
        } else {
          this.rules["" + name] = rules;
        }
      }
    };
    FormValidator2.prototype.removeRules = function(name, rules) {
      if (!name && !rules) {
        this.rules = {};
      } else if (this.rules["" + name] && !rules) {
        delete this.rules["" + name];
      } else if (!isNullOrUndefined(this.rules["" + name] && rules)) {
        for (var i = 0; i < rules.length; i++) {
          delete this.rules["" + name][rules[parseInt(i.toString(), 10)]];
        }
      } else {
        return;
      }
    };
    FormValidator2.prototype.validate = function(selected) {
      var rules = Object.keys(this.rules);
      if (selected && rules.length) {
        this.validateRules(selected);
        return rules.indexOf(selected) !== -1 && this.errorRules.filter(function(data) {
          return data.name === selected;
        }).length === 0;
      } else {
        this.errorRules = [];
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
          var name_1 = rules_1[_i];
          this.validateRules(name_1);
        }
        return this.errorRules.length === 0;
      }
    };
    FormValidator2.prototype.reset = function() {
      this.element.reset();
      this.clearForm();
    };
    FormValidator2.prototype.getInputElement = function(name) {
      this.inputElement = select('[name="' + name + '"]', this.element);
      return this.inputElement;
    };
    FormValidator2.prototype.destroy = function() {
      this.reset();
      this.unwireEvents();
      this.rules = {};
      var elements = selectAll("." + this.errorClass + ", ." + this.validClass, this.element);
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element2 = elements_1[_i];
        detach(element2);
      }
      _super.prototype.destroy.call(this);
      this.infoElement = null;
      onIntlChange.off("notifyExternalChange", this.afterLocalization);
    };
    FormValidator2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "locale":
            this.localeFunc();
            break;
        }
      }
    };
    FormValidator2.prototype.localeFunc = function() {
      for (var _i = 0, _a = Object.keys(this.defaultMessages); _i < _a.length; _i++) {
        var key = _a[_i];
        this.l10n.setLocale(this.locale);
        var value = this.l10n.getConstant(key);
        this.localyMessage["" + key] = value;
      }
    };
    FormValidator2.prototype.getModuleName = function() {
      return "formvalidator";
    };
    FormValidator2.prototype.afterLocalization = function(args) {
      this.locale = args.locale;
      this.localeFunc();
    };
    FormValidator2.prototype.refresh = function() {
      this.unwireEvents();
      this.inputElements = selectAll(this.selectQuery, this.element);
      this.wireEvents();
    };
    FormValidator2.prototype.clearForm = function() {
      this.errorRules = [];
      this.validated = [];
      var elements = selectAll(this.selectQuery, this.element);
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element2 = elements_2[_i];
        var input = element2;
        input.removeAttribute("aria-invalid");
        var inputParent = input.parentElement;
        var grandParent = inputParent.parentElement;
        if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper") || input.classList.contains("e-input") && inputParent.classList.contains("e-input-group")) {
          inputParent.classList.remove(this.errorClass);
        } else if (grandParent != null && (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper"))) {
          grandParent.classList.remove(this.errorClass);
        } else {
          input.classList.remove(this.errorClass);
        }
        if (input.name.length > 0) {
          this.getInputElement(input.name);
          this.getErrorElement(input.name);
          this.hideMessage(input.name);
        }
        if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper") || input.classList.contains("e-input") && inputParent.classList.contains("e-input-group")) {
          inputParent.classList.remove(this.validClass);
        } else if (grandParent != null && (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper"))) {
          grandParent.classList.remove(this.validClass);
        } else {
          input.classList.remove(this.validClass);
        }
      }
    };
    FormValidator2.prototype.createHTML5Rules = function() {
      var defRules = [
        "required",
        "validateHidden",
        "regex",
        "rangeLength",
        "maxLength",
        "minLength",
        "dateIso",
        "digits",
        "pattern",
        "data-val-required",
        "type",
        "data-validation",
        "min",
        "max",
        "range",
        "equalTo",
        "data-val-minlength-min",
        "data-val-equalto-other",
        "data-val-maxlength-max",
        "data-val-range-min",
        "data-val-regex-pattern",
        "data-val-length-max",
        "data-val-creditcard",
        "data-val-phone"
      ];
      var acceptedTypes = ["hidden", "email", "url", "date", "number", "tel"];
      for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
        var input = _a[_i];
        var allRule = {};
        for (var _b = 0, defRules_1 = defRules; _b < defRules_1.length; _b++) {
          var rule = defRules_1[_b];
          if (input.getAttribute(rule) !== null) {
            switch (rule) {
              case "required":
                this.defRule(input, allRule, rule, input.required);
                break;
              case "data-validation":
                rule = input.getAttribute(rule);
                this.defRule(input, allRule, rule, true);
                break;
              case "type":
                if (acceptedTypes.indexOf(input.type) !== -1) {
                  this.defRule(input, allRule, input.type, true);
                }
                break;
              case "rangeLength":
              case "range":
                this.defRule(input, allRule, rule, JSON.parse(input.getAttribute(rule)));
                break;
              case "equalTo":
                {
                  var id = input.getAttribute(rule);
                  this.defRule(input, allRule, rule, id);
                }
                break;
              default:
                if (input.getAttribute("data-val") === "true") {
                  this.annotationRule(input, allRule, rule, input.getAttribute(rule));
                } else {
                  this.defRule(input, allRule, rule, input.getAttribute(rule));
                }
            }
          }
        }
        if (Object.keys(allRule).length !== 0) {
          this.addRules(input.name, allRule);
        }
      }
    };
    FormValidator2.prototype.annotationRule = function(input, ruleCon, ruleName, value) {
      var annotationRule = ruleName.split("-");
      var rulesList = ["required", "creditcard", "phone", "maxlength", "minlength", "range", "regex", "equalto"];
      var ruleFirstName = annotationRule[annotationRule.length - 1];
      var ruleSecondName = annotationRule[annotationRule.length - 2];
      if (rulesList.indexOf(ruleFirstName) !== -1) {
        switch (ruleFirstName) {
          case "required":
            this.defRule(input, ruleCon, "required", value);
            break;
          case "creditcard":
            this.defRule(input, ruleCon, "creditcard", value);
            break;
          case "phone":
            this.defRule(input, ruleCon, "tel", value);
            break;
        }
      } else if (rulesList.indexOf(ruleSecondName) !== -1) {
        switch (ruleSecondName) {
          case "maxlength":
            this.defRule(input, ruleCon, "maxLength", value);
            break;
          case "minlength":
            this.defRule(input, ruleCon, "minLength", value);
            break;
          case "range":
            {
              var minvalue = input.getAttribute("data-val-range-min");
              var maxvalue = input.getAttribute("data-val-range-max");
              this.defRule(input, ruleCon, "range", [minvalue, maxvalue]);
            }
            break;
          case "equalto":
            {
              var id = input.getAttribute(ruleName).split(".");
              this.defRule(input, ruleCon, "equalTo", id[id.length - 1]);
            }
            break;
          case "regex":
            this.defRule(input, ruleCon, "regex", value);
            break;
        }
      }
    };
    FormValidator2.prototype.defRule = function(input, ruleCon, ruleName, value) {
      var message = input.getAttribute("data-" + ruleName + "-message");
      var annotationMessage = input.getAttribute("data-val-" + ruleName);
      var customMessage;
      if (this.rules[input.name] && ruleName !== "validateHidden" && ruleName !== "hidden") {
        this.getInputElement(input.name);
        customMessage = this.getErrorMessage(this.rules[input.name]["" + ruleName], ruleName);
      }
      if (message) {
        value = [value, message];
      } else if (annotationMessage) {
        value = [value, annotationMessage];
      } else if (customMessage) {
        value = [value, customMessage];
      }
      ruleCon["" + ruleName] = value;
    };
    FormValidator2.prototype.wireEvents = function() {
      for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
        var input = _a[_i];
        if (FormValidator_1.isCheckable(input)) {
          EventHandler.add(input, "click", this.clickHandler, this);
        } else if (input.tagName === "SELECT") {
          EventHandler.add(input, "change", this.changeHandler, this);
        } else {
          EventHandler.add(input, "focusout", this.focusOutHandler, this);
          EventHandler.add(input, "keyup", this.keyUpHandler, this);
        }
      }
      EventHandler.add(this.element, "submit", this.submitHandler, this);
      EventHandler.add(this.element, "reset", this.resetHandler, this);
    };
    FormValidator2.prototype.unwireEvents = function() {
      for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
        var input = _a[_i];
        EventHandler.clearEvents(input);
      }
      EventHandler.remove(this.element, "submit", this.submitHandler);
      EventHandler.remove(this.element, "reset", this.resetHandler);
    };
    FormValidator2.prototype.focusOutHandler = function(e) {
      this.trigger("focusout", e);
      var element2 = e.target;
      if (this.rules[element2.name]) {
        if (this.rules[element2.name][this.required] || element2.value.length > 0) {
          this.validate(element2.name);
        } else if (this.validated.indexOf(element2.name) === -1) {
          this.validated.push(element2.name);
        }
      }
    };
    FormValidator2.prototype.keyUpHandler = function(e) {
      this.trigger("keyup", e);
      var element2 = e.target;
      var excludeKeys = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
      if (e.which === 9 && (!this.rules[element2.name] || this.rules[element2.name] && !this.rules[element2.name][this.required])) {
        return;
      }
      if (this.validated.indexOf(element2.name) !== -1 && this.rules[element2.name] && excludeKeys.indexOf(e.which) === -1) {
        this.validate(element2.name);
      }
    };
    FormValidator2.prototype.clickHandler = function(e) {
      this.trigger("click", e);
      var element2 = e.target;
      if (element2.type !== "submit") {
        this.validate(element2.name);
      } else if (element2.getAttribute("formnovalidate") !== null) {
        this.allowSubmit = true;
      }
    };
    FormValidator2.prototype.changeHandler = function(e) {
      this.trigger("change", e);
      var element2 = e.target;
      this.validate(element2.name);
    };
    FormValidator2.prototype.submitHandler = function(e) {
      this.trigger("submit", e);
      if (!this.allowSubmit && !this.validate()) {
        e.preventDefault();
      } else {
        this.allowSubmit = false;
      }
    };
    FormValidator2.prototype.resetHandler = function() {
      this.clearForm();
    };
    FormValidator2.prototype.validateRules = function(name) {
      if (!this.rules["" + name]) {
        return;
      }
      var rules = Object.keys(this.rules["" + name]);
      var hiddenType = false;
      var validateHiddenType = false;
      var vhPos = rules.indexOf("validateHidden");
      var hPos = rules.indexOf("hidden");
      this.getInputElement(name);
      if (hPos !== -1) {
        hiddenType = true;
      }
      if (vhPos !== -1) {
        validateHiddenType = true;
      }
      if (!hiddenType || hiddenType && validateHiddenType) {
        if (vhPos !== -1) {
          rules.splice(vhPos, 1);
        }
        if (hPos !== -1) {
          rules.splice(hPos - 1, 1);
        }
        this.getErrorElement(name);
        for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
          var rule = rules_2[_i];
          var errorMessage = this.getErrorMessage(this.rules["" + name]["" + rule], rule);
          var errorRule = { name, message: errorMessage };
          var eventArgs = {
            inputName: name,
            element: this.inputElement,
            message: errorMessage
          };
          if (!this.isValid(name, rule) && !this.inputElement.classList.contains(this.ignore)) {
            this.removeErrorRules(name);
            this.errorRules.push(errorRule);
            this.inputElement.setAttribute("aria-invalid", "true");
            this.inputElement.setAttribute("aria-describedby", this.inputElement.id + "-info");
            var inputParent = this.inputElement.parentElement;
            var grandParent = inputParent.parentElement;
            if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper") || this.inputElement.classList.contains("e-input") && inputParent.classList.contains("e-input-group")) {
              inputParent.classList.add(this.errorClass);
              inputParent.classList.remove(this.validClass);
            } else if (grandParent != null && (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper"))) {
              grandParent.classList.add(this.errorClass);
              grandParent.classList.remove(this.validClass);
            } else {
              this.inputElement.classList.add(this.errorClass);
              this.inputElement.classList.remove(this.validClass);
            }
            if (!this.infoElement) {
              this.createErrorElement(name, errorRule.message, this.inputElement);
            } else {
              this.showMessage(errorRule);
            }
            eventArgs.errorElement = this.infoElement;
            eventArgs.status = "failure";
            if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper") || this.inputElement.classList.contains("e-input") && inputParent.classList.contains("e-input-group")) {
              inputParent.classList.add(this.errorClass);
              inputParent.classList.remove(this.validClass);
            } else if (grandParent != null && (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper"))) {
              grandParent.classList.add(this.errorClass);
              grandParent.classList.remove(this.validClass);
            } else {
              this.inputElement.classList.add(this.errorClass);
              this.inputElement.classList.remove(this.validClass);
            }
            this.optionalValidationStatus(name, eventArgs);
            this.trigger("validationComplete", eventArgs);
            if (rule === "required") {
              this.inputElement.setAttribute("aria-required", "true");
            }
            break;
          } else {
            this.hideMessage(name);
            eventArgs.status = "success";
            this.trigger("validationComplete", eventArgs);
          }
        }
      } else {
        return;
      }
    };
    FormValidator2.prototype.optionalValidationStatus = function(name, refer) {
      if (!this.rules["" + name][this.required] && !this.inputElement.value.length && !isNullOrUndefined(this.infoElement)) {
        this.infoElement.innerHTML = this.inputElement.value;
        this.infoElement.setAttribute("aria-invalid", "false");
        refer.status = "";
        this.hideMessage(name);
      }
    };
    FormValidator2.prototype.isValid = function(name, rule) {
      var params = this.rules["" + name]["" + rule];
      var param = params instanceof Array && typeof params[1] === "string" ? params[0] : params;
      var currentRule = this.rules["" + name]["" + rule];
      var dateFormat = (rule === "min" || rule === "max") && this.rules["" + name].date && typeof this.rules["" + name].date === "string" ? this.rules["" + name].date : null;
      var args = { value: this.inputElement.value, param, element: this.inputElement, formElement: this.element, format: dateFormat };
      this.trigger("validationBegin", args);
      if (!args.param && rule === "required") {
        return true;
      }
      if (currentRule && typeof currentRule[0] === "function") {
        var fn = currentRule[0];
        return fn.call(this, { element: this.inputElement, value: this.inputElement.value });
      } else if (FormValidator_1.isCheckable(this.inputElement)) {
        if (rule !== "required") {
          return true;
        }
        return selectAll('input[name="' + name + '"]:checked', this.element).length > 0;
      } else {
        return FormValidator_1.checkValidator["" + rule](args);
      }
    };
    FormValidator2.prototype.getErrorMessage = function(ruleValue, rule) {
      var message = this.inputElement.getAttribute("data-" + rule + "-message") ? this.inputElement.getAttribute("data-" + rule + "-message") : ruleValue instanceof Array && typeof ruleValue[1] === "string" ? ruleValue[1] : Object.keys(this.localyMessage).length !== 0 ? this.localyMessage["" + rule] : this.defaultMessages["" + rule];
      var formats = message.match(/{(\d)}/g);
      if (!isNullOrUndefined(formats)) {
        for (var i = 0; i < formats.length; i++) {
          var value = ruleValue instanceof Array ? ruleValue[parseInt(i.toString(), 10)] : ruleValue;
          message = message.replace(formats[parseInt(i.toString(), 10)], value);
        }
      }
      return message;
    };
    FormValidator2.prototype.createErrorElement = function(name, message, input) {
      var errorElement = createElement(this.errorElement, {
        className: this.errorClass,
        innerHTML: message,
        attrs: { for: name }
      });
      if (this.errorOption === ErrorOption.Message) {
        errorElement.classList.remove(this.errorClass);
        errorElement.classList.add("e-message");
        errorElement = createElement(this.errorContainer, { className: this.errorClass, innerHTML: errorElement.outerHTML });
      }
      errorElement.id = this.inputElement.name + "-info";
      if (this.element.querySelector('[data-valmsg-for="' + input.id + '"]')) {
        this.element.querySelector('[data-valmsg-for="' + input.id + '"]').appendChild(errorElement);
      } else if (input.hasAttribute("data-msg-containerid") === true) {
        var containerId = input.getAttribute("data-msg-containerid");
        var divElement = select("#" + containerId, this.element);
        divElement.appendChild(errorElement);
      } else if (this.customPlacement != null) {
        this.customPlacement.call(this, this.inputElement, errorElement);
      } else {
        var inputParent = this.inputElement.parentElement;
        var grandParent = inputParent.parentElement;
        if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper")) {
          grandParent.insertBefore(errorElement, inputParent.nextSibling);
        } else if (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper")) {
          grandParent.parentElement.insertBefore(errorElement, grandParent.nextSibling);
        } else {
          inputParent.insertBefore(errorElement, this.inputElement.nextSibling);
        }
      }
      errorElement.style.display = "block";
      this.getErrorElement(name);
      this.validated.push(name);
      this.checkRequired(name);
    };
    FormValidator2.prototype.getErrorElement = function(name) {
      this.infoElement = select(this.errorElement + "." + this.errorClass, this.inputElement.parentElement);
      if (!this.infoElement) {
        this.infoElement = select(this.errorElement + "." + this.errorClass + '[for="' + name + '"]', this.element);
      }
      return this.infoElement;
    };
    FormValidator2.prototype.removeErrorRules = function(name) {
      for (var i = 0; i < this.errorRules.length; i++) {
        var rule = this.errorRules[parseInt(i.toString(), 10)];
        if (rule.name === name) {
          this.errorRules.splice(i, 1);
        }
      }
    };
    FormValidator2.prototype.showMessage = function(errorRule) {
      this.infoElement.style.display = "block";
      this.infoElement.innerHTML = errorRule.message;
      this.checkRequired(errorRule.name);
    };
    FormValidator2.prototype.hideMessage = function(name) {
      if (this.infoElement) {
        this.infoElement.style.display = "none";
        this.removeErrorRules(name);
        var inputParent = this.inputElement.parentElement;
        var grandParent = inputParent.parentElement;
        if (inputParent.classList.contains("e-control-wrapper") || inputParent.classList.contains("e-wrapper") || this.inputElement.classList.contains("e-input") && inputParent.classList.contains("e-input-group")) {
          inputParent.classList.add(this.validClass);
          inputParent.classList.remove(this.errorClass);
        } else if (grandParent != null && (grandParent.classList.contains("e-control-wrapper") || grandParent.classList.contains("e-wrapper"))) {
          grandParent.classList.add(this.validClass);
          grandParent.classList.remove(this.errorClass);
        } else {
          this.inputElement.classList.add(this.validClass);
          this.inputElement.classList.remove(this.errorClass);
        }
        this.inputElement.setAttribute("aria-invalid", "false");
      }
    };
    FormValidator2.prototype.checkRequired = function(name) {
      if (!this.rules["" + name][this.required] && !this.inputElement.value.length && !isNullOrUndefined(this.infoElement)) {
        this.infoElement.innerHTML = this.inputElement.value;
        this.infoElement.setAttribute("aria-invalid", "false");
        this.hideMessage(name);
      }
    };
    FormValidator2.isCheckable = function(input) {
      var inputType = input.getAttribute("type");
      return inputType && (inputType === "checkbox" || inputType === "radio" || inputType === "submit");
    };
    var FormValidator_1;
    FormValidator2.checkValidator = {
      required: function(option) {
        return !isNaN(Date.parse(option.value)) ? !isNaN(new Date(option.value).getTime()) : option.value.toString().length > 0;
      },
      email: function(option) {
        return regex.EMAIL.test(option.value);
      },
      url: function(option) {
        return regex.URL.test(option.value);
      },
      dateIso: function(option) {
        return regex.DATE_ISO.test(option.value);
      },
      tel: function(option) {
        return regex.PHONE.test(option.value);
      },
      creditcard: function(option) {
        return regex.CREDITCARD.test(option.value);
      },
      number: function(option) {
        return !isNaN(Number(option.value)) && option.value.indexOf(" ") === -1;
      },
      digits: function(option) {
        return regex.DIGITS.test(option.value);
      },
      maxLength: function(option) {
        return option.value.length <= Number(option.param);
      },
      minLength: function(option) {
        return option.value.length >= Number(option.param);
      },
      rangeLength: function(option) {
        var param = option.param;
        return option.value.length >= param[0] && option.value.length <= param[1];
      },
      range: function(option) {
        var param = option.param;
        return !isNaN(Number(option.value)) && Number(option.value) >= param[0] && Number(option.value) <= param[1];
      },
      date: function(option) {
        if (!isNullOrUndefined(option.param) && (typeof option.param === "string" && option.param !== "")) {
          var globalize = new Internationalization();
          var dateOptions = { format: option.param.toString(), type: "dateTime", skeleton: "yMd" };
          var dateValue = globalize.parseDate(option.value, dateOptions);
          return !isNullOrUndefined(dateValue) && dateValue instanceof Date && !isNaN(+dateValue);
        } else {
          return !isNaN(new Date(option.value).getTime());
        }
      },
      max: function(option) {
        if (!isNaN(Number(option.value))) {
          return +option.value <= +option.param;
        }
        if (option.format && option.format !== "") {
          var globalize = new Internationalization();
          var dateOptions = { format: option.format.toString(), type: "dateTime", skeleton: "yMd" };
          var dateValue = globalize.parseDate(option.value, dateOptions);
          var maxValue = typeof option.param === "string" ? globalize.parseDate(JSON.parse(JSON.stringify(option.param)), dateOptions) : option.param;
          return new Date(dateValue).getTime() <= new Date(maxValue).getTime();
        } else {
          return new Date(option.value).getTime() <= new Date(JSON.parse(JSON.stringify(option.param))).getTime();
        }
      },
      min: function(option) {
        if (!isNaN(Number(option.value))) {
          return +option.value >= +option.param;
        } else if (option.value.indexOf(",") !== -1) {
          var uNum = option.value.replace(/,/g, "");
          return parseFloat(uNum) >= Number(option.param);
        } else {
          if (option.format && option.format !== "") {
            var globalize = new Internationalization();
            var dateOptions = { format: option.format.toString(), type: "dateTime", skeleton: "yMd" };
            var dateValue = globalize.parseDate(option.value, dateOptions);
            var minValue = typeof option.param === "string" ? globalize.parseDate(JSON.parse(JSON.stringify(option.param)), dateOptions) : option.param;
            return new Date(dateValue).getTime() >= new Date(minValue).getTime();
          } else {
            return new Date(option.value).getTime() >= new Date(JSON.parse(JSON.stringify(option.param))).getTime();
          }
        }
      },
      regex: function(option) {
        return new RegExp(option.param).test(option.value);
      },
      equalTo: function(option) {
        var compareTo = option.formElement.querySelector("#" + option.param);
        option.param = compareTo.value;
        return option.param === option.value;
      }
    };
    __decorate15([
      Property("")
    ], FormValidator2.prototype, "locale", void 0);
    __decorate15([
      Property("e-hidden")
    ], FormValidator2.prototype, "ignore", void 0);
    __decorate15([
      Property()
    ], FormValidator2.prototype, "rules", void 0);
    __decorate15([
      Property("e-error")
    ], FormValidator2.prototype, "errorClass", void 0);
    __decorate15([
      Property("e-valid")
    ], FormValidator2.prototype, "validClass", void 0);
    __decorate15([
      Property("label")
    ], FormValidator2.prototype, "errorElement", void 0);
    __decorate15([
      Property("div")
    ], FormValidator2.prototype, "errorContainer", void 0);
    __decorate15([
      Property(ErrorOption.Label)
    ], FormValidator2.prototype, "errorOption", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "focusout", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "keyup", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "click", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "change", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "submit", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "validationBegin", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "validationComplete", void 0);
    __decorate15([
      Event()
    ], FormValidator2.prototype, "customPlacement", void 0);
    FormValidator2 = FormValidator_1 = __decorate15([
      NotifyPropertyChanges
    ], FormValidator2);
    return FormValidator2;
  }(Base)
);

// node_modules/@syncfusion/ej2-inputs/src/uploader/uploader.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CONTROL_WRAPPER = "e-upload e-control-wrapper";
var INPUT_WRAPPER = "e-file-select";
var DROP_AREA = "e-file-drop";
var DROP_WRAPPER = "e-file-select-wrap";
var LIST_PARENT = "e-upload-files";
var FILE = "e-upload-file-list";
var STATUS = "e-file-status";
var ACTION_BUTTONS = "e-upload-actions";
var UPLOAD_BUTTONS = "e-file-upload-btn e-css e-btn e-flat e-primary";
var CLEAR_BUTTONS = "e-file-clear-btn e-css e-btn e-flat";
var FILE_NAME = "e-file-name";
var FILE_TYPE = "e-file-type";
var FILE_SIZE = "e-file-size";
var REMOVE_ICON = "e-file-remove-btn";
var DELETE_ICON = "e-file-delete-btn";
var SPINNER_PANE = "e-spinner-pane";
var ABORT_ICON = "e-file-abort-btn";
var RETRY_ICON = "e-file-reload-btn";
var DRAG_HOVER = "e-upload-drag-hover";
var PROGRESS_WRAPPER = "e-upload-progress-wrap";
var PROGRESSBAR = "e-upload-progress-bar";
var PROGRESSBAR_TEXT = "e-progress-bar-text";
var UPLOAD_INPROGRESS = "e-upload-progress";
var UPLOAD_SUCCESS = "e-upload-success";
var UPLOAD_FAILED = "e-upload-fails";
var TEXT_CONTAINER = "e-file-container";
var VALIDATION_FAILS = "e-validation-fails";
var RTL6 = "e-rtl";
var DISABLED4 = "e-disabled";
var RTL_CONTAINER = "e-rtl-container";
var ICON_FOCUSED = "e-clear-icon-focus";
var PROGRESS_INNER_WRAPPER = "e-progress-inner-wrap";
var PAUSE_UPLOAD = "e-file-pause-btn";
var RESUME_UPLOAD = "e-file-play-btn";
var RESTRICT_RETRY = "e-restrict-retry";
var wrapperAttr2 = ["title", "style", "class"];
var FORM_UPLOAD = "e-form-upload";
var HIDDEN_INPUT = "e-hidden-file-input";
var INVALID_FILE = "e-file-invalid";
var INFORMATION = "e-file-information";
var FilesProp = (
  /** @class */
  function(_super) {
    __extends15(FilesProp2, _super);
    function FilesProp2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate16([
      Property("")
    ], FilesProp2.prototype, "name", void 0);
    __decorate16([
      Property(null)
    ], FilesProp2.prototype, "size", void 0);
    __decorate16([
      Property("")
    ], FilesProp2.prototype, "type", void 0);
    return FilesProp2;
  }(ChildProperty)
);
var ButtonsProps = (
  /** @class */
  function(_super) {
    __extends15(ButtonsProps2, _super);
    function ButtonsProps2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate16([
      Property("Browse...")
    ], ButtonsProps2.prototype, "browse", void 0);
    __decorate16([
      Property("Upload")
    ], ButtonsProps2.prototype, "upload", void 0);
    __decorate16([
      Property("Clear")
    ], ButtonsProps2.prototype, "clear", void 0);
    return ButtonsProps2;
  }(ChildProperty)
);
var AsyncSettings = (
  /** @class */
  function(_super) {
    __extends15(AsyncSettings2, _super);
    function AsyncSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate16([
      Property("")
    ], AsyncSettings2.prototype, "saveUrl", void 0);
    __decorate16([
      Property("")
    ], AsyncSettings2.prototype, "removeUrl", void 0);
    __decorate16([
      Property(0)
    ], AsyncSettings2.prototype, "chunkSize", void 0);
    __decorate16([
      Property(3)
    ], AsyncSettings2.prototype, "retryCount", void 0);
    __decorate16([
      Property(500)
    ], AsyncSettings2.prototype, "retryAfterDelay", void 0);
    return AsyncSettings2;
  }(ChildProperty)
);
var Uploader = (
  /** @class */
  function(_super) {
    __extends15(Uploader2, _super);
    function Uploader2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.initialAttr = { accept: null, multiple: false, disabled: false };
      _this.uploadedFilesData = [];
      _this.base64String = [];
      _this.isForm = false;
      _this.allTypes = false;
      _this.pausedData = [];
      _this.uploadMetaData = [];
      _this.tabIndex = "0";
      _this.btnTabIndex = "0";
      _this.disableKeyboardNavigation = false;
      _this.count = -1;
      _this.actionCompleteCount = 0;
      _this.flag = true;
      _this.selectedFiles = [];
      _this.uploaderName = "UploadFiles";
      _this.fileStreams = [];
      _this.newFileRef = 0;
      _this.isFirstFileOnSelection = false;
      _this.dragCounter = 0;
      _this.fileList = [];
      _this.filesData = [];
      _this.uploaderOptions = options;
      return _this;
    }
    Uploader2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "allowedExtensions":
            this.setExtensions(this.allowedExtensions);
            this.clearAll();
            break;
          case "enabled":
            this.setControlStatus();
            break;
          case "multiple":
            this.setMultipleSelection();
            break;
          case "enableRtl":
            this.setRTL();
            this.reRenderFileList();
            break;
          case "buttons":
            this.buttons.browse = isNullOrUndefined(this.buttons.browse) ? "" : this.buttons.browse;
            this.buttons.clear = isNullOrUndefined(this.buttons.clear) ? "" : this.buttons.clear;
            this.buttons.upload = isNullOrUndefined(this.buttons.upload) ? "" : this.buttons.upload;
            this.renderButtonTemplates();
            break;
          case "dropArea":
            this.unBindDropEvents();
            this.updateDropArea();
            break;
          case "htmlAttributes":
            this.updateHTMLAttrToElement();
            this.updateHTMLAttrToWrapper();
            this.checkHTMLAttributes(true);
            break;
          case "files":
            this.renderPreLoadFiles();
            break;
          case "directoryUpload":
            this.updateDirectoryAttributes();
            break;
          case "template":
            if (this.isReact) {
              this.reRenderFileList();
            } else {
              this.clearAll();
            }
            break;
          case "minFileSize":
          case "maxFileSize":
          case "autoUpload":
            this.clearAll();
            break;
          case "sequentialUpload":
            this.clearAll();
            break;
          case "locale":
            this.l10n.setLocale(this.locale);
            this.setLocalizedTexts();
            this.preLocaleObj = getValue("currentLocale", this.l10n);
            break;
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
        }
      }
    };
    Uploader2.prototype.setLocalizedTexts = function() {
      if (isNullOrUndefined(this.template)) {
        if (typeof this.buttons.browse === "string") {
          this.browseButton.innerText = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
          this.browseButton.setAttribute("title", this.browseButton.innerText);
          if (this.uploadWrapper && !isNullOrUndefined(this.uploadWrapper.querySelector("." + DROP_AREA))) {
            this.uploadWrapper.querySelector("." + DROP_AREA).innerHTML = this.localizedTexts("dropFilesHint");
          }
        }
        this.updateFileList();
      }
    };
    Uploader2.prototype.getKeyValue = function(val) {
      var keyValue;
      for (var _i = 0, _a = Object.keys(this.preLocaleObj); _i < _a.length; _i++) {
        var key = _a[_i];
        if (this.preLocaleObj["" + key] === val) {
          keyValue = key;
        }
      }
      return keyValue;
    };
    Uploader2.prototype.updateFileList = function() {
      var element2;
      if (this.fileList.length > 0 && !isNullOrUndefined(this.uploadWrapper.querySelector("." + LIST_PARENT))) {
        for (var i = 0; i < this.fileList.length; i++) {
          element2 = this.fileList[i].querySelector(".e-file-status");
          element2.innerHTML = this.localizedTexts(this.getKeyValue(this.filesData[i].status));
          this.filesData[i].status = this.localizedTexts(this.getKeyValue(this.filesData[i].status));
          if (this.fileList[i].classList.contains(UPLOAD_SUCCESS)) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("delete"));
          }
          if (this.fileList[i].querySelector(".e-file-play-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("resume"));
          }
          if (this.fileList[i].querySelector(".e-file-remove-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("remove"));
          }
          if (this.fileList[i].querySelector(".e-file-reload-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("retry"));
          }
          if (!this.autoUpload) {
            this.uploadButton.innerText = this.buttons.upload === "Upload" ? this.localizedTexts("Upload") : this.buttons.upload;
            this.uploadButton.setAttribute("title", this.localizedTexts("Upload"));
            this.clearButton.innerText = this.buttons.clear === "Clear" ? this.localizedTexts("Clear") : this.buttons.clear;
            this.clearButton.setAttribute("title", this.localizedTexts("Clear"));
          }
        }
      }
    };
    Uploader2.prototype.reRenderFileList = function() {
      if (this.listParent) {
        detach(this.listParent);
        this.listParent = null;
        this.fileList = [];
        this.internalCreateFileList(this.filesData);
        if (this.actionButtons) {
          this.removeActionButtons();
          this.renderActionButtons();
          this.checkActionButtonStatus();
        }
      }
    };
    Uploader2.prototype.preRender = function() {
      this.localeText = {
        Browse: "Browse...",
        Clear: "Clear",
        Upload: "Upload",
        invalidFileName: "File Name is not allowed",
        dropFilesHint: "Or drop files here",
        invalidMaxFileSize: "File size is too large",
        invalidMinFileSize: "File size is too small",
        invalidFileType: "File type is not allowed",
        uploadFailedMessage: "File failed to upload",
        uploadSuccessMessage: "File uploaded successfully",
        removedSuccessMessage: "File removed successfully",
        removedFailedMessage: "Unable to remove file",
        inProgress: "Uploading",
        readyToUploadMessage: "Ready to upload",
        abort: "Abort",
        remove: "Remove",
        cancel: "Cancel",
        delete: "Delete file",
        pauseUpload: "File upload paused",
        pause: "Pause",
        resume: "Resume",
        retry: "Retry",
        fileUploadCancel: "File upload canceled",
        invalidFileSelection: "Invalid files selected",
        totalFiles: "Total files",
        size: "Size"
      };
      this.l10n = new L10n("uploader", this.localeText, this.locale);
      this.preLocaleObj = getValue("currentLocale", this.l10n);
      this.formRendered();
      this.updateHTMLAttrToElement();
      this.checkHTMLAttributes(false);
      var ejInstance = getValue("ej2_instances", this.element);
      if (this.element.tagName === "EJS-UPLOADER") {
        var inputElement = this.createElement("input", { attrs: { type: "file" } });
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          if (this.element.attributes[index].nodeName !== "id") {
            inputElement.setAttribute(this.element.attributes[index].nodeName, this.element.attributes[index].nodeValue);
          } else if (this.element.attributes[index].nodeName === "id") {
            inputElement.setAttribute(this.element.attributes[index].nodeName, getUniqueID("uploader"));
          }
          inputElement.innerHTML = this.element.innerHTML;
        }
        if (!inputElement.hasAttribute("name")) {
          inputElement.setAttribute("name", "UploadFiles");
        }
        this.element.appendChild(inputElement);
        this.element = inputElement;
        setValue("ej2_instances", ejInstance, this.element);
      }
      if (ejInstance[0].isPureReactComponent) {
        if (!isNullOrUndefined(ejInstance[0].props.name)) {
          this.element.setAttribute("name", ejInstance[0].props.name);
        } else if (!isNullOrUndefined(ejInstance[0].props.id) && isNullOrUndefined(ejInstance[0].props.name)) {
          this.element.setAttribute("name", ejInstance[0].props.id);
        } else {
          this.element.setAttribute("name", "UploadFiles");
        }
      }
      if (isNullOrUndefined(this.element.getAttribute("name"))) {
        this.element.setAttribute("name", this.element.getAttribute("id"));
      }
      if (!this.element.hasAttribute("type")) {
        this.element.setAttribute("type", "file");
      }
      this.updateDirectoryAttributes();
      this.keyConfigs = {
        enter: "enter"
      };
      if (this.element.hasAttribute("tabindex")) {
        this.tabIndex = this.element.getAttribute("tabindex");
      }
      this.browserName = Browser.info.name;
      this.uploaderName = this.element.getAttribute("name");
    };
    Uploader2.prototype.formRendered = function() {
      var parentEle = closest(this.element, "form");
      if (!isNullOrUndefined(parentEle)) {
        for (; parentEle && parentEle !== document.documentElement; parentEle = parentEle.parentElement) {
          if (parentEle.tagName === "FORM") {
            this.isForm = true;
            this.formElement = parentEle;
            parentEle.setAttribute("enctype", "multipart/form-data");
            parentEle.setAttribute("encoding", "multipart/form-data");
          }
        }
      }
    };
    Uploader2.prototype.getPersistData = function() {
      return this.addOnPersist(["filesData"]);
    };
    Uploader2.prototype.getModuleName = function() {
      return "uploader";
    };
    Uploader2.prototype.updateDirectoryAttributes = function() {
      if (this.directoryUpload) {
        this.element.setAttribute("directory", "true");
        this.element.setAttribute("webkitdirectory", "true");
      } else {
        this.element.removeAttribute("directory");
        this.element.removeAttribute("webkitdirectory");
      }
    };
    Uploader2.prototype.render = function() {
      this.renderBrowseButton();
      this.initializeUpload();
      this.updateHTMLAttrToWrapper();
      this.wireEvents();
      this.setMultipleSelection();
      this.setExtensions(this.allowedExtensions);
      this.setRTL();
      this.renderPreLoadFiles();
      this.setControlStatus();
      this.setCSSClass();
    };
    Uploader2.prototype.renderBrowseButton = function() {
      this.browseButton = this.createElement("button", { className: "e-css e-btn", attrs: { "type": "button" } });
      this.browseButton.setAttribute("tabindex", this.tabIndex);
      if (typeof this.buttons.browse === "string") {
        this.browseButton.textContent = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
        this.browseButton.setAttribute("title", this.browseButton.innerText);
      } else {
        this.browseButton.appendChild(this.buttons.browse);
      }
      this.element.setAttribute("aria-label", "Uploader");
    };
    Uploader2.prototype.renderActionButtons = function() {
      this.element.setAttribute("tabindex", "-1");
      this.actionButtons = this.createElement("div", { className: ACTION_BUTTONS });
      this.uploadButton = this.createElement("button", {
        className: UPLOAD_BUTTONS,
        attrs: { "type": "button", "tabindex": this.btnTabIndex, "aria-label": this.localizedTexts("Upload") }
      });
      this.clearButton = this.createElement("button", {
        className: CLEAR_BUTTONS,
        attrs: { "type": "button", "tabindex": this.btnTabIndex, "aria-label": this.localizedTexts("Clear") }
      });
      this.actionButtons.appendChild(this.clearButton);
      this.actionButtons.appendChild(this.uploadButton);
      this.renderButtonTemplates();
      this.uploadWrapper.appendChild(this.actionButtons);
      this.browseButton.blur();
      if (!this.isPreloadFiles) {
        this.uploadButton.focus();
      }
      this.wireActionButtonEvents();
    };
    Uploader2.prototype.serverActionButtonsEventBind = function(element2) {
      if (element2 && !this.isForm) {
        this.browseButton.blur();
        this.actionButtons = element2;
        this.uploadButton = this.actionButtons.querySelector(".e-file-upload-btn");
        this.clearButton = this.actionButtons.querySelector(".e-file-clear-btn");
        this.uploadButton.focus();
        this.unwireActionButtonEvents();
        this.wireActionButtonEvents();
        this.checkActionButtonStatus();
      }
    };
    Uploader2.prototype.wireActionButtonEvents = function() {
      EventHandler.add(this.uploadButton, "click", this.uploadButtonClick, this);
      EventHandler.add(this.clearButton, "click", this.clearButtonClick, this);
    };
    Uploader2.prototype.unwireActionButtonEvents = function() {
      EventHandler.remove(this.uploadButton, "click", this.uploadButtonClick);
      EventHandler.remove(this.clearButton, "click", this.clearButtonClick);
    };
    Uploader2.prototype.removeActionButtons = function() {
      if (this.actionButtons) {
        this.unwireActionButtonEvents();
        detach(this.actionButtons);
        this.actionButtons = null;
      }
    };
    Uploader2.prototype.renderButtonTemplates = function() {
      if (typeof this.buttons.browse === "string") {
        this.browseButton.textContent = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
        this.browseButton.setAttribute("title", this.browseButton.textContent);
      } else {
        this.browseButton.innerHTML = "";
        this.browseButton.appendChild(this.buttons.browse);
      }
      if (this.uploadButton) {
        var uploadText = isNullOrUndefined(this.buttons.upload) ? "Upload" : this.buttons.upload;
        this.buttons.upload = uploadText;
        if (typeof this.buttons.upload === "string") {
          this.uploadButton.textContent = this.buttons.upload === "Upload" ? this.localizedTexts("Upload") : this.buttons.upload;
          this.uploadButton.setAttribute("title", this.uploadButton.textContent);
        } else {
          this.uploadButton.innerHTML = "";
          this.uploadButton.appendChild(this.buttons.upload);
        }
      }
      if (this.clearButton) {
        var clearText = isNullOrUndefined(this.buttons.clear) ? "Clear" : this.buttons.clear;
        this.buttons.clear = clearText;
        if (typeof this.buttons.clear === "string") {
          this.clearButton.textContent = this.buttons.clear === "Clear" ? this.localizedTexts("Clear") : this.buttons.clear;
          this.clearButton.setAttribute("title", this.clearButton.textContent);
        } else {
          this.clearButton.innerHTML = "";
          this.clearButton.appendChild(this.buttons.clear);
        }
      }
    };
    Uploader2.prototype.initializeUpload = function() {
      this.element.setAttribute("tabindex", "-1");
      var inputWrapper = this.createElement("span", { className: INPUT_WRAPPER });
      this.element.parentElement.insertBefore(inputWrapper, this.element);
      this.dropAreaWrapper = this.createElement("div", { className: DROP_WRAPPER });
      this.element.parentElement.insertBefore(this.dropAreaWrapper, this.element);
      inputWrapper.appendChild(this.element);
      this.dropAreaWrapper.appendChild(this.browseButton);
      this.dropAreaWrapper.appendChild(inputWrapper);
      this.uploadWrapper = this.createElement("div", { className: CONTROL_WRAPPER });
      this.dropAreaWrapper.parentElement.insertBefore(this.uploadWrapper, this.dropAreaWrapper);
      this.uploadWrapper.appendChild(this.dropAreaWrapper);
      this.setDropArea();
    };
    Uploader2.prototype.renderPreLoadFiles = function() {
      if (this.files.length) {
        if (this.enablePersistence && this.filesData.length) {
          this.internalCreateFileList(this.filesData);
          return;
        }
        if (isNullOrUndefined(this.files[0].size)) {
          return;
        }
        this.isPreloadFiles = true;
        var files = [].slice.call(this.files);
        var filesData = [];
        if (!this.multiple) {
          this.clearData();
          files = [files[0]];
        }
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
          var data = files_1[_i];
          var fileData = {
            name: data.name + "." + data.type.split(".")[data.type.split(".").length - 1],
            rawFile: "",
            size: data.size,
            status: this.localizedTexts("uploadSuccessMessage"),
            type: data.type,
            validationMessages: { minSize: "", maxSize: "" },
            statusCode: "2"
          };
          filesData.push(fileData);
          this.filesData.push(fileData);
        }
        this.internalCreateFileList(filesData);
        if (!this.autoUpload && this.listParent && !this.actionButtons && (!this.isForm || this.allowUpload()) && this.showFileList) {
          this.renderActionButtons();
        }
        this.checkActionButtonStatus();
        if (this.sequentialUpload) {
          this.count = this.filesData.length - 1;
        }
        this.isPreloadFiles = false;
      }
    };
    Uploader2.prototype.checkActionButtonStatus = function() {
      if (this.actionButtons) {
        var length_1 = this.uploadWrapper.querySelectorAll("." + VALIDATION_FAILS).length + this.uploadWrapper.querySelectorAll(".e-upload-fails:not(.e-upload-progress)").length + this.uploadWrapper.querySelectorAll("span." + UPLOAD_SUCCESS).length + this.uploadWrapper.querySelectorAll("span." + UPLOAD_INPROGRESS).length;
        if (length_1 > 0 && length_1 === this.uploadWrapper.querySelectorAll("li").length) {
          this.uploadButton.setAttribute("disabled", "disabled");
        } else {
          this.uploadButton.removeAttribute("disabled");
        }
      }
    };
    Uploader2.prototype.setDropArea = function() {
      var dropTextArea = this.dropAreaWrapper.querySelector(".e-file-drop");
      if (this.dropArea) {
        this.dropZoneElement = typeof this.dropArea !== "string" ? this.dropArea : select(this.dropArea, document);
        var element2 = this.element;
        var enableDropText = false;
        while (element2.parentNode) {
          element2 = element2.parentNode;
          if (element2 === this.dropZoneElement) {
            enableDropText = true;
            if (!dropTextArea) {
              this.createDropTextHint();
            } else {
              dropTextArea.innerHTML = this.localizedTexts("dropFilesHint");
            }
          }
        }
        if (!enableDropText && dropTextArea) {
          remove(dropTextArea);
        }
      } else if (!isNullOrUndefined(this.uploaderOptions) && this.uploaderOptions.dropArea === void 0) {
        this.createDropTextHint();
        this.dropZoneElement = this.uploadWrapper;
        this.setProperties({ dropArea: this.uploadWrapper }, true);
      }
      this.bindDropEvents();
    };
    Uploader2.prototype.updateDropArea = function() {
      if (this.dropArea) {
        this.setDropArea();
      } else {
        this.dropZoneElement = null;
        var dropTextArea = this.dropAreaWrapper.querySelector(".e-file-drop");
        if (dropTextArea) {
          remove(dropTextArea);
        }
      }
    };
    Uploader2.prototype.createDropTextHint = function() {
      var fileDropArea = this.createElement("span", { className: DROP_AREA });
      fileDropArea.innerHTML = this.localizedTexts("dropFilesHint");
      this.dropAreaWrapper.appendChild(fileDropArea);
    };
    Uploader2.prototype.updateHTMLAttrToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttr2.indexOf(pro) < 0) {
            this.element.setAttribute(pro, this.htmlAttributes["" + pro]);
          }
        }
      }
    };
    Uploader2.prototype.updateHTMLAttrToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttr2.indexOf(pro) > -1) {
            if (pro === "class") {
              var updatedClassValues = this.htmlAttributes["" + pro].replace(/\s+/g, " ").trim();
              if (updatedClassValues !== "") {
                addClass([this.uploadWrapper], updatedClassValues.split(" "));
              }
            } else if (pro === "style") {
              var uploadStyle = this.uploadWrapper.getAttribute(pro);
              uploadStyle = !isNullOrUndefined(uploadStyle) ? uploadStyle + this.htmlAttributes["" + pro] : this.htmlAttributes["" + pro];
              this.uploadWrapper.setAttribute(pro, uploadStyle);
            } else {
              this.uploadWrapper.setAttribute(pro, this.htmlAttributes["" + pro]);
            }
          }
        }
      }
    };
    Uploader2.prototype.setMultipleSelection = function() {
      if (this.multiple && !this.element.hasAttribute("multiple")) {
        var newAttr = document.createAttribute("multiple");
        newAttr.value = "multiple";
        this.element.setAttributeNode(newAttr);
      } else if (!this.multiple) {
        this.element.removeAttribute("multiple");
      }
    };
    Uploader2.prototype.checkAutoUpload = function(fileData) {
      if (this.autoUpload) {
        if (this.sequentialUpload) {
          this.sequenceUpload(fileData);
        } else {
          this.upload(fileData);
        }
        this.removeActionButtons();
      } else if (!this.actionButtons) {
        this.renderActionButtons();
      }
      this.checkActionButtonStatus();
    };
    Uploader2.prototype.sequenceUpload = function(fileData) {
      if (this.filesData.length - fileData.length === 0 || this.filesData[this.filesData.length - fileData.length - 1].statusCode !== "1") {
        if (this.multiple || this.count < 0) {
          ++this.count;
        }
        var isFileListCreated = this.showFileList ? false : true;
        if (typeof this.filesData[this.count] === "object") {
          this.isFirstFileOnSelection = false;
          this.upload(this.filesData[this.count], isFileListCreated);
          if (this.filesData[this.count].statusCode === "0") {
            this.sequenceUpload(fileData);
          }
        } else {
          --this.count;
        }
      }
    };
    Uploader2.prototype.setCSSClass = function(oldCSSClass) {
      var updatedOldCssClass = oldCSSClass;
      if (!isNullOrUndefined(oldCSSClass)) {
        updatedOldCssClass = oldCSSClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(oldCSSClass) && updatedOldCssClass !== "") {
        removeClass([this.uploadWrapper], updatedOldCssClass.split(" "));
      }
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = this.cssClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(this.cssClass) && updatedCssClassValue !== "") {
        addClass([this.uploadWrapper], updatedCssClassValue.split(updatedCssClassValue.indexOf(",") > -1 ? "," : " "));
      }
    };
    Uploader2.prototype.wireEvents = function() {
      EventHandler.add(this.browseButton, "click", this.browseButtonClick, this);
      EventHandler.add(this.element, "change", this.onSelectFiles, this);
      EventHandler.add(document, "click", this.removeFocus, this);
      this.keyboardModule = new KeyboardEvents(this.uploadWrapper, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
      if (this.isForm) {
        EventHandler.add(this.formElement, "reset", this.resetForm, this);
      }
    };
    Uploader2.prototype.unWireEvents = function() {
      EventHandler.remove(this.browseButton, "click", this.browseButtonClick);
      EventHandler.remove(this.element, "change", this.onSelectFiles);
      EventHandler.remove(document, "click", this.removeFocus);
      if (this.isForm) {
        EventHandler.remove(this.formElement, "reset", this.resetForm);
      }
      if (this.keyboardModule) {
        this.keyboardModule.destroy();
      }
    };
    Uploader2.prototype.resetForm = function() {
      this.clearAll();
    };
    Uploader2.prototype.keyActionHandler = function(e) {
      var targetElement2 = e.target;
      switch (e.action) {
        case "enter":
          if (e.target === this.clearButton) {
            this.clearButtonClick();
          } else if (e.target === this.uploadButton) {
            this.uploadButtonClick();
          } else if (e.target === this.browseButton) {
            this.browseButtonClick();
          } else if (targetElement2.classList.contains(PAUSE_UPLOAD)) {
            var metaData = this.getCurrentMetaData(null, e);
            metaData.file.statusCode = "4";
            metaData.file.status = this.localizedTexts("pauseUpload");
            this.abortUpload(metaData, false);
          } else if (targetElement2.classList.contains(RESUME_UPLOAD)) {
            this.resumeUpload(this.getCurrentMetaData(null, e), e);
          } else if (targetElement2.classList.contains(RETRY_ICON)) {
            var metaData = this.getCurrentMetaData(null, e);
            if (!isNullOrUndefined(metaData)) {
              metaData.file.statusCode = "1";
              metaData.file.status = this.localizedTexts("readyToUploadMessage");
              this.chunkUpload(metaData.file);
            } else {
              var target = e.target.parentElement;
              var fileData = this.filesData[this.fileList.indexOf(target)];
              this.retry(fileData);
            }
          } else {
            this.removeFiles(e);
            if (!targetElement2.classList.contains(ABORT_ICON)) {
              this.browseButton.focus();
            }
          }
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    };
    Uploader2.prototype.getCurrentMetaData = function(fileInfo, e) {
      var fileData;
      var targetMetaData;
      if (isNullOrUndefined(fileInfo)) {
        var target = e.target.parentElement;
        fileData = this.filesData[this.fileList.indexOf(target)];
      } else {
        fileData = fileInfo;
      }
      for (var i = 0; i < this.uploadMetaData.length; i++) {
        if (this.uploadMetaData[i].file.name === fileData.name) {
          targetMetaData = this.uploadMetaData[i];
        }
      }
      return targetMetaData;
    };
    Uploader2.prototype.removeFocus = function() {
      if (this.uploadWrapper && this.listParent && this.listParent.querySelector("." + ICON_FOCUSED)) {
        document.activeElement.blur();
        this.listParent.querySelector("." + ICON_FOCUSED).classList.remove(ICON_FOCUSED);
      }
    };
    Uploader2.prototype.browseButtonClick = function() {
      this.element.click();
    };
    Uploader2.prototype.uploadButtonClick = function() {
      if (this.sequentialUpload) {
        this.sequenceUpload(this.filesData);
      } else {
        this.upload(this.filesData);
      }
    };
    Uploader2.prototype.clearButtonClick = function() {
      this.clearAll();
      if (this.sequentialUpload) {
        this.count = -1;
      }
      this.actionCompleteCount = 0;
    };
    Uploader2.prototype.bindDropEvents = function() {
      if (this.dropZoneElement) {
        EventHandler.add(this.dropZoneElement, "drop", this.dropElement, this);
        EventHandler.add(this.dropZoneElement, "dragover", this.dragHover, this);
        EventHandler.add(this.dropZoneElement, "dragleave", this.onDragLeave, this);
        EventHandler.add(this.dropZoneElement, "paste", this.onPasteFile, this);
        EventHandler.add(this.dropZoneElement, "dragenter", this.onDragEnter, this);
      }
    };
    Uploader2.prototype.unBindDropEvents = function() {
      if (this.dropZoneElement) {
        EventHandler.remove(this.dropZoneElement, "drop", this.dropElement);
        EventHandler.remove(this.dropZoneElement, "dragover", this.dragHover);
        EventHandler.remove(this.dropZoneElement, "dragleave", this.onDragLeave);
        EventHandler.remove(this.dropZoneElement, "dragenter", this.onDragEnter);
      }
    };
    Uploader2.prototype.onDragEnter = function(e) {
      if (!this.enabled) {
        return;
      }
      this.dropZoneElement.classList.add(DRAG_HOVER);
      this.dragCounter = this.dragCounter + 1;
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.onDragLeave = function() {
      if (!this.enabled) {
        return;
      }
      this.dragCounter = this.dragCounter - 1;
      if (!this.dragCounter) {
        this.dropZoneElement.classList.remove(DRAG_HOVER);
      }
    };
    Uploader2.prototype.dragHover = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.dropEffect !== "Default") {
        e.dataTransfer.dropEffect = this.dropEffect.toLowerCase();
      }
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.dropElement = function(e) {
      this.dragCounter = 0;
      this.dropZoneElement.classList.remove(DRAG_HOVER);
      this.onSelectFiles(e);
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.onPasteFile = function(event) {
      var item = event.clipboardData.items;
      if (event.type === "paste" && this.browserName !== "msie" && this.browserName !== "edge" && this.browserName !== "safari") {
        this.element.files = event.clipboardData.files;
      }
      if (item.length !== 1 && !this.multiple) {
        return;
      }
      for (var file = 0; file < item.length; file++) {
        var pasteFile = [].slice.call(item)[file];
        if (pasteFile.kind === "file" || pasteFile.type.match("^image/")) {
          this.renderSelectedFiles(event, [pasteFile.getAsFile()], false, true);
        }
      }
    };
    Uploader2.prototype.getSelectedFiles = function(index) {
      var data = [];
      var liElement = this.fileList[index];
      var allFiles = this.getFilesData();
      var nameElements = +liElement.getAttribute("data-files-count");
      var startIndex = 0;
      for (var i = 0; i < index; i++) {
        startIndex += +this.fileList[i].getAttribute("data-files-count");
      }
      for (var j = startIndex; j < startIndex + nameElements; j++) {
        data.push(allFiles[j]);
      }
      return data;
    };
    Uploader2.prototype.removeFiles = function(args) {
      if (!this.enabled) {
        return;
      }
      var selectedElement = args.target.parentElement;
      var index = this.fileList.indexOf(selectedElement);
      var liElement = this.fileList[index];
      var formUpload = this.isFormUpload();
      var fileData = formUpload ? this.getSelectedFiles(index) : this.getFilesInArray(this.filesData[index]);
      if (isNullOrUndefined(fileData)) {
        return;
      }
      if (args.target.classList.contains(ABORT_ICON) && !formUpload) {
        fileData[0].statusCode = "5";
        if (!isNullOrUndefined(liElement)) {
          var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
          createSpinner({ target: spinnerTarget, width: "20px" });
          showSpinner(spinnerTarget);
        }
        if (this.sequentialUpload) {
          this.uploadSequential();
        }
        if (!liElement.classList.contains(RESTRICT_RETRY)) {
          this.checkActionComplete(true);
        }
      } else if (!closest(args.target, "." + SPINNER_PANE)) {
        this.remove(fileData, false, false, true, args);
      }
      if (this.isForm && liElement && liElement.classList.contains(INVALID_FILE)) {
        this.element.value = "";
      }
      this.checkActionButtonStatus();
    };
    Uploader2.prototype.removeFilesData = function(file, customTemplate) {
      var index;
      if (customTemplate) {
        if (!this.showFileList) {
          index = this.filesData.indexOf(file);
          this.filesData.splice(index, 1);
        }
        return;
      }
      var selectedElement = this.getLiElement(file);
      if (isNullOrUndefined(selectedElement)) {
        return;
      }
      this.element.value = "";
      detach(selectedElement);
      index = this.fileList.indexOf(selectedElement);
      this.fileList.splice(index, 1);
      this.filesData.splice(index, 1);
      if (this.fileList.length === 0 && !isNullOrUndefined(this.listParent)) {
        detach(this.listParent);
        this.listParent = null;
        this.removeActionButtons();
      }
      if (this.sequentialUpload) {
        if (index <= this.count) {
          --this.count;
        }
      }
    };
    Uploader2.prototype.removeUploadedFile = function(file, eventArgs, removeDirectly, custom) {
      var _this = this;
      var selectedFiles = file;
      var ajax = new Ajax(this.asyncSettings.removeUrl, "POST", true, null);
      ajax.emitError = false;
      var formData = new FormData();
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        if (!removeDirectly) {
          _this.trigger("removing", eventArgs, function(eventArgs2) {
            if (eventArgs2.cancel) {
              e.cancel = true;
            } else {
              _this.removingEventCallback(eventArgs2, formData, selectedFiles, file);
            }
          });
        } else {
          _this.removingEventCallback(eventArgs, formData, selectedFiles, file);
        }
      };
      ajax.onLoad = function(e) {
        _this.removeCompleted(e, selectedFiles, custom);
        return {};
      };
      ajax.onError = function(e) {
        _this.removeFailed(e, selectedFiles, custom);
        return {};
      };
      ajax.send(formData);
    };
    Uploader2.prototype.removingEventCallback = function(eventArgs, formData, selectedFiles, file) {
      var name = this.element.getAttribute("name");
      var liElement = this.getLiElement(file);
      if (!isNullOrUndefined(liElement) && (!isNullOrUndefined(liElement.querySelector("." + DELETE_ICON)) || !isNullOrUndefined(liElement.querySelector("." + REMOVE_ICON)))) {
        var spinnerTarget = liElement.querySelector("." + DELETE_ICON) ? liElement.querySelector("." + DELETE_ICON) : liElement.querySelector("." + REMOVE_ICON);
        createSpinner({ target: spinnerTarget, width: "20px" });
        showSpinner(spinnerTarget);
      }
      if (eventArgs.postRawFile && !isNullOrUndefined(selectedFiles.rawFile) && selectedFiles.rawFile !== "") {
        formData.append(name, selectedFiles.rawFile, selectedFiles.name);
      } else {
        formData.append(name, selectedFiles.name);
      }
      this.updateFormData(formData, eventArgs.customFormData);
    };
    Uploader2.prototype.updateFormData = function(formData, customData) {
      if (customData.length > 0 && customData[0]) {
        var _loop_1 = function(i2) {
          var data = customData[i2];
          var value = Object.keys(data).map(function(e) {
            return data["" + e];
          });
          formData.append(Object.keys(data)[0], value);
        };
        for (var i = 0; i < customData.length; i++) {
          _loop_1(i);
        }
      }
    };
    Uploader2.prototype.updateCustomheader = function(request, currentRequest) {
      if (currentRequest.length > 0 && currentRequest[0]) {
        var _loop_2 = function(i2) {
          var data = currentRequest[i2];
          var value = Object.keys(data).map(function(e) {
            return data["" + e];
          });
          request.setRequestHeader(Object.keys(data)[0], value);
        };
        for (var i = 0; i < currentRequest.length; i++) {
          _loop_2(i);
        }
      }
    };
    Uploader2.prototype.removeCompleted = function(e, files, customTemplate) {
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var status = e.target;
      if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
        var args = {
          e,
          response,
          operation: "remove",
          file: this.updateStatus(files, this.localizedTexts("removedSuccessMessage"), "2")
        };
        this.trigger("success", args);
        this.removeFilesData(files, customTemplate);
        var index = this.uploadedFilesData.indexOf(files);
        this.uploadedFilesData.splice(index, 1);
        this.trigger("change", { files: this.uploadedFilesData });
      } else {
        this.removeFailed(e, files, customTemplate);
      }
    };
    Uploader2.prototype.removeFailed = function(e, files, customTemplate) {
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var args = {
        e,
        response,
        operation: "remove",
        file: this.updateStatus(files, this.localizedTexts("removedFailedMessage"), "0")
      };
      if (!customTemplate) {
        var index = this.filesData.indexOf(files);
        var rootElement = this.fileList[index];
        if (rootElement) {
          rootElement.classList.remove(UPLOAD_SUCCESS);
          rootElement.classList.add(UPLOAD_FAILED);
          var statusElement = rootElement.querySelector("." + STATUS);
          if (statusElement) {
            statusElement.classList.remove(UPLOAD_SUCCESS);
            statusElement.classList.add(UPLOAD_FAILED);
          }
        }
        this.checkActionButtonStatus();
      }
      this.trigger("failure", args);
      var liElement = this.getLiElement(files);
      if (!isNullOrUndefined(liElement) && !isNullOrUndefined(liElement.querySelector("." + DELETE_ICON))) {
        var spinnerTarget = liElement.querySelector("." + DELETE_ICON);
        hideSpinner(spinnerTarget);
        detach(liElement.querySelector(".e-spinner-pane"));
      }
    };
    Uploader2.prototype.getFilesFromFolder = function(event) {
      this.filesEntries = [];
      var items = this.multiple ? event.dataTransfer.items : [event.dataTransfer.items[0]];
      var validDirectoryUpload = this.checkDirectoryUpload(items);
      if (!validDirectoryUpload) {
        return;
      }
      var _loop_3 = function(i2) {
        var item = items[i2].webkitGetAsEntry();
        if (item.isFile) {
          var files_2 = [];
          item.file(function(fileObj) {
            var path = item.fullPath;
            files_2.push({ "path": path, "file": fileObj });
          });
          this_1.renderSelectedFiles(event, files_2, true);
        } else if (item.isDirectory) {
          this_1.traverseFileTree(item, event);
        }
      };
      var this_1 = this;
      for (var i = 0; i < items.length; i++) {
        _loop_3(i);
      }
    };
    Uploader2.prototype.checkDirectoryUpload = function(items) {
      for (var i = 0; items && i < items.length; i++) {
        var item = items[i].webkitGetAsEntry();
        if (item.isDirectory) {
          return true;
        }
      }
      return false;
    };
    Uploader2.prototype.traverseFileTree = function(item, event) {
      if (item.isFile) {
        this.filesEntries.push(item);
      } else if (item.isDirectory) {
        var directoryReader = item.createReader();
        this.readFileFromDirectory(directoryReader, event);
      }
    };
    Uploader2.prototype.readFileFromDirectory = function(directoryReader, event) {
      var _this = this;
      directoryReader.readEntries(function(entries) {
        for (var i = 0; i < entries.length; i++) {
          _this.traverseFileTree(entries[i], event);
        }
        _this.pushFilesEntries(event);
        if (entries.length) {
          _this.readFileFromDirectory(directoryReader);
        }
      });
    };
    Uploader2.prototype.pushFilesEntries = function(event) {
      var _this = this;
      var files = [];
      var _loop_4 = function(i2) {
        this_2.filesEntries[i2].file(function(fileObj) {
          if (_this.filesEntries.length) {
            var path = _this.filesEntries[i2].fullPath;
            files.push({ "path": path, "file": fileObj });
            if (i2 === _this.filesEntries.length - 1) {
              _this.filesEntries = [];
              _this.renderSelectedFiles(event, files, true);
            }
          }
        });
      };
      var this_2 = this;
      for (var i = 0; i < this.filesEntries.length; i++) {
        _loop_4(i);
      }
    };
    Uploader2.prototype.onSelectFiles = function(args) {
      if (!this.enabled) {
        return;
      }
      var targetFiles;
      if (args.type === "drop") {
        if (this.directoryUpload) {
          this.getFilesFromFolder(args);
        } else {
          var files = this.sortFilesList = args.dataTransfer.files;
          if (this.browserName !== "msie" && this.browserName !== "edge" && this.browserName !== "safari") {
            this.element.files = files;
          }
          if (files.length > 0) {
            targetFiles = this.multiple ? this.sortFileList(files) : [files[0]];
            this.renderSelectedFiles(args, targetFiles);
          }
        }
      } else {
        targetFiles = [].slice.call(args.target.files);
        this.renderSelectedFiles(args, targetFiles);
      }
      if (this.isAngular || this.isReact) {
        args.stopPropagation();
      }
    };
    Uploader2.prototype.getBase64 = function(file) {
      return new Promise(function(resolve, reject) {
        var fileReader = new FileReader();
        fileReader.readAsDataURL(file);
        fileReader.onload = function() {
          return resolve(fileReader.result);
        };
        fileReader.onerror = function(error) {
          return reject(error);
        };
      });
    };
    Uploader2.prototype.renderSelectedFiles = function(args, targetFiles, directory, paste) {
      var _this = this;
      this.base64String = [];
      var eventArgs = {
        event: args,
        cancel: false,
        filesData: [],
        isModified: false,
        modifiedFilesData: [],
        progressInterval: "",
        isCanceled: false,
        currentRequest: null,
        customFormData: null
      };
      if (targetFiles.length < 1) {
        eventArgs.isCanceled = true;
        this.trigger("selected", eventArgs);
        return;
      }
      this.flag = true;
      var fileData = [];
      if (!this.multiple) {
        this.clearData(true);
        this.actionCompleteCount = 0;
        targetFiles = [targetFiles[0]];
      }
      for (var i = 0; i < targetFiles.length; i++) {
        var file = directory ? targetFiles[i].file : targetFiles[i];
        this.updateInitialFileDetails(args, targetFiles, file, i, fileData, directory, paste);
      }
      eventArgs.filesData = fileData;
      if (this.allowedExtensions.indexOf("*") > -1) {
        this.allTypes = true;
      }
      if (this.enableHtmlSanitizer) {
        for (var i = 0; i < fileData.length; i++) {
          var sanitizeFile = SanitizeHtmlHelper.beforeSanitize();
          var sanitizeFileName = SanitizeHtmlHelper.serializeValue(sanitizeFile, fileData[parseInt(i.toString(), 10)].name);
          var currentFileName = fileData[parseInt(i.toString(), 10)].name;
          var isUTF8 = false;
          for (var i_1 = 0; i_1 < currentFileName.length; i_1++) {
            if (currentFileName.charCodeAt(i_1) > 127) {
              isUTF8 = true;
              break;
            }
          }
          var htmlTagRegex = /<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>/i;
          var hasHTMLString = htmlTagRegex.test(currentFileName);
          if (sanitizeFileName !== fileData[parseInt(i.toString(), 10)].name && !(isUTF8 && !hasHTMLString)) {
            var encodedFileName = targetFiles[parseInt(i.toString(), 10)].name.replace(/[\u00A0-\u9999<>\\&]/g, function(i2) {
              return "&#" + i2.charCodeAt(0) + ";";
            });
            fileData[parseInt(i.toString(), 10)].name = encodedFileName;
            fileData[parseInt(i.toString(), 10)].status = this.localizedTexts("invalidFileName");
            fileData[parseInt(i.toString(), 10)].statusCode = "0";
          }
        }
      }
      if (!this.allTypes) {
        fileData = this.checkExtension(fileData);
      }
      this.trigger("selected", eventArgs, function(eventArgs2) {
        _this._internalRenderSelect(eventArgs2, fileData);
      });
    };
    Uploader2.prototype.updateInitialFileDetails = function(args, targetFiles, file, i, fileData, directory, paste) {
      var fileName = directory ? targetFiles[i].path.substring(1, targetFiles[i].path.length) : paste ? getUniqueID(file.name.substring(0, file.name.lastIndexOf("."))) + "." + this.getFileType(file.name) : this.directoryUpload ? targetFiles[i].webkitRelativePath : file.name;
      var fileDetails = {
        name: fileName,
        rawFile: file,
        size: file.size,
        status: this.localizedTexts("readyToUploadMessage"),
        type: this.getFileType(file.name),
        validationMessages: this.validatedFileSize(file.size),
        statusCode: "1",
        id: getUniqueID(file.name.substring(0, file.name.lastIndexOf("."))) + "." + this.getFileType(file.name)
      };
      if (paste) {
        fileDetails.fileSource = "paste";
      }
      fileDetails.status = fileDetails.validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : fileDetails.validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : fileDetails.status;
      if (fileDetails.validationMessages.minSize !== "" || fileDetails.validationMessages.maxSize !== "") {
        fileDetails.statusCode = "0";
      }
      fileData.push(fileDetails);
    };
    Uploader2.prototype._internalRenderSelect = function(eventArgs, fileData) {
      if (!eventArgs.cancel) {
        this.selectedFiles = this.selectedFiles.concat(fileData);
        this.btnTabIndex = this.disableKeyboardNavigation ? "-1" : "0";
        if (this.showFileList) {
          if (eventArgs.isModified && eventArgs.modifiedFilesData.length > 0) {
            for (var j = 0; j < eventArgs.modifiedFilesData.length; j++) {
              for (var k = 0; k < fileData.length; k++) {
                if (eventArgs.modifiedFilesData[j].id === fileData[k].id) {
                  eventArgs.modifiedFilesData[j].rawFile = fileData[k].rawFile;
                }
              }
            }
            var dataFiles = this.allTypes ? eventArgs.modifiedFilesData : this.checkExtension(eventArgs.modifiedFilesData);
            this.updateSortedFileList(dataFiles);
            this.filesData = this.filesData.concat(dataFiles);
            if (!this.isForm || this.allowUpload()) {
              this.checkAutoUpload(dataFiles);
            }
          } else {
            this.internalCreateFileList(fileData);
            if (this.autoUpload && this.sequenceUpload && this.sequentialUpload && this.filesData.length > 0 && this.filesData[this.filesData.length - 1].statusCode !== "2" && this.filesData[this.filesData.length - 1].statusCode !== "0") {
              this.filesData = this.filesData.concat(fileData);
              return;
            }
            this.filesData = this.filesData.concat(fileData);
            if (!this.isForm || this.allowUpload()) {
              this.checkAutoUpload(fileData);
            }
          }
          if (!isNullOrUndefined(eventArgs.progressInterval) && eventArgs.progressInterval !== "") {
            this.progressInterval = eventArgs.progressInterval;
          }
        } else {
          this.filesData = this.filesData.concat(fileData);
          if (this.autoUpload) {
            this.upload(this.filesData, true);
          }
        }
        for (var item = 0; item < this.filesData.length; item++) {
          if (this.filesData[item].statusCode === "0") {
            this.checkActionComplete(true);
          }
        }
        this.isFirstFileOnSelection = true;
      }
    };
    Uploader2.prototype.allowUpload = function() {
      var allowFormUpload = false;
      if (this.isForm && (!isNullOrUndefined(this.asyncSettings.saveUrl) && this.asyncSettings.saveUrl !== "")) {
        allowFormUpload = true;
      }
      return allowFormUpload;
    };
    Uploader2.prototype.isFormUpload = function() {
      var isFormUpload = false;
      if (this.isForm && ((isNullOrUndefined(this.asyncSettings.saveUrl) || this.asyncSettings.saveUrl === "") && (isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === ""))) {
        isFormUpload = true;
      }
      return isFormUpload;
    };
    Uploader2.prototype.clearData = function(singleUpload) {
      if (!isNullOrUndefined(this.listParent)) {
        detach(this.listParent);
        this.listParent = null;
      }
      if (this.browserName !== "msie" && !singleUpload) {
        this.element.value = "";
      }
      this.fileList = [];
      this.filesData = [];
      this.removeActionButtons();
    };
    Uploader2.prototype.updateSortedFileList = function(filesData) {
      var previousListClone = this.createElement("div", { id: "clonewrapper" });
      var added = -1;
      if (this.listParent) {
        for (var i = 0; i < this.listParent.querySelectorAll("li").length; i++) {
          var liElement = this.listParent.querySelectorAll("li")[i];
          previousListClone.appendChild(liElement.cloneNode(true));
        }
        this.removeActionButtons();
        var oldList = [].slice.call(previousListClone.childNodes);
        this.createParentUL();
        for (var index = 0; index < filesData.length; index++) {
          for (var j = 0; j < this.filesData.length; j++) {
            if (this.filesData[j].name === filesData[index].name) {
              this.listParent.appendChild(oldList[j]);
              EventHandler.add(oldList[j].querySelector(".e-icons"), "click", this.removeFiles, this);
              this.fileList.push(oldList[j]);
              added = index;
            }
          }
          if (added !== index) {
            this.internalCreateFileList([filesData[index]]);
          }
        }
      } else {
        this.internalCreateFileList(filesData);
      }
    };
    Uploader2.prototype.isBlank = function(str) {
      return !str || /^\s*$/.test(str);
    };
    Uploader2.prototype.checkExtension = function(files) {
      var dropFiles = files;
      if (!this.isBlank(this.allowedExtensions)) {
        var allowedExtensions = [];
        var extensions = this.allowedExtensions.split(",");
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
          var extension = extensions_1[_i];
          allowedExtensions.push(extension.trim().toLocaleLowerCase());
        }
        for (var i = 0; i < files.length; i++) {
          var checkFileType = files[i].type.indexOf(".") !== -1 ? files[i].type.replace(".", "") : files[i].type;
          if (allowedExtensions.indexOf(("." + checkFileType).toLocaleLowerCase()) === -1) {
            files[i].status = this.localizedTexts("invalidFileType");
            files[i].statusCode = "0";
          }
        }
      }
      return dropFiles;
    };
    Uploader2.prototype.validatedFileSize = function(fileSize) {
      var minSizeError = "";
      var maxSizeError = "";
      if (fileSize < this.minFileSize) {
        minSizeError = this.localizedTexts("invalidMinFileSize");
      } else if (fileSize > this.maxFileSize) {
        maxSizeError = this.localizedTexts("invalidMaxFileSize");
      } else {
        minSizeError = "";
        maxSizeError = "";
      }
      var errorMessage = { minSize: minSizeError, maxSize: maxSizeError };
      return errorMessage;
    };
    Uploader2.prototype.isPreLoadFile = function(fileData) {
      var isPreload = false;
      for (var i = 0; i < this.files.length; i++) {
        if (this.files[i].name === fileData.name.slice(0, fileData.name.lastIndexOf(".")) && this.files[i].type === fileData.type) {
          isPreload = true;
        }
      }
      return isPreload;
    };
    Uploader2.prototype.createCustomfileList = function(fileData) {
      this.createParentUL();
      for (var _i = 0, fileData_1 = fileData; _i < fileData_1.length; _i++) {
        var listItem = fileData_1[_i];
        var listElement = this.createElement("li", { className: FILE, attrs: { "data-file-name": listItem.name } });
        this.uploadTemplateFn = this.templateComplier(this.template);
        var liTempCompiler = this.uploadTemplateFn(listItem, this, "template", this.element.id + "Template", this.isStringTemplate, null, listElement);
        if (liTempCompiler) {
          var fromElements = [].slice.call(liTempCompiler);
          append(fromElements, listElement);
        }
        var index = fileData.indexOf(listItem);
        var eventArgs = {
          element: listElement,
          fileInfo: listItem,
          index,
          isPreload: this.isPreLoadFile(listItem)
        };
        var eventsArgs = {
          element: listElement,
          fileInfo: listItem,
          index,
          isPreload: this.isPreLoadFile(listItem)
        };
        this.trigger("rendering", eventArgs);
        this.trigger("fileListRendering", eventsArgs);
        this.listParent.appendChild(listElement);
        this.fileList.push(listElement);
      }
      this.renderReactTemplates();
    };
    Uploader2.prototype.createParentUL = function() {
      if (isNullOrUndefined(this.listParent)) {
        this.listParent = this.createElement("ul", { className: LIST_PARENT });
        this.uploadWrapper.appendChild(this.listParent);
      }
    };
    Uploader2.prototype.formFileList = function(fileData, files) {
      var fileList = this.createElement("li", { className: FILE });
      fileList.setAttribute("data-files-count", fileData.length + "");
      var fileContainer = this.createElement("span", { className: TEXT_CONTAINER });
      var statusMessage;
      for (var _i = 0, fileData_2 = fileData; _i < fileData_2.length; _i++) {
        var listItem = fileData_2[_i];
        var fileNameEle = this.createElement("span", { className: FILE_NAME });
        fileNameEle.innerHTML = this.getFileNameOnly(listItem.name);
        var fileTypeEle = this.createElement("span", { className: FILE_TYPE });
        var fileType = this.getFileType(listItem.name);
        fileTypeEle.innerHTML = "." + fileType;
        if (!fileType) {
          fileTypeEle.classList.add("e-hidden");
        }
        if (!this.enableRtl) {
          fileContainer.appendChild(fileNameEle);
          fileContainer.appendChild(fileTypeEle);
        } else {
          var rtlContainer = this.createElement("span", { className: RTL_CONTAINER });
          rtlContainer.appendChild(fileTypeEle);
          rtlContainer.appendChild(fileNameEle);
          fileContainer.appendChild(rtlContainer);
        }
        this.truncateName(fileNameEle);
        statusMessage = this.formValidateFileInfo(listItem, fileList);
      }
      fileList.appendChild(fileContainer);
      this.setListToFileInfo(fileData, fileList);
      var index = this.listParent.querySelectorAll("li").length;
      var infoEle = this.createElement("span");
      if (fileList.classList.contains(INVALID_FILE)) {
        infoEle.classList.add(STATUS);
        infoEle.classList.add(INVALID_FILE);
        infoEle.innerText = fileData.length > 1 ? this.localizedTexts("invalidFileSelection") : statusMessage;
      } else {
        infoEle.classList.add(fileData.length > 1 ? INFORMATION : FILE_SIZE);
        infoEle.innerText = fileData.length > 1 ? this.localizedTexts("totalFiles") + ": " + fileData.length + " , " + this.localizedTexts("size") + ": " + this.bytesToSize(this.getFileSize(fileData)) : this.bytesToSize(fileData[0].size);
        this.createFormInput(fileData);
      }
      fileContainer.appendChild(infoEle);
      if (isNullOrUndefined(fileList.querySelector(".e-icons"))) {
        var iconElement = this.createElement("span", { className: "e-icons", attrs: { "tabindex": this.btnTabIndex } });
        if (this.browserName === "msie") {
          iconElement.classList.add("e-msie");
        }
        iconElement.setAttribute("title", this.localizedTexts("remove"));
        fileList.appendChild(fileContainer);
        fileList.appendChild(iconElement);
        EventHandler.add(iconElement, "click", this.removeFiles, this);
        iconElement.classList.add(REMOVE_ICON);
      }
      var eventArgs = {
        element: fileList,
        fileInfo: this.mergeFileInfo(fileData, fileList),
        index,
        isPreload: this.isPreLoadFile(this.mergeFileInfo(fileData, fileList))
      };
      var eventsArgs = {
        element: fileList,
        fileInfo: this.mergeFileInfo(fileData, fileList),
        index,
        isPreload: this.isPreLoadFile(this.mergeFileInfo(fileData, fileList))
      };
      this.trigger("rendering", eventArgs);
      this.trigger("fileListRendering", eventsArgs);
      this.listParent.appendChild(fileList);
      this.fileList.push(fileList);
    };
    Uploader2.prototype.formValidateFileInfo = function(listItem, fileList) {
      var statusMessage = listItem.status;
      var validationMessages = this.validatedFileSize(listItem.size);
      if (validationMessages.minSize !== "" || validationMessages.maxSize !== "") {
        this.addInvalidClass(fileList);
        statusMessage = validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : statusMessage;
      }
      var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
      if (typeValidationMessage === this.localizedTexts("invalidFileType")) {
        this.addInvalidClass(fileList);
        statusMessage = typeValidationMessage;
      }
      return statusMessage;
    };
    Uploader2.prototype.addInvalidClass = function(fileList) {
      fileList.classList.add(INVALID_FILE);
    };
    Uploader2.prototype.createFormInput = function(fileData) {
      if (this.browserName !== "safari") {
        var inputElement = this.element.cloneNode(true);
        inputElement.classList.add(HIDDEN_INPUT);
        for (var _i = 0, fileData_3 = fileData; _i < fileData_3.length; _i++) {
          var listItem = fileData_3[_i];
          listItem.input = inputElement;
        }
        inputElement.setAttribute("id", getUniqueID("hiddenUploader"));
        inputElement.setAttribute("name", this.uploaderName);
        this.uploadWrapper.querySelector("." + INPUT_WRAPPER).appendChild(inputElement);
        if (this.browserName !== "msie" && this.browserName !== "edge") {
          this.element.value = "";
        }
      }
    };
    Uploader2.prototype.getFileSize = function(fileData) {
      var fileSize = 0;
      for (var _i = 0, fileData_4 = fileData; _i < fileData_4.length; _i++) {
        var file = fileData_4[_i];
        fileSize += file.size;
      }
      return fileSize;
    };
    Uploader2.prototype.mergeFileInfo = function(fileData, fileList) {
      var result = {
        name: "",
        rawFile: "",
        size: 0,
        status: "",
        type: "",
        validationMessages: { minSize: "", maxSize: "" },
        statusCode: "1",
        list: fileList
      };
      var fileNames = [];
      var type = "";
      for (var _i = 0, fileData_5 = fileData; _i < fileData_5.length; _i++) {
        var listItem = fileData_5[_i];
        fileNames.push(listItem.name);
        type = listItem.type;
      }
      result.name = fileNames.join(", ");
      result.size = this.getFileSize(fileData);
      result.type = type;
      result.status = this.statusForFormUpload(fileData, fileList);
      return result;
    };
    Uploader2.prototype.statusForFormUpload = function(fileData, fileList) {
      var isValid = true;
      var statusMessage;
      for (var _i = 0, fileData_6 = fileData; _i < fileData_6.length; _i++) {
        var listItem = fileData_6[_i];
        statusMessage = listItem.status;
        var validationMessages = this.validatedFileSize(listItem.size);
        if (validationMessages.minSize !== "" || validationMessages.maxSize !== "") {
          isValid = false;
          statusMessage = validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : statusMessage;
        }
        var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
        if (typeValidationMessage === this.localizedTexts("invalidFileType")) {
          isValid = false;
          statusMessage = typeValidationMessage;
        }
      }
      if (!isValid) {
        fileList.classList.add(INVALID_FILE);
        statusMessage = fileData.length > 1 ? this.localizedTexts("invalidFileSelection") : statusMessage;
      } else {
        statusMessage = this.localizedTexts("totalFiles") + ": " + fileData.length + " , " + this.localizedTexts("size") + ": " + this.bytesToSize(this.getFileSize(fileData));
      }
      return statusMessage;
    };
    Uploader2.prototype.formCustomFileList = function(fileData, files) {
      this.createParentUL();
      var fileList = this.createElement("li", { className: FILE });
      fileList.setAttribute("data-files-count", fileData.length + "");
      this.setListToFileInfo(fileData, fileList);
      var result = this.mergeFileInfo(fileData, fileList);
      fileList.setAttribute("data-file-name", result.name);
      this.uploadTemplateFn = this.templateComplier(this.template);
      var liTempCompiler = this.uploadTemplateFn(result, this, "template", this.element.id + "Template", this.isStringTemplate, null, fileList);
      if (liTempCompiler) {
        var fromElements = [].slice.call(liTempCompiler);
        append(fromElements, fileList);
      }
      var index = this.listParent.querySelectorAll("li").length;
      if (!fileList.classList.contains(INVALID_FILE)) {
        this.createFormInput(fileData);
      }
      var eventArgs = {
        element: fileList,
        fileInfo: result,
        index,
        isPreload: this.isPreLoadFile(result)
      };
      var eventsArgs = {
        element: fileList,
        fileInfo: result,
        index,
        isPreload: this.isPreLoadFile(result)
      };
      this.trigger("rendering", eventArgs);
      this.trigger("fileListRendering", eventsArgs);
      this.listParent.appendChild(fileList);
      this.fileList.push(fileList);
      this.renderReactTemplates();
    };
    Uploader2.prototype.createFileList = function(fileData) {
      this.filesData = this.filesData && this.filesData.length > 0 ? this.filesData.concat(fileData) : fileData;
      this.internalCreateFileList(fileData);
    };
    Uploader2.prototype.internalCreateFileList = function(fileData) {
      this.createParentUL();
      if (this.template !== "" && !isNullOrUndefined(this.template)) {
        if (this.isFormUpload()) {
          this.uploadWrapper.classList.add(FORM_UPLOAD);
          this.formCustomFileList(fileData, this.element.files);
        } else {
          this.createCustomfileList(fileData);
        }
      } else if (this.isFormUpload()) {
        this.uploadWrapper.classList.add(FORM_UPLOAD);
        this.formFileList(fileData, this.element.files);
      } else {
        for (var _i = 0, fileData_7 = fileData; _i < fileData_7.length; _i++) {
          var listItem = fileData_7[_i];
          var liElement = this.createElement("li", {
            className: FILE,
            attrs: { "data-file-name": listItem.name, "data-files-count": "1" }
          });
          var textContainer = this.createElement("span", { className: TEXT_CONTAINER });
          var textElement = this.createElement("span", { className: FILE_NAME, attrs: { "title": listItem.name } });
          textElement.innerHTML = this.getFileNameOnly(listItem.name);
          var fileExtension = this.createElement("span", { className: FILE_TYPE });
          var fileType = this.getFileType(listItem.name);
          fileExtension.innerHTML = "." + fileType;
          if (!fileType) {
            fileExtension.classList.add("e-hidden");
          }
          if (!this.enableRtl) {
            textContainer.appendChild(textElement);
            textContainer.appendChild(fileExtension);
          } else {
            var rtlContainer = this.createElement("span", { className: RTL_CONTAINER });
            rtlContainer.appendChild(fileExtension);
            rtlContainer.appendChild(textElement);
            textContainer.appendChild(rtlContainer);
          }
          var fileSize = this.createElement("span", { className: FILE_SIZE });
          fileSize.innerHTML = this.bytesToSize(listItem.size);
          textContainer.appendChild(fileSize);
          var statusElement = this.createElement("span", { className: STATUS });
          textContainer.appendChild(statusElement);
          statusElement.innerHTML = listItem.status;
          liElement.appendChild(textContainer);
          var iconElement = this.createElement("span", {
            className: " e-icons",
            attrs: { "tabindex": this.btnTabIndex }
          });
          if (this.browserName === "msie") {
            iconElement.classList.add("e-msie");
          }
          iconElement.setAttribute("title", this.localizedTexts("remove"));
          liElement.appendChild(iconElement);
          EventHandler.add(iconElement, "click", this.removeFiles, this);
          if (listItem.statusCode === "2") {
            statusElement.classList.add(UPLOAD_SUCCESS);
            iconElement.classList.add(DELETE_ICON);
            iconElement.setAttribute("title", this.localizedTexts("delete"));
          } else if (listItem.statusCode !== "1") {
            statusElement.classList.remove(UPLOAD_SUCCESS);
            statusElement.classList.add(VALIDATION_FAILS);
          }
          if (this.autoUpload && listItem.statusCode === "1" && this.asyncSettings.saveUrl !== "") {
            statusElement.innerHTML = "";
          }
          if (!iconElement.classList.contains(DELETE_ICON)) {
            iconElement.classList.add(REMOVE_ICON);
            iconElement.setAttribute("aria-label", this.localizedTexts("remove"));
          }
          var index = fileData.indexOf(listItem);
          var eventArgs = {
            element: liElement,
            fileInfo: listItem,
            index,
            isPreload: this.isPreLoadFile(listItem)
          };
          var eventsArgs = {
            element: liElement,
            fileInfo: listItem,
            index,
            isPreload: this.isPreLoadFile(listItem)
          };
          this.trigger("rendering", eventArgs);
          this.trigger("fileListRendering", eventsArgs);
          this.listParent.appendChild(liElement);
          this.fileList.push(liElement);
          this.truncateName(textElement);
          var preventActionComplete = this.flag;
          if (this.isPreLoadFile(listItem)) {
            this.flag = false;
            this.checkActionComplete(true);
            this.flag = preventActionComplete;
          }
        }
      }
    };
    Uploader2.prototype.getSlicedName = function(nameElement) {
      var text = nameElement.textContent;
      nameElement.dataset.tail = text.slice(text.length - 10);
    };
    Uploader2.prototype.setListToFileInfo = function(fileData, fileList) {
      for (var _i = 0, fileData_8 = fileData; _i < fileData_8.length; _i++) {
        var listItem = fileData_8[_i];
        listItem.list = fileList;
      }
    };
    Uploader2.prototype.truncateName = function(name) {
      var nameElement = name;
      if (this.browserName !== "edge" && nameElement.offsetWidth < nameElement.scrollWidth) {
        this.getSlicedName(nameElement);
      } else if (nameElement.offsetWidth + 1 < nameElement.scrollWidth) {
        this.getSlicedName(nameElement);
      }
    };
    Uploader2.prototype.getFileType = function(name) {
      var extension;
      var index = name.lastIndexOf(".");
      if (index >= 0) {
        extension = name.substring(index + 1);
      }
      return extension ? extension : "";
    };
    Uploader2.prototype.getFileNameOnly = function(name) {
      var type = this.getFileType(name);
      var names = name.split("." + type);
      return type = names[0];
    };
    Uploader2.prototype.setInitialAttributes = function() {
      if (this.initialAttr.accept) {
        this.element.setAttribute("accept", this.initialAttr.accept);
      }
      if (this.initialAttr.disabled) {
        this.element.setAttribute("disabled", "disabled");
      }
      if (this.initialAttr.multiple) {
        var newAttr = document.createAttribute("multiple");
        this.element.setAttributeNode(newAttr);
      }
    };
    Uploader2.prototype.filterfileList = function(files) {
      var filterFiles = [];
      var li;
      for (var i = 0; i < files.length; i++) {
        li = this.getLiElement(files[i]);
        if (!isNullOrUndefined(li) && !li.classList.contains(UPLOAD_SUCCESS)) {
          filterFiles.push(files[i]);
        } else if (!this.showFileList && files[i].status !== "File uploaded successfully") {
          filterFiles.push(files[i]);
        }
      }
      return filterFiles;
    };
    Uploader2.prototype.updateStatus = function(files, status, statusCode, updateLiStatus) {
      if (updateLiStatus === void 0) {
        updateLiStatus = true;
      }
      if (!(status === "" || isNullOrUndefined(status)) && !(statusCode === "" || isNullOrUndefined(statusCode))) {
        files.status = status;
        files.statusCode = statusCode;
      }
      if (updateLiStatus) {
        var li = this.getLiElement(files);
        if (!isNullOrUndefined(li)) {
          if (!isNullOrUndefined(li.querySelector("." + STATUS)) && !(status === "" || isNullOrUndefined(status))) {
            li.querySelector("." + STATUS).textContent = status;
          }
        }
      }
      return files;
    };
    Uploader2.prototype.getLiElement = function(files) {
      var index;
      for (var i = 0; i < this.filesData.length; i++) {
        if (!isNullOrUndefined(files) && (!isNullOrUndefined(this.filesData[i].id) && !isNullOrUndefined(files.id) ? this.filesData[i].name === files.name && this.filesData[i].id === files.id : this.filesData[i].name === files.name)) {
          index = i;
        }
      }
      return this.fileList[index];
    };
    Uploader2.prototype.createProgressBar = function(liElement) {
      var progressbarWrapper = this.createElement("span", { className: PROGRESS_WRAPPER });
      var progressBar = this.createElement("progressbar", { className: PROGRESSBAR, attrs: { value: "0", max: "100" } });
      var progressbarInnerWrapper = this.createElement("span", { className: PROGRESS_INNER_WRAPPER });
      progressBar.setAttribute("style", "width: 0%");
      var progressbarText = this.createElement("span", { className: PROGRESSBAR_TEXT });
      progressbarText.textContent = "0%";
      progressbarInnerWrapper.appendChild(progressBar);
      progressbarWrapper.appendChild(progressbarInnerWrapper);
      progressbarWrapper.appendChild(progressbarText);
      liElement.querySelector("." + TEXT_CONTAINER).appendChild(progressbarWrapper);
    };
    Uploader2.prototype.updateProgressbar = function(e, li) {
      if (!isNaN(Math.round(e.loaded / e.total * 100)) && !isNullOrUndefined(li.querySelector("." + PROGRESSBAR))) {
        if (!isNullOrUndefined(this.progressInterval) && this.progressInterval !== "") {
          var value = Math.round(e.loaded / e.total * 100) % parseInt(this.progressInterval, 10);
          if (value === 0 || value === 100) {
            this.changeProgressValue(li, Math.round(e.loaded / e.total * 100).toString() + "%");
          }
        } else {
          this.changeProgressValue(li, Math.round(e.loaded / e.total * 100).toString() + "%");
        }
      }
    };
    Uploader2.prototype.changeProgressValue = function(li, progressValue) {
      li.querySelector("." + PROGRESSBAR).setAttribute("style", "width:" + progressValue);
      li.querySelector("." + PROGRESSBAR_TEXT).textContent = progressValue;
    };
    Uploader2.prototype.uploadInProgress = function(e, files, customUI, request) {
      var li = this.getLiElement(files);
      if (isNullOrUndefined(li) && !customUI) {
        return;
      }
      if (!isNullOrUndefined(li)) {
        if (files.statusCode === "5") {
          this.cancelUploadingFile(files, e, request, li);
        }
        if (!(li.querySelectorAll("." + PROGRESS_WRAPPER).length > 0) && li.querySelector("." + STATUS)) {
          li.querySelector("." + STATUS).classList.add(UPLOAD_INPROGRESS);
          this.createProgressBar(li);
          this.updateProgressBarClasses(li, UPLOAD_INPROGRESS);
          li.querySelector("." + STATUS).classList.remove(UPLOAD_FAILED);
        }
        this.updateProgressbar(e, li);
        var iconEle = li.querySelector("." + REMOVE_ICON);
        if (!isNullOrUndefined(iconEle)) {
          iconEle.classList.add(ABORT_ICON, UPLOAD_INPROGRESS);
          iconEle.setAttribute("title", this.localizedTexts("abort"));
          iconEle.classList.remove(REMOVE_ICON);
        }
      } else {
        this.cancelUploadingFile(files, e, request);
      }
      var args = { e, operation: "upload", file: this.updateStatus(files, this.localizedTexts("inProgress"), "3") };
      this.trigger("progress", args);
    };
    Uploader2.prototype.cancelUploadingFile = function(files, e, request, li) {
      var _this = this;
      if (files.statusCode === "5") {
        var eventArgs = {
          event: e,
          fileData: files,
          cancel: false,
          customFormData: [],
          currentRequest: null
        };
        this.trigger("canceling", eventArgs, function(eventArgs2) {
          if (eventArgs2.cancel) {
            files.statusCode = "3";
            if (!isNullOrUndefined(li)) {
              var spinnerTarget = li.querySelector("." + ABORT_ICON);
              if (!isNullOrUndefined(spinnerTarget)) {
                hideSpinner(spinnerTarget);
                detach(li.querySelector(".e-spinner-pane"));
              }
            }
          } else {
            request.emitError = false;
            request.httpRequest.abort();
            var formData = new FormData();
            if (files.statusCode === "5") {
              var name_1 = _this.element.getAttribute("name");
              formData.append(name_1, files.name);
              formData.append("cancel-uploading", files.name);
              _this.updateFormData(formData, eventArgs2.customFormData);
              var ajax_1 = new Ajax(_this.asyncSettings.removeUrl, "POST", true, null);
              ajax_1.emitError = false;
              ajax_1.beforeSend = function(e2) {
                if (eventArgs2.currentRequest) {
                  _this.updateCustomheader(ajax_1.httpRequest, eventArgs2.currentRequest);
                }
              };
              ajax_1.onLoad = function(e2) {
                _this.removecanceledFile(e2, files);
                return {};
              };
              ajax_1.send(formData);
            }
          }
        });
      }
    };
    Uploader2.prototype.removecanceledFile = function(e, file) {
      var liElement = this.getLiElement(file);
      if (isNullOrUndefined(liElement) || liElement.querySelector("." + RETRY_ICON) || isNullOrUndefined(liElement.querySelector("." + ABORT_ICON))) {
        return;
      }
      this.updateStatus(file, this.localizedTexts("fileUploadCancel"), "5");
      this.renderFailureState(e, file, liElement);
      var spinnerTarget = liElement.querySelector("." + REMOVE_ICON);
      if (!isNullOrUndefined(liElement)) {
        hideSpinner(spinnerTarget);
        if (!isNullOrUndefined(liElement.querySelector(".e-spinner-pane"))) {
          detach(liElement.querySelector(".e-spinner-pane"));
        }
      }
      var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
      var args = { event: e, response: requestResponse, operation: "cancel", file };
      this.trigger("success", args);
    };
    Uploader2.prototype.renderFailureState = function(e, file, liElement) {
      var _this = this;
      this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
      this.removeProgressbar(liElement, "failure");
      if (!isNullOrUndefined(liElement.querySelector(".e-file-status"))) {
        liElement.querySelector(".e-file-status").classList.add(UPLOAD_FAILED);
      }
      var deleteIcon = liElement.querySelector("." + ABORT_ICON);
      if (isNullOrUndefined(deleteIcon)) {
        return;
      }
      deleteIcon.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
      deleteIcon.classList.add(REMOVE_ICON);
      deleteIcon.setAttribute("title", this.localizedTexts("remove"));
      this.pauseButton = this.createElement("span", { className: "e-icons e-file-reload-btn", attrs: { "tabindex": this.btnTabIndex } });
      deleteIcon.parentElement.insertBefore(this.pauseButton, deleteIcon);
      this.pauseButton.setAttribute("title", this.localizedTexts("retry"));
      this.pauseButton.setAttribute("aria-label", this.localizedTexts("retry"));
      var retryElement = liElement.querySelector("." + RETRY_ICON);
      retryElement.addEventListener("click", function(e2) {
        _this.reloadcanceledFile(e2, file, liElement, false);
      }, false);
    };
    Uploader2.prototype.reloadcanceledFile = function(e, file, liElement, custom) {
      file.statusCode = "1";
      file.status = this.localizedTexts("readyToUploadMessage");
      if (!custom) {
        if (!isNullOrUndefined(liElement.querySelector("." + STATUS))) {
          liElement.querySelector("." + STATUS).classList.remove(UPLOAD_FAILED);
        }
        if (!isNullOrUndefined(liElement.querySelector("." + RETRY_ICON))) {
          detach(liElement.querySelector("." + RETRY_ICON));
        }
        this.pauseButton = null;
      }
      if (!isNullOrUndefined(liElement)) {
        liElement.classList.add(RESTRICT_RETRY);
      }
      this.upload([file]);
    };
    Uploader2.prototype.uploadComplete = function(e, file, customUI) {
      var status = e.target;
      if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
        var li = this.getLiElement(file);
        if (isNullOrUndefined(li) && (!customUI || isNullOrUndefined(customUI)) && this.showFileList) {
          return;
        }
        if (!isNullOrUndefined(li)) {
          this.updateProgressBarClasses(li, UPLOAD_SUCCESS);
          this.removeProgressbar(li, "success");
          var iconEle = li.querySelector("." + ABORT_ICON);
          if (!isNullOrUndefined(iconEle)) {
            iconEle.classList.add(DELETE_ICON);
            iconEle.setAttribute("title", this.localizedTexts("delete"));
            iconEle.setAttribute("aria-label", this.localizedTexts("delete"));
            iconEle.classList.remove(ABORT_ICON);
            iconEle.classList.remove(UPLOAD_INPROGRESS);
          }
        }
        this.raiseSuccessEvent(e, file);
      } else {
        this.uploadFailed(e, file);
      }
    };
    Uploader2.prototype.getResponse = function(e) {
      var target = e.currentTarget;
      var response = {
        readyState: target.readyState,
        statusCode: target.status,
        statusText: target.statusText,
        headers: target.getAllResponseHeaders(),
        withCredentials: target.withCredentials
      };
      return response;
    };
    Uploader2.prototype.raiseSuccessEvent = function(e, file) {
      var _this = this;
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var statusMessage = this.localizedTexts("uploadSuccessMessage");
      var args = {
        e,
        response,
        operation: "upload",
        file: this.updateStatus(file, statusMessage, "2", false),
        statusText: statusMessage
      };
      var liElement = this.getLiElement(file);
      if (!isNullOrUndefined(liElement)) {
        var spinnerEle = liElement.querySelector("." + SPINNER_PANE);
        if (!isNullOrUndefined(spinnerEle)) {
          hideSpinner(liElement);
          detach(spinnerEle);
        }
      }
      this.trigger("success", args, function(args2) {
        _this.updateStatus(file, args2.statusText, "2");
        _this.multiple ? _this.uploadedFilesData.push(file) : _this.uploadedFilesData = [file];
        _this.trigger("change", { file: _this.uploadedFilesData });
        _this.checkActionButtonStatus();
        if (_this.fileList.length > 0) {
          if (!_this.getLiElement(file).classList.contains(RESTRICT_RETRY)) {
            _this.uploadSequential();
            _this.checkActionComplete(true);
          } else {
            _this.getLiElement(file).classList.remove(RESTRICT_RETRY);
          }
        } else if (!_this.showFileList) {
          _this.checkActionComplete(true);
        }
      });
    };
    Uploader2.prototype.uploadFailed = function(e, file) {
      var _this = this;
      var li = this.getLiElement(file);
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var statusMessage = this.localizedTexts("uploadFailedMessage");
      var args = {
        e,
        response,
        operation: "upload",
        file: this.updateStatus(file, statusMessage, "0", false),
        statusText: statusMessage
      };
      if (!isNullOrUndefined(li)) {
        this.renderFailureState(e, file, li);
      }
      this.trigger("failure", args, function(args2) {
        _this.updateStatus(file, args2.statusText, "0");
        _this.checkActionButtonStatus();
        _this.uploadSequential();
        _this.checkActionComplete(true);
      });
    };
    Uploader2.prototype.uploadSequential = function() {
      if (this.sequentialUpload) {
        if (this.autoUpload) {
          this.checkAutoUpload(this.filesData);
        } else {
          this.uploadButtonClick();
        }
      }
    };
    Uploader2.prototype.checkActionComplete = function(increment) {
      if (increment) {
        ++this.actionCompleteCount;
      } else {
        --this.actionCompleteCount;
      }
      this.raiseActionComplete();
    };
    Uploader2.prototype.raiseActionComplete = function() {
      if (this.filesData.length === this.actionCompleteCount && this.flag) {
        this.flag = false;
        var eventArgs = {
          fileData: []
        };
        eventArgs.fileData = this.getSelectedFileStatus(this.selectedFiles);
        this.trigger("actionComplete", eventArgs);
      }
    };
    Uploader2.prototype.getSelectedFileStatus = function(selectedFiles) {
      var matchFiles = [];
      var matchFilesIndex = 0;
      for (var selectFileIndex = 0; selectFileIndex < selectedFiles.length; selectFileIndex++) {
        var selectedFileData = selectedFiles[selectFileIndex];
        for (var fileDataIndex = 0; fileDataIndex < this.filesData.length; fileDataIndex++) {
          if (this.filesData[fileDataIndex].name === selectedFileData.name && this.filesData[fileDataIndex].status === selectedFileData.status) {
            matchFiles[matchFilesIndex] = this.filesData[fileDataIndex];
            ++matchFilesIndex;
          }
        }
      }
      return matchFiles;
    };
    Uploader2.prototype.updateProgressBarClasses = function(li, className) {
      var progressBar = li.querySelector("." + PROGRESSBAR);
      if (!isNullOrUndefined(progressBar)) {
        progressBar.classList.add(className);
      }
    };
    Uploader2.prototype.removeProgressbar = function(li, callType) {
      var _this = this;
      if (!isNullOrUndefined(li.querySelector("." + PROGRESS_WRAPPER))) {
        this.progressAnimation = new Animation({ duration: 1250 });
        this.progressAnimation.animate(li.querySelector("." + PROGRESS_WRAPPER), { name: "FadeOut" });
        this.progressAnimation.animate(li.querySelector("." + PROGRESSBAR_TEXT), { name: "FadeOut" });
        setTimeout(function() {
          _this.animateProgressBar(li, callType);
        }, 750);
      }
    };
    Uploader2.prototype.animateProgressBar = function(li, callType) {
      if (callType === "success") {
        li.classList.add(UPLOAD_SUCCESS);
        if (!isNullOrUndefined(li.querySelector("." + STATUS))) {
          li.querySelector("." + STATUS).classList.remove(UPLOAD_INPROGRESS);
          this.progressAnimation.animate(li.querySelector("." + STATUS), { name: "FadeIn" });
          li.querySelector("." + STATUS).classList.add(UPLOAD_SUCCESS);
        }
      } else {
        if (!isNullOrUndefined(li.querySelector("." + STATUS))) {
          li.querySelector("." + STATUS).classList.remove(UPLOAD_INPROGRESS);
          this.progressAnimation.animate(li.querySelector("." + STATUS), { name: "FadeIn" });
          li.querySelector("." + STATUS).classList.add(UPLOAD_FAILED);
        }
      }
      if (li.querySelector("." + PROGRESS_WRAPPER)) {
        detach(li.querySelector("." + PROGRESS_WRAPPER));
      }
    };
    Uploader2.prototype.setExtensions = function(extensions) {
      if (extensions !== "" && !isNullOrUndefined(extensions)) {
        this.element.setAttribute("accept", extensions);
      } else {
        this.element.removeAttribute("accept");
      }
    };
    Uploader2.prototype.templateComplier = function(uploadTemplate) {
      if (uploadTemplate) {
        try {
          if (typeof uploadTemplate !== "function" && selectAll(uploadTemplate, document).length) {
            return compile(select(uploadTemplate, document).innerHTML.trim());
          } else {
            return compile(uploadTemplate);
          }
        } catch (exception) {
          return compile(uploadTemplate);
        }
      }
      return void 0;
    };
    Uploader2.prototype.setRTL = function() {
      if (this.enableRtl) {
        addClass([this.uploadWrapper], RTL6);
      } else {
        removeClass([this.uploadWrapper], RTL6);
      }
    };
    Uploader2.prototype.localizedTexts = function(localeText) {
      this.l10n.setLocale(this.locale);
      return this.l10n.getConstant(localeText);
    };
    Uploader2.prototype.setControlStatus = function() {
      if (!this.enabled) {
        this.uploadWrapper.classList.add(DISABLED4);
        this.element.setAttribute("disabled", "disabled");
        this.browseButton.setAttribute("disabled", "disabled");
        if (!isNullOrUndefined(this.clearButton)) {
          this.clearButton.setAttribute("disabled", "disabled");
        }
        if (!isNullOrUndefined(this.uploadButton)) {
          this.uploadButton.setAttribute("disabled", "disabled");
        }
      } else {
        if (this.uploadWrapper.classList.contains(DISABLED4)) {
          this.uploadWrapper.classList.remove(DISABLED4);
        }
        if (!isNullOrUndefined(this.browseButton) && this.element.hasAttribute("disabled")) {
          this.element.removeAttribute("disabled");
          this.browseButton.removeAttribute("disabled");
        }
        if (!isNullOrUndefined(this.clearButton) && this.clearButton.hasAttribute("disabled")) {
          this.clearButton.removeAttribute("disabled");
        }
        if (!isNullOrUndefined(this.uploadButton) && this.uploadButton.hasAttribute("disabled")) {
          this.uploadButton.hasAttribute("disabled");
        }
      }
    };
    Uploader2.prototype.checkHTMLAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["accept", "multiple", "disabled"];
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(prop))) {
          switch (prop) {
            case "accept":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["allowedExtensions"] === void 0 || isDynamic) {
                this.setProperties({ allowedExtensions: this.element.getAttribute("accept") }, !isDynamic);
                this.initialAttr.accept = this.allowedExtensions;
              }
              break;
            case "multiple":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["multiple"] === void 0 || isDynamic) {
                var isMutiple = this.element.getAttribute(prop) === "multiple" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ multiple: isMutiple }, !isDynamic);
                this.initialAttr.multiple = true;
              }
              break;
            case "disabled":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["enabled"] === void 0 || isDynamic) {
                var isDisabled = this.element.getAttribute(prop) === "disabled" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled: isDisabled }, !isDynamic);
                this.initialAttr.disabled = true;
              }
          }
        }
      }
    };
    Uploader2.prototype.chunkUpload = function(file, custom, fileIndex) {
      var start = 0;
      var end = Math.min(this.asyncSettings.chunkSize, file.size);
      var index = 0;
      var blob = file.rawFile.slice(start, end);
      var metaData = { chunkIndex: index, blob, file, start, end, retryCount: 0, request: null };
      this.sendRequest(file, metaData, custom, fileIndex);
    };
    Uploader2.prototype.sendRequest = function(file, metaData, custom, fileIndex) {
      var _this = this;
      var formData = new FormData();
      var blob = file.rawFile.slice(metaData.start, metaData.end);
      formData.append(this.uploaderName, blob, file.name);
      formData.append("chunk-index", metaData.chunkIndex.toString());
      formData.append("chunkIndex", metaData.chunkIndex.toString());
      var totalChunk = Math.max(Math.ceil(file.size / this.asyncSettings.chunkSize), 1);
      formData.append("total-chunk", totalChunk.toString());
      formData.append("totalChunk", totalChunk.toString());
      var ajax = new Ajax({ url: this.asyncSettings.saveUrl, type: "POST", async: true, contentType: null });
      ajax.emitError = false;
      ajax.onLoad = function(e) {
        _this.chunkUploadComplete(e, metaData, custom);
        return {};
      };
      ajax.onUploadProgress = function(e) {
        _this.chunkUploadInProgress(e, metaData, custom);
        return {};
      };
      var eventArgs = {
        fileData: file,
        customFormData: [],
        cancel: false,
        chunkSize: this.asyncSettings.chunkSize === 0 ? null : this.asyncSettings.chunkSize
      };
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        eventArgs.currentChunkIndex = metaData.chunkIndex;
        if (eventArgs.currentChunkIndex === 0) {
          _this.trigger("uploading", eventArgs, function(eventArgs2) {
            _this.uploadingEventCallback(formData, eventArgs2, e, file);
          });
        } else {
          _this.trigger("chunkUploading", eventArgs, function(eventArgs2) {
            _this.uploadingEventCallback(formData, eventArgs2, e, file);
          });
        }
      };
      ajax.onError = function(e) {
        _this.chunkUploadFailed(e, metaData, custom);
        return {};
      };
      ajax.send(formData);
      metaData.request = ajax;
    };
    Uploader2.prototype.uploadingEventCallback = function(formData, eventArgs, e, file) {
      if (eventArgs.cancel) {
        this.eventCancelByArgs(e, eventArgs, file);
      } else {
        this.updateFormData(formData, eventArgs.customFormData);
      }
    };
    Uploader2.prototype.eventCancelByArgs = function(e, eventArgs, file) {
      var _this = this;
      e.cancel = true;
      if (eventArgs.fileData.statusCode === "5") {
        return;
      }
      eventArgs.fileData.statusCode = "5";
      eventArgs.fileData.status = this.localizedTexts("fileUploadCancel");
      var liElement = this.getLiElement(eventArgs.fileData);
      if (liElement) {
        if (!isNullOrUndefined(liElement.querySelector("." + STATUS))) {
          liElement.querySelector("." + STATUS).innerHTML = this.localizedTexts("fileUploadCancel");
          liElement.querySelector("." + STATUS).classList.add(UPLOAD_FAILED);
        }
        this.pauseButton = this.createElement("span", { className: "e-icons e-file-reload-btn", attrs: { "tabindex": this.btnTabIndex } });
        var removeIcon = liElement.querySelector("." + REMOVE_ICON);
        if (removeIcon) {
          removeIcon.parentElement.insertBefore(this.pauseButton, removeIcon);
        }
        this.pauseButton.setAttribute("title", this.localizedTexts("retry"));
        this.pauseButton.addEventListener("click", function(e2) {
          _this.reloadcanceledFile(e2, file, liElement);
        }, false);
        this.checkActionButtonStatus();
      }
    };
    Uploader2.prototype.checkChunkUpload = function() {
      return this.asyncSettings.chunkSize <= 0 || isNullOrUndefined(this.asyncSettings.chunkSize) ? false : true;
    };
    Uploader2.prototype.chunkUploadComplete = function(e, metaData, custom) {
      var _this = this;
      var response = e.target;
      var liElement;
      if (response.readyState === 4 && response.status >= 200 && response.status < 300) {
        var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
        var totalChunk = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
        var eventArgs = {
          event: e,
          file: metaData.file,
          chunkIndex: metaData.chunkIndex,
          totalChunk,
          chunkSize: this.asyncSettings.chunkSize,
          response: requestResponse
        };
        this.trigger("chunkSuccess", eventArgs);
        if (isNullOrUndefined(custom) || !custom) {
          liElement = this.getLiElement(metaData.file);
        }
        this.updateMetaData(metaData);
        if (metaData.end === metaData.file.size) {
          metaData.file.statusCode = "3";
        }
        if (metaData.file.statusCode === "5") {
          var eventArgs_1 = { event: e, fileData: metaData.file, cancel: false, customFormData: [] };
          this.trigger("canceling", eventArgs_1, function(eventArgs2) {
            if (eventArgs2.cancel) {
              metaData.file.statusCode = "3";
              var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
              if (!isNullOrUndefined(liElement) && !isNullOrUndefined(spinnerTarget)) {
                hideSpinner(spinnerTarget);
                detach(liElement.querySelector(".e-spinner-pane"));
              }
              _this.sendNextRequest(metaData);
            } else {
              metaData.request.emitError = false;
              response.abort();
              var formData = new FormData();
              var name_2 = _this.element.getAttribute("name");
              formData.append(name_2, metaData.file.name);
              formData.append("cancel-uploading", metaData.file.name);
              formData.append("cancelUploading", metaData.file.name);
              _this.updateFormData(formData, eventArgs2.customFormData);
              var ajax = new Ajax(_this.asyncSettings.removeUrl, "POST", true, null);
              ajax.emitError = false;
              ajax.onLoad = function(e2) {
                _this.removeChunkFile(e2, metaData, custom);
                return {};
              };
              ajax.send(formData);
            }
          });
        } else {
          if (totalChunk - 1 === metaData.chunkIndex && totalChunk > metaData.chunkIndex) {
            var index = this.pausedData.indexOf(metaData);
            if (index >= 0) {
              this.pausedData.splice(index, 1);
            }
            if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom) && liElement) {
              if (liElement && !isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD))) {
                detach(liElement.querySelector("." + PAUSE_UPLOAD));
              }
              this.removeChunkProgressBar(metaData);
            }
            this.raiseSuccessEvent(e, metaData.file);
            return;
          }
          if (metaData.file.statusCode !== "4") {
            this.sendNextRequest(metaData);
          }
        }
      } else {
        this.chunkUploadFailed(e, metaData);
      }
    };
    Uploader2.prototype.sendNextRequest = function(metaData) {
      metaData.start = metaData.end;
      metaData.end += this.asyncSettings.chunkSize;
      metaData.end = Math.min(metaData.end, metaData.file.size);
      metaData.chunkIndex += 1;
      this.sendRequest(metaData.file, metaData);
    };
    Uploader2.prototype.removeChunkFile = function(e, metaData, custom) {
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) && !custom)) {
        var liElement = this.getLiElement(metaData.file);
        var deleteIcon = liElement.querySelector("." + ABORT_ICON);
        var spinnerTarget = deleteIcon;
        this.updateStatus(metaData.file, this.localizedTexts("fileUploadCancel"), "5");
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
        this.removeProgressbar(liElement, "failure");
        if (deleteIcon) {
          deleteIcon.classList.remove(ABORT_ICON);
          deleteIcon.classList.add(REMOVE_ICON);
          deleteIcon.setAttribute("title", this.localizedTexts("remove"));
        }
        var pauseIcon = liElement.querySelector("." + PAUSE_UPLOAD);
        if (pauseIcon) {
          pauseIcon.classList.add(RETRY_ICON);
          pauseIcon.classList.remove(PAUSE_UPLOAD);
          pauseIcon.setAttribute("title", this.localizedTexts("retry"));
        }
        if (!isNullOrUndefined(liElement) && !isNullOrUndefined(deleteIcon) && !isNullOrUndefined(liElement.querySelector(".e-spinner-pane"))) {
          hideSpinner(spinnerTarget);
          detach(liElement.querySelector(".e-spinner-pane"));
        }
      }
    };
    Uploader2.prototype.pauseUpload = function(metaData, e, custom) {
      metaData.file.statusCode = "4";
      metaData.file.status = this.localizedTexts("pause");
      this.updateMetaData(metaData);
      var eventArgs = {
        event: e ? e : null,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
        chunkSize: this.asyncSettings.chunkSize
      };
      this.abortUpload(metaData, custom, eventArgs);
    };
    Uploader2.prototype.abortUpload = function(metaData, custom, eventArgs) {
      if (metaData.file.statusCode !== "4") {
        metaData.request.emitError = false;
        metaData.request.httpRequest.abort();
      }
      var liElement = this.getLiElement(metaData.file);
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom)) {
        var targetElement2 = liElement.querySelector("." + PAUSE_UPLOAD);
        targetElement2.classList.remove(PAUSE_UPLOAD);
        targetElement2.classList.add(RESUME_UPLOAD);
        targetElement2.setAttribute("title", this.localizedTexts("resume"));
        targetElement2.nextElementSibling.classList.add(REMOVE_ICON);
        targetElement2.nextElementSibling.classList.remove(ABORT_ICON);
        targetElement2.nextElementSibling.setAttribute("title", this.localizedTexts("remove"));
      }
      for (var i = 0; i < this.pausedData.length; i++) {
        if (this.pausedData[i].file.name === metaData.file.name) {
          this.pausedData.splice(i, 1);
        }
      }
      this.pausedData.push(metaData);
      this.trigger("pausing", eventArgs);
    };
    Uploader2.prototype.resumeUpload = function(metaData, e, custom) {
      var liElement = this.getLiElement(metaData.file);
      var targetElement2;
      if (!isNullOrUndefined(liElement)) {
        targetElement2 = liElement.querySelector("." + RESUME_UPLOAD);
      }
      if (!isNullOrUndefined(targetElement2) && (isNullOrUndefined(custom) || !custom)) {
        targetElement2.classList.remove(RESUME_UPLOAD);
        targetElement2.classList.add(PAUSE_UPLOAD);
        targetElement2.setAttribute("title", this.localizedTexts("pause"));
        targetElement2.nextElementSibling.classList.remove(REMOVE_ICON);
        targetElement2.nextElementSibling.classList.add(ABORT_ICON);
        targetElement2.nextElementSibling.setAttribute("title", this.localizedTexts("abort"));
      }
      metaData.file.status = this.localizedTexts("inProgress");
      metaData.file.statusCode = "3";
      this.updateMetaData(metaData);
      var eventArgs = {
        event: e ? e : null,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
        chunkSize: this.asyncSettings.chunkSize
      };
      this.trigger("resuming", eventArgs);
      for (var i = 0; i < this.pausedData.length; i++) {
        if (this.pausedData[i].end === this.pausedData[i].file.size) {
          this.chunkUploadComplete(e, metaData, custom);
        } else {
          if (this.pausedData[i].file.name === metaData.file.name) {
            this.pausedData[i].start = this.pausedData[i].end;
            this.pausedData[i].end = this.pausedData[i].end + this.asyncSettings.chunkSize;
            this.pausedData[i].end = Math.min(this.pausedData[i].end, this.pausedData[i].file.size);
            this.pausedData[i].chunkIndex = this.pausedData[i].chunkIndex + 1;
            this.sendRequest(this.pausedData[i].file, this.pausedData[i], custom);
          }
        }
      }
    };
    Uploader2.prototype.updateMetaData = function(metaData) {
      if (this.uploadMetaData.indexOf(metaData) === -1) {
        this.uploadMetaData.push(metaData);
      } else {
        this.uploadMetaData.splice(this.uploadMetaData.indexOf(metaData), 1);
        this.uploadMetaData.push(metaData);
      }
    };
    Uploader2.prototype.removeChunkProgressBar = function(metaData) {
      var liElement = this.getLiElement(metaData.file);
      if (!isNullOrUndefined(liElement)) {
        this.updateProgressBarClasses(liElement, UPLOAD_SUCCESS);
        this.removeProgressbar(liElement, "success");
        var cancelButton = liElement.querySelector("." + ABORT_ICON);
        if (!isNullOrUndefined(cancelButton)) {
          cancelButton.classList.add(DELETE_ICON);
          cancelButton.setAttribute("title", this.localizedTexts("delete"));
          cancelButton.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
        }
      }
    };
    Uploader2.prototype.chunkUploadFailed = function(e, metaData, custom) {
      var _this = this;
      var chunkCount = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
      var liElement;
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom)) {
        liElement = this.getLiElement(metaData.file);
      }
      var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
      var eventArgs = {
        event: e,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        totalChunk: chunkCount,
        chunkSize: this.asyncSettings.chunkSize,
        cancel: false,
        response: requestResponse
      };
      this.trigger("chunkFailure", eventArgs, function(eventArgs2) {
        if (!eventArgs2.cancel) {
          if (metaData.retryCount < _this.asyncSettings.retryCount) {
            setTimeout(function() {
              _this.retryRequest(liElement, metaData, custom);
            }, _this.asyncSettings.retryAfterDelay);
          } else {
            if (!isNullOrUndefined(liElement)) {
              var pauseButton = liElement.querySelector("." + PAUSE_UPLOAD) ? liElement.querySelector("." + PAUSE_UPLOAD) : liElement.querySelector("." + RESUME_UPLOAD);
              if (!isNullOrUndefined(pauseButton)) {
                pauseButton.classList.add(RETRY_ICON);
                pauseButton.classList.remove(PAUSE_UPLOAD, RESUME_UPLOAD);
              }
              _this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
              _this.removeProgressbar(liElement, "failure");
              liElement.querySelector(".e-icons").classList.remove(UPLOAD_INPROGRESS);
              var iconElement = liElement.querySelector("." + ABORT_ICON) ? liElement.querySelector("." + ABORT_ICON) : liElement.querySelector("." + REMOVE_ICON);
              iconElement.classList.remove(ABORT_ICON);
              if (!isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD))) {
                detach(liElement.querySelector("." + PAUSE_UPLOAD));
              }
              if (metaData.start > 0) {
                iconElement.classList.add(DELETE_ICON);
                iconElement.setAttribute("title", _this.localizedTexts("delete"));
              } else {
                iconElement.classList.add(REMOVE_ICON);
                iconElement.setAttribute("title", _this.localizedTexts("remove"));
              }
            }
            metaData.retryCount = 0;
            var file_1 = metaData.file;
            var failureMessage = _this.localizedTexts("uploadFailedMessage");
            var args = {
              e,
              response: requestResponse,
              operation: "upload",
              file: _this.updateStatus(file_1, failureMessage, "0", false),
              statusText: failureMessage
            };
            _this.trigger("failure", args, function(args2) {
              _this.updateStatus(file_1, args2.statusText, "0");
              _this.uploadSequential();
              _this.checkActionComplete(true);
            });
          }
        }
      });
    };
    Uploader2.prototype.retryRequest = function(liElement, metaData, custom) {
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom) && liElement) {
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
      }
      metaData.retryCount += 1;
      this.sendRequest(metaData.file, metaData);
    };
    Uploader2.prototype.checkPausePlayAction = function(e) {
      var targetElement2 = e.target;
      var selectedElement = e.target.parentElement;
      var index = this.fileList.indexOf(selectedElement);
      var fileData = this.filesData[index];
      var metaData = this.getCurrentMetaData(fileData);
      if (targetElement2.classList.contains(PAUSE_UPLOAD)) {
        this.pauseUpload(metaData, e);
      } else if (targetElement2.classList.contains(RESUME_UPLOAD)) {
        this.resumeUpload(metaData, e);
      } else if (targetElement2.classList.contains(RETRY_ICON)) {
        if (metaData.file.status === this.localizedTexts("fileUploadCancel")) {
          this.retryUpload(metaData, false);
        } else {
          this.retryUpload(metaData, true);
        }
      }
    };
    Uploader2.prototype.retryUpload = function(metaData, fromcanceledStage) {
      if (fromcanceledStage) {
        metaData.end = metaData.end + this.asyncSettings.chunkSize;
        metaData.start = metaData.start + this.asyncSettings.chunkSize;
        this.sendRequest(metaData.file, metaData);
      } else {
        metaData.file.statusCode = "1";
        metaData.file.status = this.localizedTexts("readyToUploadMessage");
        this.chunkUpload(metaData.file);
      }
      this.getLiElement(metaData.file).classList.add(RESTRICT_RETRY);
    };
    Uploader2.prototype.chunkUploadInProgress = function(e, metaData, custom) {
      var _this = this;
      if (metaData.file.statusCode === "4") {
        return;
      }
      if (metaData.file.statusCode !== "4" && metaData.file.statusCode !== "5") {
        metaData.file.statusCode = "3";
        metaData.file.status = this.localizedTexts("inProgress");
      }
      this.updateMetaData(metaData);
      var liElement = this.getLiElement(metaData.file);
      if (isNullOrUndefined(liElement)) {
        return;
      }
      var retryElement = liElement.querySelector("." + RETRY_ICON);
      if (!isNullOrUndefined(retryElement)) {
        retryElement.classList.add(PAUSE_UPLOAD);
        retryElement.setAttribute("title", this.localizedTexts("pause"));
        retryElement.classList.remove(RETRY_ICON);
      }
      if (!isNullOrUndefined(liElement)) {
        if (!(liElement.querySelectorAll("." + PROGRESS_WRAPPER).length > 0)) {
          var statusElement = liElement.querySelector("." + STATUS);
          if (isNullOrUndefined(this.template)) {
            statusElement.classList.add(UPLOAD_INPROGRESS);
            statusElement.classList.remove(UPLOAD_FAILED);
            this.createProgressBar(liElement);
            this.updateProgressBarClasses(liElement, UPLOAD_INPROGRESS);
          }
          var clearIcon = liElement.querySelector("." + REMOVE_ICON) ? liElement.querySelector("." + REMOVE_ICON) : liElement.querySelector("." + DELETE_ICON);
          if (!isNullOrUndefined(clearIcon)) {
            clearIcon.classList.add(ABORT_ICON);
            clearIcon.setAttribute("title", this.localizedTexts("abort"));
            clearIcon.classList.remove(REMOVE_ICON);
          }
        }
        if (!isNaN(Math.round(e.loaded / e.total * 100)) && isNullOrUndefined(this.template) && metaData.file.statusCode !== "4") {
          var progressVal = void 0;
          var totalChunks = Math.ceil(metaData.file.size / this.asyncSettings.chunkSize) - 1;
          if (this.asyncSettings.chunkSize && totalChunks) {
            progressVal = Math.round(metaData.chunkIndex / totalChunks * 100);
            this.changeProgressValue(liElement, progressVal.toString() + "%");
          }
        }
        if (metaData.chunkIndex === 0) {
          this.checkActionButtonStatus();
        }
      }
      if (isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD)) && isNullOrUndefined(this.template) && isNullOrUndefined(liElement.querySelector("." + DELETE_ICON))) {
        this.pauseButton = this.createElement("span", { className: "e-icons e-file-pause-btn", attrs: { "tabindex": this.btnTabIndex } });
        if (this.browserName === "msie") {
          this.pauseButton.classList.add("e-msie");
        }
        var abortIcon = liElement.querySelector("." + ABORT_ICON);
        abortIcon.parentElement.insertBefore(this.pauseButton, abortIcon);
        this.pauseButton.setAttribute("title", this.localizedTexts("pause"));
        this.pauseButton.addEventListener("click", function(e2) {
          _this.checkPausePlayAction(e2);
        }, false);
      }
    };
    Uploader2.prototype.bytesToSize = function(bytes) {
      var i = -1;
      if (!bytes) {
        return "0.0 KB";
      }
      do {
        bytes = bytes / 1024;
        i++;
      } while (bytes > 99);
      if (i >= 2) {
        bytes = bytes * 1024;
        i = 1;
      }
      return Math.max(bytes, 0).toFixed(1) + " " + ["KB", "MB"][i];
    };
    Uploader2.prototype.sortFileList = function(filesData) {
      filesData = filesData ? filesData : this.sortFilesList;
      var files = filesData;
      var fileNames = [];
      for (var i = 0; i < files.length; i++) {
        fileNames.push(files[i].name);
      }
      var sortedFileNames = fileNames.sort();
      var sortedFilesData = [];
      for (var _i = 0, sortedFileNames_1 = sortedFileNames; _i < sortedFileNames_1.length; _i++) {
        var name_3 = sortedFileNames_1[_i];
        for (var i = 0; i < files.length; i++) {
          if (name_3 === files[i].name) {
            sortedFilesData.push(files[i]);
          }
        }
      }
      return sortedFilesData;
    };
    Uploader2.prototype.destroy = function() {
      this.element.value = null;
      this.clearTemplate();
      this.clearAll();
      this.unWireEvents();
      this.unBindDropEvents();
      if (this.multiple) {
        this.element.removeAttribute("multiple");
      }
      if (!this.enabled) {
        this.element.removeAttribute("disabled");
      }
      this.element.removeAttribute("accept");
      this.setInitialAttributes();
      var attributes2 = ["aria-label", "directory", "webkitdirectory", "tabindex"];
      for (var _i = 0, attributes_2 = attributes2; _i < attributes_2.length; _i++) {
        var key = attributes_2[_i];
        this.element.removeAttribute(key);
      }
      if (!isNullOrUndefined(this.uploadWrapper)) {
        this.uploadWrapper.parentElement.appendChild(this.element);
        detach(this.uploadWrapper);
      }
      this.uploadWrapper = null;
      this.uploadWrapper = null;
      this.browseButton = null;
      this.dropAreaWrapper = null;
      this.dropZoneElement = null;
      this.dropArea = null;
      this.keyboardModule = null;
      this.clearButton = null;
      this.uploadButton = null;
      _super.prototype.destroy.call(this);
    };
    Uploader2.prototype.upload = function(files, custom) {
      var _this = this;
      files = files ? files : this.filesData;
      if (this.sequentialUpload && (this.isFirstFileOnSelection || custom)) {
        this.sequenceUpload(files);
      } else {
        var uploadFiles_1 = this.getFilesInArray(files);
        var eventArgs = {
          customFormData: [],
          currentRequest: null,
          cancel: false
        };
        this.trigger("beforeUpload", eventArgs, function(eventArgs2) {
          if (!eventArgs2.cancel) {
            _this.uploadFiles(uploadFiles_1, custom);
          }
        });
      }
    };
    Uploader2.prototype.getFilesInArray = function(files) {
      var uploadFiles = [];
      if (files instanceof Array) {
        uploadFiles = files;
      } else {
        uploadFiles.push(files);
      }
      return uploadFiles;
    };
    Uploader2.prototype.serverReadFileBase64 = function(fileIndex, position, totalCount) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var file = _this.fileStreams[fileIndex].rawFile;
        try {
          var reader = new FileReader();
          reader.onload = /* @__PURE__ */ function(args) {
            return function() {
              try {
                var contents = args.result;
                var data = contents ? contents.split(";base64,")[1] : null;
                resolve(data);
              } catch (e) {
                reject(e);
              }
            };
          }(reader);
          reader.readAsDataURL(file.slice(position, position + totalCount));
        } catch (e) {
          reject(e);
        }
      });
    };
    Uploader2.prototype.uploadFileCount = function(ele) {
      var files = this.filesData;
      if (!files || files.length === 0) {
        return -1;
      }
      var result = files.length;
      return result;
    };
    Uploader2.prototype.getFileRead = function(index, ele) {
      var files = this.filesData;
      if (!files || files.length === 0) {
        return -1;
      }
      var file = files[index];
      var fileCount = this.newFileRef++;
      this.fileStreams[fileCount] = file;
      return fileCount;
    };
    Uploader2.prototype.uploadFiles = function(files, custom) {
      var selectedFiles = [];
      if (this.asyncSettings.saveUrl === "" || isNullOrUndefined(this.asyncSettings.saveUrl)) {
        return;
      }
      if (!custom || isNullOrUndefined(custom)) {
        if (!this.multiple) {
          var file = [];
          file.push(files[0]);
          selectedFiles = this.filterfileList(file);
        } else {
          selectedFiles = this.filterfileList(files);
        }
      } else {
        selectedFiles = files;
      }
      for (var i = 0; i < selectedFiles.length; i++) {
        this.uploadFilesRequest(selectedFiles, i, custom);
      }
    };
    Uploader2.prototype.uploadFilesRequest = function(selectedFiles, i, custom) {
      var _this = this;
      var chunkEnabled = this.checkChunkUpload();
      var ajax = new Ajax(this.asyncSettings.saveUrl, "POST", true, null);
      ajax.emitError = false;
      var eventArgs = {
        fileData: selectedFiles[i],
        customFormData: [],
        cancel: false
      };
      var formData = new FormData();
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        _this.trigger("uploading", eventArgs, function(eventArgs2) {
          if (eventArgs2.cancel) {
            _this.eventCancelByArgs(e, eventArgs2, selectedFiles[i]);
          }
          _this.updateFormData(formData, eventArgs2.customFormData);
        });
      };
      if (selectedFiles[i].statusCode === "1") {
        var name_4 = this.element.getAttribute("name");
        formData.append(name_4, selectedFiles[i].rawFile, selectedFiles[i].name);
        if (chunkEnabled && selectedFiles[i].size > this.asyncSettings.chunkSize) {
          this.chunkUpload(selectedFiles[i], custom, i);
        } else {
          ajax.onLoad = function(e) {
            if (eventArgs.cancel) {
              return {};
            } else {
              _this.uploadComplete(e, selectedFiles[i], custom);
              return {};
            }
          };
          ajax.onUploadProgress = function(e) {
            if (eventArgs.cancel) {
              return {};
            } else {
              _this.uploadInProgress(e, selectedFiles[i], custom, ajax);
              return {};
            }
          };
          ajax.onError = function(e) {
            _this.uploadFailed(e, selectedFiles[i]);
            return {};
          };
          ajax.send(formData);
        }
      }
    };
    Uploader2.prototype.spliceFiles = function(liIndex) {
      var liElement = this.fileList[liIndex];
      var allFiles = this.getFilesData();
      var nameElements = +liElement.getAttribute("data-files-count");
      var startIndex = 0;
      for (var i = 0; i < liIndex; i++) {
        startIndex += +this.fileList[i].getAttribute("data-files-count");
      }
      var endIndex = startIndex + nameElements - 1;
      for (var j = endIndex; j >= startIndex; j--) {
        allFiles.splice(j, 1);
      }
    };
    Uploader2.prototype.remove = function(fileData, customTemplate, removeDirectly, postRawFile, args) {
      var _this = this;
      if (isNullOrUndefined(postRawFile)) {
        postRawFile = true;
      }
      var eventArgs = {
        event: args,
        cancel: false,
        filesData: [],
        customFormData: [],
        postRawFile,
        currentRequest: null
      };
      var beforeEventArgs = {
        cancel: false,
        customFormData: [],
        currentRequest: null
      };
      this.trigger("beforeRemove", beforeEventArgs, function(beforeEventArgs2) {
        if (!beforeEventArgs2.cancel) {
          if (_this.isFormUpload()) {
            eventArgs.filesData = fileData;
            _this.trigger("removing", eventArgs, function(eventArgs2) {
              if (!eventArgs2.cancel) {
                var removingFiles = _this.getFilesInArray(fileData);
                var isLiRemoved = false;
                var liIndex = void 0;
                for (var _i2 = 0, removingFiles_1 = removingFiles; _i2 < removingFiles_1.length; _i2++) {
                  var data = removingFiles_1[_i2];
                  if (!isLiRemoved) {
                    liIndex = _this.fileList.indexOf(data.list);
                  }
                  if (liIndex > -1) {
                    var inputElement = !isNullOrUndefined(data.input) ? data.input : null;
                    if (inputElement) {
                      detach(inputElement);
                    }
                    _this.spliceFiles(liIndex);
                    detach(_this.fileList[liIndex]);
                    _this.fileList.splice(liIndex, 1);
                    isLiRemoved = true;
                    liIndex = -1;
                  }
                }
              }
            });
          } else if (_this.isForm && (isNullOrUndefined(_this.asyncSettings.removeUrl) || _this.asyncSettings.removeUrl === "")) {
            eventArgs.filesData = _this.getFilesData();
            _this.trigger("removing", eventArgs, function(eventArgs2) {
              if (!eventArgs2.cancel) {
                _this.clearAll();
              }
            });
          } else {
            var removeFiles = [];
            fileData = !isNullOrUndefined(fileData) ? fileData : _this.filesData;
            if (fileData instanceof Array) {
              removeFiles = fileData;
            } else {
              removeFiles.push(fileData);
            }
            eventArgs.filesData = removeFiles;
            var removeUrl = _this.asyncSettings.removeUrl;
            var validUrl = removeUrl === "" || isNullOrUndefined(removeUrl) ? false : true;
            var _loop_5 = function(files2) {
              var fileUploadedIndex = _this.uploadedFilesData.indexOf(files2);
              if ((files2.statusCode === "2" || files2.statusCode === "4" || files2.statusCode === "0" && fileUploadedIndex !== -1) && validUrl) {
                _this.removeUploadedFile(files2, eventArgs, removeDirectly, customTemplate);
              } else {
                if (!removeDirectly) {
                  _this.trigger("removing", eventArgs, function(eventArgs2) {
                    if (!eventArgs2.cancel) {
                      _this.removeFilesData(files2, customTemplate);
                    }
                  });
                } else {
                  _this.removeFilesData(files2, customTemplate);
                }
              }
              if (args && !args.target.classList.contains(REMOVE_ICON)) {
                _this.checkActionComplete(false);
              }
            };
            for (var _i = 0, removeFiles_1 = removeFiles; _i < removeFiles_1.length; _i++) {
              var files = removeFiles_1[_i];
              _loop_5(files);
            }
          }
        }
      });
    };
    Uploader2.prototype.clearAll = function() {
      var _this = this;
      if (isNullOrUndefined(this.listParent)) {
        if (this.browserName !== "msie") {
          this.element.value = "";
        }
        this.filesData = [];
        return;
      }
      var eventArgs = {
        cancel: false,
        filesData: this.filesData
      };
      this.trigger("clearing", eventArgs, function(eventArgs2) {
        if (!eventArgs2.cancel) {
          _this.clearData();
          _this.actionCompleteCount = 0;
          _this.count = -1;
        }
      });
    };
    Uploader2.prototype.getFilesData = function(index) {
      if (isNullOrUndefined(index)) {
        return this.filesData;
      } else {
        return this.getSelectedFiles(index);
      }
    };
    Uploader2.prototype.pause = function(fileData, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      this.pauseUploading(fileDataFiles, custom);
    };
    Uploader2.prototype.pauseUploading = function(fileData, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "3") {
          this.pauseUpload(this.getCurrentMetaData(files[i], null), null, custom);
        }
      }
    };
    Uploader2.prototype.getFiles = function(fileData) {
      var files = [];
      if (!isNullOrUndefined(fileData) && !(fileData instanceof Array)) {
        files.push(fileData);
      } else {
        files = fileData;
      }
      return files;
    };
    Uploader2.prototype.resume = function(fileData, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      this.resumeFiles(fileDataFiles, custom);
    };
    Uploader2.prototype.resumeFiles = function(fileData, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "4") {
          this.resumeUpload(this.getCurrentMetaData(files[i], null), null, custom);
        }
      }
    };
    Uploader2.prototype.retry = function(fileData, fromcanceledStage, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      if (this.sequentialUpload && this.isFirstFileOnSelection) {
        this.isFirstFileOnSelection = false;
      }
      this.retryFailedFiles(fileDataFiles, fromcanceledStage, custom);
    };
    Uploader2.prototype.retryFailedFiles = function(fileData, fromcanceledStage, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "5" || files[i].statusCode === "0") {
          if (this.asyncSettings.chunkSize > 0 && this.getCurrentMetaData(files[i], null)) {
            this.retryUpload(this.getCurrentMetaData(files[i], null), fromcanceledStage);
          } else {
            var liElement = void 0;
            if (!custom) {
              liElement = this.fileList[this.filesData.indexOf(files[i])];
            }
            this.reloadcanceledFile(null, files[i], liElement, custom);
          }
        }
      }
    };
    Uploader2.prototype.cancel = function(fileData) {
      fileData = fileData ? fileData : this.filesData;
      var cancelingFiles = this.getFilesInArray(fileData);
      this.cancelUpload(cancelingFiles);
    };
    Uploader2.prototype.cancelUpload = function(fileData) {
      var files = this.getFiles(fileData);
      if (this.asyncSettings.chunkSize > 0) {
        for (var i = 0; i < files.length; i++) {
          if (files[i].statusCode === "3") {
            var metaData = this.getCurrentMetaData(files[i], null);
            metaData.file.statusCode = "5";
            metaData.file.status = this.localizedTexts("fileUploadCancel");
            this.updateMetaData(metaData);
            this.showHideUploadSpinner(files[i]);
          }
        }
      } else {
        for (var i = 0; i < files.length; i++) {
          if (files[i].statusCode === "3") {
            files[i].statusCode = "5";
            files[i].status = this.localizedTexts("fileUploadCancel");
            this.showHideUploadSpinner(files[i]);
          }
        }
      }
    };
    Uploader2.prototype.showHideUploadSpinner = function(files) {
      var liElement = this.getLiElement(files);
      if (!isNullOrUndefined(liElement) && isNullOrUndefined(this.template)) {
        var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
        createSpinner({ target: spinnerTarget, width: "20px" });
        showSpinner(spinnerTarget);
      }
    };
    __decorate16([
      Complex({ saveUrl: "", removeUrl: "" }, AsyncSettings)
    ], Uploader2.prototype, "asyncSettings", void 0);
    __decorate16([
      Property(false)
    ], Uploader2.prototype, "sequentialUpload", void 0);
    __decorate16([
      Property({})
    ], Uploader2.prototype, "htmlAttributes", void 0);
    __decorate16([
      Property("")
    ], Uploader2.prototype, "cssClass", void 0);
    __decorate16([
      Property(true)
    ], Uploader2.prototype, "enabled", void 0);
    __decorate16([
      Property(null)
    ], Uploader2.prototype, "template", void 0);
    __decorate16([
      Property(true)
    ], Uploader2.prototype, "multiple", void 0);
    __decorate16([
      Property(true)
    ], Uploader2.prototype, "autoUpload", void 0);
    __decorate16([
      Property(true)
    ], Uploader2.prototype, "enableHtmlSanitizer", void 0);
    __decorate16([
      Complex({}, ButtonsProps)
    ], Uploader2.prototype, "buttons", void 0);
    __decorate16([
      Property("")
    ], Uploader2.prototype, "allowedExtensions", void 0);
    __decorate16([
      Property(0)
    ], Uploader2.prototype, "minFileSize", void 0);
    __decorate16([
      Property(3e7)
    ], Uploader2.prototype, "maxFileSize", void 0);
    __decorate16([
      Property(null)
    ], Uploader2.prototype, "dropArea", void 0);
    __decorate16([
      Collection([{}], FilesProp)
    ], Uploader2.prototype, "files", void 0);
    __decorate16([
      Property(true)
    ], Uploader2.prototype, "showFileList", void 0);
    __decorate16([
      Property(false)
    ], Uploader2.prototype, "directoryUpload", void 0);
    __decorate16([
      Property("Default")
    ], Uploader2.prototype, "dropEffect", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "created", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "actionComplete", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "rendering", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "beforeUpload", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "fileListRendering", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "selected", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "uploading", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "success", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "failure", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "removing", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "beforeRemove", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "clearing", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "progress", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "change", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "chunkSuccess", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "chunkFailure", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "chunkUploading", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "canceling", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "pausing", void 0);
    __decorate16([
      Event()
    ], Uploader2.prototype, "resuming", void 0);
    Uploader2 = __decorate16([
      NotifyPropertyChanges
    ], Uploader2);
    return Uploader2;
  }(Component)
);

// node_modules/@syncfusion/ej2-splitbuttons/src/common/common.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getModel(props, model) {
  var obj = extend({}, props);
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var prop = _a[_i];
    if (model.indexOf(prop) < 0) {
      deleteObject(obj, prop);
    }
  }
  return obj;
}
function upDownKeyHandler(ul, keyCode) {
  var defaultIdx = keyCode === 40 ? 0 : ul.childElementCount - 1;
  var liIdx = defaultIdx;
  var li;
  var selectedLi = ul.querySelector(".e-selected");
  if (selectedLi) {
    selectedLi.classList.remove("e-selected");
  }
  for (var i = 0, len = ul.children.length; i < len; i++) {
    if (ul.children[i].classList.contains("e-focused")) {
      li = ul.children[i];
      liIdx = i;
      li.classList.remove("e-focused");
      if (keyCode === 40) {
        liIdx++;
      } else {
        liIdx--;
      }
      if (liIdx === (keyCode === 40 ? ul.childElementCount : -1)) {
        liIdx = defaultIdx;
      }
    }
  }
  li = ul.children[liIdx];
  liIdx = isValidLI(ul, li, liIdx, keyCode);
  if (liIdx !== -1) {
    addClass([ul.children[liIdx]], "e-focused");
    ul.children[liIdx].focus();
  }
}
function isValidLI(ul, li, index, keyCode, count) {
  if (count === void 0) {
    count = 0;
  }
  if (li.classList.contains("e-separator") || li.classList.contains("e-disabled")) {
    if (index === (keyCode === 40 ? ul.childElementCount - 1 : 0)) {
      index = keyCode === 40 ? 0 : ul.childElementCount - 1;
    } else {
      if (keyCode === 40) {
        index++;
      } else {
        index--;
      }
    }
  }
  li = ul.children[index];
  if (li.classList.contains("e-separator") || li.classList.contains("e-disabled")) {
    count++;
    if (count === ul.childElementCount) {
      return index = -1;
    }
    index = isValidLI(ul, li, index, keyCode, count);
  }
  return index;
}
function setBlankIconStyle(popup, blankIcon) {
  var blankIconList = [].slice.call(popup.getElementsByClassName("e-blank-icon"));
  if (blankIcon) {
    var menuItem = [].slice.call(popup.getElementsByClassName("e-item"));
    menuItem.forEach(function(li) {
      if (li.style.paddingLeft || li.style.paddingRight) {
        li.removeAttribute("style");
      }
    });
  }
  if (!blankIconList.length) {
    return;
  }
  var iconLi = popup.querySelector(".e-item:not(.e-blank-icon):not(.e-separator)");
  if (isNullOrUndefined(iconLi)) {
    return;
  }
  if (iconLi.classList.contains("e-url")) {
    iconLi = iconLi.querySelector(".e-menu-url");
  }
  var icon = iconLi.querySelector(".e-menu-icon");
  var cssProp;
  var enableRtl = popup.classList.contains("e-rtl");
  if (enableRtl) {
    cssProp = { padding: "paddingRight", margin: "marginLeft" };
  } else {
    cssProp = { padding: "paddingLeft", margin: "marginRight" };
  }
  var size = parseInt(getComputedStyle(icon).fontSize, 10) + parseInt(enableRtl ? getComputedStyle(icon)[cssProp.margin] : getComputedStyle(icon)[cssProp.margin], 10) + parseInt(getComputedStyle(iconLi).paddingLeft, 10) + "px";
  blankIconList.forEach(function(li) {
    if (li.classList.contains("e-url")) {
      li.querySelector(".e-menu-url").style[cssProp.padding] = size;
    } else {
      li.style[cssProp.padding] = size;
    }
  });
}
var Item = (
  /** @class */
  function(_super) {
    __extends16(Item3, _super);
    function Item3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate17([
      Property("")
    ], Item3.prototype, "iconCss", void 0);
    __decorate17([
      Property("")
    ], Item3.prototype, "id", void 0);
    __decorate17([
      Property(false)
    ], Item3.prototype, "separator", void 0);
    __decorate17([
      Property("")
    ], Item3.prototype, "text", void 0);
    __decorate17([
      Property("")
    ], Item3.prototype, "url", void 0);
    __decorate17([
      Property(false)
    ], Item3.prototype, "disabled", void 0);
    return Item3;
  }(ChildProperty)
);

// node_modules/@syncfusion/ej2-splitbuttons/src/drop-down-button/drop-down-button.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var classNames3 = {
  DISABLED: "e-disabled",
  FOCUS: "e-focused",
  ICON: "e-menu-icon",
  ITEM: "e-item",
  POPUP: "e-dropdown-popup",
  RTL: "e-rtl",
  SEPARATOR: "e-separator",
  VERTICAL: "e-vertical"
};
var DropDownButton = (
  /** @class */
  function(_super) {
    __extends17(DropDownButton2, _super);
    function DropDownButton2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isPopupCreated = true;
      return _this;
    }
    DropDownButton2.prototype.preRender = function() {
    };
    DropDownButton2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    DropDownButton2.prototype.toggle = function() {
      if (this.canOpen()) {
        this.openPopUp();
      } else if (this.createPopupOnClick && !this.isPopupCreated) {
        this.createPopup();
        this.openPopUp();
      } else {
        this.closePopup();
      }
    };
    DropDownButton2.prototype.render = function() {
      this.initialize();
      if (!this.disabled) {
        this.wireEvents();
      }
      this.renderComplete();
    };
    DropDownButton2.prototype.addItems = function(items, text) {
      var newItem;
      var idx = this.items.length;
      for (var j = 0, len = this.items.length; j < len; j++) {
        if (text === this.items[j].text) {
          idx = j;
          break;
        }
      }
      for (var i = items.length - 1; i >= 0; i--) {
        newItem = new Item(this, "items", items[i], true);
        this.items.splice(idx, 0, newItem);
      }
      if (!this.canOpen()) {
        this.createItems();
      }
    };
    DropDownButton2.prototype.removeItems = function(items, isUniqueId) {
      var refresh = false;
      for (var i = 0, len = items.length; i < len; i++) {
        for (var j = 0, len_1 = this.items.length; j < len_1; j++) {
          if (items[i] === (isUniqueId ? this.items[j].id : this.items[j].text)) {
            this.items.splice(j, 1);
            refresh = true;
            break;
          }
        }
      }
      if (refresh && this.getULElement()) {
        this.createItems();
      }
    };
    DropDownButton2.prototype.createPopup = function() {
      var _a;
      var div = this.createElement("div", {
        className: classNames3.POPUP,
        id: this.element.id + "-popup"
      });
      document.body.appendChild(div);
      this.dropDown = new Popup(div, {
        relateTo: this.element,
        collision: { X: "fit", Y: "flip" },
        position: { X: "left", Y: "bottom" },
        targetType: "relative",
        content: this.target ? this.getTargetElement() : "",
        enableRtl: this.enableRtl
      });
      this.dropDown.element.setAttribute("role", "dialog");
      this.dropDown.element.setAttribute("aria-label", "dropdown menu");
      if (!isNullOrUndefined(this.popupContent)) {
        this.popupContent.style.display = "";
      }
      if (this.dropDown.element.style.position === "fixed") {
        this.dropDown.refreshPosition(this.element);
      }
      this.dropDown.hide();
      attributes(this.element, (_a = {}, _a["aria-haspopup"] = this.items.length || this.target ? "true" : "false", _a["aria-expanded"] = "false", _a["type"] = "button", _a));
      if (this.cssClass) {
        addClass([div], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      this.isPopupCreated = true;
    };
    DropDownButton2.prototype.getTargetElement = function() {
      if (this.createPopupOnClick && !this.isColorPicker() && !isNullOrUndefined(this.popupContent)) {
        return this.popupContent;
      }
      return typeof this.target === "string" ? select(this.target) : this.target;
    };
    DropDownButton2.prototype.createItems = function(appendItems) {
      var items = this.items;
      var showIcon = this.hasIcon(this.items, "iconCss");
      var span;
      var item;
      var li;
      var eventArgs;
      var ul = this.getULElement();
      if (ul) {
        ul.innerHTML = "";
      } else {
        ul = this.createElement("ul", {
          attrs: { "role": "menu", "tabindex": "0" }
        });
      }
      for (var i = 0; i < items.length; i++) {
        item = items[i];
        var tempItem = item.text;
        li = this.createElement("li", {
          innerHTML: item.url ? "" : tempItem,
          className: item.separator ? classNames3.ITEM + " " + classNames3.SEPARATOR : classNames3.ITEM,
          attrs: item.separator ? { "role": "separator", "tabindex": "-1", "aria-label": "separator", "aria-hidden": "true" } : { "role": "menuitem", "tabindex": "-1", "aria-label": tempItem },
          id: item.id ? item.id : getUniqueID("e-" + this.getModuleName() + "-item")
        });
        if (this.enableHtmlSanitizer) {
          li.textContent = item.url ? "" : tempItem;
        } else {
          li.innerHTML = item.url ? "" : tempItem;
        }
        if (item.url) {
          li.appendChild(this.createAnchor(item));
          li.classList.add("e-url");
        }
        if (item.iconCss) {
          span = this.createElement("span", { className: classNames3.ICON + " " + item.iconCss });
          if (item.url) {
            li.childNodes[0].appendChild(span);
          } else {
            li.insertBefore(span, li.childNodes[0]);
          }
        } else {
          if (showIcon && !item.separator) {
            li.classList.add("e-blank-icon");
          }
        }
        var beforeDisabled = item.disabled;
        if (item.disabled) {
          li.classList.add("e-disabled");
        }
        eventArgs = { item, element: li };
        this.trigger("beforeItemRender", eventArgs);
        var afterDisabled = eventArgs.item.disabled;
        if (beforeDisabled !== afterDisabled) {
          if (eventArgs.item.disabled) {
            li.classList.add("e-disabled");
          } else {
            li.classList.remove("e-disabled");
          }
        }
        ul.appendChild(li);
      }
      if (appendItems) {
        this.getPopUpElement().appendChild(ul);
      }
      if (showIcon) {
        setBlankIconStyle(this.getPopUpElement());
      }
    };
    DropDownButton2.prototype.hasIcon = function(items, field) {
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]["" + field]) {
          return true;
        }
      }
      return false;
    };
    DropDownButton2.prototype.createAnchor = function(item) {
      var tempItem = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(item.text) : item.text;
      return this.createElement("a", { className: "e-menu-text e-menu-url", innerHTML: tempItem, attrs: { "href": item.url } });
    };
    DropDownButton2.prototype.initialize = function() {
      this.button = new Button({
        iconCss: this.iconCss,
        iconPosition: this.iconPosition,
        cssClass: this.cssClass,
        content: this.content,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        enablePersistence: this.enablePersistence
      });
      this.button.createElement = this.createElement;
      this.button.appendTo(this.element);
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      this.appendArrowSpan();
      this.setActiveElem([this.element]);
      this.element.setAttribute("tabindex", "0");
      this.element.setAttribute("aria-label", this.element.textContent ? this.element.textContent : "dropdownbutton");
      if (this.target && !this.isColorPicker() && !this.createPopupOnClick || !this.createPopupOnClick) {
        this.createPopup();
      } else {
        this.isPopupCreated = false;
        if (this.target && !this.isColorPicker() && this.createPopupOnClick) {
          this.popupContent = this.getTargetElement();
          this.popupContent.style.display = "none";
        }
      }
    };
    DropDownButton2.prototype.isColorPicker = function() {
      if (!this.element) {
        return false;
      }
      var prevElem = this.element.previousSibling;
      if (prevElem && prevElem.classList && prevElem.classList.contains("e-split-colorpicker")) {
        return true;
      }
      return false;
    };
    DropDownButton2.prototype.appendArrowSpan = function() {
      this.cssClass = isNullOrUndefined(this.cssClass) ? "" : this.cssClass;
      this.element.appendChild(this.createElement("span", {
        className: "e-btn-icon e-icons e-icon-" + (this.cssClass.indexOf(classNames3.VERTICAL) > -1 ? "bottom" : "right") + " e-caret"
      }));
    };
    DropDownButton2.prototype.setActiveElem = function(elem) {
      this.activeElem = elem;
    };
    DropDownButton2.prototype.getModuleName = function() {
      return "dropdown-btn";
    };
    DropDownButton2.prototype.canOpen = function() {
      var val = false;
      if (this.isPopupCreated) {
        val = this.getPopUpElement().classList.contains("e-popup-close");
      }
      return val;
    };
    DropDownButton2.prototype.destroy = function() {
      var _this = this;
      _super.prototype.destroy.call(this);
      if (this.getModuleName() === "dropdown-btn") {
        var classList_1;
        if (this.element.querySelector("span.e-caret")) {
          detach(this.element.querySelector("span.e-caret"));
        }
        if (this.cssClass) {
          classList_1 = this.cssClass.split(" ");
        }
        this.button.destroy();
        if (classList_1) {
          removeClass([this.element], classList_1);
        }
        removeClass(this.activeElem, ["e-active"]);
        var attrList = this.element.getAttribute("class") ? ["aria-haspopup", "aria-expanded", "aria-owns", "type"] : ["aria-haspopup", "aria-expanded", "aria-owns", "type", "class"];
        attrList.forEach(function(key) {
          _this.element.removeAttribute(key);
        });
        this.popupUnWireEvents();
        this.destroyPopup();
        this.isPopupCreated = false;
        if (!this.disabled) {
          this.unWireEvents();
        }
      }
    };
    DropDownButton2.prototype.destroyPopup = function() {
      if (this.isPopupCreated) {
        this.dropDown.destroy();
        if (this.getPopUpElement()) {
          var popupEle = document.getElementById(this.getPopUpElement().id);
          if (popupEle) {
            removeClass([popupEle], ["e-popup-open", "e-popup-close"]);
            detach(popupEle);
          }
        }
        EventHandler.remove(this.getPopUpElement(), "click", this.clickHandler);
        EventHandler.remove(this.getPopUpElement(), "keydown", this.keyBoardHandler);
        if (this.isPopupCreated && this.dropDown) {
          this.dropDown.element = null;
          this.dropDown = void 0;
        }
      }
      this.isPopupCreated = false;
    };
    DropDownButton2.prototype.getPopUpElement = function() {
      var val = null;
      if (!this.dropDown && this.activeElem[0].classList.contains("e-split-btn")) {
        var dropDownBtn = getComponent(this.activeElem[1], "dropdown-btn");
        if (dropDownBtn) {
          this.dropDown = dropDownBtn.dropDown;
        }
      }
      if (this.dropDown) {
        val = this.dropDown.element;
      }
      return val;
    };
    DropDownButton2.prototype.getULElement = function() {
      var val = null;
      if (this.getPopUpElement()) {
        val = this.getPopUpElement().children[0];
      }
      return val;
    };
    DropDownButton2.prototype.wireEvents = function() {
      this.delegateMousedownHandler = this.mousedownHandler.bind(this);
      if (!this.createPopupOnClick) {
        EventHandler.add(document, "mousedown touchstart", this.delegateMousedownHandler, this);
      }
      EventHandler.add(this.element, "click", this.clickHandler, this);
      EventHandler.add(this.element, "keydown", this.keyBoardHandler, this);
      EventHandler.add(window, "resize", this.windowResize, this);
    };
    DropDownButton2.prototype.windowResize = function() {
      if (!this.canOpen() && this.dropDown) {
        this.dropDown.refreshPosition(this.element);
      }
    };
    DropDownButton2.prototype.popupWireEvents = function() {
      if (!this.delegateMousedownHandler) {
        this.delegateMousedownHandler = this.mousedownHandler.bind(this);
      }
      var popupElement = this.getPopUpElement();
      if (this.createPopupOnClick) {
        EventHandler.add(document, "mousedown touchstart", this.delegateMousedownHandler, this);
      }
      if (popupElement) {
        EventHandler.add(popupElement, "click", this.clickHandler, this);
        EventHandler.add(popupElement, "keydown", this.keyBoardHandler, this);
        if (this.closeActionEvents) {
          EventHandler.add(popupElement, this.closeActionEvents, this.focusoutHandler, this);
        }
      }
      this.rippleFn = rippleEffect(popupElement, { selector: "." + classNames3.ITEM });
    };
    DropDownButton2.prototype.popupUnWireEvents = function() {
      var popupElement = this.getPopUpElement();
      if (this.createPopupOnClick) {
        EventHandler.remove(document, "mousedown touchstart", this.delegateMousedownHandler);
      }
      if (popupElement && popupElement.parentElement) {
        EventHandler.remove(popupElement, "click", this.clickHandler);
        EventHandler.remove(popupElement, "keydown", this.keyBoardHandler);
        if (this.closeActionEvents) {
          EventHandler.remove(popupElement, this.closeActionEvents, this.focusoutHandler);
        }
      }
      if (isRippleEnabled && this.rippleFn) {
        this.rippleFn();
      }
    };
    DropDownButton2.prototype.keyBoardHandler = function(e) {
      if (e.target === this.element && (e.keyCode === 9 || !e.altKey && e.keyCode === 40 || e.keyCode === 38)) {
        return;
      }
      switch (e.keyCode) {
        case 38:
        case 40:
          if (e.altKey && (e.keyCode === 38 || e.keyCode === 40)) {
            this.keyEventHandler(e);
          } else {
            this.upDownKeyHandler(e);
          }
          break;
        case 9:
        case 13:
        case 27:
        case 32:
          this.keyEventHandler(e);
          break;
      }
    };
    DropDownButton2.prototype.upDownKeyHandler = function(e) {
      if (this.target && (e.keyCode === 38 || e.keyCode === 40)) {
        return;
      }
      e.preventDefault();
      upDownKeyHandler(this.getULElement(), e.keyCode);
    };
    DropDownButton2.prototype.keyEventHandler = function(e) {
      if (this.target && (e.keyCode === 13 || e.keyCode === 9)) {
        return;
      }
      if (e.keyCode === 13 && this.activeElem[0].classList.contains("e-split-btn")) {
        this.triggerSelect(e);
        this.activeElem[0].focus();
        return;
      }
      if (e.target && e.target.className.indexOf("e-edit-template") > -1 && e.keyCode === 32) {
        return;
      }
      if (e.keyCode !== 9) {
        e.preventDefault();
      }
      if (e.keyCode === 27 || e.keyCode === 38 || e.keyCode === 9) {
        if (!this.canOpen()) {
          this.closePopup(e, this.element);
        }
      } else {
        this.clickHandler(e);
      }
    };
    DropDownButton2.prototype.getLI = function(elem) {
      return elem.tagName === "LI" ? elem : closest(elem, "li");
    };
    DropDownButton2.prototype.mousedownHandler = function(e) {
      var trgt = e.target;
      if (this.dropDown && !this.canOpen() && !(closest(trgt, '[id="' + this.getPopUpElement().id + '"]') || closest(trgt, '[id="' + this.element.id + '"]'))) {
        this.closePopup(e);
      }
    };
    DropDownButton2.prototype.focusoutHandler = function(e) {
      if (this.isPopupCreated && !this.canOpen()) {
        var liTarget = e.relatedTarget;
        if (liTarget && liTarget.className.indexOf("e-item") > -1) {
          var li = this.getLI(liTarget);
          if (li) {
            var liIdx = Array.prototype.indexOf.call(this.getULElement().children, li);
            var item = this.items[liIdx];
            if (item) {
              var selectEventArgs = { element: li, item, event: e };
              this.trigger("select", selectEventArgs);
            }
          }
        }
        this.closePopup(e);
      }
    };
    DropDownButton2.prototype.clickHandler = function(e) {
      var trgt = e.target;
      if (closest(trgt, '[id="' + this.element.id + '"]')) {
        if (!this.createPopupOnClick || this.target && this.target !== "" && !this.isColorPicker() && !this.createPopupOnClick) {
          if (this.getPopUpElement().classList.contains("e-popup-close")) {
            this.openPopUp(e);
          } else {
            this.closePopup(e);
          }
        } else if (this.isPopupCreated) {
          this.closePopup(e, this.activeElem[0]);
        } else {
          this.createPopup();
          this.openPopUp(e);
        }
      } else {
        if (closest(trgt, '[id="' + this.getPopUpElement().id + '"]')) {
          var li = this.getLI(e.target);
          if (li) {
            this.triggerSelect(e);
            this.closePopup(e, this.activeElem[0]);
          }
        }
      }
    };
    DropDownButton2.prototype.triggerSelect = function(e) {
      var eventArgs;
      var liIdx;
      var item;
      var li = this.getLI(e.target);
      if (li) {
        liIdx = Array.prototype.indexOf.call(this.getULElement().children, li);
        item = this.items[liIdx];
        if (item) {
          eventArgs = { element: li, item, event: e };
          this.trigger("select", eventArgs);
        }
      }
    };
    DropDownButton2.prototype.openPopUp = function(e) {
      var _this = this;
      if (e === void 0) {
        e = null;
      }
      var isReact = false;
      var popupElem = this.getPopUpElement();
      if (!this.target) {
        this.createItems(true);
      } else {
        if (this.activeElem.length > 1) {
          var splitButton = getComponent(this.activeElem[0], "split-btn");
          if (splitButton.isReact && popupElem.childNodes.length < 1) {
            isReact = true;
            splitButton.appendReactElement(this.getTargetElement(), this.getPopUpElement());
            this.renderReactTemplates();
          }
        } else {
          if (this.isReact && popupElem.childNodes.length < 1) {
            isReact = true;
            this.appendReactElement(this.getTargetElement(), this.getPopUpElement());
            this.renderReactTemplates();
          }
        }
      }
      var ul = this.getULElement();
      this.popupWireEvents();
      var beforeOpenArgs = { element: ul, items: this.items, event: e, cancel: false };
      this.trigger("beforeOpen", beforeOpenArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          var ul_1 = _this.getULElement();
          _this.dropDown.show(null, _this.element);
          addClass([_this.element], "e-active");
          _this.element.setAttribute("aria-expanded", "true");
          _this.element.setAttribute("aria-owns", _this.getPopUpElement().id);
          if (ul_1) {
            ul_1.focus();
          }
          if (_this.enableRtl && ul_1.parentElement.style.left !== "0px") {
            var wrapperWidth = void 0;
            if (_this.element.parentElement && _this.element.parentElement.classList.contains("e-split-btn-wrapper")) {
              wrapperWidth = _this.element.parentElement.offsetWidth;
            } else {
              wrapperWidth = _this.element.offsetWidth;
            }
            var popupRect2 = ul_1.parentElement.offsetWidth - wrapperWidth;
            var popupLeft = parseFloat(ul_1.parentElement.style.left) - popupRect2;
            if (popupLeft < 0) {
              popupLeft = 0;
            }
            ul_1.parentElement.style.left = popupLeft + "px";
          }
          var openArgs = { element: ul_1, items: _this.items };
          _this.trigger("open", openArgs);
        }
      });
    };
    DropDownButton2.prototype.closePopup = function(e, focusEle) {
      var _this = this;
      if (e === void 0) {
        e = null;
      }
      var ul = this.getULElement();
      var beforeCloseArgs = { element: ul, items: this.items, event: e, cancel: false };
      this.trigger("beforeClose", beforeCloseArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          var popupElement = _this.getPopUpElement();
          if (popupElement) {
            EventHandler.remove(popupElement, "keydown", _this.keyBoardHandler);
          }
          _this.popupUnWireEvents();
          var ul_2 = _this.getULElement();
          var selectedLi = void 0;
          if (ul_2) {
            selectedLi = ul_2.querySelector(".e-selected");
          }
          if (selectedLi) {
            selectedLi.classList.remove("e-selected");
          }
          _this.dropDown.hide();
          removeClass(_this.activeElem, "e-active");
          _this.element.setAttribute("aria-expanded", "false");
          _this.element.removeAttribute("aria-owns");
          if (focusEle) {
            focusEle.focus();
          }
          var closeArgs = { element: ul_2, items: _this.items };
          _this.trigger("close", closeArgs);
          if (!_this.target && ul_2) {
            detach(ul_2);
          }
          if (!_this.target || _this.isColorPicker() || _this.target && !_this.isColorPicker()) {
            if (_this.createPopupOnClick) {
              _this.destroyPopup();
            }
          }
        } else {
          if (ul) {
            ul.focus();
          }
        }
      });
    };
    DropDownButton2.prototype.unWireEvents = function() {
      if (!this.createPopupOnClick) {
        EventHandler.remove(document, "mousedown touchstart", this.delegateMousedownHandler);
      }
      EventHandler.remove(this.element, "click", this.clickHandler);
      EventHandler.remove(this.element, "keydown", this.keyBoardHandler);
      if (this.isPopupCreated) {
        EventHandler.remove(this.getPopUpElement(), "click", this.clickHandler);
        EventHandler.remove(this.getPopUpElement(), "keydown", this.keyBoardHandler);
      }
      EventHandler.remove(window, "resize", this.windowResize);
    };
    DropDownButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var btnModel = ["content", "cssClass", "iconCss", "iconPosition", "disabled", "enableRtl"];
      this.button.setProperties(getModel(newProp, btnModel));
      var popupElement;
      if (this.isPopupCreated) {
        popupElement = this.getPopUpElement();
        this.dropDown.setProperties(getModel(newProp, ["enableRtl"]));
      }
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "content":
            if (!this.element.querySelector("span.e-caret")) {
              this.appendArrowSpan();
            }
            break;
          case "disabled":
            if (newProp.disabled) {
              this.unWireEvents();
              if (this.isPopupCreated && !this.canOpen()) {
                this.closePopup();
              }
            } else {
              this.wireEvents();
            }
            break;
          case "cssClass":
            if (newProp.cssClass.indexOf(classNames3.VERTICAL) > -1 || oldProp.cssClass.indexOf(classNames3.VERTICAL) > -1) {
              if (!this.element.querySelector("span.e-caret")) {
                this.appendArrowSpan();
              }
              var arrowSpan = this.element.querySelector("span.e-caret");
              newProp.cssClass.indexOf(classNames3.VERTICAL) > -1 ? classList(arrowSpan, ["e-icon-bottom"], ["e-icon-right"]) : classList(arrowSpan, ["e-icon-right"], ["e-icon-bottom"]);
            }
            if (this.isPopupCreated) {
              if (oldProp.cssClass) {
                removeClass([popupElement], oldProp.cssClass.split(" "));
              }
              if (newProp.cssClass) {
                addClass([popupElement], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
              }
            }
            break;
          case "target":
            this.dropDown.content = this.getTargetElement();
            this.dropDown.dataBind();
            break;
          case "items":
            if (this.isPopupCreated && this.getULElement()) {
              this.createItems();
            }
            break;
          case "createPopupOnClick":
            if (newProp.createPopupOnClick) {
              this.destroyPopup();
            } else {
              this.createPopup();
            }
            break;
        }
      }
    };
    DropDownButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate18([
      Property("")
    ], DropDownButton2.prototype, "content", void 0);
    __decorate18([
      Property("")
    ], DropDownButton2.prototype, "cssClass", void 0);
    __decorate18([
      Property(false)
    ], DropDownButton2.prototype, "disabled", void 0);
    __decorate18([
      Property("")
    ], DropDownButton2.prototype, "iconCss", void 0);
    __decorate18([
      Property("Left")
    ], DropDownButton2.prototype, "iconPosition", void 0);
    __decorate18([
      Property(true)
    ], DropDownButton2.prototype, "enableHtmlSanitizer", void 0);
    __decorate18([
      Collection([], Item)
    ], DropDownButton2.prototype, "items", void 0);
    __decorate18([
      Property(false)
    ], DropDownButton2.prototype, "createPopupOnClick", void 0);
    __decorate18([
      Property("")
    ], DropDownButton2.prototype, "target", void 0);
    __decorate18([
      Property("")
    ], DropDownButton2.prototype, "closeActionEvents", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "beforeItemRender", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "beforeOpen", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "beforeClose", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "close", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "open", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "select", void 0);
    __decorate18([
      Event()
    ], DropDownButton2.prototype, "created", void 0);
    DropDownButton2 = __decorate18([
      NotifyPropertyChanges
    ], DropDownButton2);
    return DropDownButton2;
  }(Component)
);

// node_modules/@syncfusion/ej2-splitbuttons/src/split-button/split-button.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RTL7 = "e-rtl";
var TAGNAME = "EJS-SPLITBUTTON";
var SplitButton = (
  /** @class */
  function(_super) {
    __extends18(SplitButton2, _super);
    function SplitButton2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    SplitButton2.prototype.preRender = function() {
      var ele = this.element;
      if (ele.tagName === TAGNAME) {
        var ejInstance = getValue("ej2_instances", ele);
        var btn = this.createElement("button", { attrs: { "type": "button" } });
        var wrapper = this.createElement(TAGNAME, { className: "e-" + this.getModuleName() + "-wrapper" });
        for (var idx = 0, len = ele.attributes.length; idx < len; idx++) {
          btn.setAttribute(ele.attributes[idx].nodeName, ele.attributes[idx].nodeValue);
        }
        ele.parentNode.insertBefore(wrapper, ele);
        detach(ele);
        ele = btn;
        wrapper.appendChild(ele);
        setValue("ej2_instances", ejInstance, ele);
        this.wrapper = wrapper;
        this.element = ele;
      }
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
    };
    SplitButton2.prototype.render = function() {
      this.initWrapper();
      this.createPrimaryButton();
      this.renderControl();
    };
    SplitButton2.prototype.renderControl = function() {
      this.createSecondaryButton();
      this.setActiveElem([this.element, this.secondaryBtnObj.element]);
      this.setAria();
      this.wireEvents();
      this.renderComplete();
    };
    SplitButton2.prototype.addItems = function(items, text) {
      _super.prototype.addItems.call(this, items, text);
      this.secondaryBtnObj.items = this.items;
    };
    SplitButton2.prototype.removeItems = function(items, isUniqueId) {
      _super.prototype.removeItems.call(this, items, isUniqueId);
      this.secondaryBtnObj.items = this.items;
    };
    SplitButton2.prototype.initWrapper = function() {
      if (!this.wrapper) {
        this.wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-wrapper" });
        this.element.parentNode.insertBefore(this.wrapper, this.element);
      }
      this.element.classList.remove("e-" + this.getModuleName());
      if (this.enableRtl) {
        this.wrapper.classList.add(RTL7);
      }
      if (this.cssClass) {
        addClass([this.wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
    };
    SplitButton2.prototype.createPrimaryButton = function() {
      var btnModel = {
        cssClass: this.cssClass,
        enableRtl: this.enableRtl,
        iconCss: this.iconCss,
        iconPosition: this.iconPosition,
        content: this.content,
        disabled: this.disabled
      };
      this.primaryBtnObj = new Button(btnModel);
      this.primaryBtnObj.createElement = this.createElement;
      this.primaryBtnObj.appendTo(this.element);
      this.element.classList.add("e-" + this.getModuleName());
      this.element.type = "button";
      this.wrapper.appendChild(this.element);
    };
    SplitButton2.prototype.createSecondaryButton = function() {
      var _this = this;
      var btnElem = this.createElement("button", {
        className: "e-icon-btn",
        attrs: { "tabindex": "-1" },
        id: this.element.id + "_dropdownbtn"
      });
      this.wrapper.appendChild(btnElem);
      var dropDownBtnModel = {
        cssClass: this.cssClass,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        items: this.items,
        target: this.target,
        createPopupOnClick: this.createPopupOnClick
      };
      dropDownBtnModel.beforeItemRender = function(args) {
        if (_this.createPopupOnClick) {
          _this.secondaryBtnObj.dropDown.relateTo = _this.wrapper;
          _this.dropDown = _this.secondaryBtnObj.dropDown;
        }
        _this.trigger("beforeItemRender", args);
      };
      dropDownBtnModel.open = function(args) {
        _this.trigger("open", args);
      };
      dropDownBtnModel.close = function(args) {
        _this.trigger("close", args);
      };
      dropDownBtnModel.select = function(args) {
        _this.trigger("select", args);
      };
      dropDownBtnModel.beforeOpen = function(args) {
        if (_this.createPopupOnClick && _this.items.length === 0) {
          _this.secondaryBtnObj.dropDown.relateTo = _this.wrapper;
          _this.dropDown = _this.secondaryBtnObj.dropDown;
        }
        var callBackPromise = new Deferred();
        _this.trigger("beforeOpen", args, function(observedArgs) {
          callBackPromise.resolve(observedArgs);
        });
        return callBackPromise;
      };
      dropDownBtnModel.beforeClose = function(args) {
        var callBackPromise = new Deferred();
        _this.trigger("beforeClose", args, function(observedArgs) {
          callBackPromise.resolve(observedArgs);
        });
        return callBackPromise;
      };
      this.secondaryBtnObj = new DropDownButton(dropDownBtnModel);
      this.secondaryBtnObj.createElement = this.createElement;
      this.secondaryBtnObj.appendTo(btnElem);
      if (!this.createPopupOnClick) {
        this.secondaryBtnObj.dropDown.relateTo = this.wrapper;
        this.dropDown = this.secondaryBtnObj.dropDown;
      }
      this.isPopupCreated = this.secondaryBtnObj.isPopupCreated;
      this.secondaryBtnObj.activeElem = [this.element, this.secondaryBtnObj.element];
      this.secondaryBtnObj.element.querySelector(".e-btn-icon").classList.remove("e-icon-right");
      if (this.disabled) {
        this.wrapper.classList.add("e-splitbtn-disabled");
      }
    };
    SplitButton2.prototype.setAria = function() {
      attributes(this.element, {
        "aria-expanded": "false",
        "aria-haspopup": "true",
        "aria-label": this.element.textContent ? this.element.textContent + " splitbutton" : "splitbutton",
        "aria-owns": this.element.id + "_dropdownbtn-popup"
      });
    };
    SplitButton2.prototype.getModuleName = function() {
      return "split-btn";
    };
    SplitButton2.prototype.toggle = function() {
      this.secondaryBtnObj.toggle();
    };
    SplitButton2.prototype.destroy = function() {
      var _this = this;
      var classList2 = [RTL7];
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.split(" "));
      }
      if (this.element) {
        var element2 = document.getElementById(this.element.id);
        if (element2 && element2.parentElement === this.wrapper) {
          if (this.wrapper.tagName === TAGNAME) {
            this.wrapper.innerHTML = "";
            removeClass([this.wrapper], ["e-rtl", "e-" + this.getModuleName() + "-wrapper"]);
            removeClass([this.wrapper], this.cssClass.split(" "));
          } else {
            removeClass([this.element], classList2);
            ["aria-label", "aria-haspopup", "aria-expanded", "aria-owns", "type"].forEach(function(key) {
              _this.element.removeAttribute(key);
            });
            this.wrapper.parentNode.insertBefore(this.element, this.wrapper);
            remove(this.wrapper);
          }
          this.unWireEvents();
        }
      }
      this.primaryBtnObj.destroy();
      this.secondaryBtnObj.destroy();
      _super.prototype.destroy.call(this);
      if (this.element && !this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      if (this.refreshing && this.isAngular) {
        this.element = this.wrapper;
        ["e-control", "e-split-btn", "e-lib"].forEach(function(key) {
          _this.element.classList.add(key);
        });
        setValue("ej2_instances", [this], this.element);
      }
      this.wrapper = null;
    };
    SplitButton2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.primaryBtnClickHandler, this);
      new KeyboardEvents(this.element, {
        keyAction: this.btnKeyBoardHandler.bind(this),
        keyConfigs: {
          altdownarrow: "alt+downarrow",
          enter: "enter"
        }
      });
    };
    SplitButton2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "click", this.primaryBtnClickHandler);
      getInstance(this.element, KeyboardEvents).destroy();
    };
    SplitButton2.prototype.primaryBtnClickHandler = function() {
      this.trigger("click", { element: this.element });
    };
    SplitButton2.prototype.btnKeyBoardHandler = function(e) {
      switch (e.action) {
        case "altdownarrow":
          this.clickHandler(e);
          break;
        case "enter":
          this.clickHandler(e);
          if (this.getPopUpElement() && !this.getPopUpElement().classList.contains("e-popup-close")) {
            this.element.classList.remove("e-active");
            this.secondaryBtnObj.element.classList.add("e-active");
          } else {
            this.secondaryBtnObj.element.classList.remove("e-active");
          }
          break;
      }
    };
    SplitButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var model = ["content", "iconCss", "iconPosition", "cssClass", "disabled", "enableRtl"];
      this.primaryBtnObj.setProperties(getModel(newProp, model));
      model = [
        "beforeOpen",
        "beforeItemRender",
        "select",
        "open",
        "close",
        "cssClass",
        "disabled",
        "enableRtl",
        "createPopupOnClick"
      ];
      if (Object.keys(newProp).indexOf("items") > -1) {
        this.secondaryBtnObj.items = newProp.items;
        this.secondaryBtnObj.dataBind();
      }
      this.secondaryBtnObj.setProperties(getModel(newProp, model));
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.wrapper], oldProp.cssClass.split(" "));
            }
            addClass([this.wrapper], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              addClass([this.wrapper], RTL7);
            } else {
              removeClass([this.wrapper], RTL7);
            }
            break;
          case "disabled":
            if (newProp.disabled) {
              addClass([this.wrapper], "e-splitbtn-disabled");
            } else {
              removeClass([this.wrapper], "e-splitbtn-disabled");
            }
        }
      }
    };
    SplitButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate19([
      Property("")
    ], SplitButton2.prototype, "content", void 0);
    __decorate19([
      Property("")
    ], SplitButton2.prototype, "cssClass", void 0);
    __decorate19([
      Property(false)
    ], SplitButton2.prototype, "disabled", void 0);
    __decorate19([
      Property("")
    ], SplitButton2.prototype, "iconCss", void 0);
    __decorate19([
      Property("Left")
    ], SplitButton2.prototype, "iconPosition", void 0);
    __decorate19([
      Property(false)
    ], SplitButton2.prototype, "createPopupOnClick", void 0);
    __decorate19([
      Collection([], Item)
    ], SplitButton2.prototype, "items", void 0);
    __decorate19([
      Property("")
    ], SplitButton2.prototype, "target", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "beforeItemRender", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "beforeOpen", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "beforeClose", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "click", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "close", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "open", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "select", void 0);
    __decorate19([
      Event()
    ], SplitButton2.prototype, "created", void 0);
    SplitButton2 = __decorate19([
      NotifyPropertyChanges
    ], SplitButton2);
    return SplitButton2;
  }(DropDownButton)
);
var Deferred = (
  /** @class */
  /* @__PURE__ */ function() {
    function Deferred3() {
      var _this = this;
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      this.catch = this.promise.catch.bind(this.promise);
      this.then = this.promise.then.bind(this.promise);
    }
    return Deferred3;
  }()
);

// node_modules/@syncfusion/ej2-splitbuttons/src/progress-button/progress-button.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HIDESPINNER = "e-hide-spinner";
var PROGRESS = "e-progress";
var PROGRESSACTIVE = "e-progress-active";
var CONTENTCLS = "e-btn-content";
var SpinSettings = (
  /** @class */
  function(_super) {
    __extends19(SpinSettings2, _super);
    function SpinSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate20([
      Property(null)
    ], SpinSettings2.prototype, "template", void 0);
    __decorate20([
      Property(16)
    ], SpinSettings2.prototype, "width", void 0);
    __decorate20([
      Property("Left")
    ], SpinSettings2.prototype, "position", void 0);
    return SpinSettings2;
  }(ChildProperty)
);
var AnimationSettings2 = (
  /** @class */
  function(_super) {
    __extends19(AnimationSettings3, _super);
    function AnimationSettings3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate20([
      Property(400)
    ], AnimationSettings3.prototype, "duration", void 0);
    __decorate20([
      Property("None")
    ], AnimationSettings3.prototype, "effect", void 0);
    __decorate20([
      Property("ease")
    ], AnimationSettings3.prototype, "easing", void 0);
    return AnimationSettings3;
  }(ChildProperty)
);
var ProgressButton = (
  /** @class */
  function(_super) {
    __extends19(ProgressButton2, _super);
    function ProgressButton2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.step = 1;
      return _this;
    }
    ProgressButton2.prototype.preRender = function() {
      _super.prototype.preRender.call(this);
    };
    ProgressButton2.prototype.render = function() {
      _super.prototype.render.call(this);
      this.init();
      this.wireEvents();
      this.setAria();
      this.renderComplete();
    };
    ProgressButton2.prototype.start = function(percent) {
      this.isPaused = false;
      this.startProgress(percent ? percent : this.percent, this.progressTime);
    };
    ProgressButton2.prototype.stop = function() {
      this.isPaused = true;
      cancelAnimationFrame(this.timerId);
    };
    ProgressButton2.prototype.progressComplete = function() {
      this.isPaused = false;
      this.finishProgress();
    };
    ProgressButton2.prototype.getModuleName = function() {
      return "progress-btn";
    };
    ProgressButton2.prototype.destroy = function() {
      var _this = this;
      var classList2 = [
        HIDESPINNER,
        PROGRESSACTIVE,
        "e-round-corner",
        "e-" + _super.prototype.getModuleName.call(this),
        "e-spin-" + this.spinSettings.position.toLowerCase()
      ];
      _super.prototype.destroy.call(this);
      this.unWireEvents();
      this.element.innerHTML = "";
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.split(" "));
      }
      removeClass([this.element], classList2);
      var css = this.element.getAttribute("class") ? ["aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow"] : ["aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "class"];
      css.forEach(function(key) {
        _this.element.removeAttribute(key);
      });
      if (this.disabled) {
        this.element.removeAttribute("disabled");
      }
    };
    ProgressButton2.prototype.init = function() {
      this.element.classList.add("e-" + _super.prototype.getModuleName.call(this));
      this.setContent();
      this.createSpinner();
      if (this.enableProgress) {
        this.createProgress();
      }
    };
    ProgressButton2.prototype.createSpinner = function() {
      var spinner = this.createElement("span", { className: "e-spinner" });
      this.setSpinPosition(spinner);
      createSpinner({
        target: spinner,
        width: this.spinSettings.width || 16,
        template: this.spinSettings.template
      }, this.createElement);
    };
    ProgressButton2.prototype.getSpinner = function() {
      return this.element.getElementsByClassName("e-spinner")[0];
    };
    ProgressButton2.prototype.getProgress = function() {
      return this.element.getElementsByClassName(PROGRESS)[0];
    };
    ProgressButton2.prototype.setSpinPosition = function(ele) {
      var position = this.spinSettings.position || "Left";
      if (position === "Left" || position === "Top") {
        this.element.insertBefore(ele, this.element.getElementsByClassName(CONTENTCLS)[0]);
      } else {
        this.element.appendChild(ele);
      }
      this.element.classList.add("e-spin-" + position.toLowerCase());
    };
    ProgressButton2.prototype.createProgress = function() {
      this.element.appendChild(this.createElement("span", { className: PROGRESS }));
    };
    ProgressButton2.prototype.setContent = function() {
      var cont;
      cont = this.element.innerHTML;
      if (this.enableHtmlSanitizer) {
        cont = SanitizeHtmlHelper.sanitize(this.element.innerHTML);
      }
      this.element.innerHTML = "";
      this.element.appendChild(this.createElement("span", { className: CONTENTCLS, innerHTML: cont }));
    };
    ProgressButton2.prototype.setContentIcon = function(content) {
      var contElem = this.createElement("span", { className: CONTENTCLS, innerHTML: content });
      if (this.iconCss) {
        var span = this.createElement("span", { className: "e-btn-icon " + this.iconCss });
        if (!this.element.textContent.trim()) {
          this.element.classList.add("e-icon-btn");
        } else {
          span.classList.add("e-icon-" + this.iconPosition.toLowerCase());
          if (this.iconPosition === "Top" || this.iconPosition === "Bottom") {
            this.element.classList.add("e-" + this.iconPosition.toLowerCase() + "-icon-btn");
          }
        }
        var node = contElem.childNodes[0];
        if (node && (this.iconPosition === "Left" || this.iconPosition === "Top")) {
          contElem.insertBefore(span, node);
        } else {
          contElem.appendChild(span);
        }
      }
      this.element.appendChild(contElem);
    };
    ProgressButton2.prototype.clickHandler = function() {
      if (this.element.classList.contains(PROGRESSACTIVE)) {
        return;
      }
      this.startProgress();
    };
    ProgressButton2.prototype.startProgress = function(percent, progressTime) {
      var clsList = this.element.classList;
      var isVertical = clsList.contains("e-vertical");
      clsList.add(PROGRESSACTIVE);
      if (!clsList.contains(HIDESPINNER)) {
        showSpinner(this.element.querySelector(".e-spinner"));
      }
      this.startAnimate(Date.now(), progressTime ? progressTime : 0, progressTime ? Date.now() - this.duration * 1 / 100 : Date.now(), percent ? percent : 0, 0, this.step, 0, isVertical);
      this.startContAnimate();
    };
    ProgressButton2.prototype.startAnimate = function(timestamp, progressTime, prevTime, percent, prevPercent, step, prevProgressTime, isVertical) {
      var _this = this;
      try {
        var timeDiff = timestamp - prevTime;
        var stepTime = this.duration * step / 100;
        var timeDiffBuffer_1 = timeDiff ? timeDiff < stepTime ? timeDiff - stepTime : timeDiff % stepTime : 0;
        this.progressTime = progressTime = progressTime + timeDiff - timeDiffBuffer_1;
        prevTime = timestamp - timeDiffBuffer_1;
        percent = percent + (timeDiff - timeDiffBuffer_1) / this.duration * 100;
        prevPercent = (progressTime - prevProgressTime) % stepTime === 0 || percent === 100 ? percent : prevPercent;
        var args = { percent: prevPercent, currentDuration: progressTime, step };
        this.eIsVertical = isVertical;
        if (percent === 0) {
          this.trigger("begin", args, function(observedArgs) {
            _this.successCallback(observedArgs, percent, prevPercent, progressTime, prevProgressTime, timeDiffBuffer_1, prevTime);
          });
        } else if (percent === 100 || progressTime === this.duration) {
          this.trigger("end", args, function(observedArgs) {
            _this.successCallback(observedArgs, percent, prevPercent, progressTime, prevProgressTime, timeDiffBuffer_1, prevTime);
          });
        } else {
          this.trigger("progress", args, function(observedArgs) {
            _this.successCallback(observedArgs, percent, prevPercent, progressTime, prevProgressTime, timeDiffBuffer_1, prevTime);
          });
        }
      } catch (e) {
        cancelAnimationFrame(this.timerId);
        this.trigger("fail", e);
      }
    };
    ProgressButton2.prototype.successCallback = function(args, perc, pPerc, prgTim, pPrgTim, timDif, pTim) {
      var _this = this;
      var percent = perc;
      var prevPercent = pPerc;
      var timeDiffBuffer = timDif;
      var progressTime = prgTim;
      var prevProgressTime = pPrgTim;
      var prevTime = pTim;
      var isVertical = this.eIsVertical;
      if (percent !== args.percent && args.percent !== prevPercent) {
        percent = args.percent;
      }
      this.percent = percent;
      this.step = args.step;
      if ((progressTime - prevProgressTime) % (this.duration * args.step / 100) === 0 || percent === 100) {
        this.timerId = requestAnimationFrame(function() {
          if (_this.enableProgress && _this.getProgress()) {
            _this.getProgress().style[isVertical ? "height" : "width"] = percent + "%";
          }
          _this.element.setAttribute("aria-valuenow", percent.toString());
        });
        prevPercent = percent;
        prevProgressTime = progressTime;
      }
      if (!this.isPaused) {
        if (progressTime < this.duration && percent < 100) {
          this.interval = window.setTimeout(function() {
            _this.startAnimate(Date.now(), progressTime, prevTime, percent, prevPercent, args.step, prevProgressTime, isVertical);
          }, this.duration / 100 - timeDiffBuffer);
        } else {
          this.interval = window.setTimeout(function() {
            _this.progressTime = _this.percent = 0;
            if (_this.enableProgress && _this.getProgress()) {
              _this.getProgress().style[isVertical ? "height" : "width"] = "0%";
            }
            _this.element.setAttribute("aria-valuenow", "0");
            _this.hideSpin();
          }, 100);
        }
      }
    };
    ProgressButton2.prototype.startContAnimate = function() {
      var _this = this;
      var ele = this.element.getElementsByClassName(CONTENTCLS)[0];
      if (this.animationSettings.effect !== "None") {
        new Animation({}).animate(ele, {
          duration: this.animationSettings.duration === 0 && animationMode === "Enable" ? 400 : this.animationSettings.duration,
          name: "Progress" + this.animationSettings.effect,
          timingFunction: this.animationSettings.easing,
          begin: function() {
            if (_this.spinSettings.position === "Center") {
              _this.setSpinnerSize();
            }
          },
          end: function() {
            ele.classList.add("e-animate-end");
          }
        });
      } else if (this.spinSettings.position === "Center") {
        this.setSpinnerSize();
      }
    };
    ProgressButton2.prototype.finishProgress = function() {
      var clsList = this.element.classList;
      var isVertical = clsList.contains("e-vertical");
      clsList.add(PROGRESSACTIVE);
      var count = 100;
      for (var i = this.percent; i < count; i++) {
        i += 10;
        if (i > 100) {
          i = 100;
        }
        if (this.enableProgress && this.getProgress()) {
          this.getProgress().style[isVertical ? "height" : "width"] = this.percent < 100 ? i + "%" : "100%";
        }
      }
      this.element.setAttribute("aria-valuenow", "0");
      this.hideSpin();
      var args = { step: this.step, currentDuration: this.progressTime, percent: 100 };
      clearTimeout(this.interval);
      this.trigger("end", args);
      this.progressTime = this.percent = 0;
    };
    ProgressButton2.prototype.setSpinnerSize = function() {
      var ele = this.element.getElementsByClassName(CONTENTCLS)[0];
      var spinner = this.getSpinner();
      spinner.style.width = Math.max(spinner.offsetWidth, ele.offsetWidth) + "px";
      spinner.style.height = Math.max(spinner.offsetHeight, ele.offsetHeight) + "px";
      ele.classList.add("e-cont-animate");
    };
    ProgressButton2.prototype.hideSpin = function() {
      var cont = this.element.getElementsByClassName(CONTENTCLS)[0];
      if (!this.element.classList.contains(HIDESPINNER)) {
        hideSpinner(this.element.querySelector(".e-spinner"));
      }
      this.element.classList.remove(PROGRESSACTIVE);
      if (this.animationSettings.effect !== "None") {
        cont.classList.remove("e-animate-end");
      }
      if (this.spinSettings.position === "Center") {
        var ele = this.getSpinner();
        cont.classList.remove("e-cont-animate");
        ele.style.width = "auto";
        ele.style.height = "auto";
      }
    };
    ProgressButton2.prototype.setIconSpan = function() {
      var cont = this.element.getElementsByClassName(CONTENTCLS)[0];
      var iconSpan = this.element.getElementsByClassName("e-btn-icon")[0];
      if (cont.childNodes[0] && (this.iconPosition === "Left" || this.iconPosition === "Top")) {
        cont.insertBefore(iconSpan, cont.childNodes[0]);
      } else {
        cont.appendChild(iconSpan);
      }
    };
    ProgressButton2.prototype.setAria = function() {
      attributes(this.element, {
        "aria-label": this.element.textContent + " progress"
      });
    };
    ProgressButton2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.clickHandler, this);
    };
    ProgressButton2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "click", this.clickHandler);
    };
    ProgressButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var ele = this.element;
      var isSpinning = false;
      var clsList = this.element.querySelector(".e-spinner-pane").classList;
      if (clsList.contains("e-spin-show")) {
        isSpinning = true;
      }
      _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "content":
            this.setContent();
            this.createSpinner();
            if (isSpinning) {
              showSpinner(this.element.querySelector(".e-spinner"));
              isSpinning = false;
            }
            if (this.enableProgress) {
              this.createProgress();
            }
            ele.setAttribute("aria-label", ele.textContent + " progress");
            break;
          case "iconCss":
            if (!oldProp.iconCss) {
              this.setIconSpan();
            }
            break;
          case "iconPosition":
            this.setIconSpan();
            break;
          case "enableProgress":
            if (newProp.enableProgress) {
              this.createProgress();
            } else {
              remove(this.getProgress());
            }
            break;
          case "spinSettings":
            if (newProp.spinSettings.position) {
              ele.classList.remove("e-spin-" + oldProp.spinSettings.position.toLowerCase());
              this.setSpinPosition(this.getSpinner());
            }
            if (newProp.spinSettings.template || newProp.spinSettings.width) {
              ele.removeChild(this.getSpinner());
              this.createSpinner();
            }
            break;
        }
      }
    };
    ProgressButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate20([
      Property(false)
    ], ProgressButton2.prototype, "enableProgress", void 0);
    __decorate20([
      Property(2e3)
    ], ProgressButton2.prototype, "duration", void 0);
    __decorate20([
      Property("Left")
    ], ProgressButton2.prototype, "iconPosition", void 0);
    __decorate20([
      Property("")
    ], ProgressButton2.prototype, "iconCss", void 0);
    __decorate20([
      Property(false)
    ], ProgressButton2.prototype, "disabled", void 0);
    __decorate20([
      Property(false)
    ], ProgressButton2.prototype, "isPrimary", void 0);
    __decorate20([
      Property("")
    ], ProgressButton2.prototype, "cssClass", void 0);
    __decorate20([
      Property("")
    ], ProgressButton2.prototype, "content", void 0);
    __decorate20([
      Property(false)
    ], ProgressButton2.prototype, "isToggle", void 0);
    __decorate20([
      Property(true)
    ], ProgressButton2.prototype, "enableHtmlSanitizer", void 0);
    __decorate20([
      Complex({}, SpinSettings)
    ], ProgressButton2.prototype, "spinSettings", void 0);
    __decorate20([
      Complex({}, AnimationSettings2)
    ], ProgressButton2.prototype, "animationSettings", void 0);
    __decorate20([
      Event()
    ], ProgressButton2.prototype, "created", void 0);
    __decorate20([
      Event()
    ], ProgressButton2.prototype, "begin", void 0);
    __decorate20([
      Event()
    ], ProgressButton2.prototype, "progress", void 0);
    __decorate20([
      Event()
    ], ProgressButton2.prototype, "end", void 0);
    __decorate20([
      Event()
    ], ProgressButton2.prototype, "fail", void 0);
    ProgressButton2 = __decorate20([
      NotifyPropertyChanges
    ], ProgressButton2);
    return ProgressButton2;
  }(Button)
);

// node_modules/@syncfusion/ej2-inputs/src/color-picker/color-picker.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var APPLY = "e-apply";
var CANCEL = "e-cancel";
var CURRENT = "e-current";
var CONTAINER = "e-container";
var CTRLBTN = "e-ctrl-btn";
var CTRLSWITCH = "e-switch-ctrl-btn";
var DISABLED5 = "e-disabled";
var FORMATSWITCH = "e-value-switch-btn";
var HANDLER = "e-handler";
var HEX = "e-hex";
var HIDEHEX = "e-hide-hex-value";
var HIDEOPACITY = "e-hide-opacity";
var HIDERGBA = "e-hide-switchable-value";
var HIDEVALUE = "e-hide-value";
var HIDEVALUESWITCH = "e-hide-valueswitcher";
var HSVAREA = "e-hsv-color";
var HSVCONTAINER = "e-hsv-container";
var INPUTWRAPPER = "e-selected-value";
var MODESWITCH = "e-mode-switch-btn";
var NOCOLOR = "e-nocolor-item";
var OPACITY = "e-opacity-value";
var PALETTES = "e-palette";
var PALETTECONTENT = "e-color-palette";
var PICKERCONTENT = "e-color-picker";
var PREVIEW = "e-preview-container";
var PREVIOUS = "e-previous";
var RTL8 = "e-rtl";
var SHOWVALUE = "e-show-value";
var SELECT = "e-selected";
var SPLITPREVIEW = "e-split-preview";
var TILE = "e-tile";
var presets = {
  default: [
    "#000000",
    "#f44336",
    "#e91e63",
    "#9c27b0",
    "#673ab7",
    "#2196f3",
    "#03a9f4",
    "#00bcd4",
    "#009688",
    "#ffeb3b",
    "#ffffff",
    "#ffebee",
    "#fce4ec",
    "#f3e5f5",
    "#ede7f6",
    "#e3f2fd",
    "#e1f5fe",
    "#e0f7fa",
    "#e0f2f1",
    "#fffde7",
    "#f2f2f2",
    "#ffcdd2",
    "#f8bbd0",
    "#e1bee7",
    "#d1c4e9",
    "#bbdefb",
    "#b3e5fc",
    "#b2ebf2",
    "#b2dfdb",
    "#fff9c4",
    "#e6e6e6",
    "#ef9a9a",
    "#f48fb1",
    "#ce93d8",
    "#b39ddb",
    "#90caf9",
    "#81d4fa",
    "#80deea",
    "#80cbc4",
    "#fff59d",
    "#cccccc",
    "#e57373",
    "#f06292",
    "#ba68c8",
    "#9575cd",
    "#64b5f6",
    "#4fc3f7",
    "#4dd0e1",
    "#4db6ac",
    "#fff176",
    "#b3b3b3",
    "#ef5350",
    "#ec407a",
    "#ab47bc",
    "#7e57c2",
    "#42a5f5",
    "#29b6f6",
    "#26c6da",
    "#26a69a",
    "#ffee58",
    "#999999",
    "#e53935",
    "#d81b60",
    "#8e24aa",
    "#5e35b1",
    "#1e88e5",
    "#039be5",
    "#00acc1",
    "#00897b",
    "#fdd835",
    "#808080",
    "#d32f2f",
    "#c2185b",
    "#7b1fa2",
    "#512da8",
    "#1976d2",
    "#0288d1",
    "#0097a7",
    "#00796b",
    "#fbc02d",
    "#666666",
    "#c62828",
    "#ad1457",
    "#6a1b9a",
    "#4527a0",
    "#1565c0",
    "#0277bd",
    "#00838f",
    "#00695c",
    "#f9a825",
    "#4d4d4d",
    "#b71c1c",
    "#880e4f",
    "#4a148c",
    "#311b92",
    "#0d47a1",
    "#01579b",
    "#006064",
    "#004d40",
    "#f57f17"
  ]
};
var ColorPicker = (
  /** @class */
  function(_super) {
    __extends20(ColorPicker2, _super);
    function ColorPicker2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    ColorPicker2.prototype.preRender = function() {
      var ele = this.element;
      this.formElement = closest(this.element, "form");
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
      var localeText = { Apply: "Apply", Cancel: "Cancel", ModeSwitcher: "Switch Mode" };
      this.l10n = new L10n("colorpicker", localeText, this.locale);
      if (ele.getAttribute("ejs-for") && !ele.getAttribute("name")) {
        ele.setAttribute("name", ele.id);
      }
    };
    ColorPicker2.prototype.render = function() {
      this.initWrapper();
      if (this.inline) {
        this.createWidget();
      } else {
        this.createSplitBtn();
      }
      if (!this.enableOpacity) {
        addClass([this.container.parentElement], HIDEOPACITY);
      }
      this.renderComplete();
    };
    ColorPicker2.prototype.initWrapper = function() {
      var wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-wrapper" });
      this.element.parentNode.insertBefore(wrapper, this.element);
      wrapper.appendChild(this.element);
      attributes(this.element, { "tabindex": "-1", "spellcheck": "false", "aria-label": "colorpicker" });
      this.container = this.createElement("div", { className: CONTAINER });
      this.getWrapper().appendChild(this.container);
      var value = this.value ? this.roundValue(this.value).toLowerCase() : "#008000ff";
      if (this.noColor && this.mode === "Palette" && this.value === "") {
        value = "";
      }
      var slicedValue = value.slice(0, 7);
      if (isNullOrUndefined(this.initialInputValue)) {
        this.initialInputValue = slicedValue;
      }
      this.element.value = slicedValue;
      if (this.enableOpacity) {
        this.setProperties({ "value": value }, true);
      } else {
        this.setProperties({ "value": slicedValue }, true);
      }
      if (this.enableRtl) {
        wrapper.classList.add(RTL8);
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      this.tileRipple = rippleEffect(this.container, { selector: "." + TILE });
      this.ctrlBtnRipple = rippleEffect(this.container, { selector: ".e-btn" });
    };
    ColorPicker2.prototype.getWrapper = function() {
      return this.element.parentElement;
    };
    ColorPicker2.prototype.createWidget = function() {
      if (this.mode === "Palette") {
        this.createPalette();
        if (!this.inline) {
          this.firstPaletteFocus();
        }
      } else {
        this.createPicker();
        if (!this.inline) {
          this.getDragHandler().focus();
        }
      }
      this.isRgb = true;
      this.createInput();
      this.createCtrlBtn();
      if (!this.disabled) {
        this.wireEvents();
      }
      if (this.inline && this.disabled) {
        this.toggleDisabled(true);
      }
      if (Browser.isDevice) {
        this.refreshPopupPos();
      }
    };
    ColorPicker2.prototype.createSplitBtn = function() {
      var _this = this;
      var splitButton = this.createElement("button", { className: "e-split-colorpicker" });
      this.getWrapper().appendChild(splitButton);
      this.splitBtn = new SplitButton({
        iconCss: "e-selected-color",
        target: this.container,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        createPopupOnClick: this.createPopupOnClick,
        open: this.onOpen.bind(this),
        click: function() {
          var ev = new MouseEvent("click", { bubbles: true, cancelable: false });
          _this.trigger("change", {
            currentValue: { hex: _this.value.slice(0, 7), rgba: _this.convertToRgbString(_this.hexToRgb(_this.value)) },
            previousValue: { hex: null, rgba: null },
            value: _this.value,
            event: ev
          });
        }
      });
      this.splitBtn.createElement = this.createElement;
      this.splitBtn.appendTo(splitButton);
      var preview = this.createElement("span", { className: SPLITPREVIEW });
      select(".e-selected-color", splitButton).appendChild(preview);
      preview.style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
      var popupEle = this.getPopupEle();
      addClass([popupEle], "e-colorpicker-popup");
      if (this.cssClass) {
        addClass([popupEle], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (Browser.isDevice && !this.createPopupOnClick) {
        var popupInst = this.getPopupInst();
        popupInst.relateTo = document.body;
        popupInst.position = { X: "center", Y: "center" };
        popupInst.targetType = "container";
        popupInst.collision = { X: "fit", Y: "fit" };
        popupInst.offsetY = 4;
        popupEle.style.zIndex = getZindexPartial(this.splitBtn.element).toString();
      }
      this.bindCallBackEvent();
    };
    ColorPicker2.prototype.onOpen = function() {
      this.trigger("open", { element: this.container });
      if (!Browser.isDevice) {
        var popupInst = this.getPopupInst();
        var collision = isCollide(popupInst.element);
        if (collision.length > 0) {
          popupInst.collision = { X: "flip", Y: "fit" };
          popupInst.position = { X: "right", Y: "bottom" };
          popupInst.targetType = "container";
        }
      }
    };
    ColorPicker2.prototype.getPopupInst = function() {
      return getInstance(this.getPopupEle(), Popup);
    };
    ColorPicker2.prototype.bindCallBackEvent = function() {
      var _this = this;
      this.splitBtn.beforeOpen = function(args) {
        var callBackPromise = new Deferred();
        _this.trigger("beforeOpen", args, function(observeOpenArgs) {
          if (!observeOpenArgs.cancel) {
            var popupEle = _this.getPopupEle();
            popupEle.style.top = formatUnit(0 + pageYOffset);
            popupEle.style.left = formatUnit(0 + pageXOffset);
            popupEle.style.display = "block";
            _this.createWidget();
            popupEle.style.display = "";
            if (Browser.isDevice) {
              if (_this.createPopupOnClick) {
                var popupInst = _this.getPopupInst();
                popupInst.relateTo = document.body;
                popupInst.position = { X: "center", Y: "center" };
                popupInst.targetType = "container";
                popupInst.collision = { X: "fit", Y: "fit" };
                popupInst.offsetY = 4;
                popupEle.style.zIndex = getZindexPartial(_this.splitBtn.element).toString();
              }
              _this.modal = _this.createElement("div");
              _this.modal.className = "e-" + _this.getModuleName() + " e-modal";
              _this.modal.style.display = "none";
              document.body.insertBefore(_this.modal, popupEle);
              document.body.className += " e-colorpicker-overflow";
              _this.modal.style.display = "block";
              _this.modal.style.zIndex = (Number(popupEle.style.zIndex) - 1).toString();
            }
          }
          args.cancel = observeOpenArgs.cancel;
          callBackPromise.resolve(observeOpenArgs);
        });
        return callBackPromise;
      };
      this.splitBtn.beforeClose = function(args) {
        var callBackPromise = new Deferred();
        if (!isNullOrUndefined(args.event)) {
          var beforeCloseArgs = { element: _this.container, event: args.event, cancel: false };
          _this.trigger("beforeClose", beforeCloseArgs, function(observedCloseArgs) {
            if (Browser.isDevice && args.event.target === _this.modal) {
              observedCloseArgs.cancel = true;
            }
            if (!observedCloseArgs.cancel) {
              _this.onPopupClose();
            }
            args.cancel = observedCloseArgs.cancel;
            callBackPromise.resolve(observedCloseArgs);
          });
        } else {
          callBackPromise.resolve(args);
        }
        return callBackPromise;
      };
    };
    ColorPicker2.prototype.onPopupClose = function() {
      this.unWireEvents();
      this.destroyOtherComp();
      this.container.style.width = "";
      select("." + SPLITPREVIEW, this.splitBtn.element).style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
      this.container.innerHTML = "";
      removeClass([this.container], [PICKERCONTENT, PALETTECONTENT]);
      if (Browser.isDevice && this.modal) {
        removeClass([document.body], "e-colorpicker-overflow");
        this.modal.style.display = "none";
        this.modal.outerHTML = "";
        this.modal = null;
      }
    };
    ColorPicker2.prototype.createPalette = function() {
      classList(this.container, [PALETTECONTENT], [PICKERCONTENT]);
      if (this.presetColors) {
        var paletteGroup = this.createElement("div", { className: "e-custom-palette" });
        this.appendElement(paletteGroup);
        var keys = Object.keys(this.presetColors);
        if (keys.length === 1) {
          this.appendPalette(this.presetColors[keys[0]], keys[0], paletteGroup);
        } else {
          for (var i = 0, len = keys.length; i < len; i++) {
            this.appendPalette(this.presetColors[keys[i]], keys[i], paletteGroup);
          }
        }
        if (selectAll(".e-row", paletteGroup).length > 10) {
          addClass([paletteGroup], "e-palette-group");
        }
      } else {
        this.appendPalette(presets.default, "default");
      }
      if (this.mode === "Palette" && !this.modeSwitcher && this.noColor) {
        this.setNoColor();
      }
      var width = parseInt(getComputedStyle(this.container).borderBottomWidth, 10);
      this.container.style.width = formatUnit(this.container.children[0].offsetWidth + width + width);
      this.rgb = this.hexToRgb(this.roundValue(this.value));
      this.hsv = this.rgbToHsv.apply(this, this.rgb);
    };
    ColorPicker2.prototype.firstPaletteFocus = function() {
      if (!select("." + SELECT, this.container.children[0])) {
        selectAll("." + PALETTES, this.container)[0].focus();
      }
    };
    ColorPicker2.prototype.appendPalette = function(colors, key, refEle) {
      var palette = this.createElement("div", { className: PALETTES, attrs: { "tabindex": "0", "role": "grid" } });
      if (refEle) {
        refEle.appendChild(palette);
      } else {
        this.appendElement(palette);
      }
      var row;
      var tile;
      var roundedColor;
      for (var i = 0, len = colors.length; i < len; i++) {
        if (i === 0 || i % this.columns === 0) {
          row = this.createElement("div", {
            className: "e-row",
            attrs: { "role": "row" }
          });
          palette.appendChild(row);
        }
        roundedColor = this.roundValue(colors[i]).toLowerCase();
        tile = this.createElement("span", {
          className: TILE,
          attrs: { "role": "gridcell", "aria-label": roundedColor, "aria-selected": "false", "tabindex": "0" }
        });
        this.trigger("beforeTileRender", { element: tile, presetName: key, value: colors[i] });
        row.appendChild(tile);
        if (this.value === roundedColor) {
          this.addTileSelection(tile);
          palette.focus();
        }
        tile.style.backgroundColor = this.convertToRgbString(this.hexToRgb(roundedColor));
      }
    };
    ColorPicker2.prototype.setNoColor = function() {
      var noColorEle = this.container.querySelector(".e-row").children[0];
      noColorEle.classList.add(NOCOLOR);
      if (!this.value) {
        noColorEle.classList.add(SELECT);
        closest(noColorEle, "." + PALETTES).focus();
      }
      ["aria-selected", "aria-label"].forEach(function(attr) {
        noColorEle.removeAttribute(attr);
      });
      noColorEle.style.backgroundColor = "";
    };
    ColorPicker2.prototype.appendElement = function(ele, insertPos) {
      if (insertPos === void 0) {
        insertPos = 0;
      }
      var refEle = this.container.children[insertPos];
      if (refEle) {
        this.container.insertBefore(ele, refEle);
      } else {
        this.container.appendChild(ele);
      }
    };
    ColorPicker2.prototype.addTileSelection = function(ele) {
      ele.classList.add(SELECT);
      ele.setAttribute("aria-selected", "true");
    };
    ColorPicker2.prototype.createPicker = function() {
      classList(this.container, [PICKERCONTENT], [PALETTECONTENT]);
      var hsvContainer = this.createElement("div", { className: HSVCONTAINER });
      this.appendElement(hsvContainer);
      hsvContainer.appendChild(this.createElement("div", { className: HSVAREA }));
      var dragHandler = this.createElement("span", { className: HANDLER, attrs: { "tabindex": "0" } });
      hsvContainer.appendChild(dragHandler);
      if (this.value === null || this.value === "") {
        this.value = "#008000ff";
      }
      this.rgb = this.hexToRgb(this.value);
      this.hsv = this.rgbToHsv.apply(this, this.rgb);
      this.setHsvContainerBg();
      this.setHandlerPosition();
      this.createSlider();
      this.createDragTooltip();
    };
    ColorPicker2.prototype.setHsvContainerBg = function(h) {
      if (h === void 0) {
        h = this.hsv[0];
      }
      this.getHsvContainer().style.backgroundColor = this.convertToRgbString(this.hsvToRgb(h, 100, 100, 1));
    };
    ColorPicker2.prototype.getHsvContainer = function() {
      return select("." + HSVCONTAINER, this.container);
    };
    ColorPicker2.prototype.setHandlerPosition = function() {
      var dragHandler = this.getDragHandler();
      var hsvArea = select("." + HSVAREA, this.container);
      if (this.enableRtl) {
        dragHandler.style.left = formatUnit(hsvArea.offsetWidth * Math.abs(100 - this.hsv[1]) / 100);
      } else {
        dragHandler.style.left = formatUnit(hsvArea.offsetWidth * this.hsv[1] / 100);
      }
      dragHandler.style.top = formatUnit(hsvArea.offsetHeight * (100 - this.hsv[2]) / 100);
    };
    ColorPicker2.prototype.createSlider = function() {
      var sliderPreviewWrapper = this.createElement("div", { className: "e-slider-preview" });
      this.appendElement(sliderPreviewWrapper, 1);
      this.createPreview(sliderPreviewWrapper);
      var sliderWrapper = this.createElement("div", { className: "e-colorpicker-slider" });
      sliderPreviewWrapper.insertBefore(sliderWrapper, sliderPreviewWrapper.children[0]);
      var slider = this.createElement("div", { className: "e-hue-slider" });
      sliderWrapper.appendChild(slider);
      this.hueSlider = new Slider({
        value: this.hsv[0],
        min: 0,
        max: 359,
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        change: this.hueChange.bind(this)
      });
      this.hueSlider.createElement = this.createElement;
      this.hueSlider.appendTo(slider);
      if (this.enableOpacity) {
        slider = this.createElement("div", { className: "e-opacity-slider" });
        sliderWrapper.appendChild(slider);
        this.createOpacitySlider(slider);
      }
    };
    ColorPicker2.prototype.createOpacitySlider = function(slider) {
      this.opacitySlider = new Slider({
        value: this.rgb[3] * 100,
        min: 0,
        max: 100,
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        change: this.opacityChange.bind(this)
      });
      this.opacitySlider.createElement = this.createElement;
      this.opacitySlider.appendTo(slider);
      var opacityBgTrack = this.createElement("div", { className: "e-opacity-empty-track" });
      slider.appendChild(opacityBgTrack);
      this.updateOpacitySliderBg();
    };
    ColorPicker2.prototype.updateOpacitySliderBg = function() {
      var direction = this.enableRtl ? "to left" : "to right";
      var opacityEle = select(".e-opacity-empty-track", this.opacitySlider.element);
      if (opacityEle) {
        opacityEle.style.background = "linear-gradient(" + direction + ", rgba(" + this.rgb.slice(0, 3) + ", 0) 0%, " + this.convertToRgbString(this.rgb.slice(0, 3)) + " 100%)";
      }
    };
    ColorPicker2.prototype.hueChange = function(args) {
      this.hsv[0] = args.value;
      this.setHsvContainerBg();
      this.convertToOtherFormat();
    };
    ColorPicker2.prototype.opacityChange = function(args) {
      var value = args.value;
      var pValue = this.rgbToHex(this.rgb);
      this.hsv[3] = value / 100;
      this.rgb[3] = value / 100;
      var cValue = this.rgbToHex(this.rgb);
      this.updateOpacityInput(value);
      var rgb = this.convertToRgbString(this.rgb);
      this.updatePreview(rgb);
      this.triggerEvent(cValue, pValue, rgb);
    };
    ColorPicker2.prototype.updateOpacityInput = function(value) {
      if (this.enableOpacity && !this.getWrapper().classList.contains(HIDEVALUE)) {
        var opacityTextBoxInst = getInstance(select("." + OPACITY, this.container), NumericTextBox);
        opacityTextBoxInst.value = value;
        opacityTextBoxInst.dataBind();
      }
    };
    ColorPicker2.prototype.createPreview = function(parentEle) {
      var previewContainer = this.createElement("div", { className: PREVIEW });
      parentEle.appendChild(previewContainer);
      var preview = this.createElement("span", { className: "e-preview " + CURRENT });
      previewContainer.appendChild(preview);
      var colorValue = this.convertToRgbString(this.rgb);
      preview.style.backgroundColor = colorValue;
      preview = this.createElement("span", { className: "e-preview " + PREVIOUS });
      previewContainer.appendChild(preview);
      preview.style.backgroundColor = colorValue;
    };
    ColorPicker2.prototype.isPicker = function() {
      return !this.container.classList.contains(PALETTECONTENT);
    };
    ColorPicker2.prototype.getPopupEle = function() {
      return this.container.parentElement;
    };
    ColorPicker2.prototype.createNumericInput = function(element2, value, label, max) {
      var _this = this;
      var numericInput = new NumericTextBox({
        value,
        placeholder: label,
        min: 0,
        max,
        format: "###.##",
        showSpinButton: false,
        floatLabelType: "Always",
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        readonly: this.isPicker() ? false : true,
        change: function(args) {
          if (args.event) {
            _this.inputHandler(args.event);
          }
        }
      });
      numericInput.createElement = this.createElement;
      numericInput.appendTo(element2);
    };
    ColorPicker2.prototype.createInput = function() {
      var isPicker = this.isPicker();
      var wrapper = this.getWrapper();
      if (isPicker && !wrapper.classList.contains(HIDEVALUE) || !isPicker && wrapper.classList.contains(SHOWVALUE)) {
        var inputWrap = this.createElement("div", { className: INPUTWRAPPER });
        if (isPicker) {
          this.appendElement(inputWrap, 2);
        } else {
          this.appendElement(inputWrap, 1);
        }
        var container = this.createElement("div", { className: "e-input-container" });
        inputWrap.appendChild(container);
        if (!wrapper.classList.contains(HIDEVALUESWITCH)) {
          this.appendValueSwitchBtn(inputWrap);
        }
        if (!wrapper.classList.contains(HIDEHEX)) {
          var hexInput = this.createElement("input", {
            className: HEX,
            attrs: { "maxlength": "7", "spellcheck": "false", "aria-label": "HEX" }
          });
          container.appendChild(hexInput);
          Input.createInput({
            element: hexInput,
            floatLabelType: "Always",
            properties: {
              placeholder: "HEX",
              enableRtl: this.enableRtl,
              enabled: !this.disabled,
              readonly: this.isPicker() ? false : true
            }
          }, this.createElement);
          Input.setValue(this.value.slice(0, 7), hexInput);
          hexInput.addEventListener("input", this.inputHandler.bind(this));
        }
        if (!wrapper.classList.contains(HIDERGBA)) {
          var label = void 0;
          var value = void 0;
          if (this.isRgb) {
            label = "RGB";
            value = this.rgb;
          } else {
            label = "HSV";
            value = this.hsv;
          }
          var clsName = ["rh", "gs", "bv"];
          for (var i = 0; i < 3; i++) {
            this.createNumericInput(container.appendChild(this.createElement("input", { className: "e-" + clsName[i] + "-value" })), value[i], label[i], 255);
          }
          if (this.enableOpacity) {
            this.appendOpacityValue(container);
          }
        }
      }
    };
    ColorPicker2.prototype.appendOpacityValue = function(container) {
      this.createNumericInput(container.appendChild(this.createElement("input", { className: OPACITY })), this.rgb[3] * 100, "A", 100);
    };
    ColorPicker2.prototype.appendValueSwitchBtn = function(targetEle) {
      var valueSwitchBtn = this.createElement("button", {
        className: "e-icons e-css e-btn e-flat e-icon-btn " + FORMATSWITCH,
        attrs: { "title": "Toggle format" }
      });
      targetEle.appendChild(valueSwitchBtn);
      if (this.isPicker() && !this.getWrapper().classList.contains(HIDERGBA)) {
        valueSwitchBtn.addEventListener("click", this.formatSwitchHandler.bind(this));
      }
    };
    ColorPicker2.prototype.createCtrlBtn = function() {
      if (this.modeSwitcher || this.showButtons) {
        this.l10n.setLocale(this.locale);
        var btnWrapper = this.createElement("div", { className: CTRLSWITCH });
        this.container.appendChild(btnWrapper);
        if (this.showButtons) {
          var controlBtnWrapper = this.createElement("div", { className: CTRLBTN });
          btnWrapper.appendChild(controlBtnWrapper);
          var apply = this.l10n.getConstant("Apply");
          controlBtnWrapper.appendChild(this.createElement("button", {
            innerHTML: apply,
            className: "e-btn e-css e-flat e-primary e-small " + APPLY,
            attrs: { "title": apply }
          }));
          var cancel = this.l10n.getConstant("Cancel");
          controlBtnWrapper.appendChild(this.createElement("button", {
            innerHTML: cancel,
            className: "e-btn e-css e-flat e-small " + CANCEL,
            attrs: { "title": cancel }
          }));
        }
        if (this.modeSwitcher) {
          this.appendModeSwitchBtn();
        }
      }
    };
    ColorPicker2.prototype.appendModeSwitchBtn = function() {
      var modeSwitcher = this.createElement("button", {
        className: "e-icons e-btn e-flat e-icon-btn " + MODESWITCH,
        attrs: { title: this.l10n.getConstant("ModeSwitcher") }
      });
      select("." + CTRLSWITCH, this.container).insertBefore(modeSwitcher, select("." + CTRLBTN, this.container));
    };
    ColorPicker2.prototype.createDragTooltip = function() {
      var _this = this;
      var tooltip = new Tooltip({
        opensOn: "Custom",
        showTipPointer: false,
        cssClass: "e-color-picker-tooltip",
        htmlAttributes: { title: "tooltip" },
        beforeOpen: function(args) {
          _this.tooltipEle = args.element;
        },
        animation: { open: { effect: "None" }, close: { effect: "None" } }
      });
      tooltip.createElement = this.createElement;
      tooltip.appendTo(this.container);
      tooltip.open(this.container);
      this.tooltipEle.style.zIndex = getZindexPartial(this.tooltipEle).toString();
      this.tooltipEle.setAttribute("aria-label", "colorpicker-tooltip");
      select(".e-tip-content", this.tooltipEle).appendChild(this.createElement("div", { className: "e-tip-transparent" }));
    };
    ColorPicker2.prototype.getTooltipInst = function() {
      return getInstance(this.container, Tooltip);
    };
    ColorPicker2.prototype.setTooltipOffset = function(value) {
      this.getTooltipInst().offsetY = value;
    };
    ColorPicker2.prototype.toggleDisabled = function(enable) {
      if (enable) {
        this.getWrapper().classList.add(DISABLED5);
      } else {
        this.getWrapper().classList.remove(DISABLED5);
      }
      if (this.showButtons) {
        [].slice.call(selectAll(".e-btn", this.container)).forEach(function(ele) {
          if (enable) {
            attributes(ele, { "disabled": "" });
          } else {
            ele.removeAttribute("disabled");
          }
        });
      }
    };
    ColorPicker2.prototype.convertToRgbString = function(rgb) {
      return rgb.length ? rgb.length === 4 ? "rgba(" + rgb.join() + ")" : "rgb(" + rgb.join() + ")" : "";
    };
    ColorPicker2.prototype.convertToHsvString = function(hsv) {
      return hsv.length === 4 ? "hsva(" + hsv.join() + ")" : "hsv(" + hsv.join() + ")";
    };
    ColorPicker2.prototype.updateHsv = function() {
      this.hsv[1] = this.hsv[1] > 100 ? 100 : this.hsv[1];
      this.hsv[2] = this.hsv[2] > 100 ? 100 : this.hsv[2];
      this.setHandlerPosition();
    };
    ColorPicker2.prototype.convertToOtherFormat = function(isKey, e) {
      if (isKey === void 0) {
        isKey = false;
      }
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = this.hsvToRgb.apply(this, this.hsv);
      var cValue = this.rgbToHex(this.rgb);
      var rgba = this.convertToRgbString(this.rgb);
      this.updatePreview(rgba);
      this.updateInput(cValue);
      this.triggerEvent(cValue, pValue, rgba, isKey, e);
    };
    ColorPicker2.prototype.updateInput = function(value) {
      var wrapper = this.getWrapper();
      if (!wrapper.classList.contains(HIDEVALUE)) {
        if (!wrapper.classList.contains(HIDEHEX)) {
          Input.setValue(value.substr(0, 7), select("." + HEX, this.container));
        }
        if (!wrapper.classList.contains(HIDERGBA)) {
          if (this.isRgb) {
            this.updateValue(this.rgb, false);
          } else {
            this.updateValue(this.hsv, false);
          }
        }
      }
    };
    ColorPicker2.prototype.updatePreview = function(value) {
      if (this.enableOpacity) {
        this.updateOpacitySliderBg();
      }
      select(".e-tip-transparent", this.tooltipEle).style.backgroundColor = value;
      select("." + PREVIEW + " ." + CURRENT, this.container).style.backgroundColor = value;
      select("." + PREVIEW + " ." + PREVIOUS, this.container).style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
    };
    ColorPicker2.prototype.getDragHandler = function() {
      return select("." + HANDLER, this.container);
    };
    ColorPicker2.prototype.removeTileSelection = function() {
      var selectedEle = [].slice.call(selectAll("." + SELECT, this.container.children[0]));
      selectedEle.forEach(function(ele) {
        ele.classList.remove(SELECT);
        ele.setAttribute("aria-selected", "false");
      });
    };
    ColorPicker2.prototype.convertRgbToNumberArray = function(value) {
      return value.slice(value.indexOf("(") + 1, value.indexOf(")")).split(",").map(function(n, i) {
        return i !== 3 ? parseInt(n, 10) : parseFloat(n);
      });
    };
    ColorPicker2.prototype.getValue = function(value, type) {
      if (!value) {
        value = this.value;
      }
      type = !type ? "hex" : type.toLowerCase();
      if (value[0] === "r") {
        var cValue = this.convertRgbToNumberArray(value);
        if (type === "hex" || type === "hexa") {
          var hex = this.rgbToHex(cValue);
          return type === "hex" ? hex.slice(0, 7) : hex;
        } else {
          if (type === "hsv") {
            return this.convertToHsvString(this.rgbToHsv.apply(this, cValue.slice(0, 3)));
          } else {
            if (type === "hsva") {
              return this.convertToHsvString(this.rgbToHsv.apply(this, cValue));
            } else {
              return "null";
            }
          }
        }
      } else {
        if (value[0] === "h") {
          var cValue = this.hsvToRgb.apply(this, this.convertRgbToNumberArray(value));
          if (type === "rgba") {
            return this.convertToRgbString(cValue);
          } else {
            if (type === "hex" || type === "hexa") {
              var hex = this.rgbToHex(cValue);
              return type === "hex" ? hex.slice(0, 7) : hex;
            } else {
              if (type === "rgb") {
                return this.convertToRgbString(cValue.slice(0, 3));
              } else {
                return "null";
              }
            }
          }
        } else {
          value = this.roundValue(value);
          var rgb = this.hexToRgb(value);
          if (type === "rgb" || type === "hsv") {
            rgb = rgb.slice(0, 3);
          }
          if (type === "rgba" || type === "rgb") {
            return this.convertToRgbString(rgb);
          } else {
            if (type === "hsva" || type === "hsv") {
              return this.convertToHsvString(this.rgbToHsv.apply(this, rgb));
            } else {
              if (type === "hex") {
                return value.slice(0, 7);
              } else {
                if (type === "a") {
                  return rgb[3].toString();
                } else {
                  return "null";
                }
              }
            }
          }
        }
      }
    };
    ColorPicker2.prototype.toggle = function() {
      if (this.container.parentElement.classList.contains("e-popup-close")) {
        this.splitBtn.toggle();
      } else {
        this.closePopup(null);
      }
    };
    ColorPicker2.prototype.getModuleName = function() {
      return "colorpicker";
    };
    ColorPicker2.prototype.getPersistData = function() {
      return this.addOnPersist(["value"]);
    };
    ColorPicker2.prototype.wireEvents = function() {
      if (this.isPicker()) {
        var dragHandler = this.getDragHandler();
        EventHandler.add(dragHandler, "keydown", this.pickerKeyDown, this);
        var ctrlBtn = select("." + CTRLBTN, this.container);
        if (ctrlBtn) {
          EventHandler.add(ctrlBtn, "keydown", this.ctrlBtnKeyDown, this);
        }
        EventHandler.add(this.getHsvContainer(), "mousedown touchstart", this.handlerDown, this);
        if (this.modeSwitcher || this.showButtons) {
          this.addCtrlSwitchEvent();
        }
        EventHandler.add(select("." + PREVIOUS, this.container), "click", this.previewHandler, this);
      } else {
        EventHandler.add(this.container, "click", this.paletteClickHandler, this);
        EventHandler.add(this.container, "keydown", this.paletteKeyDown, this);
      }
    };
    ColorPicker2.prototype.formResetHandler = function() {
      this.value = this.initialInputValue;
      attributes(this.element, { "value": this.initialInputValue });
    };
    ColorPicker2.prototype.addCtrlSwitchEvent = function() {
      var ctrlSwitchBtn = select("." + CTRLSWITCH, this.container);
      if (ctrlSwitchBtn) {
        EventHandler.add(ctrlSwitchBtn, "click", this.btnClickHandler, this);
      }
    };
    ColorPicker2.prototype.ctrlBtnKeyDown = function(e) {
      if (e.keyCode === 13) {
        var applyBtn = select("." + APPLY, this.container);
        if (applyBtn) {
          var cValue = this.rgbToHex(this.rgb);
          this.triggerChangeEvent(cValue);
        }
        this.splitBtn.element.focus();
      }
    };
    ColorPicker2.prototype.pickerKeyDown = function(e) {
      switch (e.keyCode) {
        case 39:
          this.handlerDragPosition(1, this.enableRtl ? -1 : 1, e);
          break;
        case 37:
          this.handlerDragPosition(1, this.enableRtl ? 1 : -1, e);
          break;
        case 38:
          this.handlerDragPosition(2, 1, e);
          break;
        case 40:
          this.handlerDragPosition(2, -1, e);
          break;
        case 13: {
          e.preventDefault();
          var cValue = this.rgbToHex(this.rgb);
          this.enterKeyHandler(cValue, e);
        }
      }
    };
    ColorPicker2.prototype.enterKeyHandler = function(value, e) {
      this.triggerChangeEvent(value);
      if (!this.inline) {
        this.splitBtn.element.focus();
      }
    };
    ColorPicker2.prototype.closePopup = function(e) {
      var _this = this;
      var beforeCloseArgs = { element: this.container, event: e, cancel: false };
      this.trigger("beforeClose", beforeCloseArgs, function(observedcloseArgs) {
        if (!observedcloseArgs.cancel) {
          _this.splitBtn.toggle();
          _this.onPopupClose();
        }
      });
    };
    ColorPicker2.prototype.triggerChangeEvent = function(value, e) {
      var hex = value.slice(0, 7);
      this.trigger("change", {
        currentValue: { hex, rgba: this.convertToRgbString(this.rgb) },
        event: e,
        previousValue: { hex: this.value.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(this.value)) },
        value: this.enableOpacity ? value : hex
      });
      if (this.enableOpacity) {
        this.setProperties({ "value": value }, true);
      } else {
        this.setProperties({ "value": hex }, true);
      }
      this.element.value = hex ? hex : "#000000";
    };
    ColorPicker2.prototype.handlerDragPosition = function(prob, value, e) {
      e.preventDefault();
      this.hsv[prob] += value * (e.ctrlKey ? 1 : 3);
      if (this.hsv[prob] < 0) {
        this.hsv[prob] = 0;
      }
      this.updateHsv();
      this.convertToOtherFormat(true, e);
    };
    ColorPicker2.prototype.handlerDown = function(e) {
      e.preventDefault();
      if (e.type === "mousedown") {
        this.clientX = Math.abs(e.pageX - pageXOffset);
        this.clientY = Math.abs(e.pageY - pageYOffset);
        this.setTooltipOffset(8);
      } else {
        this.clientX = Math.abs(e.changedTouches[0].pageX - pageXOffset);
        this.clientY = Math.abs(e.changedTouches[0].pageY - pageYOffset);
        this.setTooltipOffset(-8);
      }
      this.setHsv(this.clientX, this.clientY);
      this.getDragHandler().style.transition = "left .4s cubic-bezier(.25, .8, .25, 1), top .4s cubic-bezier(.25, .8, .25, 1)";
      this.updateHsv();
      this.convertToOtherFormat(false, e);
      this.getDragHandler().focus();
      EventHandler.add(document, "mousemove touchmove", this.handlerMove, this);
      EventHandler.add(document, "mouseup touchend", this.handlerEnd, this);
    };
    ColorPicker2.prototype.handlerMove = function(e) {
      if (e.type !== "touchmove") {
        e.preventDefault();
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = Math.abs(e.pageX - pageXOffset);
        y = Math.abs(e.pageY - pageYOffset);
      } else {
        x = Math.abs(e.changedTouches[0].pageX - pageXOffset);
        y = Math.abs(e.changedTouches[0].pageY - pageYOffset);
      }
      this.setHsv(x, y);
      var dragHandler = this.getDragHandler();
      this.updateHsv();
      this.convertToOtherFormat(false, e);
      this.getTooltipInst().refresh(dragHandler);
      if (!this.tooltipEle.style.transform) {
        if (Math.abs(this.clientX - x) > 8 || Math.abs(this.clientY - y) > 8) {
          select("." + HSVAREA, this.container).style.cursor = "pointer";
          dragHandler.style.transition = "none";
          if (!this.inline) {
            this.tooltipEle.style.zIndex = (parseInt(this.getPopupEle().style.zIndex, 10) + 1).toString();
          }
          this.tooltipEle.style.transform = "rotate(45deg)";
          dragHandler.classList.add("e-hide-handler");
        }
      }
    };
    ColorPicker2.prototype.setHsv = function(clientX, clientY) {
      var ele = select("." + HSVAREA, this.container);
      var position = ele.getBoundingClientRect();
      if (this.enableRtl) {
        clientX = clientX > position.right ? 0 : Math.abs(clientX - position.right);
      } else {
        clientX = clientX > position.left ? Math.abs(clientX - position.left) : 0;
      }
      clientY = clientY > position.top ? Math.abs(clientY - position.top) : 0;
      this.hsv[2] = Math.round(Number(100 * (ele.offsetHeight - Math.max(0, Math.min(ele.offsetHeight, clientY - ele.offsetTop))) / ele.offsetHeight) * 10) / 10;
      this.hsv[1] = Math.round(Number(100 * Math.max(0, Math.min(ele.offsetWidth, clientX - ele.offsetLeft)) / ele.offsetWidth) * 10) / 10;
    };
    ColorPicker2.prototype.handlerEnd = function(e) {
      if (e.type !== "touchend") {
        e.preventDefault();
      }
      EventHandler.remove(document, "mousemove touchmove", this.handlerMove);
      EventHandler.remove(document, "mouseup touchend", this.handlerEnd);
      var dragHandler = this.getDragHandler();
      select("." + HSVAREA, this.container).style.cursor = "";
      if (this.tooltipEle.style.transform) {
        this.tooltipEle.style.transform = "";
        dragHandler.classList.remove("e-hide-handler");
      }
      if (!this.inline && !this.showButtons) {
        this.closePopup(e);
      }
    };
    ColorPicker2.prototype.btnClickHandler = function(e) {
      var target = e.target;
      if (closest(target, "." + MODESWITCH)) {
        e.stopPropagation();
        this.switchToPalette();
      } else {
        if (target.classList.contains(APPLY) || target.classList.contains(CANCEL)) {
          this.ctrlBtnClick(target, e);
        }
      }
    };
    ColorPicker2.prototype.switchToPalette = function() {
      this.trigger("beforeModeSwitch", { element: this.container, mode: "Palette" });
      this.unWireEvents();
      this.destroyOtherComp();
      detach(select(".e-slider-preview", this.container));
      if (!this.getWrapper().classList.contains(HIDEVALUE)) {
        remove(select("." + INPUTWRAPPER, this.container));
      }
      detach(this.getHsvContainer());
      this.createPalette();
      this.firstPaletteFocus();
      this.createInput();
      this.refreshPopupPos();
      if (this.element.parentElement && this.element.parentElement.parentElement && this.element.parentElement.parentElement.classList.contains("e-ie-ddb-popup")) {
        this.refreshImageEditorPopupPos();
      }
      ;
      this.wireEvents();
      this.trigger("onModeSwitch", { element: this.container, mode: "Palette" });
    };
    ColorPicker2.prototype.refreshImageEditorPopupPos = function() {
      if (Browser.isDevice) {
        var popupEle = this.getPopupEle();
        popupEle.style.left = formatUnit(0 + pageXOffset);
        popupEle.style.top = formatUnit(0 + pageYOffset);
        var btnElem = document.querySelector("#" + this.element.parentElement.parentElement.id.split("-popup")[0]);
        if (btnElem) {
          popupEle.parentElement.ej2_instances[0].refreshPosition(btnElem);
        }
      }
    };
    ColorPicker2.prototype.refreshPopupPos = function() {
      if (!this.inline) {
        var popupEle = this.getPopupEle();
        popupEle.style.left = formatUnit(0 + pageXOffset);
        popupEle.style.top = formatUnit(0 + pageYOffset);
        this.getPopupInst().refreshPosition(this.splitBtn.element.parentElement);
      }
    };
    ColorPicker2.prototype.formatSwitchHandler = function() {
      if (this.isRgb) {
        this.updateValue(this.hsv, true, 3, [360, 100, 100]);
        this.isRgb = false;
      } else {
        this.updateValue(this.rgb, true, 2);
        this.isRgb = true;
      }
    };
    ColorPicker2.prototype.updateValue = function(value, format, idx, max) {
      var clsName = ["e-rh-value", "e-gs-value", "e-bv-value"];
      var inst;
      for (var i = 0, len = clsName.length; i < len; i++) {
        inst = getInstance(select("." + clsName[i], this.container), NumericTextBox);
        inst.value = Math.round(value[i]);
        if (format) {
          inst.placeholder = clsName[i].substr(idx, 1).toUpperCase();
          inst.max = max ? max[i] : 255;
        }
        inst.dataBind();
      }
    };
    ColorPicker2.prototype.previewHandler = function(e) {
      var target = e.target;
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = this.convertRgbToNumberArray(target.style.backgroundColor);
      if (!this.rgb[3]) {
        this.rgb[3] = 1;
      }
      var cValue = this.rgbToHex(this.rgb);
      var hsv = this.rgbToHsv.apply(this, this.rgb);
      if (hsv[0] !== this.hsv[0]) {
        this.hueSlider.setProperties({ "value": hsv[0] }, true);
        this.hueSlider.refresh();
      }
      this.setHsvContainerBg(hsv[0]);
      if (this.enableOpacity && hsv[3] !== this.hsv[3]) {
        this.opacitySlider.setProperties({ "value": hsv[3] * 100 }, true);
        this.opacitySlider.refresh();
        this.updateOpacitySliderBg();
      }
      this.hsv = hsv;
      this.setHandlerPosition();
      this.updateInput(cValue);
      select("." + PREVIEW + " ." + CURRENT, this.container).style.backgroundColor = this.convertToRgbString(this.rgb);
      this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), false, e);
    };
    ColorPicker2.prototype.paletteClickHandler = function(e) {
      e.preventDefault();
      var target = e.target;
      if (target.classList.contains(TILE)) {
        this.removeTileSelection();
        this.addTileSelection(target);
        if (target.classList.contains(NOCOLOR)) {
          this.noColorTile();
        } else {
          var cValue = target.getAttribute("aria-label");
          var pValue = this.rgbToHex(this.rgb);
          this.rgb = this.hexToRgb(this.roundValue(cValue));
          this.hsv = this.rgbToHsv.apply(this, this.rgb);
          if (this.getWrapper().classList.contains(SHOWVALUE)) {
            this.updateInput(cValue);
          }
          this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), false, e);
        }
        if (!this.inline && !this.showButtons) {
          this.closePopup(e);
        }
      } else {
        if (closest(target, "." + MODESWITCH)) {
          this.switchToPicker();
        } else {
          if (target.classList.contains(APPLY) || target.classList.contains(CANCEL)) {
            this.ctrlBtnClick(target, e);
          } else {
            if (this.getWrapper().classList.contains(SHOWVALUE) && closest(target, "." + FORMATSWITCH)) {
              this.formatSwitchHandler();
            }
          }
        }
      }
    };
    ColorPicker2.prototype.noColorTile = function(isKey) {
      if (isKey === void 0) {
        isKey = false;
      }
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = [];
      this.hsv = [];
      this.triggerEvent("", pValue, "", isKey);
    };
    ColorPicker2.prototype.switchToPicker = function() {
      var wrapper = this.getWrapper();
      this.trigger("beforeModeSwitch", { element: this.container, mode: "Picker" });
      this.unWireEvents();
      [].slice.call(selectAll("." + PALETTES, this.container)).forEach(function(ele) {
        detach(ele);
      });
      if (wrapper.classList.contains(SHOWVALUE)) {
        detach(select("." + INPUTWRAPPER, this.container));
      }
      this.container.style.width = "";
      var grpEle = select(".e-custom-palette", this.container);
      if (this.presetColors) {
        remove(grpEle);
      }
      this.createPicker();
      this.getDragHandler().focus();
      this.createInput();
      this.refreshPopupPos();
      if (this.element.parentElement && this.element.parentElement.parentElement && this.element.parentElement.parentElement.classList.contains("e-ie-ddb-popup")) {
        this.refreshImageEditorPopupPos();
      }
      ;
      this.wireEvents();
      this.trigger("onModeSwitch", { element: this.container, mode: "Picker" });
    };
    ColorPicker2.prototype.ctrlBtnClick = function(ele, e) {
      if (ele.classList.contains(APPLY)) {
        var cValue = this.rgbToHex(this.rgb);
        this.triggerChangeEvent(cValue, e);
      }
      if (!this.inline) {
        this.closePopup(e);
        this.splitBtn.element.focus();
      } else if (ele.classList.contains(CANCEL)) {
        var beforeCloseArgs = { element: this.container, event: e, cancel: false };
        this.trigger("beforeClose", beforeCloseArgs);
      }
    };
    ColorPicker2.prototype.paletteKeyDown = function(e) {
      var target = e.target;
      if (!target.classList.contains(PALETTES)) {
        return;
      }
      var selectedEle;
      var idx;
      var tiles = [].slice.call(selectAll("." + TILE, target));
      var prevSelectedEle = tiles.filter(function(tile) {
        return tile.classList.contains("e-selected");
      }).pop();
      switch (!e.altKey && e.keyCode) {
        case 39:
          e.preventDefault();
          selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, this.enableRtl ? -1 : 1)] : tiles[this.enableRtl ? tiles.length - 1 : 0];
          this.keySelectionChanges(selectedEle);
          break;
        case 37:
          e.preventDefault();
          selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, this.enableRtl ? 1 : -1)] : tiles[this.enableRtl ? 0 : tiles.length - 1];
          this.keySelectionChanges(selectedEle);
          break;
        case 38:
          e.preventDefault();
          idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, -this.columns) : 0;
          selectedEle = tiles[idx] ? tiles[idx] : tiles[idx - this.columns];
          this.keySelectionChanges(selectedEle);
          break;
        case 40:
          e.preventDefault();
          idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, this.columns) : tiles.length - 1;
          if (tiles[idx]) {
            selectedEle = tiles[idx];
          } else {
            idx %= tiles.length;
            idx += tiles[tiles.length - 1].parentElement.childElementCount;
            selectedEle = tiles[idx];
          }
          this.keySelectionChanges(selectedEle);
          break;
        case 13:
          e.preventDefault();
          if (prevSelectedEle) {
            var cValue = prevSelectedEle.getAttribute("aria-label");
            this.enterKeyHandler(cValue ? cValue : "", e);
          }
      }
    };
    ColorPicker2.prototype.keySelectionChanges = function(newEle) {
      this.removeTileSelection();
      this.addTileSelection(newEle);
      if (newEle.classList.contains(NOCOLOR)) {
        this.noColorTile(true);
      } else {
        var cValue = newEle.getAttribute("aria-label");
        var pValue = this.rgbToHex(this.rgb);
        this.rgb = this.hexToRgb(cValue);
        this.hsv = this.rgbToHsv.apply(this, this.rgb);
        if (this.getWrapper().classList.contains(SHOWVALUE)) {
          this.updateInput(cValue);
        }
        this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), true);
      }
    };
    ColorPicker2.prototype.tilePosition = function(items, element2, cIdx) {
      items = Array.prototype.slice.call(items);
      var n = items.length;
      var emptyCount = this.columns - items[n - 1].parentElement.childElementCount;
      var idx = items.indexOf(element2);
      idx += cIdx;
      if (idx < 0) {
        idx += n + emptyCount;
      } else {
        idx %= n + emptyCount;
      }
      return idx;
    };
    ColorPicker2.prototype.inputHandler = function(e) {
      var target = e.target;
      if (!target.value.length) {
        return;
      }
      var hsv;
      var pValue;
      var label = select(".e-float-text", target.parentElement).textContent;
      switch (label) {
        case "HEX": {
          var value = "";
          if (target.value[0] === "#" && target.value.length !== 5 || target.value[0] !== "#" && target.value.length !== 4) {
            value = this.roundValue(target.value);
          }
          if (value.length === 9) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb = this.hexToRgb(value + value.substr(-2));
            this.inputValueChange(this.rgbToHsv.apply(this, this.rgb), pValue, target.value, e);
          } else {
            return;
          }
          break;
        }
        case "R":
          if (this.rgb[0] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[0] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "G":
          if (this.rgb[1] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[1] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "B":
          if (this.rgb[2] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[2] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "H":
          this.hueSlider.value = Number(target.value);
          break;
        case "S":
          if (this.hsv[1] !== Number(target.value)) {
            this.hsv[1] = Number(target.value);
            this.updateHsv();
            this.convertToOtherFormat(false, e);
          }
          break;
        case "V":
          if (this.hsv[2] !== Number(target.value)) {
            this.hsv[2] = Number(target.value);
            this.updateHsv();
            this.convertToOtherFormat(false, e);
          }
          break;
        case "A":
          this.opacitySlider.value = Number(target.value);
          break;
      }
    };
    ColorPicker2.prototype.inputValueChange = function(hsv, pValue, value, e) {
      if (hsv[0] !== this.hsv[0]) {
        this.hueSlider.setProperties({ "value": hsv[0] }, true);
        this.hueSlider.refresh();
        this.setHsvContainerBg(hsv[0]);
      }
      this.hsv = hsv;
      var cValue = this.rgbToHex(this.rgb);
      this.setHandlerPosition();
      this.updateInput(value ? value : cValue);
      var rgba = this.convertToRgbString(this.rgb);
      this.updatePreview(rgba);
      this.triggerEvent(cValue, pValue, rgba, false, e);
    };
    ColorPicker2.prototype.triggerEvent = function(cValue, pValue, rgba, isKey, e) {
      if (isKey === void 0) {
        isKey = false;
      }
      var hex = cValue.slice(0, 7);
      if (isNullOrUndefined(e)) {
        e = new MouseEvent("click", { bubbles: true, cancelable: false });
      }
      if (!this.showButtons && !isKey) {
        this.trigger("change", {
          currentValue: { hex, rgba },
          event: e,
          previousValue: { hex: this.value.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(this.value)) },
          value: cValue
        });
        if (this.enableOpacity) {
          this.setProperties({ "value": cValue }, true);
        } else {
          this.setProperties({ "value": hex }, true);
        }
        this.element.value = hex ? hex : "#000000";
      } else {
        this.trigger("select", {
          currentValue: { hex, rgba },
          event: e,
          previousValue: { hex: pValue.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(pValue)) }
        });
      }
    };
    ColorPicker2.prototype.destroy = function() {
      var _this = this;
      var wrapper = this.getWrapper();
      _super.prototype.destroy.call(this);
      ["tabindex", "spellcheck"].forEach(function(attr) {
        _this.element.removeAttribute(attr);
      });
      if (this.inline) {
        this.unWireEvents();
        this.destroyOtherComp();
      } else {
        if (this.isPopupOpen()) {
          this.unWireEvents();
          this.destroyOtherComp();
        }
        this.splitBtn.destroy();
        this.splitBtn = null;
      }
      this.tileRipple();
      this.tileRipple = null;
      this.ctrlBtnRipple();
      this.ctrlBtnRipple = null;
      if (this.element.nextElementSibling) {
        detach(this.element.nextElementSibling);
      }
      if (wrapper) {
        wrapper.parentElement.insertBefore(this.element, wrapper);
        detach(wrapper);
      }
      this.container = null;
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    ColorPicker2.prototype.destroyOtherComp = function() {
      if (this.isPicker()) {
        var popup = closest(this.hueSlider.element, ".e-color-picker");
        var numericElemColl = popup.querySelectorAll(".e-numerictextbox");
        for (var i = 0; i < numericElemColl.length; i++) {
          getInstance(numericElemColl[i], NumericTextBox).destroy();
        }
        this.hueSlider.destroy();
        if (this.enableOpacity) {
          this.opacitySlider.destroy();
          this.opacitySlider = null;
        }
        this.hueSlider = null;
        var tooltipInst = this.getTooltipInst();
        tooltipInst.close();
        tooltipInst.destroy();
        this.tooltipEle = null;
      }
    };
    ColorPicker2.prototype.isPopupOpen = function() {
      return this.getPopupEle().classList.contains("e-popup-open");
    };
    ColorPicker2.prototype.unWireEvents = function() {
      if (this.isPicker()) {
        var dragHandler = this.getDragHandler();
        EventHandler.remove(dragHandler, "keydown", this.pickerKeyDown);
        var ctrlBtn = select("." + CTRLBTN, this.container);
        if (ctrlBtn) {
          EventHandler.remove(ctrlBtn, "keydown", this.ctrlBtnKeyDown);
        }
        EventHandler.remove(this.getHsvContainer(), "mousedown touchstart", this.handlerDown);
        if (this.modeSwitcher || this.showButtons) {
          EventHandler.remove(select("." + CTRLSWITCH, this.container), "click", this.btnClickHandler);
        }
        EventHandler.remove(select("." + PREVIOUS, this.container), "click", this.previewHandler);
      } else {
        EventHandler.remove(this.container, "click", this.paletteClickHandler);
        EventHandler.remove(this.container, "keydown", this.paletteKeyDown);
      }
    };
    ColorPicker2.prototype.roundValue = function(value) {
      if (!value) {
        return "";
      }
      if (value[0] !== "#") {
        value = "#" + value;
      }
      var len = value.length;
      if (len === 4) {
        value += "f";
        len = 5;
      }
      if (len === 5) {
        var tempValue = "";
        for (var i = 1, len_1 = value.length; i < len_1; i++) {
          tempValue += value.charAt(i) + value.charAt(i);
        }
        value = "#" + tempValue;
        len = 9;
      }
      if (len === 7) {
        value += "ff";
      }
      return value;
    };
    ColorPicker2.prototype.hexToRgb = function(hex) {
      if (!hex) {
        return [];
      }
      hex = hex.trim();
      if (hex.length !== 9) {
        hex = this.roundValue(hex);
      }
      var opacity = Number((parseInt(hex.slice(-2), 16) / 255).toFixed(2));
      hex = hex.slice(1, 7);
      var bigInt = parseInt(hex, 16);
      var h = [];
      h.push(bigInt >> 16 & 255);
      h.push(bigInt >> 8 & 255);
      h.push(bigInt & 255);
      h.push(opacity);
      return h;
    };
    ColorPicker2.prototype.rgbToHsv = function(r, g, b, opacity) {
      if (this.rgb && !this.rgb.length) {
        return [];
      }
      r /= 255;
      g /= 255;
      b /= 255;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      var hsv = [Math.round(h * 360), Math.round(s * 1e3) / 10, Math.round(v * 1e3) / 10];
      if (!isNullOrUndefined(opacity)) {
        hsv.push(opacity);
      }
      return hsv;
    };
    ColorPicker2.prototype.hsvToRgb = function(h, s, v, opacity) {
      var r;
      var g;
      var b;
      s /= 100;
      v /= 100;
      if (s === 0) {
        r = g = b = v;
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), opacity];
      }
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        default:
          r = v;
          g = p;
          b = q;
      }
      var rgb = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      if (!isNullOrUndefined(opacity)) {
        rgb.push(opacity);
      }
      return rgb;
    };
    ColorPicker2.prototype.rgbToHex = function(rgb) {
      return rgb.length ? "#" + this.hex(rgb[0]) + this.hex(rgb[1]) + this.hex(rgb[2]) + (!isNullOrUndefined(rgb[3]) ? rgb[3] !== 0 ? (Math.round(rgb[3] * 255) + 65536).toString(16).substr(-2) : "00" : "") : "";
    };
    ColorPicker2.prototype.hex = function(x) {
      return ("0" + x.toString(16)).slice(-2);
    };
    ColorPicker2.prototype.changeModeSwitcherProp = function(prop) {
      var ctrlSwitchWrapper = select("." + CTRLSWITCH, this.container);
      if (prop) {
        if (ctrlSwitchWrapper) {
          this.appendModeSwitchBtn();
        } else {
          this.createCtrlBtn();
          if (this.isPicker() && !this.disabled) {
            this.addCtrlSwitchEvent();
          }
        }
      } else {
        if (ctrlSwitchWrapper) {
          if (this.showButtons) {
            detach(select("." + MODESWITCH, ctrlSwitchWrapper));
          } else {
            remove(ctrlSwitchWrapper);
          }
        }
      }
    };
    ColorPicker2.prototype.changeShowBtnProps = function(prop) {
      var ctrlBtnWrapper = select("." + CTRLSWITCH, this.container);
      if (prop) {
        if (ctrlBtnWrapper) {
          remove(ctrlBtnWrapper);
        }
        this.createCtrlBtn();
        if (this.isPicker() && !this.disabled) {
          this.addCtrlSwitchEvent();
        }
      } else {
        if (this.modeSwitcher) {
          detach(select("." + CTRLBTN, ctrlBtnWrapper));
        } else {
          remove(ctrlBtnWrapper);
        }
      }
    };
    ColorPicker2.prototype.changeValueProp = function(newProp) {
      if (this.isPicker()) {
        this.rgb = this.hexToRgb(newProp);
        this.hsv = this.rgbToHsv.apply(this, this.rgb);
        this.setHandlerPosition();
        detach(closest(this.hueSlider.element, ".e-slider-preview"));
        this.createSlider();
        this.setHsvContainerBg();
        this.updateInput(newProp);
        if (this.rgb.length === 4) {
          this.updateOpacityInput(this.rgb[3] * 100);
        }
      } else {
        this.removeTileSelection();
        var ele = this.container.querySelector('span[aria-label="' + this.roundValue(newProp) + '"]');
        if (ele) {
          this.addTileSelection(ele);
        }
      }
    };
    ColorPicker2.prototype.setInputEleProps = function() {
      remove(select("." + INPUTWRAPPER, this.container));
      this.createInput();
    };
    ColorPicker2.prototype.changeDisabledProp = function(newProp) {
      if (this.isPicker()) {
        this.hueSlider.enabled = !newProp;
        this.opacitySlider.enabled = !newProp;
        this.setInputEleProps();
      }
      if (newProp) {
        this.toggleDisabled(true);
        this.unWireEvents();
      } else {
        this.toggleDisabled(false);
        this.wireEvents();
      }
    };
    ColorPicker2.prototype.changeCssClassProps = function(newProp, oldProp) {
      var wrapper = this.getWrapper();
      var popupWrapper = this.getPopupEle();
      if (oldProp) {
        removeClass([wrapper, popupWrapper], oldProp.split(" "));
      }
      if (newProp) {
        addClass([wrapper, popupWrapper], newProp.replace(/\s+/g, " ").trim().split(" "));
      }
    };
    ColorPicker2.prototype.changeRtlProps = function(newProp) {
      if (newProp) {
        addClass([this.getWrapper()], "e-rtl");
      } else {
        removeClass([this.getWrapper()], "e-rtl");
      }
    };
    ColorPicker2.prototype.changePaletteProps = function() {
      detach(this.container.children[0]);
      this.container.style.width = "";
      this.createPalette();
    };
    ColorPicker2.prototype.changeOpacityProps = function(newProp) {
      var wrapper = this.getWrapper();
      if (newProp) {
        removeClass([this.container.parentElement], HIDEOPACITY);
        this.createOpacitySlider(select(".e-colorpicker-slider", this.container).appendChild(this.createElement("div", { className: "e-opacity-slider" })));
        if (!wrapper.classList.contains(HIDEVALUE) && !wrapper.classList.contains(HIDERGBA)) {
          this.appendOpacityValue(select(".e-input-container", this.container));
        }
      } else {
        addClass([this.container.parentElement], HIDEOPACITY);
        this.opacitySlider.destroy();
        remove(this.opacitySlider.element);
        this.opacitySlider = null;
        if (!wrapper.classList.contains(HIDEVALUE) && !wrapper.classList.contains(HIDERGBA)) {
          remove(select("." + OPACITY, this.container).parentElement);
        }
      }
    };
    ColorPicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      if (!isNullOrUndefined(newProp.value)) {
        var value = this.roundValue(newProp.value);
        if (value.length === 9) {
          this.element.value = this.roundValue(value).slice(0, 7);
          var preview = this.splitBtn && select("." + SPLITPREVIEW, this.splitBtn.element);
          if (preview) {
            preview.style.backgroundColor = this.convertToRgbString(this.hexToRgb(newProp.value));
          }
        } else if (this.noColor && this.mode === "Palette" && this.value === "") {
          var preview = this.splitBtn && select("." + SPLITPREVIEW, this.splitBtn.element);
          preview.style.backgroundColor = "";
        } else {
          this.value = oldProp.value;
        }
      }
      if (!this.inline && isNullOrUndefined(newProp.inline)) {
        var otherCompModel = ["disabled", "enableRtl"];
        this.splitBtn.setProperties(getModel(newProp, otherCompModel));
        if (!this.isPopupOpen()) {
          this.changeCssClassProps(newProp.cssClass, oldProp.cssClass);
          this.changeRtlProps(newProp.enableRtl);
          return;
        }
      }
      var _loop_1 = function(prop2) {
        switch (prop2) {
          case "inline":
            if (newProp.inline) {
              this_1.getWrapper().appendChild(this_1.container);
              this_1.splitBtn.destroy();
              detach(this_1.element.nextElementSibling);
              if (!this_1.container.children.length) {
                this_1.createWidget();
              }
            } else {
              this_1.destroyOtherComp();
              this_1.unWireEvents();
              this_1.container.innerHTML = "";
              this_1.createSplitBtn();
            }
            break;
          case "cssClass": {
            this_1.changeCssClassProps(newProp.cssClass, oldProp.cssClass);
            var props = newProp.cssClass.split(" ").concat(oldProp.cssClass.split(" "));
            props = props.reduce(function(a, b) {
              if (a.indexOf(b) < 0) {
                a.push(b);
              }
              return a;
            }, []);
            var count_1 = 0;
            props.forEach(function(cls) {
              if (count_1 === 0 && (cls === HIDEVALUE || cls === HIDEVALUESWITCH || cls === SHOWVALUE || cls === HIDEHEX || cls === HIDERGBA)) {
                var inputWrap = select("." + INPUTWRAPPER, _this.container);
                if (inputWrap) {
                  remove(select("." + INPUTWRAPPER, _this.container));
                }
                _this.createInput();
                count_1++;
              }
            });
            break;
          }
          case "enableRtl":
            if (this_1.isPicker()) {
              this_1.hueSlider.enableRtl = newProp.enableRtl;
              if (this_1.enableOpacity) {
                this_1.opacitySlider.enableRtl = newProp.enableRtl;
              }
              this_1.setInputEleProps();
            }
            this_1.changeRtlProps(newProp.enableRtl);
            break;
          case "disabled":
            this_1.changeDisabledProp(newProp.disabled);
            break;
          case "value":
            if (this_1.value !== oldProp.value) {
              this_1.changeValueProp(newProp.value);
            }
            break;
          case "showButtons":
            this_1.changeShowBtnProps(newProp.showButtons);
            break;
          case "mode":
            if (newProp.mode === "Picker") {
              this_1.switchToPicker();
            } else {
              this_1.switchToPalette();
            }
            break;
          case "modeSwitcher":
            this_1.changeModeSwitcherProp(newProp.modeSwitcher);
            break;
          case "columns":
          case "presetColors":
            if (!this_1.isPicker()) {
              this_1.changePaletteProps();
            }
            break;
          case "noColor":
            if (newProp.noColor) {
              if (this_1.mode === "Palette" && !this_1.modeSwitcher) {
                this_1.setNoColor();
              }
            } else {
              this_1.changePaletteProps();
            }
            break;
          case "enableOpacity":
            this_1.changeOpacityProps(newProp.enableOpacity);
            break;
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        _loop_1(prop);
      }
    };
    ColorPicker2.prototype.focusIn = function() {
      this.element.parentElement.focus();
    };
    __decorate21([
      Property("#008000ff")
    ], ColorPicker2.prototype, "value", void 0);
    __decorate21([
      Property("")
    ], ColorPicker2.prototype, "cssClass", void 0);
    __decorate21([
      Property(false)
    ], ColorPicker2.prototype, "disabled", void 0);
    __decorate21([
      Property("Picker")
    ], ColorPicker2.prototype, "mode", void 0);
    __decorate21([
      Property(true)
    ], ColorPicker2.prototype, "modeSwitcher", void 0);
    __decorate21([
      Property(null)
    ], ColorPicker2.prototype, "presetColors", void 0);
    __decorate21([
      Property(true)
    ], ColorPicker2.prototype, "showButtons", void 0);
    __decorate21([
      Property(10)
    ], ColorPicker2.prototype, "columns", void 0);
    __decorate21([
      Property(false)
    ], ColorPicker2.prototype, "inline", void 0);
    __decorate21([
      Property(false)
    ], ColorPicker2.prototype, "noColor", void 0);
    __decorate21([
      Property(false)
    ], ColorPicker2.prototype, "enablePersistence", void 0);
    __decorate21([
      Property(true)
    ], ColorPicker2.prototype, "enableOpacity", void 0);
    __decorate21([
      Property(false)
    ], ColorPicker2.prototype, "createPopupOnClick", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "select", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "change", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "beforeTileRender", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "beforeOpen", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "open", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "beforeClose", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "beforeModeSwitch", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "onModeSwitch", void 0);
    __decorate21([
      Event()
    ], ColorPicker2.prototype, "created", void 0);
    ColorPicker2 = __decorate21([
      NotifyPropertyChanges
    ], ColorPicker2);
    return ColorPicker2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/textbox/textbox.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HIDE_CLEAR = "e-clear-icon-hide";
var TextBox = (
  /** @class */
  function(_super) {
    __extends21(TextBox2, _super);
    function TextBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.previousValue = null;
      _this.isHiddenInput = false;
      _this.isForm = false;
      _this.inputPreviousValue = null;
      _this.textboxOptions = options;
      return _this;
    }
    TextBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "floatLabelType":
            Input.removeFloating(this.textboxWrapper);
            Input.addFloating(this.respectiveElement, this.floatLabelType, this.placeholder);
            break;
          case "enabled":
            Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
            this.bindClearEvent();
            break;
          case "width":
            Input.setWidth(newProp.width, this.textboxWrapper.container);
            break;
          case "value":
            {
              var prevOnChange = this.isProtectedOnChange;
              this.isProtectedOnChange = true;
              if (!Input.isBlank(this.value)) {
                this.value = this.value.toString();
              }
              this.isProtectedOnChange = prevOnChange;
              Input.setValue(this.value, this.respectiveElement, this.floatLabelType, this.showClearButton);
              if (this.isHiddenInput) {
                this.element.value = this.respectiveElement.value;
              }
              this.inputPreviousValue = this.respectiveElement.value;
              if ((this.isAngular || this.isVue) && this.preventChange === true) {
                this.previousValue = this.isAngular ? this.value : this.previousValue;
                this.preventChange = false;
              } else if (isNullOrUndefined(this.isAngular) || !this.isAngular || this.isAngular && !this.preventChange || this.isAngular && isNullOrUndefined(this.preventChange)) {
                this.raiseChangeEvent();
              }
            }
            break;
          case "htmlAttributes":
            {
              this.updateHTMLAttributesToElement();
              this.updateHTMLAttributesToWrapper();
              this.checkAttributes(true);
              if (this.multiline && !isNullOrUndefined(this.textarea)) {
                Input.validateInputType(this.textboxWrapper.container, this.textarea);
              } else {
                Input.validateInputType(this.textboxWrapper.container, this.element);
              }
            }
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.respectiveElement);
            break;
          case "type":
            if (this.respectiveElement.tagName !== "TEXTAREA") {
              this.respectiveElement.setAttribute("type", this.type);
              Input.validateInputType(this.textboxWrapper.container, this.element);
              this.raiseChangeEvent();
            }
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.respectiveElement, this.textboxWrapper);
            this.bindClearEvent();
            break;
          case "enableRtl":
            Input.setEnableRtl(this.enableRtl, [this.textboxWrapper.container]);
            break;
          case "placeholder":
            Input.setPlaceholder(this.placeholder, this.respectiveElement);
            Input.calculateWidth(this.respectiveElement, this.textboxWrapper.container);
            break;
          case "autocomplete":
            if (this.autocomplete !== "on" && this.autocomplete !== "") {
              this.respectiveElement.autocomplete = this.autocomplete;
            } else {
              this.removeAttributes(["autocomplete"]);
            }
            break;
          case "cssClass":
            Input.updateCssClass(newProp.cssClass, oldProp.cssClass, this.textboxWrapper.container);
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.placeholder, this.respectiveElement);
            break;
        }
      }
    };
    TextBox2.prototype.getModuleName = function() {
      return "textbox";
    };
    TextBox2.prototype.preRender = function() {
      this.cloneElement = this.element.cloneNode(true);
      this.formElement = closest(this.element, "form");
      if (!isNullOrUndefined(this.formElement)) {
        this.isForm = true;
      }
      if (this.element.tagName === "EJS-TEXTBOX") {
        var ejInstance = getValue("ej2_instances", this.element);
        var inputElement = this.multiline ? this.createElement("textarea") : this.createElement("input");
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (attributeName !== "id" && attributeName !== "class") {
            inputElement.setAttribute(attributeName, this.element.attributes[index].nodeValue);
            inputElement.innerHTML = this.element.innerHTML;
            if (attributeName === "name") {
              this.element.removeAttribute("name");
            }
          } else if (attributeName === "class") {
            inputElement.setAttribute(attributeName, this.element.className.split(" ").filter(function(item) {
              return item.indexOf("ng-") !== 0;
            }).join(" "));
          }
        }
        this.element.appendChild(inputElement);
        this.element = inputElement;
        setValue("ej2_instances", ejInstance, this.element);
      }
      this.updateHTMLAttributesToElement();
      this.checkAttributes(false);
      if ((isNullOrUndefined(this.textboxOptions) || this.textboxOptions["value"] === void 0) && this.element.value !== "") {
        this.setProperties({ value: this.element.value }, true);
      }
      if (this.element.tagName !== "TEXTAREA") {
        this.element.setAttribute("type", this.type);
      }
      if (this.type === "text" || this.element.tagName === "INPUT" && this.multiline && this.isReact) {
        this.element.setAttribute("role", "textbox");
      }
      this.globalize = new Internationalization(this.locale);
      var localeText = { placeholder: this.placeholder };
      this.l10n = new L10n("textbox", localeText, this.locale);
      if (this.l10n.getConstant("placeholder") !== "") {
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      if (!this.element.hasAttribute("id")) {
        this.element.setAttribute("id", getUniqueID("textbox"));
      }
      if (!this.element.hasAttribute("name")) {
        this.element.setAttribute("name", this.element.getAttribute("id"));
      }
      if (this.element.tagName === "INPUT" && this.multiline) {
        this.isHiddenInput = true;
        this.textarea = this.createElement("textarea");
        this.element.parentNode.insertBefore(this.textarea, this.element);
        this.element.setAttribute("type", "hidden");
        this.textarea.setAttribute("name", this.element.getAttribute("name"));
        this.element.removeAttribute("name");
        this.textarea.setAttribute("role", this.element.getAttribute("role"));
        this.element.removeAttribute("role");
        this.textarea.setAttribute("id", getUniqueID("textarea"));
        var apiAttributes = ["placeholder", "disabled", "value", "readonly", "type", "autocomplete"];
        for (var index = 0; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (this.element.hasAttribute(attributeName) && containerAttributes.indexOf(attributeName) < 0 && !(attributeName === "id" || attributeName === "type" || attributeName === "e-mappinguid")) {
            this.textarea.setAttribute(attributeName, this.element.attributes[index].nodeValue);
            if (apiAttributes.indexOf(attributeName) < 0) {
              this.element.removeAttribute(attributeName);
              index--;
            }
          }
        }
      }
    };
    TextBox2.prototype.checkAttributes = function(isDynamic) {
      var attrs = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["placeholder", "disabled", "value", "readonly", "type", "autocomplete"];
      for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
        var key = attrs_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(key))) {
          switch (key) {
            case "disabled":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["enabled"] === void 0 || isDynamic) {
                var enabled = this.element.getAttribute(key) === "disabled" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.element.getAttribute(key) === "readonly" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "autocomplete":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["autocomplete"] === void 0 || isDynamic) {
                var autoCompleteTxt = this.element.autocomplete === "off" ? "off" : "on";
                this.setProperties({ autocomplete: autoCompleteTxt }, !isDynamic);
              }
              break;
            case "value":
              if ((isNullOrUndefined(this.textboxOptions) || this.textboxOptions["value"] === void 0 || isDynamic) && this.element.value !== "") {
                this.setProperties({ value: this.element.value }, !isDynamic);
              }
              break;
            case "type":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["type"] === void 0 || isDynamic) {
                this.setProperties({ type: this.element.type }, !isDynamic);
              }
              break;
          }
        }
      }
    };
    TextBox2.prototype.render = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = Input.getInputValidClassList(this.cssClass);
      }
      this.respectiveElement = this.isHiddenInput ? this.textarea : this.element;
      this.textboxWrapper = Input.createInput({
        element: this.respectiveElement,
        floatLabelType: this.floatLabelType,
        properties: {
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          cssClass: updatedCssClassValue,
          readonly: this.readonly,
          placeholder: this.placeholder,
          showClearButton: this.showClearButton
        }
      });
      this.updateHTMLAttributesToWrapper();
      if (this.isHiddenInput) {
        this.respectiveElement.parentNode.insertBefore(this.element, this.respectiveElement);
      }
      this.wireEvents();
      if (!isNullOrUndefined(this.value)) {
        Input.setValue(this.value, this.respectiveElement, this.floatLabelType, this.showClearButton);
        if (this.isHiddenInput) {
          this.element.value = this.respectiveElement.value;
        }
      }
      if (!isNullOrUndefined(this.value)) {
        this.initialValue = this.value;
        this.setInitialValue();
      }
      if (this.autocomplete !== "on" && this.autocomplete !== "") {
        this.respectiveElement.autocomplete = this.autocomplete;
      } else if (!isNullOrUndefined(this.textboxOptions) && this.textboxOptions["autocomplete"] !== void 0) {
        this.removeAttributes(["autocomplete"]);
      }
      this.previousValue = this.value;
      this.inputPreviousValue = this.value;
      this.respectiveElement.defaultValue = this.respectiveElement.value;
      Input.setWidth(this.width, this.textboxWrapper.container);
      if (!isNullOrUndefined(closest(this.element, "fieldset")) && closest(this.element, "fieldset").disabled) {
        this.enabled = false;
      }
      if (!this.element.hasAttribute("aria-labelledby") && !this.element.hasAttribute("placeholder")) {
        this.element.setAttribute("aria-label", "textbox");
      }
      this.renderComplete();
    };
    TextBox2.prototype.updateHTMLAttributesToWrapper = function() {
      Input.updateHTMLAttributesToWrapper(this.htmlAttributes, this.textboxWrapper.container);
    };
    TextBox2.prototype.updateHTMLAttributesToElement = function() {
      Input.updateHTMLAttributesToElement(this.htmlAttributes, this.respectiveElement ? this.respectiveElement : this.multiline && !isNullOrUndefined(this.textarea) ? this.textarea : this.element);
    };
    TextBox2.prototype.setInitialValue = function() {
      if (!this.isAngular) {
        this.respectiveElement.setAttribute("value", this.initialValue);
      }
    };
    TextBox2.prototype.wireEvents = function() {
      EventHandler.add(this.respectiveElement, "focus", this.focusHandler, this);
      EventHandler.add(this.respectiveElement, "blur", this.focusOutHandler, this);
      EventHandler.add(this.respectiveElement, "keydown", this.keydownHandler, this);
      EventHandler.add(this.respectiveElement, "input", this.inputHandler, this);
      EventHandler.add(this.respectiveElement, "change", this.changeHandler, this);
      if (this.isForm) {
        EventHandler.add(this.formElement, "reset", this.resetForm, this);
      }
      this.bindClearEvent();
      if (!isNullOrUndefined(this.textboxWrapper.container.querySelector(".e-float-text")) && this.floatLabelType === "Auto" && this.textboxWrapper.container.classList.contains("e-autofill") && this.textboxWrapper.container.classList.contains("e-outline")) {
        EventHandler.add(this.textboxWrapper.container.querySelector(".e-float-text"), "animationstart", this.animationHandler, this);
      }
    };
    TextBox2.prototype.animationHandler = function() {
      this.textboxWrapper.container.classList.add("e-valid-input");
      var label = this.textboxWrapper.container.querySelector(".e-float-text");
      if (!isNullOrUndefined(label)) {
        label.classList.add("e-label-top");
        if (label.classList.contains("e-label-bottom")) {
          label.classList.remove("e-label-bottom");
        }
      }
    };
    TextBox2.prototype.resetValue = function(value) {
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      this.value = value;
      if (value == null && this.textboxWrapper.container.classList.contains("e-valid-input")) {
        this.textboxWrapper.container.classList.remove("e-valid-input");
      }
      this.isProtectedOnChange = prevOnChange;
    };
    TextBox2.prototype.resetForm = function() {
      if (this.isAngular) {
        this.resetValue("");
      } else {
        this.resetValue(this.initialValue);
      }
      if (!isNullOrUndefined(this.textboxWrapper)) {
        var label = this.textboxWrapper.container.querySelector(".e-float-text");
        if (!isNullOrUndefined(label) && this.floatLabelType !== "Always") {
          if (isNullOrUndefined(this.initialValue) || this.initialValue === "") {
            label.classList.add("e-label-bottom");
            label.classList.remove("e-label-top");
          } else if (this.initialValue !== "") {
            label.classList.add("e-label-top");
            label.classList.remove("e-label-bottom");
          }
        }
      }
    };
    TextBox2.prototype.focusHandler = function(args) {
      var eventArgs = {
        container: this.textboxWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("focus", eventArgs);
    };
    TextBox2.prototype.focusOutHandler = function(args) {
      if (!(this.previousValue === null && this.value === null && this.respectiveElement.value === "") && this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      var eventArgs = {
        container: this.textboxWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("blur", eventArgs);
    };
    TextBox2.prototype.keydownHandler = function(args) {
      if ((args.keyCode === 13 || args.keyCode === 9) && !((this.previousValue === null || this.previousValue === "") && (this.value === null || this.value === "") && this.respectiveElement.value === "")) {
        this.setProperties({ value: this.respectiveElement.value }, true);
      }
    };
    TextBox2.prototype.inputHandler = function(args) {
      var textboxObj = this;
      var eventArgs = {
        event: args,
        value: this.respectiveElement.value,
        previousValue: this.inputPreviousValue,
        container: this.textboxWrapper.container
      };
      this.inputPreviousValue = this.respectiveElement.value;
      if (this.isAngular) {
        textboxObj.localChange({ value: this.respectiveElement.value });
        this.preventChange = true;
      }
      if (this.isVue) {
        this.preventChange = true;
      }
      this.trigger("input", eventArgs);
      args.stopPropagation();
    };
    TextBox2.prototype.changeHandler = function(args) {
      this.setProperties({ value: this.respectiveElement.value }, true);
      if (this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      args.stopPropagation();
    };
    TextBox2.prototype.raiseChangeEvent = function(event, interaction) {
      var eventArgs = {
        event,
        value: this.value,
        previousValue: this.previousValue,
        container: this.textboxWrapper.container,
        isInteraction: interaction ? interaction : false,
        isInteracted: interaction ? interaction : false
      };
      this.preventChange = false;
      this.trigger("change", eventArgs);
      this.previousValue = this.value;
      if (this.element.tagName === "INPUT" && this.multiline && Browser.info.name === "mozilla") {
        this.element.value = this.respectiveElement.value;
      }
    };
    TextBox2.prototype.bindClearEvent = function() {
      if (this.showClearButton) {
        if (this.enabled) {
          EventHandler.add(this.textboxWrapper.clearButton, "mousedown touchstart", this.resetInputHandler, this);
        } else {
          EventHandler.remove(this.textboxWrapper.clearButton, "mousedown touchstart", this.resetInputHandler);
        }
      }
    };
    TextBox2.prototype.resetInputHandler = function(event) {
      event.preventDefault();
      if (!this.textboxWrapper.clearButton.classList.contains(HIDE_CLEAR) || this.textboxWrapper.container.classList.contains("e-static-clear")) {
        Input.setValue("", this.respectiveElement, this.floatLabelType, this.showClearButton);
        if (this.isHiddenInput) {
          this.element.value = this.respectiveElement.value;
        }
        this.setProperties({ value: this.respectiveElement.value }, true);
        var eventArgs = {
          event,
          value: this.respectiveElement.value,
          previousValue: this.inputPreviousValue,
          container: this.textboxWrapper.container
        };
        this.trigger("input", eventArgs);
        this.inputPreviousValue = this.respectiveElement.value;
        this.raiseChangeEvent(event, true);
        if (closest(this.element, "form")) {
          var element2 = this.element;
          var keyupEvent = document.createEvent("KeyboardEvent");
          keyupEvent.initEvent("keyup", false, true);
          element2.dispatchEvent(keyupEvent);
        }
      }
    };
    TextBox2.prototype.unWireEvents = function() {
      EventHandler.remove(this.respectiveElement, "focus", this.focusHandler);
      EventHandler.remove(this.respectiveElement, "blur", this.focusOutHandler);
      EventHandler.remove(this.respectiveElement, "keydown", this.keydownHandler);
      EventHandler.remove(this.respectiveElement, "input", this.inputHandler);
      EventHandler.remove(this.respectiveElement, "change", this.changeHandler);
      if (this.isForm) {
        EventHandler.remove(this.formElement, "reset", this.resetForm);
      }
      if (!isNullOrUndefined(this.textboxWrapper.container.querySelector(".e-float-text")) && this.floatLabelType === "Auto" && this.textboxWrapper.container.classList.contains("e-outline") && this.textboxWrapper.container.classList.contains("e-autofill")) {
        EventHandler.remove(this.textboxWrapper.container.querySelector(".e-float-text"), "animationstart", this.animationHandler);
      }
    };
    TextBox2.prototype.destroy = function() {
      this.unWireEvents();
      if (this.showClearButton) {
        this.clearButton = document.getElementsByClassName("e-clear-icon")[0];
      }
      if (this.element.tagName === "INPUT" && this.multiline) {
        detach(this.textboxWrapper.container.getElementsByTagName("textarea")[0]);
        this.respectiveElement = this.element;
        this.element.removeAttribute("type");
      }
      this.respectiveElement.value = this.respectiveElement.defaultValue;
      this.respectiveElement.classList.remove("e-input");
      this.removeAttributes(["aria-disabled", "aria-readonly", "aria-labelledby"]);
      if (!isNullOrUndefined(this.textboxWrapper)) {
        this.textboxWrapper.container.insertAdjacentElement("afterend", this.respectiveElement);
        detach(this.textboxWrapper.container);
      }
      this.textboxWrapper = null;
      Input.destroy({
        element: this.respectiveElement,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      _super.prototype.destroy.call(this);
    };
    TextBox2.prototype.addIcon = function(position, icons) {
      Input.addIcon(position, icons, this.textboxWrapper.container, this.respectiveElement, this.createElement);
    };
    TextBox2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    TextBox2.prototype.addAttributes = function(attributes2) {
      for (var _i = 0, _a = Object.keys(attributes2); _i < _a.length; _i++) {
        var key = _a[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: false }, true);
          Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: true }, true);
          Input.setReadonly(this.readonly, this.respectiveElement);
        } else if (key === "class") {
          this.respectiveElement.classList.add(attributes2["" + key]);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: attributes2["" + key] }, true);
          Input.setPlaceholder(this.placeholder, this.respectiveElement);
        } else if (key === "rows" && this.respectiveElement.tagName === "TEXTAREA") {
          this.respectiveElement.setAttribute(key, attributes2["" + key]);
        } else {
          this.respectiveElement.setAttribute(key, attributes2["" + key]);
        }
      }
    };
    TextBox2.prototype.removeAttributes = function(attributes2) {
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var key = attributes_1[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: true }, true);
          Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: false }, true);
          Input.setReadonly(this.readonly, this.respectiveElement);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: null }, true);
          Input.setPlaceholder(this.placeholder, this.respectiveElement);
        } else {
          this.respectiveElement.removeAttribute(key);
        }
      }
    };
    TextBox2.prototype.focusIn = function() {
      if (document.activeElement !== this.respectiveElement && this.enabled) {
        this.respectiveElement.focus();
        if (this.textboxWrapper.container.classList.contains("e-input-group") || this.textboxWrapper.container.classList.contains("e-outline") || this.textboxWrapper.container.classList.contains("e-filled")) {
          addClass([this.textboxWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    TextBox2.prototype.focusOut = function() {
      if (document.activeElement === this.respectiveElement && this.enabled) {
        this.respectiveElement.blur();
        if (this.textboxWrapper.container.classList.contains("e-input-group") || this.textboxWrapper.container.classList.contains("e-outline") || this.textboxWrapper.container.classList.contains("e-filled")) {
          removeClass([this.textboxWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    __decorate22([
      Property("text")
    ], TextBox2.prototype, "type", void 0);
    __decorate22([
      Property(false)
    ], TextBox2.prototype, "readonly", void 0);
    __decorate22([
      Property(null)
    ], TextBox2.prototype, "value", void 0);
    __decorate22([
      Property("Never")
    ], TextBox2.prototype, "floatLabelType", void 0);
    __decorate22([
      Property("")
    ], TextBox2.prototype, "cssClass", void 0);
    __decorate22([
      Property(null)
    ], TextBox2.prototype, "placeholder", void 0);
    __decorate22([
      Property("on")
    ], TextBox2.prototype, "autocomplete", void 0);
    __decorate22([
      Property({})
    ], TextBox2.prototype, "htmlAttributes", void 0);
    __decorate22([
      Property(false)
    ], TextBox2.prototype, "multiline", void 0);
    __decorate22([
      Property(true)
    ], TextBox2.prototype, "enabled", void 0);
    __decorate22([
      Property(false)
    ], TextBox2.prototype, "showClearButton", void 0);
    __decorate22([
      Property(false)
    ], TextBox2.prototype, "enablePersistence", void 0);
    __decorate22([
      Property(null)
    ], TextBox2.prototype, "width", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "created", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "destroyed", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "change", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "blur", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "focus", void 0);
    __decorate22([
      Event()
    ], TextBox2.prototype, "input", void 0);
    TextBox2 = __decorate22([
      NotifyPropertyChanges
    ], TextBox2);
    return TextBox2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/textarea/textarea.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HIDE_CLEAR2 = "e-clear-icon-hide";
var AUTO_WIDTH = "e-auto-width";
var RESIZE_X = "e-resize-x";
var RESIZE_Y = "e-resize-y";
var RESIZE_XY = "e-resize-xy";
var RESIZE_NONE = "e-resize-none";
var TextArea = (
  /** @class */
  function(_super) {
    __extends22(TextArea2, _super);
    function TextArea2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.previousValue = null;
      _this.isForm = false;
      _this.inputPreviousValue = null;
      _this.textareaOptions = options;
      return _this;
    }
    TextArea2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "floatLabelType":
            Input.removeFloating(this.textareaWrapper);
            Input.addFloating(this.element, this.floatLabelType, this.placeholder);
            if (this.floatLabelType === "Never") {
              this.element.removeAttribute("aria-labelledby");
            }
            break;
          case "enabled":
            Input.setEnabled(this.enabled, this.element, this.floatLabelType, this.textareaWrapper.container);
            this.bindClearEvent();
            if (!this.enabled && this.resizeMode !== "None") {
              this.element.classList.remove(this.getCurrentResizeClass(this.resizeMode));
              this.element.classList.add(RESIZE_NONE);
            } else {
              this.element.classList.add(this.getCurrentResizeClass(this.resizeMode));
            }
            break;
          case "width":
            if (this.resizeMode !== "None" && this.resizeMode !== "Vertical") {
              this.setElementWidth(newProp.width);
              this.textareaWrapper.container.classList.add(AUTO_WIDTH);
            } else {
              if (this.textareaWrapper.container.classList.contains(AUTO_WIDTH)) {
                this.textareaWrapper.container.classList.remove(AUTO_WIDTH);
              }
              Input.setWidth(newProp.width, this.textareaWrapper.container);
            }
            break;
          case "value":
            {
              var prevOnChange = this.isProtectedOnChange;
              this.isProtectedOnChange = true;
              if (!Input.isBlank(this.value)) {
                this.value = this.value.toString();
              }
              this.isProtectedOnChange = prevOnChange;
              Input.setValue(this.value, this.element, this.floatLabelType, this.showClearButton);
              this.inputPreviousValue = this.element.value;
              if ((this.isAngular || this.isVue) && this.preventChange === true) {
                this.previousValue = this.isAngular ? this.value : this.previousValue;
                this.preventChange = false;
              } else if (isNullOrUndefined(this.isAngular) || !this.isAngular || this.isAngular && !this.preventChange || this.isAngular && isNullOrUndefined(this.preventChange)) {
                this.raiseChangeEvent();
              }
            }
            break;
          case "htmlAttributes":
            {
              this.updateHTMLAttributesToElement();
              this.updateHTMLAttributesToWrapper();
              this.checkAttributes(true);
              Input.validateInputType(this.textareaWrapper.container, this.element);
            }
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.element);
            if (this.readonly) {
              this.element.setAttribute("aria-readonly", "true");
            } else {
              this.element.removeAttribute("aria-readonly");
            }
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.element, this.textareaWrapper);
            this.bindClearEvent();
            break;
          case "enableRtl":
            Input.setEnableRtl(this.enableRtl, [this.textareaWrapper.container]);
            break;
          case "placeholder":
            Input.setPlaceholder(this.placeholder, this.element);
            Input.calculateWidth(this.element, this.textareaWrapper.container);
            break;
          case "cssClass":
            Input.updateCssClass(newProp.cssClass, oldProp.cssClass, this.textareaWrapper.container);
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.placeholder, this.element);
            break;
          case "rows":
            if (this.rows) {
              this.element.setAttribute("rows", this.rows.toString());
            }
            break;
          case "cols":
            if (this.cols) {
              this.element.setAttribute("cols", this.cols.toString());
              if (this.width == null) {
                this.textareaWrapper.container.classList.add(AUTO_WIDTH);
              }
            }
            break;
          case "maxLength":
            if (this.maxLength) {
              this.element.setAttribute("maxlength", this.maxLength.toString());
            }
            break;
          case "resizeMode":
            if (this.enabled) {
              if (this.element.classList.contains(this.getCurrentResizeClass(oldProp.resizeMode))) {
                this.element.classList.remove(this.getCurrentResizeClass(oldProp.resizeMode));
              }
              this.element.classList.add(this.getCurrentResizeClass(this.resizeMode));
              if (this.element.style.width && (this.resizeMode === "None" || this.resizeMode === "Vertical")) {
                Input.setWidth(this.element.style.width, this.textareaWrapper.container);
              } else {
                var currentWidth = this.element.offsetWidth;
                this.element.style.width = currentWidth + "px";
                if (this.textareaWrapper.container.style.width) {
                  this.textareaWrapper.container.style.width = "";
                }
              }
              this.setWrapperWidth();
            }
            break;
        }
      }
    };
    TextArea2.prototype.preRender = function() {
      this.formElement = closest(this.element, "form");
      if (!isNullOrUndefined(this.formElement)) {
        this.isForm = true;
      }
      if (this.element.tagName === "EJS-TEXTAREA") {
        var ejInstance = getValue("ej2_instances", this.element);
        var inputElement = this.createElement("textarea");
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (attributeName !== "id" && attributeName !== "class") {
            inputElement.setAttribute(attributeName, this.element.attributes[index].nodeValue);
            inputElement.innerHTML = this.element.innerHTML;
            if (attributeName === "name") {
              this.element.removeAttribute("name");
            }
          } else if (attributeName === "class") {
            inputElement.setAttribute(attributeName, this.element.className.split(" ").filter(function(item) {
              return item.indexOf("ng-") !== 0;
            }).join(" "));
          }
        }
        this.element.appendChild(inputElement);
        this.element = inputElement;
        setValue("ej2_instances", ejInstance, this.element);
      }
      this.updateHTMLAttributesToElement();
      this.checkAttributes(false);
      if ((isNullOrUndefined(this.textareaOptions) || this.textareaOptions["value"] === void 0) && this.element.value !== "") {
        this.setProperties({ value: this.element.value }, true);
      }
      this.globalize = new Internationalization(this.locale);
      var localeText = { placeholder: this.placeholder };
      this.l10n = new L10n("textarea", localeText, this.locale);
      if (this.l10n.getConstant("placeholder") !== "") {
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      if (!this.element.hasAttribute("id")) {
        this.element.setAttribute("id", getUniqueID("textbox"));
      }
      if (!this.element.hasAttribute("name")) {
        this.element.setAttribute("name", this.element.getAttribute("id"));
      }
      if (this.rows) {
        this.element.setAttribute("rows", this.rows.toString());
      }
      if (this.cols) {
        this.element.setAttribute("cols", this.cols.toString());
      }
      if (this.maxLength) {
        this.element.setAttribute("maxlength", this.maxLength.toString());
      }
      if (!this.element.style.resize && this.enabled) {
        this.element.classList.add(this.getCurrentResizeClass(this.resizeMode));
      }
      if (this.enabled) {
        this.element.setAttribute("aria-multiline", "true");
      }
    };
    TextArea2.prototype.render = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = Input.getInputValidClassList(this.cssClass);
      }
      this.textareaWrapper = Input.createInput({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: {
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          cssClass: updatedCssClassValue,
          readonly: this.readonly,
          placeholder: this.placeholder,
          showClearButton: this.showClearButton
        }
      });
      this.updateHTMLAttributesToWrapper();
      this.wireEvents();
      if (!isNullOrUndefined(this.value)) {
        Input.setValue(this.value, this.element, this.floatLabelType, this.showClearButton);
      }
      if (!isNullOrUndefined(this.value)) {
        this.initialValue = this.value;
        if (!this.isAngular) {
          this.element.setAttribute("value", this.initialValue);
        }
      }
      this.previousValue = this.value;
      this.inputPreviousValue = this.value;
      this.element.defaultValue = this.element.value;
      Input.setWidth(this.width, this.textareaWrapper.container);
      this.setWrapperWidth();
      this.renderComplete();
    };
    TextArea2.prototype.getModuleName = function() {
      return "textarea";
    };
    TextArea2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    TextArea2.prototype.checkAttributes = function(isDynamic) {
      var attrs = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["placeholder", "disabled", "value", "readonly"];
      for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
        var key = attrs_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(key))) {
          switch (key) {
            case "disabled":
              if (isNullOrUndefined(this.textareaOptions) || this.textareaOptions["enabled"] === void 0 || isDynamic) {
                var enabled = this.element.getAttribute(key) === "disabled" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.textareaOptions) || this.textareaOptions["readonly"] === void 0 || isDynamic) {
                var readonly = this.element.getAttribute(key) === "readonly" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.textareaOptions) || this.textareaOptions["placeholder"] === void 0 || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "value":
              if ((isNullOrUndefined(this.textareaOptions) || this.textareaOptions["value"] === void 0 || isDynamic) && this.element.value !== "") {
                this.setProperties({ value: this.element.value }, !isDynamic);
              }
              break;
          }
        }
      }
    };
    TextArea2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "blur", this.focusOutHandler, this);
      EventHandler.add(this.element, "keydown", this.keydownHandler, this);
      EventHandler.add(this.element, "input", this.inputHandler, this);
      EventHandler.add(this.element, "change", this.changeHandler, this);
      if (this.isForm) {
        EventHandler.add(this.formElement, "reset", this.resetForm, this);
      }
      this.bindClearEvent();
    };
    TextArea2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "blur", this.focusOutHandler);
      EventHandler.remove(this.element, "keydown", this.keydownHandler);
      EventHandler.remove(this.element, "input", this.inputHandler);
      EventHandler.remove(this.element, "change", this.changeHandler);
      if (this.isForm) {
        EventHandler.remove(this.formElement, "reset", this.resetForm);
      }
    };
    TextArea2.prototype.destroy = function() {
      this.unWireEvents();
      if (this.showClearButton) {
        this.clearButton = document.getElementsByClassName("e-clear-icon")[0];
      }
      this.element.value = this.element.defaultValue;
      this.element.classList.remove("e-input", RESIZE_X, RESIZE_Y, RESIZE_XY, RESIZE_NONE);
      this.removeAttributes(["aria-disabled", "aria-readonly", "aria-labelledby", "aria-multiline"]);
      if (!isNullOrUndefined(this.textareaWrapper)) {
        this.textareaWrapper.container.insertAdjacentElement("afterend", this.element);
        detach(this.textareaWrapper.container);
      }
      this.textareaWrapper = null;
      Input.destroy({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      this.formElement = null;
      _super.prototype.destroy.call(this);
    };
    TextArea2.prototype.focusHandler = function(args) {
      var eventArgs = {
        container: this.textareaWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("focus", eventArgs);
    };
    TextArea2.prototype.focusOutHandler = function(args) {
      if (!(this.previousValue === null && this.value === null) && this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      var eventArgs = {
        container: this.textareaWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("blur", eventArgs);
    };
    TextArea2.prototype.keydownHandler = function(args) {
      if ((args.keyCode === 13 || args.keyCode === 9) && !((this.previousValue === null || this.previousValue === "") && (this.value === null || this.value === "") && this.element.value === "")) {
        this.setProperties({ value: this.element.value }, true);
      }
    };
    TextArea2.prototype.inputHandler = function(args) {
      var textareaObj = this;
      var eventArgs = {
        event: args,
        value: this.element.value,
        previousValue: this.inputPreviousValue,
        container: this.textareaWrapper.container
      };
      this.inputPreviousValue = this.element.value;
      if (this.isAngular) {
        textareaObj.localChange({ value: this.element.value });
        this.preventChange = true;
      }
      if (this.isVue) {
        this.preventChange = true;
      }
      this.trigger("input", eventArgs);
      args.stopPropagation();
    };
    TextArea2.prototype.changeHandler = function(args) {
      this.setProperties({ value: this.element.value }, true);
      if (this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      args.stopPropagation();
    };
    TextArea2.prototype.raiseChangeEvent = function(event, interaction) {
      var eventArgs = {
        event,
        value: this.value,
        previousValue: this.previousValue,
        container: this.textareaWrapper.container,
        isInteraction: interaction ? interaction : false,
        isInteracted: interaction ? interaction : false
      };
      this.preventChange = false;
      this.trigger("change", eventArgs);
      this.previousValue = this.value;
    };
    TextArea2.prototype.updateHTMLAttributesToWrapper = function() {
      Input.updateHTMLAttributesToWrapper(this.htmlAttributes, this.textareaWrapper.container);
    };
    TextArea2.prototype.updateHTMLAttributesToElement = function() {
      Input.updateHTMLAttributesToElement(this.htmlAttributes, this.element);
    };
    TextArea2.prototype.bindClearEvent = function() {
      if (this.showClearButton) {
        if (this.enabled) {
          EventHandler.add(this.textareaWrapper.clearButton, "mousedown touchstart", this.resetInputHandler, this);
        } else {
          EventHandler.remove(this.textareaWrapper.clearButton, "mousedown touchstart", this.resetInputHandler);
        }
      }
    };
    TextArea2.prototype.resetInputHandler = function(event) {
      event.preventDefault();
      if (!this.textareaWrapper.clearButton.classList.contains(HIDE_CLEAR2) || this.textareaWrapper.container.classList.contains("e-static-clear")) {
        Input.setValue("", this.element, this.floatLabelType, this.showClearButton);
        this.setProperties({ value: this.element.value }, true);
      }
      var eventArgs = {
        event,
        value: this.element.value,
        previousValue: this.inputPreviousValue,
        container: this.textareaWrapper.container
      };
      this.trigger("input", eventArgs);
      this.inputPreviousValue = this.element.value;
      this.raiseChangeEvent(event, true);
      if (closest(this.element, "form")) {
        var element2 = this.element;
        var keyupEvent = document.createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    TextArea2.prototype.addAttributes = function(attributes2) {
      for (var _i = 0, _a = Object.keys(attributes2); _i < _a.length; _i++) {
        var key = _a[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: false }, true);
          Input.setEnabled(this.enabled, this.element, this.floatLabelType, this.textareaWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: true }, true);
          Input.setReadonly(this.readonly, this.element);
        } else if (key === "class") {
          this.element.classList.add(attributes2["" + key]);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: attributes2["" + key] }, true);
          Input.setPlaceholder(this.placeholder, this.element);
        } else {
          this.element.setAttribute(key, attributes2["" + key]);
        }
      }
    };
    TextArea2.prototype.removeAttributes = function(attributes2) {
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var key = attributes_1[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: true }, true);
          Input.setEnabled(this.enabled, this.element, this.floatLabelType, this.textareaWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: false }, true);
          Input.setReadonly(this.readonly, this.element);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: null }, true);
          Input.setPlaceholder(this.placeholder, this.element);
        } else {
          this.element.removeAttribute(key);
        }
      }
    };
    TextArea2.prototype.focusIn = function() {
      if (document.activeElement !== this.element && this.enabled) {
        this.element.focus();
        if (this.textareaWrapper.container.classList.contains("e-input-group") || this.textareaWrapper.container.classList.contains("e-outline") || this.textareaWrapper.container.classList.contains("e-filled")) {
          addClass([this.textareaWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    TextArea2.prototype.focusOut = function() {
      if (document.activeElement === this.element && this.enabled) {
        this.element.blur();
        if (this.textareaWrapper.container.classList.contains("e-input-group") || this.textareaWrapper.container.classList.contains("e-outline") || this.textareaWrapper.container.classList.contains("e-filled")) {
          removeClass([this.textareaWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    TextArea2.prototype.setWrapperWidth = function() {
      if (this.enabled && (this.resizeMode !== "None" && this.resizeMode !== "Vertical" || (this.cols || this.element.getAttribute("cols")))) {
        if (this.resizeMode !== "None" && this.resizeMode !== "Vertical") {
          if (this.textareaWrapper.container.style.width) {
            this.setElementWidth(this.textareaWrapper.container.style.width);
            this.textareaWrapper.container.style.width = "";
            this.textareaWrapper.container.classList.add(AUTO_WIDTH);
          }
        }
        this.textareaWrapper.container.classList.add(AUTO_WIDTH);
      } else {
        if (this.textareaWrapper.container.classList.contains(AUTO_WIDTH)) {
          this.textareaWrapper.container.classList.remove(AUTO_WIDTH);
        }
      }
    };
    TextArea2.prototype.resetForm = function() {
      if (this.isAngular) {
        this.resetValue("");
      } else {
        this.resetValue(this.initialValue);
      }
      if (!isNullOrUndefined(this.textareaWrapper)) {
        var label = this.textareaWrapper.container.querySelector(".e-float-text");
        if (!isNullOrUndefined(label) && this.floatLabelType !== "Always") {
          if (isNullOrUndefined(this.initialValue) || this.initialValue === "") {
            label.classList.add("e-label-bottom");
            label.classList.remove("e-label-top");
          } else if (this.initialValue !== "") {
            label.classList.add("e-label-top");
            label.classList.remove("e-label-bottom");
          }
        }
      }
    };
    TextArea2.prototype.resetValue = function(value) {
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      this.value = value;
      if (value == null && this.textareaWrapper.container.classList.contains("e-valid-input")) {
        this.textareaWrapper.container.classList.remove("e-valid-input");
      }
      this.isProtectedOnChange = prevOnChange;
    };
    TextArea2.prototype.setElementWidth = function(width) {
      if (typeof width === "number") {
        this.element.style.width = formatUnit(width);
      } else if (typeof width === "string") {
        this.element.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
      }
    };
    TextArea2.prototype.getCurrentResizeClass = function(resizeMode) {
      return resizeMode === "None" ? RESIZE_NONE : resizeMode === "Both" ? RESIZE_XY : resizeMode === "Horizontal" ? RESIZE_X : RESIZE_Y;
    };
    __decorate23([
      Property(false)
    ], TextArea2.prototype, "readonly", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "value", void 0);
    __decorate23([
      Property("Never")
    ], TextArea2.prototype, "floatLabelType", void 0);
    __decorate23([
      Property("")
    ], TextArea2.prototype, "cssClass", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "placeholder", void 0);
    __decorate23([
      Property({})
    ], TextArea2.prototype, "htmlAttributes", void 0);
    __decorate23([
      Property(true)
    ], TextArea2.prototype, "enabled", void 0);
    __decorate23([
      Property(false)
    ], TextArea2.prototype, "showClearButton", void 0);
    __decorate23([
      Property(false)
    ], TextArea2.prototype, "enablePersistence", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "width", void 0);
    __decorate23([
      Property("Both")
    ], TextArea2.prototype, "resizeMode", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "maxLength", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "cols", void 0);
    __decorate23([
      Property(null)
    ], TextArea2.prototype, "rows", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "created", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "destroyed", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "change", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "blur", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "focus", void 0);
    __decorate23([
      Event()
    ], TextArea2.prototype, "input", void 0);
    TextArea2 = __decorate23([
      NotifyPropertyChanges
    ], TextArea2);
    return TextArea2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/common/signature-base.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SignatureBase = (
  /** @class */
  function(_super) {
    __extends23(SignatureBase2, _super);
    function SignatureBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.minDistance = 5;
      _this.previous = 0;
      _this.interval = 30;
      _this.timeout = null;
      _this.isSignatureEmpty = true;
      _this.backgroundLoaded = null;
      _this.isBlazor = false;
      _this.isResponsive = false;
      _this.signPointsColl = [];
      _this.signRatioPointsColl = [];
      _this.canRedraw = true;
      return _this;
    }
    SignatureBase2.prototype.initialize = function(element2, dotnetRef) {
      this.clearArray = [];
      this.element = element2;
      this.canvasContext = this.element.getContext("2d");
      this.canvasContext.canvas.tabIndex = -1;
      if (dotnetRef) {
        this.dotnetRef = dotnetRef;
        this.isBlazor = true;
        if (this.signatureValue) {
          this.loadPersistedSignature();
        }
      }
      this.setHTMLProperties();
      if (isNullOrUndefined(this.signatureValue)) {
        this.updateSnapCollection(true);
      }
      this.wireEvents();
      if (!this.isBlazor) {
        this.trigger("created", null);
      }
    };
    SignatureBase2.prototype.wireEvents = function() {
      if (isNullOrUndefined(this.pointColl) && !this.isReadOnly && !this.disabled) {
        EventHandler.add(this.canvasContext.canvas, "mousedown touchstart", this.mouseDownHandler, this);
        EventHandler.add(this.canvasContext.canvas, "keydown", this.keyboardHandler, this);
        window.addEventListener("resize", this.resizeHandler.bind(this));
      } else if (this.pointColl) {
        EventHandler.add(this.canvasContext.canvas, "mousemove touchmove", this.mouseMoveHandler, this);
        EventHandler.add(this.canvasContext.canvas, "mouseup touchend", this.mouseUpHandler, this);
        EventHandler.add(document, "mouseup", this.mouseUpHandler, this);
      }
    };
    SignatureBase2.prototype.unwireEvents = function(type) {
      if (type === "mouseup" || type === "touchend") {
        EventHandler.remove(this.canvasContext.canvas, "mousemove touchmove", this.mouseMoveHandler);
        EventHandler.remove(this.canvasContext.canvas, "mouseup touchend", this.mouseUpHandler);
        EventHandler.remove(document, "mouseup", this.mouseUpHandler);
      } else {
        EventHandler.remove(this.canvasContext.canvas, "mousedown touchstart", this.mouseDownHandler);
        EventHandler.remove(this.canvasContext.canvas, "keydown", this.keyboardHandler);
        window.removeEventListener("resize", this.resizeHandler);
      }
    };
    SignatureBase2.prototype.setHTMLProperties = function() {
      if (this.element.height === 150 && this.element.width === 300 && this.element.offsetHeight !== 0 && this.element.offsetWidth !== 0) {
        this.element.height = this.element.offsetHeight;
        this.element.width = this.element.offsetWidth;
        this.isResponsive = true;
      } else if ((this.element.height !== this.element.offsetHeight - 1 || this.element.width !== this.element.offsetWidth - 1) && this.element.offsetHeight !== 0 && this.element.offsetWidth !== 0) {
        this.element.height = this.element.offsetHeight;
        this.element.width = this.element.offsetWidth;
      }
      this.canvasContext.fillStyle = this.strokeColor;
      this.tempCanvas = this.createElement("canvas", { className: "e-" + this.getModuleName() + "-temp" });
      this.tempContext = this.tempCanvas.getContext("2d");
      this.tempCanvas.width = this.element.width;
      this.tempCanvas.height = this.element.height;
      if (this.backgroundImage) {
        this.canvasContext.canvas.style.backgroundImage = "url(" + this.backgroundImage + ")";
        this.canvasContext.canvas.style.backgroundRepeat = "no-repeat";
        if (this.saveWithBackground) {
          this.setBackgroundImage(this.backgroundImage, "temp");
        }
      } else if (this.backgroundColor) {
        this.canvasContext.canvas.style.backgroundColor = this.backgroundColor;
      }
    };
    SignatureBase2.prototype.mouseDownHandler = function(e) {
      if (e.buttons === 1 || e.buttons === 2 || e.type === "touchstart") {
        if (e.type === "touchstart") {
          e.preventDefault();
          e.stopPropagation();
        }
        this.beginStroke(e);
        this.wireEvents();
      }
    };
    SignatureBase2.prototype.mouseMoveHandler = function(e) {
      if (e.buttons === 1 || e.buttons === 2 || e.type === "touchmove") {
        if (e.type === "touchmove") {
          e.preventDefault();
          e.stopPropagation();
        }
        if (this.interval) {
          this.updateStrokeWithThrottle(e);
        } else {
          this.updateStroke(e);
        }
      }
    };
    SignatureBase2.prototype.mouseUpHandler = function(e) {
      var args = { actionName: "strokeUpdate" };
      if (e.type === "touchstart") {
        e.preventDefault();
        e.stopPropagation();
      }
      this.endDraw();
      this.updateSnapCollection();
      this.unwireEvents(e.type);
      if (!this.isBlazor) {
        this.trigger("change", args);
      } else {
        this.dotnetRef.invokeMethodAsync("TriggerEventAsync", "mouseUp");
      }
      this.signatureValue = this.snapColl[this.incStep];
      for (var i = 0; i < this.signPointsColl.length; i++) {
        this.signRatioPointsColl.push({
          x: this.signPointsColl[i].x / this.canvasContext.canvas.width,
          y: this.signPointsColl[i].y / this.canvasContext.canvas.height
        });
      }
      this.signPointsColl = [];
    };
    SignatureBase2.prototype.keyboardHandler = function(e) {
      var _this = this;
      var args = { fileName: "Signature", type: "Png", cancel: false };
      switch (e.key) {
        case "Delete":
          this.clear();
          break;
        case (e.ctrlKey && "s"):
          if (!this.isBlazor) {
            this.trigger("beforeSave", args, function(observableSaveArgs) {
              if (!args.cancel) {
                _this.save(observableSaveArgs.type, observableSaveArgs.fileName);
              }
            });
          } else {
            this.dotnetRef.invokeMethodAsync("TriggerEventAsync", "beforeSave");
          }
          e.preventDefault();
          e.stopImmediatePropagation();
          break;
        case (e.ctrlKey && "z"):
          this.undo();
          break;
        case (e.ctrlKey && "y"):
          this.redo();
          break;
      }
    };
    SignatureBase2.prototype.resizeHandler = function() {
      var proxy = this;
      if (this.isResponsive && this.canRedraw) {
        this.canvasContext.canvas.width = this.element.offsetWidth;
        this.canvasContext.canvas.height = this.element.offsetHeight;
        this.canvasContext.scale(1, 1);
        var pointSize = (this.minStrokeWidth + this.maxStrokeWidth) / 2;
        for (var i = 0; i < this.signRatioPointsColl.length; i++) {
          this.arcDraw(this.signRatioPointsColl[i].x * this.canvasContext.canvas.width, this.signRatioPointsColl[i].y * this.canvasContext.canvas.height, pointSize);
        }
        this.signPointsColl = [];
        this.canvasContext.closePath();
        this.canvasContext.fill();
      } else {
        var restoreImg_1 = new Image();
        restoreImg_1.src = this.snapColl[this.incStep];
        restoreImg_1.onload = function() {
          proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
          proxy.canvasContext.drawImage(restoreImg_1, 0, 0, proxy.element.width, proxy.element.height);
        };
      }
    };
    SignatureBase2.prototype.beginStroke = function(e) {
      this.internalRefresh();
      this.updateStroke(e);
    };
    SignatureBase2.prototype.updateStroke = function(e) {
      var point = this.createPoint(e);
      this.addPoint(point);
    };
    SignatureBase2.prototype.updateStrokeWithThrottle = function(args) {
      var now = Date.now();
      var remaining = this.interval - (now - this.previous);
      this.storedArgs = args;
      if (remaining <= 0 || remaining > this.interval) {
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.previous = now;
        this.updateStroke(this.storedArgs);
        if (!this.timeout) {
          this.storedArgs = null;
        }
      } else if (!this.timeout) {
        this.timeout = window.setTimeout(this.delay.bind(this), remaining);
      }
    };
    SignatureBase2.prototype.delay = function() {
      this.previous = Date.now();
      this.timeout = null;
      this.updateStroke(this.storedArgs);
      if (!this.timeout) {
        this.storedArgs = null;
      }
    };
    SignatureBase2.prototype.createPoint = function(e) {
      var rect = this.canvasContext.canvas.getBoundingClientRect();
      if (e.type === "mousedown" || e.type === "mousemove") {
        return this.point(e.clientX - rect.left, e.clientY - rect.top, (/* @__PURE__ */ new Date()).getTime());
      } else {
        return this.point(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top, (/* @__PURE__ */ new Date()).getTime());
      }
    };
    SignatureBase2.prototype.point = function(pointX, pointY, time) {
      this.pointX = pointX;
      this.pointY = pointY;
      this.time = time || (/* @__PURE__ */ new Date()).getTime();
      return { x: this.pointX, y: this.pointY, time: this.time };
    };
    SignatureBase2.prototype.addPoint = function(point) {
      var points = this.pointColl;
      var controlPoint1;
      var controlPoint2;
      var lastPoint = points.length > 0 && points[points.length - 1];
      var isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= this.minDistance : false;
      if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
        points.push(point);
        if (points.length > 2) {
          if (points.length === 3) {
            points.unshift(points[0]);
          }
          controlPoint1 = this.calculateCurveControlPoints(points[0], points[1], points[2]).controlPoint2;
          controlPoint2 = this.calculateCurveControlPoints(points[1], points[2], points[3]).controlPoint1;
          this.startPoint = points[1];
          this.controlPoint1 = controlPoint1;
          this.controlPoint2 = controlPoint2;
          this.endPoint = points[2];
          this.startDraw();
          points.shift();
        }
      }
    };
    SignatureBase2.prototype.startDraw = function() {
      var velocity;
      velocity = this.pointVelocityCalc(this.startPoint);
      velocity = this.velocity * velocity + (1 - this.velocity) * this.lastVelocity;
      var newWidth = Math.max(this.maxStrokeWidth / (velocity + 1), this.minStrokeWidth);
      this.curveDraw(this.lastWidth, newWidth);
      this.lastVelocity = velocity;
      this.lastWidth = newWidth;
    };
    SignatureBase2.prototype.endDraw = function() {
      if (isNullOrUndefined(this.pointColl)) {
        return;
      }
      ;
      var canDrawCurve = this.pointColl.length > 2;
      var point = this.pointColl[0];
      if (!canDrawCurve && point) {
        this.strokeDraw(point);
      }
    };
    SignatureBase2.prototype.curveDraw = function(startWidth, endWidth) {
      var context = this.canvasContext;
      var width;
      var i;
      var t1;
      var t2;
      var t3;
      var u1;
      var u2;
      var u3;
      var x;
      var y;
      var widthValue = endWidth - startWidth;
      var bezierLength = this.bezierLengthCalc();
      var drawSteps = Math.ceil(bezierLength) * 2;
      context.beginPath();
      for (i = 0; i < drawSteps; i++) {
        t1 = i / drawSteps;
        t2 = t1 * t1;
        t3 = t2 * t1;
        u1 = 1 - t1;
        u2 = u1 * u1;
        u3 = u2 * u1;
        x = u3 * this.startPoint.x;
        x += 3 * u2 * t1 * this.controlPoint1.x;
        x += 3 * u1 * t2 * this.controlPoint2.x;
        x += t3 * this.endPoint.x;
        y = u3 * this.startPoint.y;
        y += 3 * u2 * t1 * this.controlPoint1.y;
        y += 3 * u1 * t2 * this.controlPoint2.y;
        y += t3 * this.endPoint.y;
        width = Math.min(startWidth + t3 * widthValue, this.maxStrokeWidth);
        this.arcDraw(x, y, width);
      }
      context.closePath();
      context.fill();
      this.isSignatureEmpty = false;
    };
    SignatureBase2.prototype.strokeDraw = function(point) {
      var context = this.canvasContext;
      var pointSize = (this.minStrokeWidth + this.maxStrokeWidth) / 2;
      context.beginPath();
      this.arcDraw(point.x, point.y, pointSize);
      context.closePath();
      context.fill();
      this.isSignatureEmpty = false;
    };
    SignatureBase2.prototype.arcDraw = function(x, y, size) {
      this.signPointsColl.push({ x, y });
      var context = this.canvasContext;
      context.moveTo(x, y);
      context.arc(x, y, size, 0, 2 * Math.PI, false);
    };
    SignatureBase2.prototype.calculateCurveControlPoints = function(p1, p2, p3) {
      var dx1 = p1.x - p2.x;
      var dy1 = p1.y - p2.y;
      var dx2 = p2.x - p3.x;
      var dy2 = p2.y - p3.y;
      var m1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var m2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      var dxm = m1.x - m2.x;
      var dym = m1.y - m2.y;
      var k = l2 / (l1 + l2);
      var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
      var tx = p2.x - cm.x;
      var ty = p2.y - cm.y;
      return {
        controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),
        controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)
      };
    };
    SignatureBase2.prototype.bezierLengthCalc = function() {
      var steps = 10;
      var length = 0;
      var i;
      var t;
      var pointx1;
      var pointy1;
      var pointx2;
      var pointy2;
      var pointx3;
      var pointy3;
      for (i = 0; i <= steps; i++) {
        t = i / steps;
        pointx1 = this.bezierPointCalc(t, this.startPoint.x, this.controlPoint1.x, this.controlPoint2.x, this.endPoint.x);
        pointy1 = this.bezierPointCalc(t, this.startPoint.y, this.controlPoint1.y, this.controlPoint2.y, this.endPoint.y);
        if (i > 0) {
          pointx3 = pointx1 - pointx2;
          pointy3 = pointy1 - pointy2;
          length += Math.sqrt(pointx3 * pointx3 + pointy3 * pointy3);
        }
        pointx2 = pointx1;
        pointy2 = pointy1;
      }
      return length;
    };
    SignatureBase2.prototype.bezierPointCalc = function(t, startpoint, cp1, cp2, endpoint) {
      return startpoint * (1 - t) * (1 - t) * (1 - t) + 3 * cp1 * (1 - t) * (1 - t) * t + 3 * cp2 * (1 - t) * t * t + endpoint * t * t * t;
    };
    SignatureBase2.prototype.pointVelocityCalc = function(startPoint) {
      return this.time !== startPoint.time ? this.distanceTo(startPoint) / (this.time - startPoint.time) : 0;
    };
    SignatureBase2.prototype.distanceTo = function(start) {
      return Math.sqrt(Math.pow(this.pointX - start.x, 2) + Math.pow(this.pointY - start.y, 2));
    };
    SignatureBase2.prototype.isRead = function(isRead) {
      if (isRead) {
        EventHandler.remove(this.canvasContext.canvas, "mousedown touchstart", this.mouseDownHandler);
      } else if (!this.disabled) {
        EventHandler.add(this.canvasContext.canvas, "mousedown touchstart", this.mouseDownHandler, this);
      }
    };
    SignatureBase2.prototype.enableOrDisable = function(isDisable) {
      this.disabled = isDisable;
      if (isDisable) {
        this.canvasContext.canvas.style.filter = "opacity(0.5)";
        this.isRead(true);
      } else {
        this.canvasContext.canvas.style.filter = "";
        this.isRead(false);
      }
    };
    SignatureBase2.prototype.updateSnapCollection = function(isClear) {
      if (isNullOrUndefined(this.incStep)) {
        this.incStep = -1;
        this.incStep++;
        this.snapColl = [];
        this.clearArray = [];
      } else {
        this.incStep++;
      }
      if (this.incStep < this.snapColl.length) {
        this.snapColl.length = this.incStep;
      }
      if (this.incStep > 0) {
        var canvasNew = this.createElement("canvas", { className: "e-" + this.getModuleName() + "-wrapper" });
        var canvasContextNew = canvasNew.getContext("2d");
        canvasNew.width = this.canvasContext.canvas.width;
        canvasNew.height = this.canvasContext.canvas.height;
        canvasContextNew.drawImage(this.canvasContext.canvas, 0, 0, canvasNew.width, canvasNew.height);
        this.snapColl.push(canvasNew.toDataURL());
      } else {
        this.snapColl.push(this.canvasContext.canvas.toDataURL());
      }
      if (isClear) {
        this.clearArray.push(this.incStep);
      }
    };
    SignatureBase2.prototype.setBackgroundImage = function(imageSrc, type) {
      var proxy = this;
      var imageObj = new Image();
      imageObj.crossOrigin = "anonymous";
      imageObj.src = imageSrc;
      if (type == "temp") {
        imageObj.onload = function() {
          proxy.tempContext.globalCompositeOperation = "source-over";
          proxy.tempContext.drawImage(imageObj, 0, 0, proxy.element.width, proxy.element.height);
        };
      } else {
        imageObj.onload = function() {
          proxy.canvasContext.globalCompositeOperation = "source-over";
          proxy.canvasContext.drawImage(imageObj, 0, 0, proxy.element.width, proxy.element.height);
          proxy.updateSnapCollection();
          proxy.saveBackground(true);
        };
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      }
    };
    SignatureBase2.prototype.setBackgroundColor = function(color) {
      var canvasEle = this.canvasContext;
      canvasEle.strokeStyle = color;
      var i;
      var j;
      for (i = 1; i <= canvasEle.canvas.width; i++) {
        for (j = 1; j <= canvasEle.canvas.height; j++) {
          canvasEle.strokeRect(0, 0, i, j);
        }
      }
      this.updateSnapCollection();
    };
    SignatureBase2.prototype.loadPersistedSignature = function() {
      if (isNullOrUndefined(this.signatureValue)) {
        return;
      }
      var proxy = this;
      var lastImage = new Image();
      lastImage.src = this.signatureValue;
      lastImage.onload = function() {
        proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
        proxy.canvasContext.drawImage(lastImage, 0, 0);
        proxy.updateSnapCollection();
      };
      this.isSignatureEmpty = false;
    };
    SignatureBase2.prototype.getBlob = function(url) {
      var arr = url.split(",");
      var type = arr[0].match(/:(.*?);/)[1];
      var bstr = atob(arr[1]);
      var n = bstr.length;
      var u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type });
    };
    SignatureBase2.prototype.download = function(blob, fileName) {
      var blobUrl = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.href = blobUrl;
      a.target = "_parent";
      a.download = fileName;
      (document.body || document.documentElement).appendChild(a);
      a.click();
      a.parentNode.removeChild(a);
    };
    SignatureBase2.prototype.internalRefresh = function() {
      this.pointColl = [];
      this.lastVelocity = 0;
      this.lastWidth = (this.minStrokeWidth + this.maxStrokeWidth) / 2;
    };
    SignatureBase2.prototype.refresh = function() {
      this.isResponsive = false;
      this.setHTMLProperties();
      this.resizeHandler();
      this.internalRefresh();
    };
    SignatureBase2.prototype.clear = function() {
      var args = { actionName: "clear" };
      this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      this.tempContext.clearRect(0, 0, this.tempContext.canvas.width, this.tempContext.canvas.height);
      if (this.saveWithBackground && this.backgroundImage) {
        this.setBackgroundImage(this.backgroundImage, "temp");
      }
      this.internalRefresh();
      this.signRatioPointsColl = [];
      this.updateSnapCollection(true);
      this.isSignatureEmpty = this.canRedraw = true;
      if (!this.isBlazor) {
        this.trigger("change", args);
      } else {
        this.dotnetRef.invokeMethodAsync("TriggerEventAsync", "Clear");
      }
    };
    SignatureBase2.prototype.undo = function() {
      var args = { actionName: "undo" };
      var proxy = this;
      if (this.incStep > 0) {
        this.incStep--;
        var undoImg_1 = new Image();
        undoImg_1.src = this.snapColl[this.incStep];
        undoImg_1.onload = function() {
          proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
          proxy.canvasContext.drawImage(undoImg_1, 0, 0, proxy.element.width, proxy.element.height);
        };
      }
      this.isClear();
      if (!this.isBlazor) {
        this.trigger("change", args);
      } else {
        this.dotnetRef.invokeMethodAsync("TriggerEventAsync", "Undo");
      }
    };
    SignatureBase2.prototype.redo = function() {
      var args = { actionName: "redo" };
      var proxy = this;
      if (this.incStep < this.snapColl.length - 1) {
        this.incStep++;
        var redoImg_1 = new Image();
        redoImg_1.src = this.snapColl[this.incStep];
        redoImg_1.onload = function() {
          proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
          proxy.canvasContext.drawImage(redoImg_1, 0, 0, proxy.element.width, proxy.element.height);
        };
      }
      this.isClear();
      if (!this.isBlazor) {
        this.trigger("change", args);
      } else {
        this.dotnetRef.invokeMethodAsync("TriggerEventAsync", "Redo");
      }
    };
    SignatureBase2.prototype.isClear = function() {
      if (this.clearArray) {
        var empty = false;
        for (var i = 0; i < this.clearArray.length; i++) {
          if (this.clearArray[i] === this.incStep) {
            this.isSignatureEmpty = true;
            empty = true;
          }
        }
        if (!empty) {
          this.isSignatureEmpty = false;
        }
      }
    };
    SignatureBase2.prototype.isEmpty = function() {
      return this.isSignatureEmpty;
    };
    SignatureBase2.prototype.canUndo = function() {
      return this.incStep > 0;
    };
    SignatureBase2.prototype.canRedo = function() {
      return this.incStep < this.snapColl.length - 1;
    };
    SignatureBase2.prototype.draw = function(text, fontFamily, fontSize, x, y) {
      var args = { actionName: "draw-text" };
      this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      fontFamily = fontFamily || "Arial";
      fontSize = fontSize || 30;
      this.canvasContext.font = fontSize + "px " + fontFamily;
      var startX = this.element.width / 2;
      var startY = this.element.height / 2;
      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
        this.canvasContext.textAlign = "center";
        this.canvasContext.textBaseline = "middle";
      } else {
        startX = isNullOrUndefined(x) ? startX : x;
        startY = isNullOrUndefined(y) ? startY + fontSize / 2 : y + fontSize / 2;
      }
      this.canvasContext.fillText(text, startX, startY);
      this.updateSnapCollection();
      this.isSignatureEmpty = false;
      this.trigger("change", args);
    };
    SignatureBase2.prototype.load = function(signature, width, height) {
      height = height || this.element.height;
      width = width || this.element.width;
      this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      var proxy = this;
      var bitmapImage = new Image();
      bitmapImage.src = signature;
      if (signature.slice(0, 4) !== "data") {
        bitmapImage.crossOrigin = "anonymous";
      }
      bitmapImage.onload = function() {
        Promise.all([
          createImageBitmap(bitmapImage, 0, 0, width, height)
        ]).then(function(results) {
          var tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCanvas.getContext("2d").drawImage(results[0], 0, 0);
          if (signature.slice(0, 4) !== "data") {
            proxy.canvasContext.globalCompositeOperation = "source-over";
          }
          proxy.canvasContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, proxy.element.width, proxy.element.height);
          proxy.updateSnapCollection();
        });
      };
      this.isSignatureEmpty = this.canRedraw = false;
    };
    SignatureBase2.prototype.saveBackground = function(savebg) {
      var imageSrc;
      if (savebg && this.backgroundImage) {
        imageSrc = this.snapColl[this.incStep - 1];
      } else {
        imageSrc = this.snapColl[this.incStep];
      }
      if (!savebg) {
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        if (this.backgroundImage) {
          this.setBackgroundImage(this.backgroundImage);
        } else if (this.backgroundColor) {
          this.setBackgroundColor(this.backgroundColor);
          savebg = true;
        }
      }
      if (savebg) {
        var proxy_1 = this;
        var imageObj_1 = new Image();
        imageObj_1.crossOrigin = "anonymous";
        imageObj_1.src = imageSrc;
        imageObj_1.onload = function() {
          proxy_1.backgroundLoaded = true;
          proxy_1.canvasContext.globalCompositeOperation = "source-over";
          proxy_1.canvasContext.drawImage(imageObj_1, 0, 0, proxy_1.element.width, proxy_1.element.height);
          proxy_1.save(proxy_1.fileType, proxy_1.fileName);
        };
      }
    };
    SignatureBase2.prototype.save = function(type, fileName) {
      if (this.saveWithBackground && this.backgroundLoaded == null && (this.backgroundImage || this.backgroundColor)) {
        this.backgroundLoaded = false;
        this.fileType = type;
        this.fileName = fileName;
        this.saveBackground(false);
      } else if (type === "Svg") {
        fileName = fileName || "Signature";
        this.toSVG(fileName);
      } else if (type === "Jpeg") {
        fileName = fileName || "Signature";
        if (!this.saveWithBackground || this.saveWithBackground && !(this.backgroundImage || this.backgroundColor)) {
          this.toJPEG(fileName);
        } else {
          var dataURL = this.canvasContext.canvas.toDataURL("image/jpeg");
          this.download(this.getBlob(dataURL), fileName + ".jpeg");
        }
      } else {
        fileName = fileName || "Signature";
        var dataURL = this.canvasContext.canvas.toDataURL("image/png");
        this.download(this.getBlob(dataURL), fileName + ".png");
      }
      if (this.saveWithBackground && this.backgroundLoaded) {
        this.resetSnap();
      }
    };
    SignatureBase2.prototype.resetSnap = function() {
      this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      var proxy = this;
      var restoreObj = new Image();
      restoreObj.src = this.snapColl[this.incStep - 1];
      restoreObj.onload = function() {
        proxy.canvasContext.drawImage(restoreObj, 0, 0, proxy.element.width, proxy.element.height);
        proxy.updateSnapCollection();
      };
      this.backgroundLoaded = null;
      this.snapColl.pop();
      this.incStep--;
      this.snapColl.pop();
      this.incStep--;
    };
    SignatureBase2.prototype.toJPEG = function(fileName) {
      var _this = this;
      var imageSrc = this.snapColl[this.incStep];
      this.setBackgroundColor("#ffffff");
      var proxy = this;
      var imageObj = new Image();
      imageObj.crossOrigin = "anonymous";
      imageObj.src = imageSrc;
      imageObj.onload = function() {
        proxy.canvasContext.globalCompositeOperation = "source-over";
        proxy.canvasContext.drawImage(imageObj, 0, 0, proxy.element.width, proxy.element.height);
        var dataURL = proxy.canvasContext.canvas.toDataURL("image/jpeg");
        proxy.download(proxy.getBlob(dataURL), fileName + ".jpeg");
        proxy.canvasContext.clearRect(0, 0, proxy.canvasContext.canvas.width, proxy.canvasContext.canvas.height);
        _this.resizeHandler();
      };
      this.snapColl.pop();
      this.incStep--;
    };
    SignatureBase2.prototype.toSVG = function(fileName, dataUrl) {
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", this.canvasContext.canvas.width.toString());
      svg.setAttribute("height", this.canvasContext.canvas.height.toString());
      var XLinkNS = "http://www.w3.org/1999/xlink";
      var img = document.createElementNS("http://www.w3.org/2000/svg", "image");
      img.setAttributeNS(null, "height", this.canvasContext.canvas.height.toString());
      img.setAttributeNS(null, "width", this.canvasContext.canvas.width.toString());
      img.setAttributeNS(XLinkNS, "xlink:href", dataUrl);
      svg.appendChild(img);
      var prefix = "data:image/svg+xml;base64,";
      var header = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"' + (' width="' + this.canvasContext.canvas.width + '"') + (' height="' + this.canvasContext.canvas.height + '"') + ">";
      var footer = "</svg>";
      var body = svg.innerHTML;
      var data = header + body + footer;
      var svgDataUrl = prefix + btoa(data);
      if (fileName == null) {
        return svgDataUrl;
      } else {
        this.download(this.getBlob(svgDataUrl), fileName + ".svg");
        return null;
      }
    };
    SignatureBase2.prototype.saveAsBlob = function() {
      return this.getBlob(this.canvasContext.canvas.toDataURL("image/png"));
    };
    SignatureBase2.prototype.getSignature = function(type) {
      if (this.saveWithBackground && this.backgroundColor && !this.backgroundImage) {
        this.tempContext.fillStyle = this.backgroundColor;
        this.tempContext.fillRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      } else if (!this.backgroundColor && !this.backgroundImage && type === "Jpeg") {
        this.tempContext.fillStyle = "#fff";
        this.tempContext.fillRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
      }
      this.tempContext.drawImage(this.element, 0, 0);
      if (type === "Jpeg") {
        return this.tempCanvas.toDataURL("image/jpeg");
      } else if (type === "Svg") {
        return this.toSVG(null, this.tempCanvas.toDataURL("image/png"));
      } else {
        return this.tempCanvas.toDataURL("image/png");
      }
    };
    SignatureBase2.prototype.getModuleName = function() {
      return "signature";
    };
    SignatureBase2.prototype.getPersistData = function() {
      this.signatureValue = this.snapColl[this.incStep];
      return this.addOnPersist(["signatureValue"]);
    };
    SignatureBase2.prototype.destroy = function() {
      if (this.getModuleName() !== "image-editor") {
        this.unwireEvents(null);
        removeClass([this.element], "e-" + this.getModuleName());
        this.element.removeAttribute("tabindex");
        this.pointColl = null;
      }
      _super.prototype.destroy.call(this);
    };
    SignatureBase2.prototype.propertyChanged = function(key, value) {
      var canvasNew = this.canvasContext;
      switch (key) {
        case "backgroundColor":
          canvasNew.canvas.style.backgroundColor = value;
          this.backgroundColor = value;
          break;
        case "backgroundImage":
          canvasNew.canvas.style.backgroundImage = "url(" + value + ")";
          this.backgroundImage = value;
          if (this.saveWithBackground) {
            this.setBackgroundImage(this.backgroundImage, "temp");
          }
          break;
        case "strokeColor":
          canvasNew.fillStyle = value;
          this.strokeColor = value;
          break;
        case "saveWithBackground":
          this.saveWithBackground = value;
          break;
        case "maxStrokeWidth":
          this.maxStrokeWidth = value;
          break;
        case "minStrokeWidth":
          this.minStrokeWidth = value;
          break;
        case "velocity":
          this.velocity = value;
          break;
        case "isReadOnly":
          this.isRead(value);
          break;
        case "disabled":
          this.enableOrDisable(value);
          break;
      }
    };
    return SignatureBase2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/signature/signature.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Signature = (
  /** @class */
  function(_super) {
    __extends24(Signature2, _super);
    function Signature2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    Signature2.prototype.preRender = function() {
    };
    Signature2.prototype.render = function() {
      this.initialize();
    };
    Signature2.prototype.initialize = function() {
      this.element.setAttribute("role", "img");
      this.element.setAttribute("aria-label", "signature");
      addClass([this.element], "e-" + this.getModuleName());
      _super.prototype.initialize.call(this, this.element);
      if (this.enablePersistence) {
        this.loadPersistedSignature();
      }
    };
    Signature2.prototype.getModuleName = function() {
      return "signature";
    };
    Signature2.prototype.getPersistData = function() {
      return this.addOnPersist(["signatureValue"]);
    };
    Signature2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "backgroundColor":
            _super.prototype.propertyChanged.call(this, prop, newProp.backgroundColor);
            break;
          case "backgroundImage":
            _super.prototype.propertyChanged.call(this, prop, newProp.backgroundImage);
            break;
          case "strokeColor":
            if (newProp.strokeColor !== oldProp.strokeColor) {
              _super.prototype.propertyChanged.call(this, prop, newProp.strokeColor);
            }
            break;
          case "saveWithBackground":
            _super.prototype.propertyChanged.call(this, prop, newProp.saveWithBackground);
            break;
          case "isReadOnly":
            _super.prototype.propertyChanged.call(this, prop, newProp.isReadOnly);
            break;
          case "disabled":
            _super.prototype.propertyChanged.call(this, prop, newProp.disabled);
            break;
        }
      }
    };
    __decorate24([
      Property("")
    ], Signature2.prototype, "backgroundColor", void 0);
    __decorate24([
      Property("")
    ], Signature2.prototype, "backgroundImage", void 0);
    __decorate24([
      Property(false)
    ], Signature2.prototype, "disabled", void 0);
    __decorate24([
      Property(false)
    ], Signature2.prototype, "isReadOnly", void 0);
    __decorate24([
      Property(true)
    ], Signature2.prototype, "saveWithBackground", void 0);
    __decorate24([
      Property("#000000")
    ], Signature2.prototype, "strokeColor", void 0);
    __decorate24([
      Property(0.5)
    ], Signature2.prototype, "minStrokeWidth", void 0);
    __decorate24([
      Property(2)
    ], Signature2.prototype, "maxStrokeWidth", void 0);
    __decorate24([
      Property(0.7)
    ], Signature2.prototype, "velocity", void 0);
    __decorate24([
      Property("en-US")
    ], Signature2.prototype, "locale", void 0);
    __decorate24([
      Property(false)
    ], Signature2.prototype, "enableRtl", void 0);
    __decorate24([
      Property(false)
    ], Signature2.prototype, "enablePersistence", void 0);
    __decorate24([
      Event()
    ], Signature2.prototype, "beforeSave", void 0);
    __decorate24([
      Event()
    ], Signature2.prototype, "change", void 0);
    __decorate24([
      Event()
    ], Signature2.prototype, "created", void 0);
    Signature2 = __decorate24([
      NotifyPropertyChanges
    ], Signature2);
    return Signature2;
  }(SignatureBase)
);

// node_modules/@syncfusion/ej2-inputs/src/rating/rating.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ICONCSS = "e-rating-icon e-icons e-star-filled";
var ITEMLIST = "e-rating-item-list";
var ITEMCONTAINER = "e-rating-item-container";
var SELECTED = "e-rating-selected";
var INTERMEDIATE = "e-rating-intermediate";
var LABEL3 = "e-rating-label";
var RESET = "e-icons e-reset";
var HIDDEN = "e-rating-hidden";
var DISABLED6 = "e-disabled";
var READONLY = "e-rating-readonly";
var RTL9 = "e-rtl";
var ANIMATION = "e-rating-animation";
var FULLTEMPLATE = "e-rating-full";
var EMPTYTEMPLATE = "e-rating-empty";
var SELECTEDVALUE = "e-selected-value";
var RATINGVALUE = "--rating-value";
var LabelPosition;
(function(LabelPosition2) {
  LabelPosition2["Top"] = "Top";
  LabelPosition2["Bottom"] = "Bottom";
  LabelPosition2["Left"] = "Left";
  LabelPosition2["Right"] = "Right";
})(LabelPosition || (LabelPosition = {}));
var PrecisionType;
(function(PrecisionType2) {
  PrecisionType2["Full"] = "Full";
  PrecisionType2["Half"] = "Half";
  PrecisionType2["Quarter"] = "Quarter";
  PrecisionType2["Exact"] = "Exact";
})(PrecisionType || (PrecisionType = {}));
var Rating = (
  /** @class */
  function(_super) {
    __extends25(Rating2, _super);
    function Rating2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.itemElements = [];
      return _this;
    }
    Rating2.prototype.preRender = function() {
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      this.keyConfigs = {
        downarrow: "downarrow",
        leftarrow: "leftarrow",
        rightarrow: "rightarrow",
        uparrow: "uparrow",
        space: "space"
      };
      this.tooltipOpen = false;
      this.isTouchSelected = false;
    };
    Rating2.prototype.render = function() {
      this.initialize();
      this.updateMinValue();
      this.updateTemplateFunction();
      this.triggerChange(null, this.value, false);
      this.renderItems();
      this.displayLabel();
    };
    Rating2.prototype.initialize = function() {
      this.wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-container " });
      this.element.parentNode.insertBefore(this.wrapper, this.element);
      this.wrapper.appendChild(this.element);
      if (this.element.getAttribute("name") == null) {
        this.element.setAttribute("name", this.element.id);
      }
      attributes(this.element, { "aria-label": "rating" });
      this.renderItemList();
      this.updateReset();
      if (this.readOnly) {
        this.wrapper.classList.add(READONLY);
      }
      if (!this.visible) {
        this.wrapper.classList.add(HIDDEN);
      }
      if (this.enableRtl) {
        this.wrapper.classList.add(RTL9);
      }
      if (this.enableAnimation) {
        this.wrapper.classList.add(ANIMATION);
      }
      if (this.cssClass) {
        addClass([this.wrapper], this.cssClass.split(" "));
      }
      this.updateTooltip();
      this.wireKeyboardEvent();
      this.updateDisabled();
    };
    Rating2.prototype.updateDisabled = function() {
      this.wrapper.classList[this.disabled ? "add" : "remove"](DISABLED6);
      attributes(this.ratingItemList, { "tabindex": this.disabled ? "-1" : "0" });
      this.updateResetButton();
    };
    Rating2.prototype.updateResetButton = function() {
      if (this.allowReset) {
        var isDisabled = this.value <= this.min || this.disabled;
        this.resetElement.classList[isDisabled ? "add" : "remove"](DISABLED6);
        attributes(this.resetElement, { "tabindex": isDisabled ? "-1" : "0", "aria-hidden": isDisabled.toString() });
      }
    };
    Rating2.prototype.renderItemList = function() {
      var _this = this;
      this.ratingItemList = this.createElement("div", {
        className: ITEMLIST,
        id: this.element.id + "_item-list"
      });
      attributes(this.ratingItemList, { "aria-label": "rating", "role": "slider" });
      this.wrapper.appendChild(this.ratingItemList);
      EventHandler.add(this.ratingItemList, "touchmove", function(e) {
        return _this.touchMoveHandler(e);
      }, this);
      EventHandler.add(this.ratingItemList, Browser.touchEndEvent, this.touchEndHandler, this);
    };
    Rating2.prototype.touchMoveHandler = function(e) {
      if (!this.isTouchSelected) {
        this.wrapper.classList.add("e-rating-touch");
        this.isTouchSelected = true;
      }
      this.wrapper.classList.add("e-touch-select");
      var rect = this.ratingItemList.getBoundingClientRect();
      var x = e.touches[0].clientX - rect.x;
      var currValue = x / rect.width * this.itemsCount;
      currValue = this.enableRtl ? this.itemsCount - currValue : currValue;
      currValue = currValue < this.min ? this.min : currValue > this.itemsCount ? this.itemsCount : currValue;
      currValue = this.validateValue(currValue);
      var element2 = currValue === 0 ? null : this.itemElements[parseInt((Math.ceil(currValue) - 1).toString(), 10)];
      if (currValue === this.currentValue) {
        if (this.showTooltip && element2) {
          this.openRatingTooltip(element2, false);
        }
        return;
      }
      var previousValue = this.currentValue;
      this.triggerChange(e, currValue);
      this.updateCurrentValue(currValue);
      if (this.showTooltip) {
        if (element2) {
          if (Math.ceil(currValue) !== Math.ceil(previousValue)) {
            this.closeRatingTooltip();
          }
          this.openRatingTooltip(element2, true);
        } else {
          this.closeRatingTooltip();
        }
      }
    };
    Rating2.prototype.touchEndHandler = function() {
      this.closeRatingTooltip();
      this.wrapper.classList.remove("e-touch-select");
    };
    Rating2.prototype.updateTemplateFunction = function() {
      this.emptyTemplateFunction = this.emptyTemplate ? this.getTemplateString(this.emptyTemplate) : null;
      this.fullTemplateFunction = this.fullTemplate ? this.getTemplateString(this.fullTemplate) : null;
    };
    Rating2.prototype.renderItems = function() {
      var _this = this;
      for (var i = 0; i < this.itemsCount; i++) {
        var ratingItemContainer = this.createElement("span", { className: ITEMCONTAINER });
        var spanItem = this.createElement("span", { className: "e-rating-item" });
        var ratingValue = this.getRatingValue(this.value, i);
        this.renderItemContent(spanItem, ratingValue, i, false);
        ratingItemContainer.appendChild(spanItem);
        this.wireItemsEvents(ratingItemContainer, i + 1);
        this.itemElements.push(ratingItemContainer);
        var eventArgs = { element: ratingItemContainer, value: i + 1 };
        this.trigger("beforeItemRender", eventArgs, function(args) {
          _this.ratingItemList.appendChild(args.element);
        });
      }
      attributes(this.ratingItemList, { "aria-valuemax": this.itemsCount.toString() });
      this.updateItemValue(false);
    };
    Rating2.prototype.renderItemContent = function(spanEle, val, index, isrerender) {
      if (isrerender) {
        this.removeItemContent(spanEle);
      }
      if (this.fullTemplate && val === 1) {
        spanEle.classList.add(FULLTEMPLATE);
        append(this.fullTemplateFunction({ index, ratingValue: val }, this, "ratingFullTemplate", this.element.id + "fullTemplate", this.isStringTemplate), spanEle);
      } else if (this.emptyTemplate) {
        spanEle.classList.add(EMPTYTEMPLATE);
        append(this.emptyTemplateFunction({ index, ratingValue: val }, this, "ratingEmptyTemplate", this.element.id + "emptyTemplate", this.isStringTemplate), spanEle);
      } else {
        addClass([spanEle], ICONCSS.split(" "));
      }
    };
    Rating2.prototype.removeItemContent = function(spanEle) {
      spanEle.classList.remove(FULLTEMPLATE, EMPTYTEMPLATE);
      removeClass([spanEle], ICONCSS.split(" "));
      if (spanEle.firstChild) {
        spanEle.innerHTML = "";
      }
    };
    Rating2.prototype.updateTooltip = function() {
      if (this.showTooltip) {
        this.tooltipObj = new Tooltip({
          target: ".e-rating-item-container",
          windowCollision: true,
          opensOn: "Custom",
          cssClass: this.cssClass ? "e-rating-tooltip " + this.cssClass : "e-rating-tooltip"
        });
        this.tooltipObj.appendTo(this.ratingItemList);
      } else {
        if (!isNullOrUndefined(this.tooltipObj)) {
          this.tooltipObj.destroy();
          this.tooltipObj = null;
        }
      }
    };
    Rating2.prototype.updateMinValue = function() {
      this.setProperties({ min: this.validateValue(this.min) }, true);
      if (this.min > 0 && this.value < this.min) {
        this.triggerChange(null, this.min, false);
      }
      attributes(this.ratingItemList, { "aria-valuemin": this.min.toString() });
    };
    Rating2.prototype.validateValue = function(currentValue) {
      if (currentValue > this.itemsCount) {
        currentValue = this.itemsCount;
      } else if (currentValue < 0) {
        currentValue = 0;
      } else {
        currentValue = this.precision === PrecisionType.Full || this.enableSingleSelection ? Math.round(currentValue) : this.precision === PrecisionType.Half ? Math.round(currentValue * 2) / 2 : this.precision === PrecisionType.Quarter ? Math.round(currentValue * 4) / 4 : Math.round(currentValue * 10) / 10;
      }
      return currentValue;
    };
    Rating2.prototype.getRatingValue = function(value, i) {
      return this.enableSingleSelection ? value > i && value <= i + 1 ? 1 : 0 : value >= i + 1 ? 1 : value < i ? 0 : value - i;
    };
    Rating2.prototype.updateItemValue = function(isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = true;
      }
      if (isUpdate && this.isReact) {
        this.clearTemplate(["ratingEmptyTemplate", "ratingFullTemplate"]);
      }
      for (var i = 0; i < this.itemsCount; i++) {
        var itemElement = this.itemElements[parseInt(i.toString(), 10)];
        itemElement.classList.remove(SELECTED, INTERMEDIATE, SELECTEDVALUE);
        var ratingValue = this.getRatingValue(this.currentValue, i);
        if (ratingValue === 1) {
          itemElement.classList.add(SELECTED);
        } else if (ratingValue > 0) {
          itemElement.classList.add(INTERMEDIATE);
        } else if (this.precision === PrecisionType.Full && i + 1 <= this.value && !this.enableSingleSelection) {
          itemElement.classList.add(SELECTEDVALUE);
        }
        if (isUpdate) {
          this.updateItemContent(ratingValue, i);
        }
        itemElement.style.setProperty(RATINGVALUE, ratingValue * 100 + "%");
        itemElement.classList[this.value === 0 && i === 0 || this.value === i + 1 || ratingValue > 0 && ratingValue < 1 ? "add" : "remove"]("e-rating-focus");
      }
      if (isUpdate) {
        this.renderReactTemplates();
      }
      this.updateResetButton();
      attributes(this.ratingItemList, { "aria-valuenow": this.currentValue.toString() });
      attributes(this.element, { "value": this.value.toString() });
    };
    Rating2.prototype.updateItemContent = function(ratingValue, index) {
      if (!this.fullTemplate && !this.emptyTemplate) {
        return;
      }
      var spanEle = this.itemElements[parseInt(index.toString(), 10)].querySelector(".e-rating-item");
      if (this.fullTemplate && ratingValue === 1) {
        if (!this.isReact && spanEle.classList.contains(FULLTEMPLATE)) {
          return;
        }
        this.removeItemContent(spanEle);
        spanEle.classList.add(FULLTEMPLATE);
        append(this.fullTemplateFunction({ ratingValue, index }, this, "ratingFullTemplate", this.element.id + "fullTemplate" + index, this.isStringTemplate), spanEle);
      } else if (this.emptyTemplate) {
        if (!this.isReact && spanEle.classList.contains(EMPTYTEMPLATE)) {
          return;
        }
        this.removeItemContent(spanEle);
        spanEle.classList.add(EMPTYTEMPLATE);
        append(this.emptyTemplateFunction({ ratingValue, index }, this, "ratingEmptyTemplate", this.element.id + "emptyTemplate" + index, this.isStringTemplate), spanEle);
      } else {
        this.removeItemContent(spanEle);
        addClass([spanEle], ICONCSS.split(" "));
      }
    };
    Rating2.prototype.updateTooltipContent = function(isChange) {
      var _this = this;
      if (this.showTooltip) {
        if (this.isReact) {
          this.clearTemplate(["ratingTooltipTemplate"]);
        }
        var content_1;
        if (this.tooltipTemplate) {
          content_1 = this.createElement("span", { className: "e-rating-tooltip-content" });
          var templateFunction = this.getTemplateString(this.tooltipTemplate);
          append(templateFunction({ value: this.currentValue }, this, "ratingTooltipTemplate", this.element.id + "tooltipTemplate", this.isStringTemplate), content_1);
          this.tooltipObj.setProperties({ content: content_1 }, isChange);
          if (this.isAngular) {
            setTimeout(function() {
              var ratingSpan = _this.ratingItemList.querySelectorAll("." + ITEMCONTAINER + "." + SELECTED);
              _this.tooltipObj.refresh(ratingSpan[ratingSpan.length - 1]);
            });
          }
        } else {
          content_1 = this.currentValue.toString();
          this.tooltipObj.setProperties({ content: initializeCSPTemplate(function() {
            return content_1;
          }) }, isChange);
        }
        this.renderReactTemplates();
      }
    };
    Rating2.prototype.getTemplateString = function(template) {
      var stringContent = "";
      try {
        if (typeof template !== "function") {
          var tempEle = select(template);
          if (tempEle) {
            stringContent = tempEle.tagName === "SCRIPT" ? tempEle.innerHTML : tempEle.outerHTML;
          } else {
            stringContent = template;
          }
        } else {
          stringContent = template;
        }
      } catch (e) {
        stringContent = template;
      }
      return compile(stringContent);
    };
    Rating2.prototype.displayLabel = function() {
      if (this.showLabel) {
        this.spanLabel = this.createElement("span", { className: LABEL3 });
        this.updateLabel();
        this.updateLabelPosition();
      } else {
        if (this.wrapper.contains(this.spanLabel)) {
          remove(this.spanLabel);
          this.spanLabel = null;
        }
      }
    };
    Rating2.prototype.updateLabel = function() {
      if (this.showLabel) {
        if (this.labelTemplate) {
          if (this.isReact) {
            this.clearTemplate(["ratingLabelTemplate"]);
          }
          if (this.spanLabel.firstChild) {
            this.spanLabel.innerHTML = "";
          }
          var templateFunction = this.getTemplateString(this.labelTemplate);
          append(templateFunction({ value: this.currentValue }, this, "ratingLabelTemplate", this.element.id + "labelTemplate", this.isStringTemplate), this.spanLabel);
          this.renderReactTemplates();
        } else {
          this.spanLabel.textContent = this.currentValue + " / " + this.itemsCount;
        }
      }
    };
    Rating2.prototype.updateReset = function() {
      if (this.allowReset) {
        this.resetElement = this.createElement("span", {
          className: RESET,
          attrs: { "aria-label": "resetbutton", "role": "button" }
        });
        this.updateResetButton();
        EventHandler.add(this.resetElement, "click", this.resetClicked, this);
        this.wrapper.insertBefore(this.resetElement, this.ratingItemList);
      } else {
        if (this.wrapper.contains(this.resetElement)) {
          remove(this.resetElement);
          this.resetElement = null;
        }
      }
    };
    Rating2.prototype.updateLabelPosition = function() {
      this.clearLabelPosition();
      this.spanLabel.classList.add("e-label-" + this.labelPosition.toLowerCase());
      if (this.labelPosition === "Left" || this.labelPosition === "Top") {
        this.wrapper.firstChild.after(this.spanLabel);
      } else {
        this.wrapper.appendChild(this.spanLabel);
      }
    };
    Rating2.prototype.clearLabelPosition = function() {
      var removeCss = this.spanLabel.classList.value.match(/(e-label-[top|bottom|right|left]+)/g);
      if (removeCss) {
        removeClass([this.spanLabel], removeCss);
      }
    };
    Rating2.prototype.wireItemsEvents = function(itemElement, index) {
      var _this = this;
      EventHandler.add(itemElement, "click", function(e) {
        return _this.clickHandler(e);
      }, this);
      EventHandler.add(itemElement, "mousemove", function(e) {
        return _this.mouseMoveHandler(index, e);
      }, this);
      EventHandler.add(itemElement, "mouseleave", this.mouseLeaveHandler, this);
    };
    Rating2.prototype.clickHandler = function(e) {
      this.currentValue = this.min > 0 && this.currentValue < this.min ? this.min : this.currentValue;
      this.triggerChange(e, this.currentValue);
      this.updateItemValue();
      this.updateLabel();
      this.updateResetButton();
    };
    Rating2.prototype.updateValueChange = function(e, val, isInteracted) {
      if (isInteracted === void 0) {
        isInteracted = true;
      }
      this.triggerChange(e, val, isInteracted);
      this.updateItemValue();
      this.updateLabel();
    };
    Rating2.prototype.triggerChange = function(e, val, isInteracted) {
      if (isInteracted === void 0) {
        isInteracted = true;
      }
      val = this.validateValue(val);
      this.currentValue = val;
      if (this.currentValue === this.value) {
        return;
      }
      var eventArgs = { event: e, isInteracted, value: val, previousValue: this.value };
      this.setProperties({ value: val }, true);
      this.trigger("valueChanged", eventArgs);
    };
    Rating2.prototype.mouseMoveHandler = function(index, e) {
      if (this.isTouchSelected) {
        this.wrapper.classList.remove("e-rating-touch");
        this.isTouchSelected = false;
      }
      var currValue = this.calculateCurrentValue(index, e);
      currValue = this.validateValue(currValue);
      var element2 = this.itemElements[parseInt((index - 1).toString(), 10)];
      if (currValue === this.currentValue) {
        this.openRatingTooltip(element2, false);
        return;
      }
      this.updateCurrentValue(currValue);
      this.openRatingTooltip(element2, true);
      var eventArgs = { element: element2, event: e, value: currValue };
      this.trigger("onItemHover", eventArgs);
    };
    Rating2.prototype.openRatingTooltip = function(element2, isChange) {
      if (this.showTooltip) {
        if (!this.tooltipOpen) {
          this.updateTooltipContent(false);
          this.tooltipObj.open(element2);
          this.tooltipOpen = true;
        } else if (isChange) {
          this.updateTooltipContent(true);
          this.tooltipObj.refresh(element2);
        }
      }
    };
    Rating2.prototype.closeRatingTooltip = function() {
      if (this.tooltipOpen) {
        this.tooltipObj.close();
        this.tooltipOpen = false;
      }
    };
    Rating2.prototype.updateCurrentValue = function(currValue) {
      this.currentValue = currValue;
      this.updateItemValue();
      this.updateLabel();
    };
    Rating2.prototype.mouseLeaveHandler = function() {
      this.closeRatingTooltip();
      this.updateCurrentValue(this.value);
    };
    Rating2.prototype.calculateCurrentValue = function(index, args) {
      var currentValue = index;
      if (!(this.enableSingleSelection || this.precision === PrecisionType.Full)) {
        currentValue = args.offsetX / this.itemElements[index - 1].clientWidth;
        currentValue = this.enableRtl ? 1 - currentValue : currentValue;
        if (this.precision === PrecisionType.Quarter) {
          currentValue = currentValue <= 0.25 ? 0.25 : currentValue <= 0.5 ? 0.5 : currentValue < 0.75 ? 0.75 : 1;
        } else if (this.precision === PrecisionType.Half) {
          currentValue = currentValue <= 0.5 ? 0.5 : 1;
        }
        currentValue = currentValue + index - 1;
      }
      return currentValue;
    };
    Rating2.prototype.reset = function() {
      this.resetClicked(null, false);
    };
    Rating2.prototype.resetClicked = function(e, isInteracted) {
      if (isInteracted === void 0) {
        isInteracted = true;
      }
      this.updateValueChange(e, this.min, isInteracted);
      this.updateResetButton();
    };
    Rating2.prototype.wireKeyboardEvent = function() {
      this.keyboardModuleRating = new KeyboardEvents(this.wrapper, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
    };
    Rating2.prototype.keyActionHandler = function(e) {
      e.preventDefault();
      if (this.disabled || this.readOnly) {
        return;
      }
      if (e.target.classList.contains(ITEMLIST)) {
        switch (e.action) {
          case "uparrow":
            this.handleNavigation(e, true);
            break;
          case "downarrow":
            this.handleNavigation(e, false);
            break;
          case "leftarrow":
            this.handleNavigation(e, this.enableRtl);
            break;
          case "rightarrow":
            this.handleNavigation(e, !this.enableRtl);
            break;
        }
      }
      if (this.allowReset && e.target.classList.contains("e-reset")) {
        switch (e.action) {
          case "space":
            this.resetClicked(e);
            break;
        }
      }
    };
    Rating2.prototype.handleNavigation = function(e, isIncrease) {
      if (!isIncrease && this.value > this.min || isIncrease && this.value < this.itemsCount) {
        var currentValue = this.precision === PrecisionType.Full || this.enableSingleSelection ? 1 : this.precision === PrecisionType.Half ? 0.5 : this.precision === PrecisionType.Quarter ? 0.25 : Math.round(0.1 * 10) / 10;
        currentValue = isIncrease ? this.value + currentValue : this.value - currentValue;
        this.updateValueChange(e, currentValue);
        this.updateResetButton();
      }
    };
    Rating2.prototype.updateContent = function() {
      if (this.isReact) {
        this.clearTemplate(["ratingEmptyTemplate", "ratingFullTemplate"]);
      }
      for (var i = 0; i < this.itemsCount; i++) {
        var itemElement = this.itemElements[parseInt(i.toString(), 10)].firstElementChild;
        this.renderItemContent(itemElement, this.getRatingValue(this.value, i), i, true);
      }
    };
    Rating2.prototype.getModuleName = function() {
      return "rating";
    };
    Rating2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Rating2.prototype.removeItemElements = function() {
      for (var i = 0; i < this.itemElements.length; i++) {
        remove(this.itemElements[parseInt(i.toString(), 10)]);
      }
      this.itemElements = [];
    };
    Rating2.prototype.destroy = function() {
      var _this = this;
      _super.prototype.destroy.call(this);
      this.removeItemElements();
      this.clearTemplate();
      if (this.spanLabel) {
        remove(this.spanLabel);
        this.spanLabel = null;
      }
      if (this.resetElement) {
        remove(this.resetElement);
        this.resetElement = null;
      }
      if (this.showTooltip) {
        this.tooltipObj.destroy();
        this.tooltipObj = null;
      }
      remove(this.ratingItemList);
      this.ratingItemList = null;
      this.wrapper.parentNode.insertBefore(this.element, this.wrapper);
      remove(this.wrapper);
      this.wrapper = null;
      this.keyboardModuleRating.destroy();
      this.keyboardModuleRating = null;
      ["value", "aria-label", "name"].forEach(function(attr) {
        _this.element.removeAttribute(attr);
      });
    };
    Rating2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            this.updateValueChange(null, this.value > this.min ? this.value : this.min, false);
            break;
          case "min":
            this.updateMinValue();
            this.updateItemValue();
            this.updateLabel();
            break;
          case "showLabel":
            this.displayLabel();
            break;
          case "visible":
            this.wrapper.classList[!this.visible ? "add" : "remove"](HIDDEN);
            break;
          case "disabled":
            this.updateDisabled();
            break;
          case "readOnly":
            this.wrapper.classList[this.readOnly ? "add" : "remove"](READONLY);
            break;
          case "allowReset":
            this.updateReset();
            break;
          case "enableRtl":
            this.wrapper.classList[this.enableRtl ? "add" : "remove"](RTL9);
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.wrapper], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.wrapper], newProp.cssClass.split(" "));
            }
            if (this.tooltipObj) {
              this.tooltipObj.setProperties({ cssClass: this.cssClass ? "e-rating-tooltip " + this.cssClass : "e-rating-tooltip" });
            }
            break;
          case "labelPosition":
            this.updateLabelPosition();
            break;
          case "showTooltip":
            this.updateTooltip();
            break;
          case "precision":
            this.updateMinValue();
            this.triggerChange(null, this.value, false);
            this.updateItemValue();
            this.updateLabel();
            break;
          case "enableSingleSelection":
            this.updateValueChange(null, this.currentValue, false);
            break;
          case "enableAnimation":
            this.wrapper.classList[this.enableAnimation ? "add" : "remove"](ANIMATION);
            break;
          case "emptyTemplate":
          case "fullTemplate":
            this.updateTemplateFunction();
            this.updateContent();
            break;
          case "labelTemplate":
            this.updateLabel();
            break;
          case "itemsCount":
            this.removeItemElements();
            this.renderItems();
            this.updateLabel();
            break;
        }
      }
    };
    __decorate25([
      Property(false)
    ], Rating2.prototype, "allowReset", void 0);
    __decorate25([
      Property("")
    ], Rating2.prototype, "cssClass", void 0);
    __decorate25([
      Property(false)
    ], Rating2.prototype, "disabled", void 0);
    __decorate25([
      Property("")
    ], Rating2.prototype, "emptyTemplate", void 0);
    __decorate25([
      Property(true)
    ], Rating2.prototype, "enableAnimation", void 0);
    __decorate25([
      Property(false)
    ], Rating2.prototype, "enableSingleSelection", void 0);
    __decorate25([
      Property("")
    ], Rating2.prototype, "fullTemplate", void 0);
    __decorate25([
      Property(5)
    ], Rating2.prototype, "itemsCount", void 0);
    __decorate25([
      Property(LabelPosition.Right)
    ], Rating2.prototype, "labelPosition", void 0);
    __decorate25([
      Property("")
    ], Rating2.prototype, "labelTemplate", void 0);
    __decorate25([
      Property(0)
    ], Rating2.prototype, "min", void 0);
    __decorate25([
      Property(PrecisionType.Full)
    ], Rating2.prototype, "precision", void 0);
    __decorate25([
      Property(false)
    ], Rating2.prototype, "readOnly", void 0);
    __decorate25([
      Property(false)
    ], Rating2.prototype, "showLabel", void 0);
    __decorate25([
      Property(true)
    ], Rating2.prototype, "showTooltip", void 0);
    __decorate25([
      Property("")
    ], Rating2.prototype, "tooltipTemplate", void 0);
    __decorate25([
      Property(0)
    ], Rating2.prototype, "value", void 0);
    __decorate25([
      Property(true)
    ], Rating2.prototype, "visible", void 0);
    __decorate25([
      Event()
    ], Rating2.prototype, "beforeItemRender", void 0);
    __decorate25([
      Event()
    ], Rating2.prototype, "created", void 0);
    __decorate25([
      Event()
    ], Rating2.prototype, "onItemHover", void 0);
    __decorate25([
      Event()
    ], Rating2.prototype, "valueChanged", void 0);
    Rating2 = __decorate25([
      NotifyPropertyChanges
    ], Rating2);
    return Rating2;
  }(Component)
);

// node_modules/@syncfusion/ej2-inputs/src/otp-input/otp-input.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var INPUTFIELD = "e-otp-input-field";
var RTL10 = "e-rtl";
var OtpInputType;
(function(OtpInputType2) {
  OtpInputType2["Number"] = "number";
  OtpInputType2["Text"] = "text";
  OtpInputType2["Password"] = "password";
})(OtpInputType || (OtpInputType = {}));
var OtpInputStyle;
(function(OtpInputStyle2) {
  OtpInputStyle2["Outlined"] = "outlined";
  OtpInputStyle2["Underlined"] = "underlined";
  OtpInputStyle2["Filled"] = "filled";
})(OtpInputStyle || (OtpInputStyle = {}));
var OtpInput = (
  /** @class */
  function(_super) {
    __extends26(OtpInput2, _super);
    function OtpInput2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.inputs = [];
      _this.previousValue = "";
      _this.separatorElements = [];
      _this.shouldFireFocus = true;
      _this.shouldFireBlur = true;
      _this.isFocusInCalled = false;
      _this.isFocusOutCalled = false;
      return _this;
    }
    OtpInput2.prototype.preRender = function() {
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
    };
    OtpInput2.prototype.render = function() {
      this.initialize();
    };
    OtpInput2.prototype.initialize = function() {
      attributes(this.element, { "role": "group" });
      this.renderInputs();
      this.renderSeparator(1, this.inputs.length);
      this.addPlaceHolder();
      this.updateCssClass(this.cssClass);
      this.updateVariantClass();
      this.updateAriaLabel(this.ariaLabels);
      this.setElementAttributes(this.htmlAttributes, this.element);
      if (this.enableRtl) {
        this.element.classList.add(RTL10);
      }
      this.previousValue = this.value.toString();
    };
    OtpInput2.prototype.renderInputs = function() {
      this.hiddenInputEle = this.createElement("input", {
        id: "otpInput_hidden",
        attrs: {
          name: this.element.id,
          type: "hidden",
          value: this.type === "number" ? this.value.toString().replace(/\D/g, "") : this.value.toString(),
          autoComplete: "off"
        }
      });
      this.element.appendChild(this.hiddenInputEle);
      for (var i = 0; i < this.length; i++) {
        this.createOtpInput(i);
      }
    };
    OtpInput2.prototype.createOtpInput = function(index) {
      var valueContainer = this.getDefaultValue();
      var inputValue = "";
      if (valueContainer) {
        if (this.type === "number") {
          var valueAtIndex = valueContainer[parseInt(index.toString(), 10)];
          if (!isNaN(Number(valueAtIndex))) {
            inputValue = valueAtIndex;
          }
        } else {
          inputValue = valueContainer[parseInt(index.toString(), 10)] || "";
        }
      }
      var inputEle = this.createElement("input", {
        id: this.element.id + "-" + (index + 1),
        className: INPUTFIELD + " e-input",
        attrs: {
          maxlength: "1",
          type: this.type,
          inputmode: this.type === "number" ? "numeric" : "text"
        }
      });
      if (this.disabled) {
        inputEle.setAttribute("disabled", "disabled");
      }
      this.element.appendChild(inputEle);
      this.inputs.push(inputEle);
      if (inputValue) {
        inputEle.value = inputValue;
      }
      this.wireEvents(inputEle, index);
    };
    OtpInput2.prototype.renderSeparator = function(index, length) {
      if (this.separator.length > 0) {
        for (var i = index; i < length; i++) {
          var separatorElement = this.createElement("span", {
            className: "e-otp-separator"
          });
          separatorElement.textContent = this.separator;
          this.separatorElements.push(separatorElement);
          this.element.insertBefore(separatorElement, this.inputs[parseInt(i.toString(), 10)]);
        }
      }
    };
    OtpInput2.prototype.updateSeparatorValue = function() {
      if (this.separator === "") {
        for (var i = 0; i < this.separatorElements.length; i++) {
          remove(this.separatorElements[parseInt(i.toString(), 10)]);
        }
        this.separatorElements = [];
        return;
      }
      for (var i = 0; i < this.separatorElements.length; i++) {
        this.separatorElements[parseInt(i.toString(), 10)].textContent = this.separator;
      }
    };
    OtpInput2.prototype.addPlaceHolder = function() {
      for (var i = 0; i < this.inputs.length; i++) {
        this.setElementAttributes({ "placeholder": this.placeholder.length === 1 || this.placeholder.length === 0 ? this.placeholder : this.placeholder.charAt(i) }, this.inputs[parseInt(i.toString(), 10)]);
      }
    };
    OtpInput2.prototype.updateInputType = function(inputType) {
      this.inputs.forEach(function(input) {
        input.type = inputType;
        input.setAttribute("inputmode", inputType === "number" ? "numeric" : "text");
      });
    };
    OtpInput2.prototype.getDefaultValue = function() {
      var extractedValue = typeof this.value === "number" ? this.value.toString() : this.value;
      var value = extractedValue.replace(/\s/g, "");
      if (value.length > 0) {
        return value.split("");
      }
      return void 0;
    };
    OtpInput2.prototype.handleInputChange = function(index, event) {
      var currentInputElement = this.inputs[parseInt(index.toString(), 10)];
      if (currentInputElement && index < this.length - 1 && currentInputElement.value.length > 0) {
        var nextInputElement = this.inputs[parseInt(index.toString(), 10) + 1];
        this.shouldFireFocus = this.shouldFireBlur = false;
        nextInputElement.focus();
        if (nextInputElement && nextInputElement.value.length > 0) {
          nextInputElement.select();
        }
      }
      var target = event.target;
      if (target.value.length > 1) {
        target.value = target.value.slice(0, 1);
      }
      this.triggerInputEvent(event);
      this.triggerValuechanged(event, true);
    };
    OtpInput2.prototype.handleKeyAction = function(index, event) {
      if (event.key.length > 1 && !(index === 0 && event.key === "Backspace" || index === this.length - 1 && event.key === "Delete")) {
        this.shouldFireFocus = this.shouldFireBlur = false;
      }
      var currentInputElement = this.inputs[parseInt(index.toString(), 10)];
      var previousInputElement = this.inputs[parseInt(index.toString(), 10) - 1];
      var nextInputElement = this.inputs[parseInt(index.toString(), 10) + 1];
      if (event.key === "Delete") {
        var value = "";
        if (currentInputElement.value.length > 0) {
          value = currentInputElement.value;
          currentInputElement.value = "";
        } else {
          if (index !== this.inputs.length - 1) {
            value = nextInputElement.value;
            nextInputElement.value = "";
            nextInputElement.focus();
          }
        }
        if (value.length > 0) {
          this.triggerInputEvent(event);
        }
      } else if (event.key === "Backspace") {
        if (index !== 0 && currentInputElement.value.length === 0) {
          var previousValue = previousInputElement.value;
          previousInputElement.value = "";
          previousInputElement.focus();
          if (previousValue.length > 0) {
            this.triggerInputEvent(event);
          }
        }
      } else if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
        if (event.key === "ArrowLeft") {
          if (index > 0) {
            previousInputElement.focus();
            previousInputElement.select();
          }
        } else {
          if (index < this.inputs.length - 1) {
            nextInputElement.focus();
            nextInputElement.select();
          }
        }
        event.preventDefault();
      } else if (event.key === "ArrowUp" || event.key === "ArrowDown") {
        event.preventDefault();
      } else {
        if (event.key !== "Tab" && !event.shiftKey && !event.ctrlKey) {
          if (this.type === "number" && /\D/.test(event.key.toLocaleLowerCase())) {
            event.preventDefault();
          }
        }
      }
    };
    OtpInput2.prototype.handleSelection = function(index) {
      var currentInputElement = this.inputs[parseInt(index.toString(), 10)];
      if (currentInputElement.value) {
        currentInputElement.select();
      }
    };
    OtpInput2.prototype.handleFocus = function(index, event) {
      addClass([this.inputs[parseInt(index.toString(), 10)]], "e-otp-input-focus");
      if (this.shouldFireFocus) {
        var eventArgs = {
          element: this.element,
          event,
          isInteracted: this.isFocusInCalled ? false : true,
          value: this.value
        };
        this.trigger("focus", eventArgs);
      }
      this.shouldFireFocus = true;
    };
    OtpInput2.prototype.handleBlur = function(index, event) {
      removeClass([this.inputs[parseInt(index.toString(), 10)]], "e-otp-input-focus");
      if (this.shouldFireBlur) {
        var eventArgs = {
          element: this.element,
          event,
          isInteracted: this.isFocusOutCalled ? false : true,
          value: this.value
        };
        this.trigger("blur", eventArgs);
      }
      this.shouldFireBlur = true;
    };
    OtpInput2.prototype.handlePaste = function(index, event) {
      var clipboardData = event.clipboardData;
      if (clipboardData) {
        var pastedText = clipboardData.getData("text");
        var pastedValues = pastedText.split("");
        var pastedValueIndex = 0;
        for (var i = index; i < this.inputs.length; i++) {
          if (pastedValues.length > 0 && pastedValues[parseInt(pastedValueIndex.toString(), 10)]) {
            this.inputs[parseInt(i.toString(), 10)].value = pastedValues[parseInt(pastedValueIndex.toString(), 10)];
            pastedValueIndex++;
            this.updateValueProperty();
          }
        }
        this.focusIn();
        this.triggerValuechanged(event, true);
      }
    };
    OtpInput2.prototype.triggerInputEvent = function(event) {
      var previousValue = this.value.toString();
      this.updateValueProperty();
      var inputEventArgs = {
        element: this.element,
        event,
        previousValue,
        value: this.value.toString()
      };
      this.trigger("input", inputEventArgs);
    };
    OtpInput2.prototype.triggerValuechanged = function(event, isInteracted) {
      if (this.length === this.value.toString().length) {
        if (this.previousValue !== this.value) {
          var eventArgs = {
            element: this.element,
            event,
            isInteracted: isInteracted ? isInteracted : false,
            previousValue: this.previousValue,
            value: this.value
          };
          this.trigger("valueChanged", eventArgs);
          this.previousValue = this.value.toString();
        }
      }
    };
    OtpInput2.prototype.wireEvents = function(inputEle, index) {
      inputEle.addEventListener("focus", this.handleFocus.bind(this, index));
      inputEle.addEventListener("blur", this.handleBlur.bind(this, index));
      inputEle.addEventListener("input", this.handleInputChange.bind(this, index));
      inputEle.addEventListener("keydown", this.handleKeyAction.bind(this, index));
      inputEle.addEventListener("click", this.handleSelection.bind(this, index));
      inputEle.addEventListener("paste", this.handlePaste.bind(this, index));
    };
    OtpInput2.prototype.unWireEvents = function() {
      for (var i = 0; i < this.inputs.length; i++) {
        var currentInputElement = this.inputs[parseInt(i.toString(), 10)];
        currentInputElement.removeEventListener("focus", this.handleFocus.bind(this, i));
        currentInputElement.removeEventListener("blur", this.handleBlur.bind(this, i));
        currentInputElement.removeEventListener("input", this.handleInputChange.bind(this, i));
        currentInputElement.removeEventListener("keydown", this.handleKeyAction.bind(this, i));
        currentInputElement.removeEventListener("click", this.handleSelection.bind(this, i));
        currentInputElement.removeEventListener("paste", this.handlePaste.bind(this, i));
      }
    };
    OtpInput2.prototype.updateValueProperty = function() {
      var value = "";
      this.inputs.forEach(function(input) {
        value += input.value;
      });
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      this.value = typeof this.value === "number" ? parseInt(value, 10) : value;
      this.isProtectedOnChange = prevOnChange;
      this.hiddenInputEle.value = this.value.toString();
    };
    OtpInput2.prototype.updateInputValue = function(previousValue) {
      var stringifiedValue = this.value.toString();
      for (var i = 0; i < this.inputs.length; i++) {
        var isValueChanged = previousValue.toString().charAt(i) !== stringifiedValue.charAt(i);
        if (isValueChanged) {
          this.inputs[parseInt(i.toString(), 10)].value = stringifiedValue.charAt(i);
          this.hiddenInputEle.value = stringifiedValue;
        }
      }
      this.focusIn();
    };
    OtpInput2.prototype.updateCssClass = function(addCss, removeCss) {
      if (removeCss === void 0) {
        removeCss = "";
      }
      var _a, _b;
      var cssClasses;
      if (removeCss) {
        cssClasses = removeCss.trim().split(" ");
        (_a = this.element.classList).remove.apply(_a, cssClasses);
      }
      if (addCss) {
        cssClasses = addCss.trim().split(" ");
        (_b = this.element.classList).add.apply(_b, cssClasses);
      }
    };
    OtpInput2.prototype.updateVariantClass = function() {
      var variantClass = this.stylingMode.toLocaleLowerCase();
      variantClass = variantClass === "outlined" ? "outline" : variantClass;
      if (variantClass === "underlined" || variantClass === "filled" || variantClass === "outline") {
        removeClass([this.element], ["e-underlined", "e-filled", "e-outline"]);
        addClass([this.element], "e-" + variantClass);
      }
    };
    OtpInput2.prototype.updateAriaLabel = function(customAriaLabel) {
      this.inputs.forEach(function(input, index) {
        var defaultLabel = "Enter Otp Character " + (index + 1);
        var ariaLabel = customAriaLabel && customAriaLabel.length > 0 ? customAriaLabel[parseInt(index.toString(), 10)] || defaultLabel : defaultLabel;
        input.setAttribute("aria-label", ariaLabel);
      });
    };
    OtpInput2.prototype.updateDisabledState = function() {
      var _this = this;
      this.inputs.forEach(function(input) {
        if (_this.disabled) {
          input.setAttribute("disabled", "disabled");
        } else {
          input.removeAttribute("disabled");
        }
      });
    };
    OtpInput2.prototype.setElementAttributes = function(htmlAttributes, element2) {
      if (!isNullOrUndefined(htmlAttributes)) {
        for (var key in htmlAttributes) {
          if (key === "class") {
            var elementClass2 = htmlAttributes["class"].replace(/\s+/g, " ").trim();
            if (elementClass2) {
              addClass([element2], elementClass2.split(" "));
            }
          } else if (key === "name" && this.element.id === element2.id) {
            this.hiddenInputEle.setAttribute(key, htmlAttributes["" + key]);
          } else {
            element2.setAttribute(key, htmlAttributes["" + key]);
          }
        }
      }
    };
    OtpInput2.prototype.handleLengthChange = function(currentValue, previousValue) {
      var isLengthAdded = currentValue - previousValue > 0;
      if (isLengthAdded) {
        for (var i = previousValue; i < currentValue; i++) {
          this.createOtpInput(i);
        }
        this.renderSeparator(previousValue, currentValue);
        this.addPlaceHolder();
        this.updateAriaLabel(this.ariaLabels);
      } else {
        if (currentValue >= 0 && this.inputs.length > 0) {
          for (var i = currentValue; i < this.inputs.length; i++) {
            remove(this.inputs[parseInt(i.toString(), 10)]);
          }
          this.inputs.splice(currentValue);
          if (this.separatorElements.length > 0) {
            var index = currentValue === 0 ? 0 : currentValue - 1;
            for (var i = index; i < this.separatorElements.length; i++) {
              remove(this.separatorElements[parseInt(i.toString(), 10)]);
            }
            this.separatorElements.splice(index);
          }
        }
      }
    };
    OtpInput2.prototype.getModuleName = function() {
      return "otpinput";
    };
    OtpInput2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    OtpInput2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unWireEvents();
      for (var i = 0; i < this.inputs.length; i++) {
        remove(this.inputs[parseInt(i.toString(), 10)]);
      }
      for (var i = 0; i < this.separatorElements.length; i++) {
        remove(this.separatorElements[parseInt(i.toString(), 10)]);
      }
      remove(this.hiddenInputEle);
      removeClass([this.element], ["e-underlined", "e-filled", "e-outline", "e-rtl"]);
      if (this.cssClass) {
        removeClass([this.element], this.cssClass.trim().split(" "));
      }
      this.element.removeAttribute("role");
      this.inputs = [];
      this.separatorElements = [];
      this.hiddenInputEle = null;
    };
    OtpInput2.prototype.focusIn = function() {
      this.isFocusInCalled = true;
      var focusIndex = 0;
      this.inputs.forEach(function(input, index) {
        if (input.value.length > 0) {
          focusIndex = index;
        }
      });
      this.inputs[parseInt(focusIndex.toString(), 10)].focus();
      this.isFocusInCalled = false;
    };
    OtpInput2.prototype.focusOut = function() {
      this.isFocusOutCalled = true;
      this.inputs.forEach(function(input) {
        input.blur();
      });
      this.isFocusOutCalled = false;
    };
    OtpInput2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "value":
            {
              this.updateInputValue(oldProp.value);
              this.triggerValuechanged();
            }
            break;
          case "placeholder":
            this.addPlaceHolder();
            break;
          case "disabled":
            this.updateDisabledState();
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "separator":
            if (oldProp.separator === "") {
              this.renderSeparator(1, this.inputs.length);
            } else {
              this.updateSeparatorValue();
            }
            break;
          case "type":
            this.updateInputType(newProp.type);
            break;
          case "stylingMode":
            this.updateVariantClass();
            break;
          case "ariaLabels":
            this.updateAriaLabel(newProp.ariaLabels);
            break;
          case "length":
            this.handleLengthChange(newProp.length, oldProp.length);
            break;
          case "enableRtl":
            this.element.classList[this.enableRtl ? "add" : "remove"](RTL10);
            break;
        }
      }
    };
    __decorate26([
      Property(4)
    ], OtpInput2.prototype, "length", void 0);
    __decorate26([
      Property("")
    ], OtpInput2.prototype, "value", void 0);
    __decorate26([
      Property(OtpInputType.Number)
    ], OtpInput2.prototype, "type", void 0);
    __decorate26([
      Property("")
    ], OtpInput2.prototype, "separator", void 0);
    __decorate26([
      Property("")
    ], OtpInput2.prototype, "placeholder", void 0);
    __decorate26([
      Property(OtpInputStyle.Outlined)
    ], OtpInput2.prototype, "stylingMode", void 0);
    __decorate26([
      Property(false)
    ], OtpInput2.prototype, "disabled", void 0);
    __decorate26([
      Property("")
    ], OtpInput2.prototype, "cssClass", void 0);
    __decorate26([
      Property({})
    ], OtpInput2.prototype, "htmlAttributes", void 0);
    __decorate26([
      Property([])
    ], OtpInput2.prototype, "ariaLabels", void 0);
    __decorate26([
      Event()
    ], OtpInput2.prototype, "created", void 0);
    __decorate26([
      Event()
    ], OtpInput2.prototype, "valueChanged", void 0);
    __decorate26([
      Event()
    ], OtpInput2.prototype, "focus", void 0);
    __decorate26([
      Event()
    ], OtpInput2.prototype, "blur", void 0);
    __decorate26([
      Event()
    ], OtpInput2.prototype, "input", void 0);
    OtpInput2 = __decorate26([
      NotifyPropertyChanges
    ], OtpInput2);
    return OtpInput2;
  }(Component)
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/base/image-editor.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FinetuneSettings = (
  /** @class */
  function(_super) {
    __extends27(FinetuneSettings2, _super);
    function FinetuneSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "brightness", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "contrast", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "hue", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "saturation", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "exposure", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "opacity", void 0);
    __decorate27([
      Property(null)
    ], FinetuneSettings2.prototype, "blur", void 0);
    return FinetuneSettings2;
  }(ChildProperty)
);
var ZoomSettings = (
  /** @class */
  function(_super) {
    __extends27(ZoomSettings2, _super);
    function ZoomSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([
      Property(null)
    ], ZoomSettings2.prototype, "zoomTrigger", void 0);
    __decorate27([
      Property(1)
    ], ZoomSettings2.prototype, "minZoomFactor", void 0);
    __decorate27([
      Property(10)
    ], ZoomSettings2.prototype, "maxZoomFactor", void 0);
    __decorate27([
      Property(1)
    ], ZoomSettings2.prototype, "zoomFactor", void 0);
    __decorate27([
      Property(null)
    ], ZoomSettings2.prototype, "zoomPoint", void 0);
    return ZoomSettings2;
  }(ChildProperty)
);
var SelectionSettings = (
  /** @class */
  function(_super) {
    __extends27(SelectionSettings2, _super);
    function SelectionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([
      Property(true)
    ], SelectionSettings2.prototype, "showCircle", void 0);
    __decorate27([
      Property(null)
    ], SelectionSettings2.prototype, "strokeColor", void 0);
    __decorate27([
      Property(null)
    ], SelectionSettings2.prototype, "fillColor", void 0);
    return SelectionSettings2;
  }(ChildProperty)
);
var FontFamily = (
  /** @class */
  function(_super) {
    __extends27(FontFamily2, _super);
    function FontFamily2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate27([
      Property("Arial")
    ], FontFamily2.prototype, "default", void 0);
    __decorate27([
      Property(null)
    ], FontFamily2.prototype, "items", void 0);
    return FontFamily2;
  }(ChildProperty)
);
var ImageEditor = (
  /** @class */
  function(_super) {
    __extends27(ImageEditor2, _super);
    function ImageEditor2(options, element2) {
      var _this = _super.call(this, options) || this;
      _this.isImageLoaded = false;
      _this.activeObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        rotatedAngle: 0,
        opacity: 1,
        order: null
      };
      _this.currObjType = {
        shape: "",
        isDragging: false,
        isActiveObj: false,
        isText: false,
        isInitialText: false,
        isLine: false,
        isInitialLine: false,
        isCustomCrop: false,
        isZoomed: false,
        isUndoZoom: false,
        isUndoAction: false,
        isFiltered: false,
        isSave: false,
        isResize: false
      };
      _this.objColl = [];
      _this.pointColl = {};
      _this.freehandCounter = 0;
      _this.points = [];
      _this.togglePen = false;
      _this.togglePan = false;
      _this.img = { destLeft: 0, destTop: 0, destWidth: 0, destHeight: 0, srcLeft: 0, srcTop: 0, srcWidth: 0, srcHeight: 0 };
      _this.rotateFlipColl = [];
      _this.cropObj = {
        cropZoom: 0,
        defaultZoom: 0,
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        tempFlipPanPoint: { x: 0, y: 0 },
        activeObj: {},
        rotateFlipColl: [],
        degree: 0,
        currFlipState: "",
        straighten: 0,
        destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        filter: "",
        isBrightAdjust: false,
        zoomFactor: 0,
        previousZoomValue: 0,
        aspectWidth: null,
        aspectHeight: null,
        frame: "none",
        straightenZoom: 0,
        adjustmentLevel: {
          brightness: 0,
          contrast: 0,
          hue: 0,
          opacity: 100,
          saturation: 0,
          blur: 0,
          exposure: 0,
          transparency: 100,
          sharpen: false,
          bw: false
        },
        currentFilter: ""
      };
      _this.afterCropActions = [];
      _this.transform = { degree: 0, currFlipState: "", zoomFactor: 0, cropZoomFactor: null, defaultZoomFactor: 0, straighten: 0 };
      _this.panPoint = {
        currentPannedPoint: { x: 0, y: 0 },
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 }
      };
      _this.isUndoRedo = false;
      _this.isCropTab = false;
      _this.isCircleCrop = false;
      _this.fontSizeColl = [];
      _this.initialAdjustmentValue = "";
      _this.currentFilter = "";
      _this.canvasFilter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      _this.toolbarHeight = 0;
      _this.isPublicMethod = false;
      _this.isCropToolbar = false;
      _this.cursor = "default";
      _this.resizeSrc = { startX: _this.img.srcLeft, startY: _this.img.srcTop, width: _this.img.srcWidth, height: _this.img.srcHeight };
      _this.isResize = false;
      _this.isAspectRatio = false;
      _this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      _this.tempFrameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      _this.allowDownScale = true;
      _this.gradientColor = "";
      _this.size = 20;
      _this.inset = 0;
      _this.offset = 0;
      _this.borderRadius = 0;
      _this.lineCount = 0;
      _this.prevStraightenedDegree = 0;
      _this.tempStraighten = 0;
      _this.isStraightening = false;
      _this.isFinetuning = false;
      _this.isZoomBtnClick = false;
      _this.isFinetuneBtnClick = false;
      _this.isFilterCanvasClick = false;
      _this.isFrameBtnClick = false;
      _this.isChangesSaved = false;
      _this.isShapeDrawing = false;
      _this.noPushUndo = false;
      _this.isUndoRedoStack = false;
      _this.shapeColl = [];
      _this.isKBDNavigation = false;
      ImageEditor_1.Inject(Crop, Draw, Selection, Transform, Export, ToolbarModule);
      ImageEditor_1.Inject(UndoRedo);
      ImageEditor_1.Inject(Filter);
      ImageEditor_1.Inject(Shape);
      ImageEditor_1.Inject(FreehandDrawing);
      if (element2) {
        _this.appendTo(element2);
      }
      return _this;
    }
    ImageEditor_1 = ImageEditor2;
    ImageEditor2.prototype.requiredModules = function() {
      var modules = [];
      modules.push({ member: "crop", args: [this] });
      modules.push({ member: "draw", args: [this] });
      modules.push({ member: "selection", args: [this] });
      modules.push({ member: "transform", args: [this] });
      modules.push({ member: "export", args: [this] });
      modules.push({ member: "toolbar-module", args: [this] });
      modules.push({ member: "undo-redo", args: [this] });
      modules.push({ member: "filter", args: [this] });
      modules.push({ member: "shape", args: [this] });
      modules.push({ member: "freehand-draw", args: [this] });
      return modules;
    };
    ImageEditor2.prototype.preRender = function() {
      this.element.id = this.element.id || getUniqueID("ej2-image-editor");
      if (Browser.isDevice) {
        this.element.classList.add("e-device");
      }
      this.initializeThemeColl();
    };
    ImageEditor2.prototype.render = function() {
      if (this.isAngular) {
        var originalElement = this.element;
        var clonedElement = originalElement.cloneNode(true);
        originalElement.parentNode.replaceChild(clonedElement, originalElement);
        this.element = clonedElement;
        setValue("ej2_instances", [this], this.element);
      }
      this.initialize();
    };
    ImageEditor2.prototype.getModuleName = function() {
      return "image-editor";
    };
    ImageEditor2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    ImageEditor2.prototype.onPropertyChanged = function(newProperties, oldProperties) {
      var indexObj;
      for (var _i = 0, _a = Object.keys(newProperties); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            if (oldProperties.cssClass) {
              removeClass([this.element], oldProperties.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            if (newProperties.cssClass) {
              addClass([this.element], newProperties.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "disabled":
            if (newProperties.disabled) {
              this.element.classList.add("e-disabled");
              this.unwireEvent();
            } else {
              this.element.classList.remove("e-disabled");
              this.wireEvent();
            }
            break;
          case "height":
            this.element.style.height = newProperties.height;
            this.update();
            break;
          case "width":
            this.element.style.width = newProperties.width;
            this.update();
            break;
          case "theme":
            if (newProperties.theme) {
              if (this.theme && this.theme !== "") {
                this.theme = this.toPascalCase(this.theme);
              } else {
                this.theme = "Bootstrap5";
              }
              this.upperContext.strokeStyle = this.themeColl[this.theme]["primaryColor"];
              this.upperContext.fillStyle = this.themeColl[this.theme]["secondaryColor"];
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "finetuneSettings":
            if (newProperties.finetuneSettings) {
              this.finetuneSettings = newProperties.finetuneSettings;
              this.notify("filter", { prop: "update-finetunes" });
            }
            break;
          case "locale":
            if (newProperties.locale) {
              this.notify("toolbar", { prop: "setLocale", onPropertyChange: false, value: { locale: newProperties.locale } });
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "allowUndoRedo":
            if (newProperties.allowUndoRedo) {
              this.allowUndoRedo = true;
            } else {
              this.allowUndoRedo = false;
            }
            this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "main",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
            break;
          case "showQuickAccessToolbar":
            if (newProperties.showQuickAccessToolbar) {
              this.showQuickAccessToolbar = true;
              this.notify("toolbar", { prop: "create-qa-toolbar", onPropertyChange: false });
              indexObj = { freehandSelectedIndex: null };
              this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
              if (this.activeObj.shape) {
                this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
              } else if (indexObj["freehandSelectedIndex"]) {
                this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
              }
            } else {
              this.showQuickAccessToolbar = false;
              this.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            }
            break;
          case "zoomSettings":
            if (newProperties.zoomSettings) {
              this.zoomSettings.zoomTrigger = newProperties.zoomSettings.zoomTrigger;
            }
            if (isNullOrUndefined(this.zoomSettings.zoomTrigger)) {
              this.zoomSettings.zoomTrigger = ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands;
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if ((newProperties.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "selectionSettings":
            if (newProperties.selectionSettings) {
              this.selectionSettings = newProperties.selectionSettings;
              if (this.activeObj.shape) {
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: this.activeObj } });
              }
            }
            break;
          case "toolbar":
            if (newProperties.toolbar) {
              this.toolbar = newProperties.toolbar;
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "toolbarTemplate":
            if (newProperties.toolbarTemplate) {
              this.notify("toolbar", { prop: "destroy-bottom-toolbar", onPropertyChange: false });
              this.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
              this.element.appendChild(this.createElement("div", {
                id: this.element.id + "_toolbarArea",
                className: "e-toolbar-area"
              }));
              this.toolbarTemplateFn();
            }
            break;
          case "quickAccessToolbarTemplate":
            if (newProperties.quickAccessToolbarTemplate) {
              this.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
              this.quickAccessToolbarTemplateFn();
            }
            break;
        }
      }
    };
    ImageEditor2.prototype.destroy = function() {
      var classList2 = [];
      this.element.removeAttribute("tabindex");
      var saveDialog = this.element.querySelector("#" + this.element.id + "_saveDialog");
      if (saveDialog && saveDialog.style.display === "block") {
        getComponent(document.getElementById(this.element.id + "_saveDialog"), "dialog").destroy();
      }
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      removeClass([this.element], classList2);
      if (!this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      this.unwireEvent();
      this.notify("toolbar", { prop: "destroySubComponents", onPropertyChange: false });
      this.notify("destroyed", null);
      _super.prototype.destroy.call(this);
      this.element.innerHTML = "";
    };
    ImageEditor2.prototype.initialize = function() {
      if (this.toolbarTemplate) {
        this.element.appendChild(this.createElement("div", {
          id: this.element.id + "_toolbarArea",
          className: "e-toolbar-area"
        }));
        this.toolbarTemplateFn();
      } else {
        this.notify("toolbar", { prop: "create-toolbar", onPropertyChange: false });
        this.notify("toolbar", { prop: "create-contextual-toolbar", onPropertyChange: false });
      }
      this.createCanvas();
      if (this.element.offsetWidth > 359 && this.element.querySelector(".e-ie-min-drop-content") && this.element.querySelector(".e-ie-drop-content")) {
        this.element.querySelector(".e-ie-min-drop-content").style.display = "none";
        this.element.querySelector(".e-ie-drop-content").style.display = "block";
      }
      this.createDropUploader();
      if (this.showQuickAccessToolbar) {
        var canvasWrapper = document.querySelector("#" + this.element.id + "_canvasWrapper");
        canvasWrapper.appendChild(this.createElement("div", {
          id: this.element.id + "_quickAccessToolbarArea",
          className: "e-quick-access-toolbar-area"
        }));
        var quickAccessToolbar = document.getElementById(this.element.id + "_quickAccessToolbarArea");
        quickAccessToolbar.style.position = "absolute";
        quickAccessToolbar.style.display = "none";
        if (this.activeObj) {
          quickAccessToolbar.style.left = this.activeObj.activePoint.startX + "px";
          quickAccessToolbar.style.top = this.activeObj.activePoint.startY + "px";
        }
        quickAccessToolbar.style.width = "100%";
      }
      if (this.quickAccessToolbarTemplate) {
        this.quickAccessToolbarTemplateFn();
      } else {
        this.notify("toolbar", { prop: "create-qa-toolbar", onPropertyChange: false });
      }
      this.wireEvent();
      this.lowerContext = this.lowerCanvas.getContext("2d");
      this.upperContext = this.upperCanvas.getContext("2d");
      this.inMemoryContext = this.inMemoryCanvas.getContext("2d");
      this.lowerContext.filter = this.getDefaultFilter();
      this.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      this.canvasFilter = this.lowerContext.filter;
      this.notify("toolbar", { prop: "setInitialAdjustmentValue", onPropertyChange: false, value: { value: this.lowerContext.filter } });
      if (this.cssClass) {
        addClass([this.element], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.element) {
        createSpinner({
          target: this.element
        });
      }
      this.initializeZoomSettings();
      if (this.imgSrc) {
        this.open(this.imgSrc);
      }
    };
    ImageEditor2.prototype.createDropUploader = function() {
      var _this = this;
      var uploadObj = new Uploader({
        dropArea: this.element.getElementsByClassName("e-canvas-wrapper")[0],
        allowedExtensions: ".jpg, .jpeg, .png,.svg",
        multiple: false,
        selected: function(args) {
          if (args.event.type === "change" || args.event.type === "drop") {
            var type = args.filesData[0].type;
            var errType = "unsupported";
            if ((args.event.type === "change" || args.event.type === "drop" && args.event.dataTransfer.files.length === 1) && (type === "png" || type === "jpg" || type === "jpeg" || type === "svg")) {
              _this.notify("draw", { prop: "fileSelect", value: { inputElement: _this.element.querySelector("#" + _this.element.id + "_dropfileUpload"), args } });
            } else {
              if (args.event.type === "drop" && args.event.dataTransfer.files.length > 1) {
                errType = "multi-select-image";
              }
              _this.showDialogPopup(errType);
            }
          }
        }
      });
      uploadObj.appendTo("#" + this.element.id + "_dropfileUpload");
    };
    ImageEditor2.prototype.dlgCloseBtnClick = function() {
      getComponent(document.getElementById(this.element.id + "_dialog"), "dialog").destroy();
    };
    ImageEditor2.prototype.showDialogPopup = function(type) {
      var content = "";
      this.element.querySelector("#" + this.element.id + "_dialog").style.display = "block";
      var headerObj;
      var okObj = { key: "DlgOK" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: okObj } });
      if (type === "multi-select-image") {
        headerObj = { key: "ImageErrorDialogHeader" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
        var contentObj = { key: "ImageErrorDialogContent" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
        content = "<span>" + contentObj["value"] + "</span>";
      } else {
        headerObj = { key: "AlertDialogHeader" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
        var contentObj = { key: "AlertDialogContent" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
        var supportObj = { key: "SupportText" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: supportObj } });
        content = "<span>" + contentObj["value"] + " " + supportObj["value"] + "<b> JPG, PNG, and SVG</b></span>";
      }
      var dialog = new Dialog({
        header: headerObj["value"],
        closeOnEscape: true,
        content,
        target: document.getElementById("target"),
        width: "285px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        close: this.dlgCloseBtnClick.bind(this),
        buttons: [
          {
            click: this.dlgCloseBtnClick.bind(this),
            buttonModel: { content: okObj["value"] }
          }
        ]
      });
      dialog.appendTo("#" + this.element.id + "_dialog");
    };
    ImageEditor2.prototype.wireEvent = function() {
      EventHandler.add(document, "keydown", this.keyDownEventHandler, this);
      EventHandler.add(document, "keypress", this.keyUpEventHandler, this);
      EventHandler.add(this.upperCanvas, "mousedown", this.mouseDownEventHandler, this);
      EventHandler.add(this.upperCanvas, "mousemove", this.mouseMoveEventHandler, this);
      EventHandler.add(this.upperCanvas, "mouseup", this.mouseUpEventHandler, this);
      EventHandler.add(document, "mouseup", this.mouseUpEventHandler, this);
      EventHandler.add(this.lowerCanvas, "mousedown", this.canvasMouseDownHandler, this);
      EventHandler.add(this.lowerCanvas, "mousemove", this.canvasMouseMoveHandler, this);
      EventHandler.add(this.lowerCanvas, "mouseup", this.canvasMouseUpHandler, this);
      EventHandler.add(this.upperCanvas, "touchstart", this.touchStartHandler, this);
      EventHandler.add(this.lowerCanvas, "touchstart", this.touchStartHandler, this);
      EventHandler.add(this.lowerCanvas, "mousewheel DOMMouseScroll", this.handleScroll, this);
      EventHandler.add(this.upperCanvas, "mousewheel DOMMouseScroll", this.handleScroll, this);
      window.addEventListener("resize", this.windowResizeHandler.bind(this));
      if (!Browser.isIos && Browser.info.name !== "safari") {
        screen.orientation.addEventListener("change", this.screenOrientation.bind(this));
      }
      this.notify("shape", { prop: "wireEvent", onPropertyChange: false });
    };
    ImageEditor2.prototype.unwireEvent = function() {
      EventHandler.remove(document, "keydown", this.keyDownEventHandler);
      EventHandler.remove(document, "keypress", this.keyUpEventHandler);
      EventHandler.remove(this.upperCanvas, "mousedown", this.mouseDownEventHandler);
      EventHandler.remove(this.upperCanvas, "mousemove", this.mouseMoveEventHandler);
      EventHandler.remove(this.upperCanvas, "mouseup", this.mouseUpEventHandler);
      EventHandler.remove(document, "mouseup", this.mouseUpEventHandler);
      EventHandler.remove(this.lowerCanvas, "mousedown", this.canvasMouseDownHandler);
      EventHandler.remove(this.lowerCanvas, "mousemove", this.canvasMouseMoveHandler);
      EventHandler.remove(this.lowerCanvas, "mouseup", this.canvasMouseUpHandler);
      EventHandler.remove(this.upperCanvas, "touchstart", this.touchStartHandler);
      EventHandler.remove(this.lowerCanvas, "touchstart", this.touchStartHandler);
      EventHandler.remove(this.lowerCanvas, "mousewheel DOMMouseScroll", this.handleScroll);
      EventHandler.remove(this.upperCanvas, "mousewheel DOMMouseScroll", this.handleScroll);
      window.removeEventListener("resize", this.windowResizeHandler.bind(this));
      if (!Browser.isIos && Browser.info.name !== "safari") {
        screen.orientation.removeEventListener("change", this.screenOrientation.bind(this));
      }
      this.notify("shape", { prop: "unWireEvent", onPropertyChange: false });
      this.notify("selection", { prop: "unWireEvent", onPropertyChange: false });
    };
    ImageEditor2.prototype.createCanvas = function() {
      this.element.style.boxSizing = "border-box";
      var obj = { toolbarHeight: 0 };
      this.notify("toolbar", { prop: "getToolbarHeight", value: { obj } });
      var height = obj["toolbarHeight"];
      if (this.toolbar && this.toolbar.length > 0 && this.toolbar.indexOf("Open") === -1) {
        height = 0;
      }
      this.element.style.width = this.width;
      this.element.style.height = this.height;
      var canvasWrapper = this.element.appendChild(this.createElement("div", {
        id: this.element.id + "_canvasWrapper",
        className: "e-canvas-wrapper",
        attrs: { style: "height:" + (this.element.offsetHeight - height - 2) + "px; width:" + (this.element.offsetWidth - 2) + "px; position: relative; overflow: hidden; margin: 0 auto;" }
      }));
      var dragObj = { key: "DragText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: dragObj } });
      var dropObj = { key: "DropText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: dropObj } });
      var browseObj = { key: "BrowseText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: browseObj } });
      var supportObj = { key: "SupportText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: supportObj } });
      var dropAreaElement = this.createElement("div", { id: this.element.id + "_dropArea", className: "e-ie-drop-area", attrs: { style: "position: relative;" } });
      var dropIconElement = this.createElement("span", { className: "e-ie-drop-icon e-icons e-image", attrs: { style: "position: absolute;" } });
      var dropContentElement = this.createElement("span", { className: "e-ie-drop-content", attrs: { style: "position: absolute; display: none;" } });
      dropContentElement.textContent = dragObj["value"] + " ";
      var minDropContentElem = this.createElement("span", { className: "e-ie-min-drop-content", attrs: { style: "position: absolute;" } });
      minDropContentElem.textContent = dropObj["value"] + " ";
      var dropAnchorElement = this.createElement("a", { id: this.element.id + "_dropBrowse", className: "e-ie-drop-browse" });
      dropAnchorElement.textContent = browseObj["value"];
      var minDropAnchorElem = this.createElement("a", { id: this.element.id + "_dropBrowse", className: "e-ie-drop-browse" });
      minDropAnchorElem.textContent = browseObj["value"];
      dropContentElement.appendChild(dropAnchorElement);
      minDropContentElem.appendChild(minDropAnchorElem);
      dropAnchorElement.href = "";
      minDropAnchorElem.href = "";
      var dropInfoElement = this.createElement("span", { className: "e-ie-drop-info", attrs: { position: "absolute" } });
      dropInfoElement.textContent = supportObj["value"] + " SVG, PNG, and JPG";
      var dropUploader = dropAreaElement.appendChild(this.createElement("input", {
        id: this.element.id + "_dropfileUpload",
        className: "e-fileUpload e-image-upload"
      }));
      dropUploader.setAttribute("type", "file");
      dropUploader.setAttribute("accept", "image/*");
      dropAreaElement.appendChild(dropIconElement);
      dropAreaElement.appendChild(dropContentElement);
      dropAreaElement.appendChild(minDropContentElem);
      dropAreaElement.appendChild(dropInfoElement);
      canvasWrapper.appendChild(dropAreaElement);
      this.lowerCanvas = canvasWrapper.appendChild(this.createElement("canvas", {
        id: this.element.id + "_lowerCanvas",
        attrs: { name: "canvasImage" }
      }));
      this.upperCanvas = canvasWrapper.appendChild(this.createElement("canvas", {
        id: this.element.id + "_upperCanvas",
        attrs: { name: "canvasImage" }
      }));
      this.inMemoryCanvas = this.createElement("canvas", {
        id: this.element.id + "_inMemoryCanvas",
        attrs: { name: "canvasImage" }
      });
      this.baseImgCanvas = this.createElement("canvas", {
        id: this.element.id + "_baseImgCanvas",
        attrs: { name: "canvasImage" }
      });
      this.textArea = canvasWrapper.appendChild(this.createElement("textarea", {
        id: this.element.id + "_textArea",
        className: "e-textarea",
        attrs: { name: "textArea" }
      }));
      var dialog = this.element.appendChild(this.createElement("div", {
        id: this.element.id + "_dialog",
        className: "e-dialog"
      }));
      dialog.style.display = "none";
      var uploader = this.element.appendChild(this.createElement("input", {
        id: this.element.id + "_fileUpload",
        className: "e-fileUpload"
      }));
      uploader.setAttribute("type", "file");
      uploader.setAttribute("accept", "image/*");
      uploader.style.display = "none";
      this.textArea.setAttribute("spellcheck", "false");
      this.textArea.style.lineHeight = "normal";
      this.lowerCanvas.style.width = this.upperCanvas.style.width = this.inMemoryCanvas.style.width = "100%";
      this.lowerCanvas.style.height = this.upperCanvas.style.height = this.inMemoryCanvas.style.height = "100%";
      this.upperCanvas.style.position = this.lowerCanvas.style.position = this.textArea.style.position = "absolute";
      this.textArea.style.backgroundColor = "transparent";
      this.textArea.style.display = "none";
      this.textArea.style.resize = "none";
      this.lowerContext = this.lowerCanvas.getContext("2d");
      this.baseImg = this.createElement("img", {
        id: this.element.id + "_orgImg",
        attrs: { name: "Image", crossorigin: "anonymous" }
      });
      this.upperCanvas.style.cursor = this.cursor = "default";
      this.upperCanvas.style.display = "block";
      this.upperContext = this.upperCanvas.getContext("2d");
      dropAnchorElement.addEventListener("click", function(e) {
        e.preventDefault();
        dropUploader.click();
        return false;
      });
      minDropAnchorElem.addEventListener("click", function(e) {
        e.preventDefault();
        dropUploader.click();
        return false;
      });
    };
    ImageEditor2.prototype.touchStartHandler = function(e) {
      this.notify("selection", { prop: "touchStartHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseDownEventHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "mouseDownEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseMoveEventHandler = function(e) {
      this.notify("selection", { prop: "mouseMoveEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseUpEventHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "mouseUpEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.keyDownEventHandler = function(e) {
      this.notify("selection", { prop: "keyDownEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.keyUpEventHandler = function(e) {
      if ((this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") && e.target.id === this.element.id + "_textArea") {
        this.notify("selection", { prop: "textKeyDown", value: { e } });
      }
    };
    ImageEditor2.prototype.canvasMouseDownHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "canvasMouseDownHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.canvasMouseMoveHandler = function(e) {
      this.notify("selection", { prop: "canvasMouseMoveHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.canvasMouseUpHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "canvasMouseUpHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.handleScroll = function(e) {
      this.notify("selection", { prop: "handleScroll", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.adjustToScreen = function() {
      this.update();
    };
    ImageEditor2.prototype.screenOrientation = function() {
      if (Browser.isDevice) {
        setTimeout(this.adjustToScreen.bind(this), 100);
      }
    };
    ImageEditor2.prototype.windowResizeHandler = function() {
      if (!Browser.isDevice && this.element.classList.contains("e-image-editor")) {
        this.adjustToScreen();
      }
    };
    ImageEditor2.prototype.notifyResetForAllModules = function() {
      var modules = this.requiredModules();
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i].member;
        this.notify(module === "toolbar-module" ? "toolbar" : module, { prop: "reset", onPropertyChange: false });
      }
    };
    ImageEditor2.prototype.allowShape = function(x, y) {
      this.isPublicMethod = true;
      this.applyShapes();
      var obj = { inRange: false };
      this.notify("shape", {
        prop: "isPointsInRange",
        onPropertyChange: false,
        value: { x, y, obj }
      });
      return obj["inRange"];
    };
    ImageEditor2.prototype.clearSelection = function(resetCrop) {
      this.notify("selection", { prop: "clearSelection", onPropertyChange: false, value: { resetCrop } });
    };
    ImageEditor2.prototype.crop = function() {
      var obj = { isCrop: false };
      this.notify("crop", { prop: "crop", onPropertyChange: false, value: { obj } });
      return obj["isCrop"];
    };
    ImageEditor2.prototype.flip = function(direction) {
      this.notify("transform", { prop: "flip", value: { direction } });
      this.notify("draw", { prop: "redrawDownScale" });
      this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
    };
    ImageEditor2.prototype.getImageData = function() {
      var obj = { canvas: null };
      this.applyShapes();
      this.notify("export", { prop: "exportToCanvas", value: { object: obj } });
      return obj["canvas"].getContext("2d").getImageData(0, 0, obj["canvas"].width, obj["canvas"].height);
    };
    ImageEditor2.prototype.open = function(data) {
      if (isNullOrUndefined(data)) {
        return;
      }
      var dropArea = document.getElementById(this.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "none";
      }
      this.notify("draw", { prop: "open", value: { data } });
    };
    ImageEditor2.prototype.reset = function() {
      var obj = { isErrorImage: false };
      this.notify("draw", { prop: "getErrorImage", value: { obj } });
      if (!this.disabled && !obj["isErrorImage"]) {
        this.clearContext(this.inMemoryContext);
        this.clearContext(this.lowerContext);
        this.clearContext(this.upperContext);
        this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: false,
          isCropping: false,
          isZooming: null,
          cType: null
        } });
        if (Browser.isDevice && document.getElementById(this.element.id + "_bottomToolbar")) {
          getComponent(document.getElementById(this.element.id + "_bottomToolbar"), "toolbar").destroy();
          this.notify("toolbar", { prop: "create-bottom-toolbar", onPropertyChange: false });
        }
        var isImageLoaded = this.isImageLoaded;
        this.currObjType.isUndoAction = this.isUndoRedo = this.togglePan = this.togglePen = this.isImageLoaded = this.isFinetuning = false;
        this.isCircleCrop = this.isCropTab = false;
        this.objColl = [];
        this.transform.degree = 0;
        this.upperCanvas.style.display = "block";
        this.transform.currFlipState = "";
        this.allowDownScale = true;
        this.upperCanvas.style.cursor = this.cursor = this.lowerCanvas.style.cursor = "default";
        this.lowerContext.lineWidth = this.upperContext.lineWidth = void 0;
        this.frameDestPoints = null;
        this.textArea.value = this.textArea.textContent = "";
        this.textArea.style.display = "none";
        this.lowerContext.filter = this.canvasFilter = this.getDefaultFilter();
        this.img.destLeft = this.img.destTop = this.img.srcLeft = this.img.srcTop = 0;
        this.img.destWidth = this.img.destHeight = this.img.srcWidth = this.img.srcHeight = null;
        this.currSelectionPoint = null;
        this.panPoint.currentPannedPoint = { x: 0, y: 0 };
        this.rotateFlipColl = [];
        this.points = [];
        this.pointColl = {};
        this.freehandCounter = 0;
        this.notify("draw", { prop: "resetPanPoints" });
        this.lowerCanvas.style.left = this.upperCanvas.style.left = "";
        this.fontSizeColl = [];
        this.lowerCanvas.style.top = this.upperCanvas.style.top = "";
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = "";
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = "";
        this.transform.defaultZoomFactor = this.transform.zoomFactor = 0;
        this.transform.cropZoomFactor = null;
        this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
        this.tempFrameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
        this.currObjType = {
          shape: "",
          isDragging: false,
          isActiveObj: false,
          isText: false,
          isInitialText: false,
          isLine: false,
          isInitialLine: false,
          isCustomCrop: false,
          isZoomed: false,
          isUndoZoom: false,
          isUndoAction: false,
          isFiltered: false,
          isSave: false,
          isResize: false
        };
        this.cropObj = {
          cropZoom: 0,
          defaultZoom: 0,
          totalPannedPoint: { x: 0, y: 0 },
          totalPannedClientPoint: { x: 0, y: 0 },
          totalPannedInternalPoint: { x: 0, y: 0 },
          tempFlipPanPoint: { x: 0, y: 0 },
          activeObj: {},
          rotateFlipColl: [],
          degree: 0,
          currFlipState: "",
          straighten: 0,
          zoomFactor: 0,
          previousZoomValue: 0,
          destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          frame: "none",
          srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          filter: "",
          isBrightAdjust: false,
          aspectWidth: null,
          aspectHeight: null,
          straightenZoom: 0,
          adjustmentLevel: {
            brightness: 0,
            contrast: 0,
            hue: 0,
            opacity: 100,
            saturation: 0,
            blur: 0,
            exposure: 0,
            transparency: 100,
            sharpen: false,
            bw: false
          },
          currentFilter: ""
        };
        this.afterCropActions = [];
        this.currentFilter = "";
        this.tempFrameZoomLevel = null;
        this.cxtTbarHeight = null;
        this.straightenPoint = null;
        this.transform.straighten = 0;
        this.cancelCropSelection = null;
        this.aspectWidth = this.aspectHeight = null;
        this.isResize = false;
        this.drawingShape = null;
        this.isShapeDrawing = this.noPushUndo = this.isUndoRedoStack = this.isKBDNavigation = false;
        this.shapeColl = [];
        var obj_1 = { initialZoomValue: false };
        this.notify("draw", { prop: "getInitialZoomValue", onPropertyChange: false, value: { obj: obj_1 } });
        if (obj_1["initialZoomValue"]) {
          this.setProperties({ zoomSettings: { zoomFactor: obj_1["initialZoomValue"] } }, true);
        }
        var qtArea = document.getElementById(this.element.id + "_quickAccessToolbarArea");
        if (qtArea) {
          qtArea.style.display = "none";
        }
        this.notifyResetForAllModules();
        this.notify("filter", { prop: "update-finetunes" });
        if (this.toolbarTemplate) {
          this.toolbarHeight = this.element.querySelector("#" + this.element.id + "_toolbarArea").clientHeight;
        } else if (this.element.querySelector("#" + this.element.id + "_toolbar")) {
          this.toolbarHeight = this.element.querySelector("#" + this.element.id + "_toolbar").clientHeight;
        }
        this.notify("toolbar", { prop: "setToolbarHeight", value: { height: this.toolbarHeight } });
        this.isImageLoaded = isImageLoaded;
        this.straightenBaseImageCanvas();
        this.isImageLoaded = false;
        this.notify("draw", { prop: "update-canvas", onPropertyChange: false });
        this.isImageLoaded = isImageLoaded;
        this.prevStraightenedDegree = 0;
        var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
        if (ctWrapper) {
          ctWrapper.classList.add("e-hide");
        }
        this.notify("toolbar", { prop: "refresh-dropdown-btn", value: { isDisabled: false } });
        this.notify("toolbar", { prop: "enable-disable-btns" });
        var straightenObj = { bool: this.isStraightening };
        if (Browser.isDevice && straightenObj["bool"]) {
          this.notify("crop", { prop: "resizeWrapper" });
        }
      }
    };
    ImageEditor2.prototype.rotate = function(degree) {
      var obj = { isRotate: false };
      if (degree === 90 || degree === -90) {
        this.updateImageTransformColl(degree === 90 ? "rotateright" : "rotateleft");
      }
      this.notify("transform", { prop: "rotate", value: { degree, obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      return obj["isRotate"];
    };
    ImageEditor2.prototype.export = function(type, fileName, imageQuality) {
      this.applyShapes();
      this.notify("export", { prop: "export", onPropertyChange: false, value: { type, fileName, imgQuality: imageQuality } });
    };
    ImageEditor2.prototype.select = function(type, startX, startY, width, height) {
      this.applyShapes();
      this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-" + type } });
      this.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type, startX, startY, width, height }
      });
      if (startX && startY || width && height) {
        this.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type, startX, startY, width, height }
        });
      } else {
        this.cropObj = {
          cropZoom: 0,
          defaultZoom: 0,
          totalPannedPoint: { x: 0, y: 0 },
          totalPannedClientPoint: { x: 0, y: 0 },
          totalPannedInternalPoint: { x: 0, y: 0 },
          tempFlipPanPoint: { x: 0, y: 0 },
          activeObj: {},
          rotateFlipColl: [],
          degree: 0,
          currFlipState: "",
          straighten: 0,
          zoomFactor: 0,
          previousZoomValue: 0,
          destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          frame: "none",
          srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          filter: "",
          isBrightAdjust: false,
          aspectWidth: null,
          aspectHeight: null,
          straightenZoom: 0,
          adjustmentLevel: {
            brightness: 0,
            contrast: 0,
            hue: 0,
            opacity: 100,
            saturation: 0,
            blur: 0,
            exposure: 0,
            transparency: 100,
            sharpen: false,
            bw: false
          },
          currentFilter: ""
        };
      }
    };
    ImageEditor2.prototype.freeHandDraw = function(value) {
      this.notify("freehand-draw", { prop: "freeHandDraw", onPropertyChange: false, value: { value } });
    };
    ImageEditor2.prototype.freehandDraw = function(value) {
      if (!this.disabled && this.isImageLoaded) {
        this.applyShapes();
        this.freeHandDraw(value);
      }
    };
    ImageEditor2.prototype.pan = function(value, x, y) {
      this.applyShapes();
      this.notify("transform", { prop: "pan", onPropertyChange: false, value: { value, x, y } });
    };
    ImageEditor2.prototype.zoom = function(zoomFactor, zoomPoint) {
      this.isZoomBtnClick = true;
      this.notify("transform", {
        prop: "zoom",
        onPropertyChange: false,
        value: { zoomFactor, zoomPoint }
      });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.drawEllipse = function(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      var isEllipse = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isEllipse = true;
        this.notify("shape", { prop: "drawEllipse", onPropertyChange: false, value: {
          x,
          y,
          radiusX,
          radiusY,
          strokeWidth,
          strokeColor,
          fillColor,
          degree,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isEllipse;
    };
    ImageEditor2.prototype.drawLine = function(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
      var isLine = false;
      var isPointsInRange = this.allowShape(startX, startY);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(startX) && isNullOrUndefined(startY))) {
        isLine = true;
        this.notify("shape", { prop: "drawLine", onPropertyChange: false, value: {
          startX,
          startY,
          endX,
          endY,
          strokeWidth,
          strokeColor,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isLine;
    };
    ImageEditor2.prototype.drawArrow = function(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
      var isArrow = false;
      var isPointsInRange = this.allowShape(startX, startY);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(startX) && isNullOrUndefined(startY))) {
        isArrow = true;
        this.notify("shape", { prop: "drawArrow", onPropertyChange: false, value: {
          startX,
          startY,
          endX,
          endY,
          strokeWidth,
          strokeColor,
          arrowStart,
          arrowEnd,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isArrow;
    };
    ImageEditor2.prototype.drawPath = function(pointColl, strokeWidth, strokeColor, isSelected) {
      this.isPublicMethod = true;
      var obj = { inRange: false };
      var isPath = false;
      if (pointColl && pointColl.length > 0) {
        for (var i = 0; i < pointColl.length; i++) {
          if (obj["inRange"]) {
            break;
          }
          this.notify("shape", {
            prop: "isPointsInRange",
            onPropertyChange: false,
            value: { x: pointColl[i].x, y: pointColl[i].y, obj }
          });
        }
      }
      if (!this.disabled && this.isImageLoaded && (obj["inRange"] || isNullOrUndefined(pointColl))) {
        isPath = true;
        this.applyShapes();
        this.notify("shape", { prop: "drawPath", onPropertyChange: false, value: {
          pointColl,
          strokeWidth,
          strokeColor,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isPath;
    };
    ImageEditor2.prototype.drawRectangle = function(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      var isRectangle = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isRectangle = true;
        this.notify("shape", { prop: "drawRectangle", onPropertyChange: false, value: {
          x,
          y,
          width,
          height,
          strokeWidth,
          strokeColor,
          fillColor,
          degree,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isRectangle;
    };
    ImageEditor2.prototype.drawText = function(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree) {
      var isText = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isText = true;
        this.notify("shape", { prop: "drawText", onPropertyChange: false, value: {
          x,
          y,
          text,
          fontFamily,
          fontSize,
          bold,
          italic,
          color,
          isSelected,
          degree
        } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isText;
    };
    ImageEditor2.prototype.drawImage = function(data, x, y, width, height, isAspectRatio, degree, opacity, isSelected) {
      var isImage = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        var length_1 = this.objColl.length;
        this.notify("shape", { prop: "drawImage", onPropertyChange: false, value: {
          x,
          y,
          width,
          height,
          src: data,
          degree,
          isAspectRatio,
          opacity,
          isSelected
        } });
        this.notify("draw", { prop: "redrawDownScale" });
        if (this.objColl.length > length_1) {
          isImage = true;
        }
      }
      return isImage;
    };
    ImageEditor2.prototype.selectShape = function(id) {
      this.applyShapes();
      var obj = { isSelected: false };
      this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id, obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      return obj["isSelected"];
    };
    ImageEditor2.prototype.deleteShape = function(id) {
      this.applyShapes();
      this.notify("shape", { prop: "deleteShape", onPropertyChange: false, value: { id } });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.getShapeSetting = function(id) {
      this.applyShapes();
      var obj = { shapeDetails: null };
      this.notify("shape", {
        prop: "getShapeSetting",
        onPropertyChange: false,
        value: { id, obj }
      });
      this.notify("draw", { prop: "redrawDownScale" });
      var shapeDetails = obj["shapeDetails"] ? obj["shapeDetails"] : {};
      return shapeDetails;
    };
    ImageEditor2.prototype.getShapeSettings = function() {
      this.applyShapes();
      var obj = { shapeDetailsColl: [] };
      this.notify("shape", { prop: "getShapeSettings", onPropertyChange: false, value: { obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      return obj["shapeDetailsColl"];
    };
    ImageEditor2.prototype.update = function() {
      this.notify("transform", { prop: "update" });
    };
    ImageEditor2.prototype.finetuneImage = function(finetuneOption, value) {
      if (!this.disabled && this.isImageLoaded) {
        this.applyShapes();
        this.notify("filter", { prop: "finetuneImage", value: { value, option: finetuneOption } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
    };
    ImageEditor2.prototype.applyImageFilter = function(filterOption) {
      if (!this.disabled && this.isImageLoaded) {
        this.applyShapes();
        this.notify("filter", { prop: "applyImageFilter", value: { option: filterOption.toString() } });
        this.notify("draw", { prop: "redrawDownScale" });
        this.canvasFilter = this.lowerContext.filter;
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    ImageEditor2.prototype.undo = function() {
      this.applyShapes();
      this.notify("undo-redo", { prop: "undo", onPropertyChange: false });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.redo = function() {
      this.applyShapes();
      this.notify("undo-redo", { prop: "redo", onPropertyChange: false });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.getImageDimension = function() {
      return { x: this.img.destLeft, y: this.img.destTop, width: this.img.destWidth, height: this.img.destHeight };
    };
    ImageEditor2.prototype.resize = function(width, height, isAspectRatio) {
      var isResized = false;
      if (width.toString().length <= 4 && height.toString().length <= 4) {
        this.applyShapes();
        var destPoints = {
          startX: this.img.destLeft,
          startY: this.img.destTop,
          width: this.img.destWidth,
          height: this.img.destHeight
        };
        if (isAspectRatio) {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        }
        var aspectRatioWidth = this.element.querySelector("#" + this.element.id + "_resizeWidth");
        var aspectRatioHeight = this.element.querySelector("#" + this.element.id + "_resizeHeight");
        if (aspectRatioWidth && aspectRatioHeight) {
          getComponent(aspectRatioWidth, "numerictextbox").value = Math.floor(width);
          aspectRatioWidth.value = Math.floor(width).toString() + " px";
          getComponent(aspectRatioHeight, "numerictextbox").value = Math.floor(height);
          aspectRatioHeight.value = Math.floor(height).toString() + " px";
        }
        this.notify("transform", { prop: "resize", value: { width, height, isAspectRatio } });
        if (destPoints.startX !== this.img.destLeft || destPoints.startY !== this.img.destTop || destPoints.width !== this.img.destWidth || destPoints.height !== this.img.destHeight) {
          isResized = true;
          this.okBtn();
        } else {
          this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        }
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isResized;
    };
    ImageEditor2.prototype.drawFrame = function(frameType, color, gradientColor, size, inset, offset, borderRadius, frameLineStyle, lineCount) {
      this.applyShapes();
      var isFrame = false;
      var obj = { frameChangeEventArgs: null };
      color = color ? color : "#fff";
      gradientColor = gradientColor ? gradientColor : "";
      size = size ? size : 20;
      inset = inset ? inset : 0;
      offset = offset ? offset : 0;
      borderRadius = borderRadius ? borderRadius : 0;
      frameLineStyle = frameLineStyle ? frameLineStyle : FrameLineStyle.Solid;
      lineCount = lineCount ? lineCount : 0;
      var prevFrameSettings = {
        type: this.toPascalCase(this.frameObj.type),
        color: this.frameObj.color,
        gradientColor: this.frameObj.gradientColor,
        size: this.frameObj.size,
        inset: this.frameObj.inset,
        offset: this.frameObj.offset,
        borderRadius: this.frameObj.radius,
        frameLineStyle: this.toPascalCase(this.frameObj.border),
        lineCount: this.frameObj.amount
      };
      extend(this.tempFrameObj, this.frameObj);
      this.tempFrameZoomLevel = this.transform.zoomFactor;
      this.frameDestPoints = extend({}, this.img, {}, true);
      this.notify("toolbar", { prop: "frameToolbarClick" });
      this.frameObj.type = frameType.toLowerCase();
      this.frameObj.color = color;
      this.frameObj.gradientColor = gradientColor;
      this.frameObj.size = size;
      this.frameObj.inset = inset;
      this.frameObj.offset = offset;
      this.frameObj.radius = borderRadius;
      this.frameObj.border = frameLineStyle.toLowerCase();
      this.frameObj.amount = lineCount;
      this.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
      if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
          isFrame = true;
          this.okBtn();
        } else {
          this.tempFrameZoomLevel = null;
        }
      } else {
        this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        extend(this.frameObj, this.tempFrameObj);
        this.tempFrameZoomLevel = null;
      }
      this.notify("draw", { prop: "redrawDownScale" });
      return isFrame;
    };
    ImageEditor2.prototype.straightenImage = function(degree) {
      var isStraightened = false;
      if (degree >= -45 && degree <= 45) {
        this.applyShapes();
        isStraightened = true;
        this.notify("transform", { prop: "straightenImage", value: { degree } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isStraightened;
    };
    ImageEditor2.prototype.updateShape = function(setting, isSelected) {
      var obj = { isSelected: false };
      var isTextArea = false;
      var freehandObj = { bool: false };
      if (isNullOrUndefined(setting.id)) {
        if (setting.strokeColor) {
          this.activeObj.strokeSettings.strokeColor = setting.strokeColor;
        }
        if (setting.fillColor) {
          this.activeObj.strokeSettings.fillColor = setting.fillColor;
        }
        if (setting.strokeWidth) {
          this.activeObj.strokeSettings.strokeWidth = setting.strokeWidth;
        }
        if (setting.index) {
          this.activeObj.order = setting.index;
        }
        if (setting.type === "FreehandDraw" && setting.strokeWidth) {
          this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: setting.strokeWidth } });
        }
      } else {
        if (setting.type.toLowerCase() === "text" && (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block")) {
          this.okBtn(null, true);
          isTextArea = true;
        }
        this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id: setting.id, obj } });
        this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: freehandObj } });
        if (obj["isSelected"]) {
          var tempFontSize = this.activeObj.textSettings.fontSize;
          this.notify("shape", {
            prop: "updateShapeChangeEventArgs",
            onPropertyChange: false,
            value: { shapeSettings: setting }
          });
          if (this.activeObj.shape === "text" && tempFontSize) {
            var diff = this.activeObj.textSettings.fontSize - tempFontSize;
            if (diff !== 0) {
              this.activeObj.activePoint.height += diff;
              this.activeObj.activePoint.startY -= diff / 2;
              this.activeObj.activePoint.endY += diff / 2;
              this.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                actPoint: this.activeObj.activePoint,
                obj: this.activeObj,
                isMouseMove: null,
                x: null,
                y: null
              } });
            }
          }
          var activeObj = extend({}, this.activeObj, {}, true);
          this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: null } });
          this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
          if (activeObj.shape) {
            this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
          }
          if (this.activeObj.shape === "text") {
            this.notify("toolbar", { prop: "editText", onPropertyChange: false });
          }
          if (freehandObj["bool"]) {
            this.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
          }
          this.okBtn(isSelected, true);
          if (freehandObj["bool"]) {
            this.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
          }
          this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
          this.notify("draw", { prop: "redrawDownScale" });
          if (isTextArea) {
            this.enableTextEditing();
          }
          if (isSelected) {
            this.selectShape(setting.id);
          }
        }
      }
      return obj["isSelected"];
    };
    ImageEditor2.prototype.cloneShape = function(shapeId) {
      var obj = { isSelected: false };
      if (shapeId.split("_")[0] === "shape") {
        this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id: shapeId, obj } });
        if (obj["isSelected"]) {
          this.notify("toolbar", { prop: "duplicateShape", onPropertyChange: false, value: { isPreventUndoRedo: false } });
          this.okBtn(null, true);
          this.notify("draw", { prop: "redrawDownScale" });
        }
      }
      return obj["isSelected"];
    };
    ImageEditor2.prototype.getImageFilter = function(filterOption) {
      var canvas = this.createElement("canvas");
      var ctx = canvas.getContext("2d");
      this.notify("filter", { prop: "updateAdj", value: { type: filterOption.toLowerCase(), value: null, isPreview: true, ctx } });
      return ctx.filter;
    };
    ImageEditor2.prototype.enableTextEditing = function() {
      var activeObj = extend({}, this.activeObj, {}, true);
      if (!activeObj.order) {
        this.noPushUndo = true;
        this.okBtn();
        this.noPushUndo = false;
        this.selectShape(activeObj.currIndex);
        activeObj.order = this.activeObj.order;
      }
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: false } });
      this.activeObj = activeObj;
      this.notify("toolbar", { prop: "editText", onPropertyChange: false });
    };
    ImageEditor2.prototype.canUndo = function() {
      var canUndo = false;
      var object = this.getUndoRedoColl();
      var undoRedoIndex = object["index"];
      if (undoRedoIndex > 0) {
        canUndo = true;
      }
      return canUndo;
    };
    ImageEditor2.prototype.canRedo = function() {
      var canRedo = false;
      var object = this.getUndoRedoColl();
      var undoRedoColl = object["undoRedoColl"];
      var undoRedoIndex = object["index"];
      if (undoRedoColl && undoRedoColl.length > 0 && undoRedoIndex < undoRedoColl.length - 1) {
        canRedo = true;
      }
      if (undoRedoIndex === undoRedoColl.length) {
        canRedo = false;
      } else if (undoRedoIndex === 0 && undoRedoColl.length > 0) {
        canRedo = true;
      } else if (undoRedoIndex > 0) {
        canRedo = true;
      }
      return canRedo;
    };
    ImageEditor2.prototype.apply = function() {
      this.closeOverlayTbar();
      this.okBtn(null, true);
    };
    ImageEditor2.prototype.discard = function() {
      this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: this.closeOverlayTbar(), isFinalCancel: true } });
    };
    ImageEditor2.prototype.enableShapeDrawing = function(shapeType, isEnabled) {
      if (isEnabled) {
        this.drawingShape = shapeType.toLowerCase();
        this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (shapeType && isEnabled) {
        this.currObjType.shape = shapeType.toLowerCase();
        this.activeObj.shape = this.currObjType.shape;
        this.currObjType.isDragging = this.currObjType.isCustomCrop = false;
        this.activeObj.shapeDegree = this.transform.degree;
        this.activeObj.shapeFlip = this.transform.currFlipState;
        this.activeObj.textFlip = this.transform.currFlipState;
        this.activeObj.flipObjColl = [];
        var orderObj = { order: null };
        this.notify("shape", { prop: "getNewOrder", onPropertyChange: false, value: { obj: orderObj } });
        this.activeObj.order = orderObj["order"];
        this.notify("selection", { prop: "annotate", value: { shape: this.currObjType.shape } });
        if (this.currObjType.shape === "text") {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "text",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "shapes",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        }
        this.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      } else if (!isEnabled) {
        this.okBtn(null, true);
      }
    };
    ImageEditor2.prototype.bringToFront = function(shapeId) {
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "bringToFront");
        this.apply();
      }
    };
    ImageEditor2.prototype.bringForward = function(shapeId) {
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "bringForward");
        this.apply();
      }
    };
    ImageEditor2.prototype.sendToBack = function(shapeId) {
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "sendToBack");
        this.apply();
      }
    };
    ImageEditor2.prototype.sendBackward = function(shapeId) {
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "sendBackward");
        this.apply();
      }
    };
    ImageEditor2.prototype.clearImage = function() {
      this.reset();
      this.isImageLoaded = false;
      this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
      var btoolbar = document.getElementById(this.element.id + "_bottomToolbar");
      if (Browser.isDevice && btoolbar) {
        document.getElementById(this.element.id + "_bottomToolbar").style.display = "none";
      }
      this.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
      this.notify("toolbar", { prop: "create-toolbar", onPropertyChange: false });
      this.notify("toolbar", { prop: "create-contextual-toolbar", onPropertyChange: false });
      var dropArea = document.getElementById(this.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "block";
      }
    };
    ImageEditor2.prototype.applyShapes = function() {
      if (this.isUndoRedoStack) {
        return;
      }
      var shapes = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image"];
      var dummyObj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: dummyObj } });
      if (dummyObj["bool"] || this.togglePen || this.activeObj.shape && shapes.indexOf(this.activeObj.shape) !== -1 || this.drawingShape) {
        this.okBtn(null, true);
      }
    };
    ImageEditor2.prototype.closeOverlayTbar = function() {
      var isContextualToolbar = false;
      var frameObject = { bool: null };
      this.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (!frameObject["bool"] && this.element.querySelector(".e-contextual-toolbar-wrapper")) {
        if (!this.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
          isContextualToolbar = true;
        }
        var straightenObj = { bool: this.isStraightening };
        if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
          this.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        }
      }
      return isContextualToolbar;
    };
    ImageEditor2.prototype.toolbarTemplateFn = function() {
      var template;
      var templateID = this.element.id + "_toolbar";
      var toolbarArea = this.element.querySelector("#" + this.element.id + "_toolbarArea");
      if (this.toolbarTemplate) {
        this.toolbarFn = this.templateParser(this.toolbarTemplate);
        if (this.isReact) {
          template = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID)[0];
        } else if (this.isAngular) {
          var templateColl = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID);
          template = templateColl[0].nodeType === 3 ? templateColl[1] : templateColl[0];
        } else {
          template = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID)[0];
        }
        toolbarArea.appendChild(template);
        this.toolbarHeight = toolbarArea.clientHeight;
        this.notify("toolbar", { prop: "setToolbarHeight", value: { height: this.toolbarHeight } });
        this["renderReactTemplates"]();
      }
    };
    ImageEditor2.prototype.quickAccessToolbarTemplateFn = function() {
      var template;
      var templateID = this.element.id + "_quickAccessToolbar";
      var toolbarArea = this.element.querySelector("#" + this.element.id + "_quickAccessToolbarArea");
      if (this.quickAccessToolbarTemplate) {
        this.qatFn = this.templateParser(this.quickAccessToolbarTemplate);
        if (this.isReact) {
          template = this.qatFn({ type: "toolbar" }, this, "Template", templateID)[0];
        } else if (this.isAngular) {
          var templateColl = this.qatFn({ type: "toolbar" }, this, "Template", templateID);
          template = templateColl[0].nodeType === 3 ? templateColl[1] : templateColl[0];
        } else {
          template = this.qatFn({ type: "toolbar" }, this, "Template", templateID)[0];
        }
        toolbarArea.appendChild(template);
        this["renderReactTemplates"]();
      }
    };
    ImageEditor2.prototype.templateParser = function(template) {
      if (template) {
        try {
          if (typeof template !== "function" && document.querySelectorAll(template).length) {
            return compile(document.querySelector(template).innerHTML.trim());
          } else {
            return compile(template);
          }
        } catch (error) {
          return compile(template);
        }
      }
      return void 0;
    };
    ImageEditor2.prototype.getTextFromId = function(id) {
      var idToValue = {
        "1": "none",
        "2": "bar",
        "3": "arrow",
        "4": "arrowSolid",
        "5": "circle",
        "6": "circleSolid",
        "7": "square",
        "8": "squareSolid"
      };
      return idToValue["" + id];
    };
    ImageEditor2.prototype.getFinetuneOption = function(type) {
      var typeToOption = {
        "brightness": ImageFinetuneOption.Brightness,
        "contrast": ImageFinetuneOption.Contrast,
        "hue": ImageFinetuneOption.Hue,
        "saturation": ImageFinetuneOption.Saturation,
        "opacity": ImageFinetuneOption.Opacity,
        "blur": ImageFinetuneOption.Blur,
        "exposure": ImageFinetuneOption.Exposure
      };
      return typeToOption["" + type];
    };
    ImageEditor2.prototype.setPenStroke = function(args) {
      this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: parseInt(args, 10) } });
    };
    ImageEditor2.prototype.updateFreehandDrawColorChange = function() {
      var obj = { tempFreeHandDrawEditingStyles: null };
      this.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
      this.notify("freehand-draw", { prop: "color-change", value: { color: obj["tempFreeHandDrawEditingStyles"].strokeColor } });
    };
    ImageEditor2.prototype.getUndoRedoColl = function() {
      var obj = { undoRedoColl: null, index: null };
      var undoRedoObj = { undoRedoStep: null };
      var object = { appliedUndoRedoColl: [] };
      this.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
      this.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
      obj["undoRedoColl"] = object["appliedUndoRedoColl"];
      obj["index"] = undoRedoObj["undoRedoStep"];
      return obj;
    };
    ImageEditor2.prototype.updateImageTransformColl = function(type) {
      var value;
      if (type === "rotateleft") {
        value = -90;
      } else if (type === "rotateright") {
        value = 90;
      } else if (type === "horizontalflip") {
        value = "horizontal";
      } else if (type === "verticalflip") {
        value = "vertical";
      }
      for (var i = 0; i < this.objColl.length; i++) {
        var shape = this.objColl[i].shape;
        if (shape === "image" || shape === "text") {
          if (isNullOrUndefined(this.objColl[i].rotateFlipColl)) {
            this.objColl[i].rotateFlipColl = [];
          }
          this.objColl[i].rotateFlipColl.push(value);
          var obj = { collection: this.objColl[i].rotateFlipColl };
          this.notify("shape", {
            prop: "alignRotateFlipColl",
            onPropertyChange: false,
            value: { collection: this.objColl[i].rotateFlipColl, isRotateFlipCollection: false, obj }
          });
          this.objColl[i].rotateFlipColl = obj["collection"];
        }
      }
    };
    ImageEditor2.prototype.setInitialZoomState = function() {
      this.objColl.push(this.activeObj);
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      var isUndoRedo = this.isUndoRedo;
      this.isCropTab = false;
      this.isUndoRedo = true;
      if (this.transform.cropZoomFactor && this.transform.cropZoomFactor > 0) {
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: -this.transform.cropZoomFactor, zoomPoint: null, isResize: true }
        });
      } else {
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: Math.abs(this.transform.cropZoomFactor), zoomPoint: null, isResize: true }
        });
      }
      this.isUndoRedo = isUndoRedo;
      this.panPoint.totalPannedPoint = { x: 0, y: 0 };
      this.transform.cropZoomFactor = 0;
      this.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
      this.activeObj = extend({}, this.objColl[this.objColl.length - 1], {}, true);
      this.objColl.pop();
      this.isCropTab = true;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: this.activeObj } });
    };
    ImageEditor2.prototype.updateCropTransformItems = function() {
      this.prevCurrSelectionPoint = extend({}, this.currSelectionPoint, {}, true);
      this.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
    };
    ImageEditor2.prototype.toPascalCase = function(str, obj) {
      var strArr = [];
      if (!isNullOrUndefined(str)) {
        strArr = str.toLowerCase().split("-");
      }
      for (var i = 0; i < strArr.length; i++) {
        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].slice(1);
      }
      if (obj) {
        obj["maxText"] = strArr.join("");
      }
      return strArr.join("");
    };
    ImageEditor2.prototype.getFontSizes = function() {
      var items = [];
      this.fontSizeColl = [];
      var fontSize;
      if (this.transform.degree === 0 || this.transform.degree % 180 === 0) {
        fontSize = this.img.destWidth / 25;
      } else {
        fontSize = this.img.destHeight / 25;
      }
      for (var i = 1; i <= 10; i++) {
        this.fontSizeColl.push({ text: (i * Math.round(fontSize / 2)).toString() });
        items.push({ text: i.toString() });
      }
      return items;
    };
    ImageEditor2.prototype.okBtn = function(isMouseDown, isFinalApply) {
      if (isFinalApply) {
        this.noPushUndo = false;
        var tempActiveObj = {
          activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
          flipObjColl: [],
          triangle: [],
          triangleRatio: [],
          order: null
        };
        this.notify("selection", { prop: "setTempActObj", onPropertyChange: false, value: { obj: tempActiveObj } });
      }
      var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
      if (ctWrapper) {
        ctWrapper.classList.remove("e-frame-wrapper");
      }
      var isCropSelection = false;
      var splitWords;
      this.isResizeOkBtn = true;
      var aspectIcon = this.element.querySelector("#" + this.element.id + "_aspectratio");
      var nonAspectIcon = this.element.querySelector("#" + this.element.id + "_nonaspectratio");
      var blrAspRatElem = this.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
      var blrNAspRatElem = this.element.querySelector(".e-ie-toolbar-nonaspect-ratio-btn");
      if (this.activeObj.shape !== void 0) {
        splitWords = this.activeObj.shape.split("-");
      }
      if (splitWords === void 0 && this.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== void 0 && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      this.allowDownScale = true;
      if ((this.activeObj.shape && this.activeObj.shape !== "image" || this.togglePen) && !isCropSelection) {
        var objt = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt["shapeSettingsObj"];
        if (this.togglePen) {
          shapeSettings.type = ShapeType.FreehandDraw;
        }
        var shapeChangedArgs = { action: "apply", currentShapeSettings: extend({}, shapeSettings, {}, true) };
        this.trigger("shapeChange", shapeChangedArgs);
      }
      if (aspectIcon || nonAspectIcon) {
        var obj_2 = { width: null, height: null };
        this.notify("selection", { prop: "getNumTextValue", onPropertyChange: false, value: { obj: obj_2 } });
        var point = { x: obj_2["width"], y: obj_2["height"] };
        var obj1 = { prevCropObj: this.prevCropObj };
        var obj2 = { prevObj: this.prevObj };
        if (point && point.x && point.y && obj1["prevCropObj"] && obj2["prevObj"]) {
          if (nonAspectIcon || blrNAspRatElem && !blrNAspRatElem.classList.contains("e-hidden")) {
            this.notify("transform", { prop: "resize", value: { width: point.x, height: point.y, isAspectRatio: false } });
          } else if (aspectIcon || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
            this.notify("transform", { prop: "resize", value: { width: point.x, height: null, isAspectRatio: true } });
          }
          this.isResize = false;
          this.aspectWidth = point.x;
          this.aspectHeight = point.y;
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "main",
            isApplyBtn: false,
            isCropping: false,
            isZooming: null,
            cType: null
          } });
          this.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -this.transform.zoomFactor, zoomPoint: null, isResize: true }
          });
          this.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: obj2["prevObj"]["defaultZoom"], zoomPoint: null, isResize: true }
          });
          if (obj2["prevObj"].zoomFactor) {
            this.setProperties({ zoomSettings: { zoomFactor: obj2["prevObj"].zoomFactor } }, true);
          }
          this.notify("transform", {
            prop: "setPreviousZoomValue",
            onPropertyChange: false,
            value: { previousZoomValue: this.zoomSettings.zoomFactor }
          });
          this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
            operation: "resize",
            previousObj: obj2["prevObj"],
            previousObjColl: obj2["prevObj"]["objColl"],
            previousPointColl: obj2["prevObj"]["pointColl"],
            previousSelPointColl: obj2["prevObj"]["selPointColl"],
            previousCropObj: obj1["prevCropObj"],
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          } });
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          var obj_3 = this.cancelCropSelection;
          if (obj_3 && (isNullOrUndefined(nonAspectIcon) || !nonAspectIcon)) {
            obj_3.previousObj.aspectWidth = obj_3.currentObj.aspectWidth = this.aspectWidth;
            obj_3.previousObj.aspectHeight = obj_3.currentObj.aspectHeight = this.aspectHeight;
            obj_3.previousCropObj = extend({}, this.cropObj, {}, true);
            obj_3.currentCropObj = extend({}, this.cropObj, {}, true);
            this.notify("draw", { prop: "updateCropSelObj" });
          }
          this.cancelCropSelection = null;
        } else if (point && (point.x === 0 || point.y === 0)) {
          this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "main",
            isApplyBtn: false,
            isCropping: false,
            isZooming: null,
            cType: null
          } });
        }
        this.isAspectRatio = false;
      }
      var selElem = this.element.querySelector(".e-contextual-toolbar-wrapper .e-toolbar-item.e-selected");
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      var frameObject = { bool: null };
      this.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      var sliderWrap = document.querySelector("#" + this.element.id + "_sliderWrapper");
      if (selElem) {
        this.currentFilter = selElem.children[0].children[0].id.replace("Canvas", "");
      }
      if (isCropSelection) {
        if (this.transform.straighten !== 0 && (this.panPoint.totalPannedPoint.x !== 0 || this.panPoint.totalPannedPoint.y !== 0 || this.panPoint.totalPannedClientPoint.x !== 0 || this.panPoint.totalPannedClientPoint.y !== 0)) {
          var temp = this.prevStraightenedDegree;
          this.prevStraightenedDegree = this.transform.straighten;
          this.setStraighten(this.transform.straighten - 3);
          this.setStraighten(this.transform.straighten + 3);
          this.prevStraightenedDegree = temp;
        }
        this.isCroppedEvent = this.crop();
      } else if (this.togglePen) {
        this.freeHandDraw(false);
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      } else if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
        if (isNullOrUndefined(isMouseDown)) {
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      } else if (sliderWrap || this.currObjType.isFiltered) {
        this.initialAdjustmentValue = this.canvasFilter = this.lowerContext.filter;
        this.currObjType.isFiltered = false;
        var obj_4 = { value: null };
        this.notify("draw", { prop: "getTempAdjustmentValue", value: { obj: obj_4 } });
        if (obj_4["value"] !== this.lowerContext.filter && (!sliderWrap || !sliderWrap.classList.contains("e-ie-finetune-slider-wrap"))) {
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
        if (this.activeObj.activePoint.width !== 0 && this.activeObj.activePoint.height !== 0 || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0) {
          this.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        }
      } else if (obj["bool"]) {
        this.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
        this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
        this.notify("toolbar", { prop: "destroy-qa-toolbar" });
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        this.notify("freehand-draw", { prop: "resetFreehandDrawSelectedId", onPropertyChange: false });
      } else if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0 || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0) {
        if (this.activeObj.shape === "image") {
          this.notify("draw", { prop: "setImageApply", onPropertyChange: false, value: { bool: true } });
        }
        this.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      } else {
        if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
          var object = { currObj: {} };
          this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
            operation: "frame",
            previousObj: object["currObj"],
            previousObjColl: object["currObj"]["objColl"],
            previousPointColl: object["currObj"]["pointColl"],
            previousSelPointColl: object["currObj"]["selPointColl"],
            previousCropObj: extend({}, this.cropObj, {}, true),
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          } });
          this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          this.tempFrameObj = extend({}, this.frameObj, {}, true);
        }
        this.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: true } });
      }
      if (!obj["isCropToolbar"]) {
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: false,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
      }
      this.notify("draw", { prop: "setNewPath", value: { bool: false } });
      this.transform.zoomFactor = this.transform.defaultZoomFactor;
      this.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
      this.isResizeOkBtn = false;
      this.notify("draw", { prop: "redrawDownScale" });
      this.isChangesSaved = false;
      if (isFinalApply) {
        this.drawingShape = null;
        this.notify("draw", { prop: "resetTempObjColl" });
        this.notify("draw", { prop: "resetTempPointColl" });
      }
    };
    ImageEditor2.prototype.getObjFromId = function(id) {
      var obj;
      if (this.activeObj.currIndex && this.activeObj.currIndex === id) {
        obj = extend({}, this.activeObj, {}, true);
      } else {
        for (var i = 0; i < this.shapeColl.length; i++) {
          var shapeId = this.shapeColl[i].id ? this.shapeColl[i].id : this.shapeColl[i].currIndex;
          if (shapeId === id) {
            obj = extend({}, this.shapeColl[i], {}, true);
            break;
          }
        }
      }
      return obj;
    };
    ImageEditor2.prototype.setTempFilterProperties = function() {
      this.upperCanvas.style.display = "block";
      this.cropSelectedState();
      var obj = { adjustmentLevel: null };
      this.notify("filter", {
        prop: "getAdjustmentLevel",
        onPropertyChange: false,
        value: { obj }
      });
      this.lowerContext.filter = this.initialAdjustmentValue;
      this.notify("draw", { prop: "setTempAdjustmentValue", value: { tempAdjustmentValue: this.lowerContext.filter } });
      this.notify("filter", {
        prop: "setTempAdjustmentLevel",
        onPropertyChange: false,
        value: { tempAdjustmentLevel: extend({}, obj["adjustmentLevel"], {}, true) }
      });
      this.notify("draw", { prop: "setTempFilter", value: { tempFilter: this.currentFilter } });
      var undoRedoObj = { undoRedoStep: null };
      this.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
      this.notify("draw", { prop: "setTempUndoRedoStep", value: { tempUndoRedoStep: undoRedoObj["undoRedoStep"] } });
    };
    ImageEditor2.prototype.cropSelectedState = function() {
      if (this.activeObj.shape && this.activeObj.shape.split("-")[0] === "crop") {
        this.okBtn();
      }
    };
    ImageEditor2.prototype.getCurrentCanvasData = function() {
      var tempFrame = extend({}, this.frameObj, {}, true);
      this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      var tempFilter = this.lowerContext.filter;
      this.lowerContext.filter = this.canvasFilter = "none";
      var objColl = extend([], this.objColl, null, true);
      var pointColl = extend([], this.pointColl, null, true);
      this.objColl = [];
      this.pointColl = [];
      this.freehandCounter = 0;
      this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
      if (ctWrapper) {
        ctWrapper.classList.add("e-hide");
      }
      var data = this.getImageData();
      if (ctWrapper) {
        ctWrapper.classList.remove("e-hide");
      }
      if (!Browser.isDevice) {
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: true,
          isCropping: false
        } });
      }
      this.element.querySelector("#" + this.element.id + "_contextualToolbarArea").classList.remove("e-hide");
      this.objColl = objColl;
      this.pointColl = pointColl;
      this.freehandCounter = pointColl.length;
      this.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
      });
      this.lowerContext.filter = this.canvasFilter = tempFilter;
      this.frameObj = tempFrame;
      return data;
    };
    ImageEditor2.prototype.setCurrAdjustmentValue = function(type, value) {
      var finetuneValueChanging = { finetune: this.getFinetuneOption(type), value, cancel: false };
      this.trigger("finetuneValueChanging", finetuneValueChanging);
      if (finetuneValueChanging.cancel) {
        return;
      }
      this.notify("filter", { prop: "setCurrAdjValue", value: { type: type.toLowerCase(), value } });
    };
    ImageEditor2.prototype.getSquarePointForPath = function(obj) {
      var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      if (obj.pointColl.length > 0) {
        point = { startX: obj.pointColl[0].x, startY: obj.pointColl[0].y, endX: obj.pointColl[0].x, endY: obj.pointColl[0].y };
        for (var i = 1; i < obj.pointColl.length; i++) {
          if (obj.pointColl[i].x < point.startX) {
            point.startX = obj.pointColl[i].x;
          }
          if (obj.pointColl[i].y < point.startY) {
            point.startY = obj.pointColl[i].y;
          }
          if (obj.pointColl[i].x > point.endX) {
            point.endX = obj.pointColl[i].x;
          }
          if (obj.pointColl[i].y > point.endY) {
            point.endY = obj.pointColl[i].y;
          }
        }
        point.width = point.endX - point.startX;
        point.height = point.endY - point.startY;
      }
      return point;
    };
    ImageEditor2.prototype.getSelectionType = function(type) {
      type = type === "crop-custom" ? "CropCustom" : type;
      var typeToSelectionType = {
        "CropCustom": "Custom",
        "CropSquare": "Square",
        "CropCircle": "Circle",
        "Crop3:2": "3:2",
        "Crop4:3": "4:3",
        "Crop5:4": "5:4",
        "Crop7:5": "7:5",
        "Crop16:9": "16:9",
        "Crop2:3": "2:3",
        "Crop3:4": "3:4",
        "Crop4:5": "4:5",
        "Crop5:7": "5:7",
        "Crop9:16": "9:16"
      };
      return typeToSelectionType["" + type] ? typeToSelectionType["" + type] : type.split("Crop")[1];
    };
    ImageEditor2.prototype.clearContext = function(ctx) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.clearRect(0, 0, ctx.canvas.height, ctx.canvas.width);
    };
    ImageEditor2.prototype.updateArrow = function(type, id) {
      this.notify("shape", { prop: "pushActItemIntoObj" });
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      this.objColl.pop();
      if (type === "startArrow") {
        this.activeObj.start = this.getTextFromId(id);
      } else if (type === "endArrow") {
        this.activeObj.end = this.getTextFromId(id);
      }
      this.notify("shape", { prop: "setStrokeSettings", value: {
        strokeSettings: null,
        strokeColor: null,
        fillColor: null,
        strokeWidth: this.activeObj.strokeSettings.strokeWidth
      } });
      this.objColl.push(this.activeObj);
      if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      if (Browser.isDevice) {
        if (document.getElementById(this.element.id + "_bottomToolbar")) {
          var toolbar_1 = getComponent(this.element.id + "_bottomToolbar", "toolbar");
          toolbar_1.refreshOverflow();
        }
      } else {
        if (document.getElementById(this.element.id + "_toolbar")) {
          var toolbar_2 = getComponent(this.element.id + "_toolbar", "toolbar");
          toolbar_2.refreshOverflow();
        }
      }
      var shapeChangedArgs = { action: type, currentShapeSettings: extend({}, shapeSettings, {}, true) };
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updateFontFamily = function(id) {
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      this.notify("shape", { prop: "pushActItemIntoObj" });
      var objColl = extend([], this.objColl, [], true);
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: true }
        });
        var temp = this.activeObj.textSettings.fontFamily;
        this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.objColl.pop();
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        var width = this.activeObj.activePoint.width + this.activeObj.textSettings.fontSize * 0.25;
        this.textArea.style.width = width + "px";
        this.textArea.style.fontFamily = this.toPascalCase(id);
        this.activeObj.textSettings.fontFamily = temp;
        this.notify("shape", {
          prop: "updateFontStyles",
          onPropertyChange: false,
          value: { isTextBox: null }
        });
      } else {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: null }
        });
        var fontFamily = this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
        this.notify("shape", {
          prop: "setTextSettings",
          onPropertyChange: false,
          value: { textSettings: null, fontFamily, fontSize: null }
        });
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: objColl,
              previousPointColl: extend([], this.pointColl, [], true),
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
      var shapeChangedArgs = { action: "font-family", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontFamily = this.textArea.style.fontFamily;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updateFontSize = function(text) {
      var itemText = text;
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      this.notify("shape", { prop: "pushActItemIntoObj" });
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: true }
        });
        var temp = this.activeObj.textSettings.fontSize;
        this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10);
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.objColl.pop();
        var textStyle = "";
        if (this.textArea.style.fontWeight === "bold") {
          textStyle = "bold ";
        }
        if (this.textArea.style.fontStyle === "italic") {
          textStyle = "italic ";
        }
        if (this.textArea.style.fontWeight === "bold" && this.textArea.style.fontStyle === "italic") {
          textStyle = "italic bold ";
        }
        this.upperContext.font = textStyle + this.activeObj.textSettings.fontSize + "px " + this.textArea.style.fontFamily;
        var rows = this.textArea.value.split("\n");
        var obj = { maxText: "" };
        this.notify("shape", {
          prop: "getMaxText",
          onPropertyChange: false,
          value: { isTextBox: true, text: null, obj }
        });
        var text_1 = obj["maxText"];
        var width = this.upperContext.measureText(text_1).width + this.activeObj.textSettings.fontSize * 0.5;
        this.textArea.style.width = width + "px";
        this.textArea.style.height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25) + "px";
        this.activeObj.textSettings.fontSize = temp;
        this.upperContext.font = this.activeObj.textSettings.fontSize + "px " + this.activeObj.textSettings.fontFamily;
        this.textArea.style.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10) + "px";
        if (this.textArea.style.fontFamily === "georgia") {
          this.textArea.style.width = parseFloat(this.textArea.style.width) + parseFloat(this.textArea.style.fontSize) + "px";
        }
      } else {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: null }
        });
        var fontSize = this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10);
        this.notify("shape", {
          prop: "setTextSettings",
          onPropertyChange: false,
          value: { textSettings: null, fontFamily: null, fontSize }
        });
        this.upperContext.font = this.activeObj.textSettings.fontSize + "px " + this.activeObj.textSettings.fontFamily;
        var rows = this.activeObj.keyHistory.split("\n");
        var obj = { maxText: "" };
        this.notify("shape", {
          prop: "getMaxText",
          onPropertyChange: false,
          value: { isTextBox: null, text: null, obj }
        });
        var text_2 = obj["maxText"];
        var width = this.upperContext.measureText(text_2).width + this.activeObj.textSettings.fontSize * 0.5;
        var height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("selection", {
            prop: "setTextSelection",
            onPropertyChange: false,
            value: { width, height }
          });
          this.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: this.activeObj.activePoint,
            obj: this.activeObj,
            isMouseMove: null,
            x: null,
            y: null
          } });
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
      var shapeChangedArgs = { action: "font-size", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontSize = this.activeObj.textSettings.fontSize;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updateFontColor = function(value) {
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      this.notify("shape", { prop: "pushActItemIntoObj" });
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      if (this.textArea.style.display === "none") {
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: this.activeObj.strokeSettings.strokeColor,
          fillColor: null,
          strokeWidth: null
        } });
        if (!this.togglePen) {
          this.objColl.push(this.activeObj);
          if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "shapeTransform",
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
            this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
          }
        }
      } else if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.textArea.style.color = value;
        var temp = this.activeObj.strokeSettings.strokeColor;
        this.activeObj.strokeSettings.strokeColor = value;
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.objColl.pop();
        this.activeObj.strokeSettings.strokeColor = temp;
      } else if (!this.togglePen) {
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        }
      }
      var shapeChangedArgs = { action: "font-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fillColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updatePenStrokeWidth = function(id) {
      var temp = extend([], this.pointColl, [], true);
      this.updateFreehandDrawColorChange();
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.pointColl = temp;
      this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: true } });
      this.setPenStroke(id);
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var obj_5 = { penStrokeWidth: null };
        this.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: obj_5 } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: obj_5["penStrokeWidth"] }
        });
        var indexObj = { freehandSelectedIndex: null };
        this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        this.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth = obj_5["penStrokeWidth"];
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        this.notify("draw", { prop: "redrawDownScale" });
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: obj_5["penStrokeWidth"] }
        });
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "freehanddrawCustomized",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      shapeSettings.type = ShapeType.FreehandDraw;
      var shapeChangedArgs = { action: "stroke-width", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updatePenStrokeColor = function(value) {
      var temp = extend([], this.pointColl, [], true);
      this.updateFreehandDrawColorChange();
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.pointColl = temp;
      this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: true } });
      this.activeObj.strokeSettings.strokeColor = value;
      var indexObj = { freehandSelectedIndex: null };
      this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (indexObj["freehandSelectedIndex"] !== null && indexObj["freehandSelectedIndex"] !== void 0) {
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        this.notify("draw", { prop: "redrawDownScale" });
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: null }
        });
      }
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var indexObj_1 = { freehandSelectedIndex: null };
        this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj_1 } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.pointColl[indexObj_1["freehandSelectedIndex"]].strokeColor = value;
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: value }
        });
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "freehanddrawCustomized",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      } else if (!this.togglePen) {
        this.notify("selection", { prop: "redrawShape", value: { obj: this.activeObj } });
      }
      shapeSettings.type = ShapeType.FreehandDraw;
      var shapeChangedArgs = { action: "stroke-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updateStrokeWidth = function(id) {
      if (this.activeObj.shape && (this.activeObj.shape !== "path" || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0)) {
        var obj = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        this.notify("shape", { prop: "pushActItemIntoObj" });
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
        this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10);
        if (this.activeObj.shape === "rectangle" || this.activeObj.shape === "ellipse") {
          this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10) - 1;
        }
        this.activeObj.strokeSettings.strokeWidth *= 2;
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: null,
          strokeWidth: this.activeObj.strokeSettings.strokeWidth
        } });
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        var shapeChangedArgs = { action: "stroke-width", currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
        this.trigger("shapeChange", shapeChangedArgs);
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10);
        this.activeObj.strokeSettings.strokeWidth *= 2;
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: null,
          strokeWidth: this.activeObj.strokeSettings.strokeWidth
        } });
      }
    };
    ImageEditor2.prototype.updateStrokeColor = function(value) {
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      if (this.activeObj.shape && (this.activeObj.shape !== "path" || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0)) {
        this.notify("shape", { prop: "pushActItemIntoObj" });
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
        if (!this.togglePen) {
          this.objColl.push(this.activeObj);
          if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "shapeTransform",
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
          }
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        }
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
      }
      var shapeChangedArgs = { action: "stroke-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.updateFillColor = function(value) {
      var obj = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      this.notify("shape", { prop: "pushActItemIntoObj" });
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      this.activeObj.strokeSettings.fillColor = value;
      this.notify("shape", {
        prop: "setStrokeSettings",
        value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: this.activeObj.strokeSettings.fillColor,
          strokeWidth: null
        }
      });
      this.objColl.push(this.activeObj);
      if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      var shapeChangedArgs = { action: "fill-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      this.trigger("shapeChange", shapeChangedArgs);
    };
    ImageEditor2.prototype.horizontalFlip = function(ctx, isPreventURC) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(isPreventURC)) {
        if (isNullOrUndefined(this.activeObj.imageRatio)) {
          this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        this.notify("shape", { prop: "pushActItemIntoObj" });
        prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
      }
      this.notify("toolbar", { prop: "refreshSlider" });
      ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
      var activePoint = this.duplicateImage();
      this.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: this.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: null }
      });
      this.activeObj.activePoint = activePoint;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      if (isNullOrUndefined(isPreventURC)) {
        this.objColl.push(this.activeObj);
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "imageHFlip",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
    };
    ImageEditor2.prototype.verticalFlip = function(ctx, isPreventURC) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(isPreventURC)) {
        if (isNullOrUndefined(this.activeObj.imageRatio)) {
          this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        this.notify("shape", { prop: "pushActItemIntoObj" });
        prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
      }
      this.notify("toolbar", { prop: "refreshSlider" });
      ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
      var activePoint = this.duplicateImage();
      this.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: this.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: true }
      });
      this.activeObj.activePoint = activePoint;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      if (isNullOrUndefined(isPreventURC)) {
        this.objColl.push(this.activeObj);
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "imageVFlip",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
    };
    ImageEditor2.prototype.rotateImage = function(rotate) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(this.activeObj.imageRatio)) {
        this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      }
      this.notify("shape", { prop: "pushActItemIntoObj" });
      prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      this.notify("toolbar", { prop: "refreshSlider" });
      if (rotate === "rotleft") {
        this.activeObj.rotatedAngle -= 90 * (Math.PI / 180);
      } else {
        this.activeObj.rotatedAngle += 90 * (Math.PI / 180);
      }
      this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.activeObj } });
      this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.objColl.push(this.activeObj);
      this.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "imageRotate",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      this.notify("toolbar", { prop: "destroy-qa-toolbar" });
      this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
    };
    ImageEditor2.prototype.pascalToSplitWords = function(str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
      var splitStr = str.match(/[A-Z][a-z]+/g);
      if (isNullOrUndefined(splitStr)) {
        return str;
      } else {
        return splitStr.map(function(word) {
          return word.charAt(0).toUpperCase() + word.slice(1);
        }).join(" ");
      }
    };
    ImageEditor2.prototype.getCurrAdjustmentValue = function(type) {
      var value = 100;
      var indexObj = { freehandSelectedIndex: null };
      this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (type === "transparency" && this.togglePen) {
        var obj = { penOpacity: 1 };
        this.notify("freehand-draw", { prop: "getPenOpacity", onPropertyChange: false, value: { obj } });
        value = obj["penOpacity"] * 100;
      } else if (type === "transparency" && indexObj["freehandSelectedIndex"] !== null && indexObj["freehandSelectedIndex"] !== void 0) {
        value = this.pointColl[indexObj["freehandSelectedIndex"]].opacity * 100;
      } else {
        var obj = { adjustmentLevel: null };
        this.notify("filter", {
          prop: "getAdjustmentLevel",
          onPropertyChange: false,
          value: { obj }
        });
        var typeToAdjustmentLevel = {
          "brightness": obj["adjustmentLevel"].brightness,
          "contrast": obj["adjustmentLevel"].contrast,
          "hue": obj["adjustmentLevel"].hue,
          "saturation": obj["adjustmentLevel"].saturation,
          "opacity": obj["adjustmentLevel"].opacity,
          "blur": obj["adjustmentLevel"].blur,
          "exposure": obj["adjustmentLevel"].exposure,
          "transparency": obj["adjustmentLevel"].transparency,
          "straighten": this.transform.straighten
        };
        value = typeToAdjustmentLevel["" + type];
      }
      return value;
    };
    ImageEditor2.prototype.transformSelect = function(type) {
      if (this.transform.straighten === 0 && (type === "rotateleft" || type === "rotateright") && this.activeObj.shape && ([
        "crop-2:3",
        "crop-3:2",
        "crop-3:4",
        "crop-4:3",
        "crop-4:5",
        "crop-5:4",
        "crop-5:7",
        "crop-7:5",
        "crop-9:16",
        "crop-16:9"
      ].indexOf(this.activeObj.shape) !== -1 || this.activeObj.shape.indexOf("crop-") !== -1 && this.activeObj.shape !== "crop-custom" && this.activeObj.shape !== "crop-square" && this.activeObj.shape !== "crop-circle")) {
        this.activeObj.shape = "crop-" + this.activeObj.shape.split("-")[1].split(":")[1] + ":" + this.activeObj.shape.split("-")[1].split(":")[0];
        this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: this.activeObj.shape, isTransform: true } });
      }
      this.isCropToolbar = true;
      this.allowDownScale = false;
      var straighten = this.transform.straighten;
      var straightenObj = extend({}, this.activeObj, {}, true);
      var zoomFactor = this.transform.zoomFactor;
      this.prevEventSelectionPoint = extend({}, this.activeObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      this.prevEventObjPoint = object["currObj"];
      this.prevEventObjPoint.objColl = extend([], this.objColl, [], true);
      this.prevEventObjPoint.pointColl = extend([], this.pointColl, [], true);
      this.prevEventObjPoint.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      this.prevEventObjPoint.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (this.transform.straighten !== 0) {
        this.transform.straighten = 0;
        this.straightenBaseImageCanvas();
        for (var i = 0, len = this.objColl.length; i < len; i++) {
          var shape = this.objColl[i].shape;
          if (shape !== "line" && shape !== "arrow" && shape !== "path") {
            this.objColl[i].rotatedAngle -= straighten * (Math.PI / 180);
            this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
          }
        }
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        this.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      this.setInitialZoomState();
      var activeObj = extend({}, this.activeObj, {}, true);
      this.notify("crop", { prop: "setTransformCrop", onPropertyChange: false, value: { bool: true } });
      this.cropSelectedState();
      this.notify("crop", { prop: "setTransformCrop", onPropertyChange: false, value: { bool: false } });
      this.notify("draw", { prop: "resetCurrentSelectionPoint" });
      this.updateImageTransformColl(type);
      this.notify("transform", { prop: "performTransformation", value: { text: type } });
      this.isCropTab = true;
      this.notify("draw", { prop: "moveToSelectionRange", value: { type, activeObj } });
      if (this.isStraightening && (type === "horizontalflip" || type === "verticalflip")) {
        this.notify("draw", { prop: "resetStraightenDestPoints" });
        this.notify("draw", { prop: "setDestForStraighten" });
      }
      if (straighten !== 0) {
        this.transform.straighten = straighten;
        this.straightenBaseImageCanvas();
        for (var i = 0, len = this.objColl.length; i < len; i++) {
          var shape = this.objColl[i].shape;
          if (shape !== "line" && shape !== "arrow" && shape !== "path") {
            this.objColl[i].rotatedAngle += straighten * (Math.PI / 180);
            this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
          }
        }
        this.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: straightenObj } });
        this.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
        this.notify("draw", { prop: "setStraightenInitZoom", value: { zoomFactor } });
        if (this.isStraightening && (type === "horizontalflip" || type === "verticalflip") && isNullOrUndefined(this.transform.zoomFactor) || this.transform.zoomFactor === 0) {
          if (this.transform.degree === 0) {
            this.transform.zoomFactor += 0.025;
          } else if (this.transform.zoomFactor === 0) {
            this.transform.zoomFactor = null;
          }
        }
        this.notify("draw", { prop: "zoomToSel", value: { activeObj: straightenObj, isToolbar: false } });
      }
      this.isCropToolbar = false;
      var stValPan = this.element.querySelector(".e-ie-straighten-value-span");
      if (stValPan) {
        stValPan.innerHTML = this.transform.straighten.toString() + "&#176";
      }
    };
    ImageEditor2.prototype.getDefaultFilter = function() {
      return "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
    };
    ImageEditor2.prototype.setStraighten = function(value) {
      var straightenEventArgs = { cancel: false, previousDegree: this.transform.straighten, currentDegree: value };
      this.trigger("rotating", straightenEventArgs);
      if (!straightenEventArgs.cancel) {
        this.performStraighten(straightenEventArgs);
      }
    };
    ImageEditor2.prototype.duplicateImage = function() {
      var activePoint = extend({}, this.activeObj.activePoint, {}, true);
      var dimObj = { width: 0, height: 0 };
      this.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.activeObj.imageElement.width, height: this.activeObj.imageElement.height, obj: dimObj, isImgShape: null }
      });
      this.activeObj.activePoint.width = dimObj["width"];
      this.activeObj.activePoint.height = dimObj["height"];
      return activePoint;
    };
    ImageEditor2.prototype.performStraighten = function(straightenEventArgs) {
      var value = straightenEventArgs.currentDegree;
      var stValPan = this.element.querySelector(".e-ie-straighten-value-span");
      if (stValPan) {
        stValPan.innerHTML = value.toString() + "&#176";
      }
      var obj = extend({}, this.activeObj, null, true);
      this.notify("freehand-draw", { prop: "setCenterSelPoints" });
      this.transform.straighten = value;
      this.straightenPoint = {
        x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
        y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2
      };
      this.straightenBaseImageCanvas();
      for (var i = 0, len = this.objColl.length; i < len; i++) {
        var shape = this.objColl[i].shape;
        if (shape !== "line" && shape !== "arrow" && shape !== "path") {
          this.objColl[i].rotatedAngle += (this.transform.straighten - this.prevStraightenedDegree) * (Math.PI / 180);
          this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
        }
      }
      if (this.transform.degree % 90 === 0 && this.transform.degree % 180 !== 0) {
        if (this.transform.straighten === 0) {
          this.transform.straighten = 360;
        }
        this.notify("draw", {
          prop: "performPointZoom",
          onPropertyChange: false,
          value: {
            x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
            y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2,
            type: "zoomIn",
            isResize: true
          }
        });
        this.notify("draw", {
          prop: "performPointZoom",
          onPropertyChange: false,
          value: {
            x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
            y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2,
            type: "zoomOut",
            isResize: true
          }
        });
        if (this.transform.straighten === 360) {
          this.transform.straighten = 0;
        }
      } else {
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: null, isStraighten: true } });
      }
      this.notify("draw", {
        prop: "drawObject",
        onPropertyChange: false,
        value: { canvas: "duplicate", obj }
      });
      this.notify("draw", { prop: "zoomToSel", value: { activeObj: obj, isToolbar: true } });
      this.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
      this.prevStraightenedDegree = this.transform.straighten;
    };
    ImageEditor2.prototype.straightenBaseImageCanvas = function() {
      if (this.isImageLoaded) {
        var flipState = this.getStraightenFlipState();
        var straighten = flipState === "horizontal" || flipState === "vertical" ? -this.transform.straighten : this.transform.straighten;
        var ctx = this.baseImgCanvas.getContext("2d");
        if (ctx.canvas.width !== this.lowerContext.canvas.width && ctx.canvas.height !== this.lowerContext.canvas.height) {
          var obj_6 = { width: 0, height: 0 };
          this.notify("crop", {
            prop: "calcRatio",
            onPropertyChange: false,
            value: { obj: obj_6, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } }
          });
        }
        var dimension = void 0;
        dimension = this.getRotatedCanvasDim(this.baseImg.width, this.baseImg.height, this.transform.straighten);
        this.img.srcWidth = ctx.canvas.width = dimension.width;
        this.img.srcHeight = ctx.canvas.height = dimension.height;
        var x = ctx.canvas.width / 2;
        var y = ctx.canvas.height / 2;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.translate(x, y);
        ctx.rotate(straighten * Math.PI / 180);
        ctx.drawImage(this.baseImg, -this.baseImg.width / 2, -this.baseImg.height / 2, this.baseImg.width, this.baseImg.height);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var obj = { width: 0, height: 0 };
        this.notify("crop", { prop: "calcRatio", onPropertyChange: false, value: { obj, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } } });
      }
    };
    ImageEditor2.prototype.getRotatedCanvasDim = function(width, height, angle) {
      var angleRad = angle * Math.PI / 180;
      var cosAngle = Math.cos(angleRad);
      var sinAngle = Math.sin(angleRad);
      var minX = Math.min(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
      var maxX = Math.max(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
      var minY = Math.min(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
      var maxY = Math.max(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
      return { width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY) };
    };
    ImageEditor2.prototype.updateShapeOrder = function(id, value) {
      var shapeObj = this.getObjFromId(id);
      if (shapeObj.shape && (shapeObj.shape !== "path" || shapeObj.shape === "path" && shapeObj.pointColl.length > 0) || shapeObj && shapeObj["id"] && shapeObj["id"].indexOf("pen") > -1) {
        var obj = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        if (shapeObj.shape) {
          this.notify("shape", { prop: "pushActItemIntoObj" });
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (shapeObj.shape) {
          this.objColl.pop();
        }
        this.notify("shape", { prop: "z-order", onPropertyChange: false, value: { obj: shapeObj, value } });
        if (shapeObj.shape) {
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: null,
            fillColor: null,
            strokeWidth: shapeObj.strokeSettings.strokeWidth
          } });
          this.objColl.push(shapeObj);
        }
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        if (shapeObj.shape) {
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
          this.activeObj.order = shapeObj.order;
        }
        var shapeChangedArgs = {
          action: "stroke-width",
          previousShapeSettings: extend({}, shapeSettings, {}, true),
          currentShapeSettings: extend({}, shapeSettings, {}, true)
        };
        shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: null,
          strokeWidth: this.activeObj.strokeSettings.strokeWidth
        } });
      }
    };
    ImageEditor2.prototype.getStraightenFlipState = function() {
      var flipState = "";
      if (this.rotateFlipColl.length > 0) {
        for (var i = 0, len = this.rotateFlipColl.length; i < len; i++) {
          var curFlip = this.rotateFlipColl[i];
          if (curFlip === "horizontal") {
            flipState += "horizontal";
          } else if (curFlip === "vertical") {
            flipState += "vertical";
          }
          if (flipState === "horizontalvertical" || flipState === "verticalhorizontal") {
            flipState = "";
          }
        }
      }
      return flipState;
    };
    ImageEditor2.prototype.initializeZoomSettings = function() {
      this.theme = isNullOrUndefined(this.theme) ? "Bootstrap5" : this.theme;
      if (isNullOrUndefined(this.zoomSettings.zoomTrigger) || this.zoomSettings.zoomTrigger === 0) {
        this.zoomSettings.zoomTrigger = ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands;
      }
      if (isNullOrUndefined(this.selectionSettings.strokeColor)) {
        this.selectionSettings.strokeColor = this.themeColl[this.theme]["primaryColor"];
      }
      if (isNullOrUndefined(this.selectionSettings.fillColor)) {
        this.selectionSettings.fillColor = this.themeColl[this.theme]["secondaryColor"];
      }
    };
    ImageEditor2.prototype.initializeThemeColl = function() {
      this.themeColl = {
        Bootstrap5: { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        Bootstrap5Dark: { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        Tailwind: { primaryColor: "#4f46e5", secondaryColor: "#fff" },
        TailwindDark: { primaryColor: "#22d3ee", secondaryColor: "#fff" },
        Fluent: { primaryColor: "#0078d4", secondaryColor: "#fff" },
        FluentDark: { primaryColor: "#0078d4", secondaryColor: "#fff" },
        Bootstrap4: { primaryColor: "#007bff", secondaryColor: "#fff" },
        Bootstrap: { primaryColor: "#317ab9", secondaryColor: "#fff" },
        BootstrapDark: { primaryColor: "#317ab9", secondaryColor: "#fff" },
        Material: { primaryColor: "#e3165b", secondaryColor: "#fff" },
        MaterialDark: { primaryColor: "#00b0ff", secondaryColor: "#fff" },
        Fabric: { primaryColor: "#0078d6", secondaryColor: "#fff" },
        FabricDark: { primaryColor: "#0074cc", secondaryColor: "#fff" },
        Highcontrast: { primaryColor: "#000000", secondaryColor: "#fff" },
        Material3: { primaryColor: "#6750a4", secondaryColor: "#fff" },
        Material3Dark: { primaryColor: "#d0bcff", secondaryColor: "#fff" },
        Fluent2: { primaryColor: "#0f6cbd", secondaryColor: "#fff" },
        Fluent2Dark: { primaryColor: "#115ea3", secondaryColor: "#fff" },
        Fluent2Highcontrast: { primaryColor: "#1aebff", secondaryColor: "#fff" }
      };
    };
    var ImageEditor_1;
    __decorate27([
      Property("")
    ], ImageEditor2.prototype, "cssClass", void 0);
    __decorate27([
      Property(false)
    ], ImageEditor2.prototype, "disabled", void 0);
    __decorate27([
      Property("100%")
    ], ImageEditor2.prototype, "height", void 0);
    __decorate27([
      Property("Bootstrap5")
    ], ImageEditor2.prototype, "theme", void 0);
    __decorate27([
      Property()
    ], ImageEditor2.prototype, "toolbar", void 0);
    __decorate27([
      Property()
    ], ImageEditor2.prototype, "toolbarTemplate", void 0);
    __decorate27([
      Property("100%")
    ], ImageEditor2.prototype, "width", void 0);
    __decorate27([
      Property(true)
    ], ImageEditor2.prototype, "allowUndoRedo", void 0);
    __decorate27([
      Property(true)
    ], ImageEditor2.prototype, "showQuickAccessToolbar", void 0);
    __decorate27([
      Property()
    ], ImageEditor2.prototype, "quickAccessToolbarTemplate", void 0);
    __decorate27([
      Property(false)
    ], ImageEditor2.prototype, "isReadOnly", void 0);
    __decorate27([
      Property(false)
    ], ImageEditor2.prototype, "enableRtl", void 0);
    __decorate27([
      Property(false)
    ], ImageEditor2.prototype, "enablePersistence", void 0);
    __decorate27([
      Complex({}, FinetuneSettings)
    ], ImageEditor2.prototype, "finetuneSettings", void 0);
    __decorate27([
      Complex({}, ZoomSettings)
    ], ImageEditor2.prototype, "zoomSettings", void 0);
    __decorate27([
      Complex({}, SelectionSettings)
    ], ImageEditor2.prototype, "selectionSettings", void 0);
    __decorate27([
      Complex({}, FontFamily)
    ], ImageEditor2.prototype, "fontFamily", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "beforeSave", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "created", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "destroyed", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "zooming", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "panning", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "cropping", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "rotating", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "flipping", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "shapeChanging", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "selectionChanging", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "fileOpened", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "saved", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "toolbarCreated", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "toolbarUpdating", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "toolbarItemClicked", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "imageFiltering", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "finetuneValueChanging", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "click", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "shapeChange", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "quickAccessToolbarOpen", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "resizing", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "quickAccessToolbarItemClick", void 0);
    __decorate27([
      Event()
    ], ImageEditor2.prototype, "frameChange", void 0);
    ImageEditor2 = ImageEditor_1 = __decorate27([
      NotifyPropertyChanges
    ], ImageEditor2);
    return ImageEditor2;
  }(Component)
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/base/enum.js
var FileType;
(function(FileType2) {
  FileType2["Png"] = "Png";
  FileType2["Jpeg"] = "Jpeg";
  FileType2["Svg"] = "Svg";
})(FileType || (FileType = {}));
var Direction;
(function(Direction2) {
  Direction2["Horizontal"] = "Horizontal";
  Direction2["Vertical"] = "Vertical";
})(Direction || (Direction = {}));
var ShapeType;
(function(ShapeType2) {
  ShapeType2["Rectangle"] = "Rectangle";
  ShapeType2["Ellipse"] = "Ellipse";
  ShapeType2["Line"] = "Line";
  ShapeType2["Arrow"] = "Arrow";
  ShapeType2["Path"] = "Path";
  ShapeType2["Text"] = "Text";
  ShapeType2["FreehandDraw"] = "FreehandDraw";
  ShapeType2["Image"] = "Image";
})(ShapeType || (ShapeType = {}));
var ZoomTrigger;
(function(ZoomTrigger2) {
  ZoomTrigger2[ZoomTrigger2["MouseWheel"] = 1] = "MouseWheel";
  ZoomTrigger2[ZoomTrigger2["Pinch"] = 2] = "Pinch";
  ZoomTrigger2[ZoomTrigger2["Commands"] = 4] = "Commands";
  ZoomTrigger2[ZoomTrigger2["Toolbar"] = 8] = "Toolbar";
})(ZoomTrigger || (ZoomTrigger = {}));
var Theme;
(function(Theme2) {
  Theme2["Bootstrap5"] = "Bootstrap5";
  Theme2["Bootstrap5Dark"] = "Bootstrap5Dark";
  Theme2["Tailwind"] = "Tailwind";
  Theme2["TailwindDark"] = "TailwindDark";
  Theme2["Fluent"] = "Fluent";
  Theme2["FluentDark"] = "FluentDark";
  Theme2["Bootstrap4"] = "Bootstrap4";
  Theme2["Bootstrap"] = "Bootstrap";
  Theme2["BootstrapDark"] = "BootstrapDark";
  Theme2["Material"] = "Material";
  Theme2["MaterialDark"] = "MaterialDark";
  Theme2["Fabric"] = "Fabric";
  Theme2["FabricDark"] = "FabricDark";
  Theme2["Highcontrast"] = "Highcontrast";
  Theme2["Fluent2"] = "Fluent2";
  Theme2["Fluent2Dark"] = "Fluent2Dark";
})(Theme || (Theme = {}));
var ImageEditorCommand;
(function(ImageEditorCommand2) {
  ImageEditorCommand2["Crop"] = "Crop";
  ImageEditorCommand2["Transform"] = "Transform";
  ImageEditorCommand2["Annotate"] = "Annotate";
  ImageEditorCommand2["ZoomIn"] = "ZoomIn";
  ImageEditorCommand2["ZoomOut"] = "ZoomOut";
  ImageEditorCommand2["Open"] = "Open";
  ImageEditorCommand2["Reset"] = "Reset";
  ImageEditorCommand2["Save"] = "Save";
  ImageEditorCommand2["Pan"] = "Pan";
  ImageEditorCommand2["Move"] = "Move";
  ImageEditorCommand2["Pen"] = "Pen";
  ImageEditorCommand2["Line"] = "Line";
  ImageEditorCommand2["Arrow"] = "Arrow";
  ImageEditorCommand2["Path"] = "Path";
  ImageEditorCommand2["Rectangle"] = "Rectangle";
  ImageEditorCommand2["Image"] = "Image";
  ImageEditorCommand2["Ellipse"] = "Ellipse";
  ImageEditorCommand2["Text"] = "Text";
  ImageEditorCommand2["CustomSelection"] = "CustomSelection";
  ImageEditorCommand2["CircleSelection"] = "CircleSelection";
  ImageEditorCommand2["SquareSelection"] = "SquareSelection";
  ImageEditorCommand2["RatioSelection"] = "RatioSelection";
  ImageEditorCommand2["RotateLeft"] = "RotateLeft";
  ImageEditorCommand2["RotateRight"] = "RotateRight";
  ImageEditorCommand2["FlipHorizontal"] = "FlipHorizontal";
  ImageEditorCommand2["FlipVertical"] = "FlipVertical";
  ImageEditorCommand2["Undo"] = "Undo";
  ImageEditorCommand2["Redo"] = "Redo";
  ImageEditorCommand2["None"] = "None";
  ImageEditorCommand2["Mat"] = "Mat";
  ImageEditorCommand2["Bevel"] = "Bevel";
  ImageEditorCommand2["Inset"] = "Inset";
  ImageEditorCommand2["Hook"] = "Hook";
  ImageEditorCommand2["Finetune"] = "Finetune";
  ImageEditorCommand2["Filter"] = "Filter";
  ImageEditorCommand2["Frame"] = "Frame";
  ImageEditorCommand2["Resize"] = "Resize";
  ImageEditorCommand2["HorizontalFlip"] = "HorizontalFlip";
  ImageEditorCommand2["VerticalFlip"] = "VerticalFlip";
  ImageEditorCommand2["Brightness"] = "Brightness";
  ImageEditorCommand2["Contrast"] = "Contrast";
  ImageEditorCommand2["Hue"] = "Hue";
  ImageEditorCommand2["Saturation"] = "Saturation";
  ImageEditorCommand2["Opacity"] = "Opacity";
  ImageEditorCommand2["Blur"] = "Blur";
  ImageEditorCommand2["Exposure"] = "Exposure";
  ImageEditorCommand2["Default"] = "Default";
  ImageEditorCommand2["Chrome"] = "Chrome";
  ImageEditorCommand2["Cold"] = "Cold";
  ImageEditorCommand2["Warm"] = "Warm";
  ImageEditorCommand2["Grayscale"] = "Grayscale";
  ImageEditorCommand2["Sepia"] = "Sepia";
  ImageEditorCommand2["Invert"] = "Invert";
  ImageEditorCommand2["Straightening"] = "Straightening";
})(ImageEditorCommand || (ImageEditorCommand = {}));
var ImageFilterOption;
(function(ImageFilterOption2) {
  ImageFilterOption2["Default"] = "Default";
  ImageFilterOption2["Chrome"] = "Chrome";
  ImageFilterOption2["Cold"] = "Cold";
  ImageFilterOption2["Warm"] = "Warm";
  ImageFilterOption2["Grayscale"] = "Grayscale";
  ImageFilterOption2["Sepia"] = "Sepia";
  ImageFilterOption2["Invert"] = "Invert";
})(ImageFilterOption || (ImageFilterOption = {}));
var ImageFinetuneOption;
(function(ImageFinetuneOption2) {
  ImageFinetuneOption2["Brightness"] = "Brightness";
  ImageFinetuneOption2["Contrast"] = "Contrast";
  ImageFinetuneOption2["Hue"] = "Hue";
  ImageFinetuneOption2["Saturation"] = "Saturation";
  ImageFinetuneOption2["Exposure"] = "Exposure";
  ImageFinetuneOption2["Opacity"] = "Opacity";
  ImageFinetuneOption2["Blur"] = "Blur";
})(ImageFinetuneOption || (ImageFinetuneOption = {}));
var ArrowheadType;
(function(ArrowheadType2) {
  ArrowheadType2["None"] = "None";
  ArrowheadType2["Arrow"] = "Arrow";
  ArrowheadType2["SolidArrow"] = "SolidArrow";
  ArrowheadType2["Circle"] = "Circle";
  ArrowheadType2["SolidCircle"] = "SolidCircle";
  ArrowheadType2["Square"] = "Square";
  ArrowheadType2["SolidSquare"] = "SolidSquare";
  ArrowheadType2["Bar"] = "Bar";
})(ArrowheadType || (ArrowheadType = {}));
var FrameType;
(function(FrameType2) {
  FrameType2["None"] = "None";
  FrameType2["Mat"] = "Mat";
  FrameType2["Bevel"] = "Bevel";
  FrameType2["Line"] = "Line";
  FrameType2["Inset"] = "Inset";
  FrameType2["Hook"] = "Hook";
})(FrameType || (FrameType = {}));
var FrameLineStyle;
(function(FrameLineStyle2) {
  FrameLineStyle2["Solid"] = "Solid";
  FrameLineStyle2["Dashed"] = "Dashed";
  FrameLineStyle2["Dotted"] = "Dotted";
})(FrameLineStyle || (FrameLineStyle = {}));

// node_modules/@syncfusion/ej2-navigations/src/common/h-scroll.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT = "e-hscroll";
var CLS_RTL = "e-rtl";
var CLS_DISABLE = "e-overlay";
var CLS_HSCROLLBAR = "e-hscroll-bar";
var CLS_HSCROLLCON = "e-hscroll-content";
var CLS_NAVARROW = "e-nav-arrow";
var CLS_NAVRIGHTARROW = "e-nav-right-arrow";
var CLS_NAVLEFTARROW = "e-nav-left-arrow";
var CLS_HSCROLLNAV = "e-scroll-nav";
var CLS_HSCROLLNAVRIGHT = "e-scroll-right-nav";
var CLS_HSCROLLNAVLEFT = "e-scroll-left-nav";
var CLS_DEVICE = "e-scroll-device";
var CLS_OVERLAY = "e-scroll-overlay";
var CLS_RIGHTOVERLAY = "e-scroll-right-overlay";
var CLS_LEFTOVERLAY = "e-scroll-left-overlay";
var OVERLAY_MAXWID = 40;
var HScroll = (
  /** @class */
  function(_super) {
    __extends28(HScroll2, _super);
    function HScroll2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    HScroll2.prototype.preRender = function() {
      this.browser = Browser.info.name;
      this.browserCheck = this.browser === "mozilla";
      this.isDevice = Browser.isDevice;
      this.customStep = true;
      var element2 = this.element;
      this.ieCheck = this.browser === "edge" || this.browser === "msie";
      this.initialize();
      if (element2.id === "") {
        element2.id = getUniqueID("hscroll");
        this.uniqueId = true;
      }
      element2.style.display = "block";
      if (this.enableRtl) {
        element2.classList.add(CLS_RTL);
      }
    };
    HScroll2.prototype.render = function() {
      this.touchModule = new Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
      EventHandler.add(this.scrollEle, "scroll", this.scrollHandler, this);
      if (!this.isDevice) {
        this.createNavIcon(this.element);
      } else {
        this.element.classList.add(CLS_DEVICE);
        this.createOverlay(this.element);
      }
      this.setScrollState();
    };
    HScroll2.prototype.setScrollState = function() {
      if (isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
        this.scrollStep = this.scrollEle.offsetWidth;
        this.customStep = false;
      } else {
        this.customStep = true;
      }
    };
    HScroll2.prototype.initialize = function() {
      var scrollEle = this.createElement("div", { className: CLS_HSCROLLCON });
      var scrollDiv = this.createElement("div", { className: CLS_HSCROLLBAR });
      scrollDiv.setAttribute("tabindex", "-1");
      var ele = this.element;
      var innerEle = [].slice.call(ele.children);
      for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
        var ele_1 = innerEle_1[_i];
        scrollEle.appendChild(ele_1);
      }
      scrollDiv.appendChild(scrollEle);
      ele.appendChild(scrollDiv);
      scrollDiv.style.overflowX = "hidden";
      this.scrollEle = scrollDiv;
      this.scrollItems = scrollEle;
    };
    HScroll2.prototype.getPersistData = function() {
      var keyEntity = ["scrollStep"];
      return this.addOnPersist(keyEntity);
    };
    HScroll2.prototype.getModuleName = function() {
      return "hScroll";
    };
    HScroll2.prototype.destroy = function() {
      var ele = this.element;
      ele.style.display = "";
      ele.classList.remove(CLS_ROOT);
      ele.classList.remove(CLS_DEVICE);
      ele.classList.remove(CLS_RTL);
      var nav = selectAll(".e-" + ele.id + "_nav." + CLS_HSCROLLNAV, ele);
      var overlay = selectAll("." + CLS_OVERLAY, ele);
      [].slice.call(overlay).forEach(function(ele2) {
        detach(ele2);
      });
      for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
        var elem = _a[_i];
        ele.appendChild(elem);
      }
      if (this.uniqueId) {
        this.element.removeAttribute("id");
      }
      detach(this.scrollEle);
      if (nav.length > 0) {
        detach(nav[0]);
        if (!isNullOrUndefined(nav[1])) {
          detach(nav[1]);
        }
      }
      EventHandler.remove(this.scrollEle, "scroll", this.scrollHandler);
      this.touchModule.destroy();
      this.touchModule = null;
      _super.prototype.destroy.call(this);
    };
    HScroll2.prototype.disable = function(value) {
      var navEles = selectAll(".e-scroll-nav:not(." + CLS_DISABLE + ")", this.element);
      if (value) {
        this.element.classList.add(CLS_DISABLE);
      } else {
        this.element.classList.remove(CLS_DISABLE);
      }
      [].slice.call(navEles).forEach(function(el) {
        el.setAttribute("tabindex", !value ? "0" : "-1");
      });
    };
    HScroll2.prototype.createOverlay = function(element2) {
      var id = element2.id.concat("_nav");
      var rightOverlayEle = this.createElement("div", { className: CLS_OVERLAY + " " + CLS_RIGHTOVERLAY });
      var clsRight = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVRIGHT);
      var rightEle = this.createElement("div", { id: id.concat("_right"), className: clsRight });
      var navItem = this.createElement("div", { className: CLS_NAVRIGHTARROW + " " + CLS_NAVARROW + " e-icons" });
      rightEle.appendChild(navItem);
      var leftEle = this.createElement("div", { className: CLS_OVERLAY + " " + CLS_LEFTOVERLAY });
      if (this.ieCheck) {
        rightEle.classList.add("e-ie-align");
      }
      element2.appendChild(rightOverlayEle);
      element2.appendChild(rightEle);
      element2.insertBefore(leftEle, element2.firstChild);
      this.eventBinding([rightEle]);
    };
    HScroll2.prototype.createNavIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var clsRight = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVRIGHT);
      var rightAttributes = { "role": "button", "id": id.concat("_right"), "aria-label": "Scroll right" };
      var nav = this.createElement("div", { className: clsRight, attrs: rightAttributes });
      nav.setAttribute("aria-disabled", "false");
      var navItem = this.createElement("div", { className: CLS_NAVRIGHTARROW + " " + CLS_NAVARROW + " e-icons" });
      var clsLeft = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVLEFT);
      var leftAttributes = { "role": "button", "id": id.concat("_left"), "aria-label": "Scroll left" };
      var navEle = this.createElement("div", { className: clsLeft + " " + CLS_DISABLE, attrs: leftAttributes });
      navEle.setAttribute("aria-disabled", "true");
      var navLeftItem = this.createElement("div", { className: CLS_NAVLEFTARROW + " " + CLS_NAVARROW + " e-icons" });
      navEle.appendChild(navLeftItem);
      nav.appendChild(navItem);
      element2.appendChild(nav);
      element2.insertBefore(navEle, element2.firstChild);
      if (this.ieCheck) {
        nav.classList.add("e-ie-align");
        navEle.classList.add("e-ie-align");
      }
      this.eventBinding([nav, navEle]);
    };
    HScroll2.prototype.onKeyPress = function(e) {
      var _this = this;
      if (e.key === "Enter") {
        var timeoutFun_1 = function() {
          _this.keyTimeout = true;
          _this.eleScrolling(10, e.target, true);
        };
        this.keyTimer = window.setTimeout(function() {
          timeoutFun_1();
        }, 100);
      }
    };
    HScroll2.prototype.onKeyUp = function(e) {
      if (e.key !== "Enter") {
        return;
      }
      if (this.keyTimeout) {
        this.keyTimeout = false;
      } else {
        e.target.click();
      }
      clearTimeout(this.keyTimer);
    };
    HScroll2.prototype.eventBinding = function(ele) {
      var _this = this;
      [].slice.call(ele).forEach(function(el) {
        new Touch(el, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
        el.addEventListener("keydown", _this.onKeyPress.bind(_this));
        el.addEventListener("keyup", _this.onKeyUp.bind(_this));
        el.addEventListener("mouseup", _this.repeatScroll.bind(_this));
        el.addEventListener("touchend", _this.repeatScroll.bind(_this));
        el.addEventListener("contextmenu", function(e) {
          e.preventDefault();
        });
        EventHandler.add(el, "click", _this.clickEventHandler, _this);
      });
    };
    HScroll2.prototype.repeatScroll = function() {
      clearInterval(this.timeout);
    };
    HScroll2.prototype.tabHoldHandler = function(e) {
      var _this = this;
      var trgt = e.originalEvent.target;
      trgt = this.contains(trgt, CLS_HSCROLLNAV) ? trgt.firstElementChild : trgt;
      var scrollDis = 10;
      var timeoutFun = function() {
        _this.eleScrolling(scrollDis, trgt, true);
      };
      this.timeout = window.setInterval(function() {
        timeoutFun();
      }, 50);
    };
    HScroll2.prototype.contains = function(ele, className) {
      return ele.classList.contains(className);
    };
    HScroll2.prototype.eleScrolling = function(scrollDis, trgt, isContinuous) {
      var rootEle = this.element;
      var classList2 = trgt.classList;
      if (classList2.contains(CLS_HSCROLLNAV)) {
        classList2 = trgt.querySelector("." + CLS_NAVARROW).classList;
      }
      if (this.contains(rootEle, CLS_RTL) && this.browserCheck) {
        scrollDis = -scrollDis;
      }
      if (!this.contains(rootEle, CLS_RTL) || this.browserCheck || this.ieCheck) {
        if (classList2.contains(CLS_NAVRIGHTARROW)) {
          this.frameScrollRequest(scrollDis, "add", isContinuous);
        } else {
          this.frameScrollRequest(scrollDis, "", isContinuous);
        }
      } else {
        if (classList2.contains(CLS_NAVLEFTARROW)) {
          this.frameScrollRequest(scrollDis, "add", isContinuous);
        } else {
          this.frameScrollRequest(scrollDis, "", isContinuous);
        }
      }
    };
    HScroll2.prototype.clickEventHandler = function(e) {
      this.eleScrolling(this.scrollStep, e.target, false);
    };
    HScroll2.prototype.swipeHandler = function(e) {
      var swipeEle = this.scrollEle;
      var distance;
      if (e.velocity <= 1) {
        distance = e.distanceX / (e.velocity * 10);
      } else {
        distance = e.distanceX / e.velocity;
      }
      var start = 0.5;
      var animate = function() {
        var step = Math.sin(start);
        if (step <= 0) {
          window.cancelAnimationFrame(step);
        } else {
          if (e.swipeDirection === "Left") {
            swipeEle.scrollLeft += distance * step;
          } else if (e.swipeDirection === "Right") {
            swipeEle.scrollLeft -= distance * step;
          }
          start -= 0.5;
          window.requestAnimationFrame(animate);
        }
      };
      animate();
    };
    HScroll2.prototype.scrollUpdating = function(scrollVal, action) {
      if (action === "add") {
        this.scrollEle.scrollLeft += scrollVal;
      } else {
        this.scrollEle.scrollLeft -= scrollVal;
      }
      if (this.enableRtl && this.scrollEle.scrollLeft > 0) {
        this.scrollEle.scrollLeft = 0;
      }
    };
    HScroll2.prototype.frameScrollRequest = function(scrollVal, action, isContinuous) {
      var _this = this;
      var step = 10;
      if (isContinuous) {
        this.scrollUpdating(scrollVal, action);
        return;
      }
      if (!this.customStep) {
        [].slice.call(selectAll("." + CLS_OVERLAY, this.element)).forEach(function(el) {
          scrollVal -= el.offsetWidth;
        });
      }
      var animate = function() {
        var scrollValue;
        var scrollStep;
        if (_this.contains(_this.element, CLS_RTL) && _this.browserCheck) {
          scrollValue = -scrollVal;
          scrollStep = -step;
        } else {
          scrollValue = scrollVal;
          scrollStep = step;
        }
        if (scrollValue < step) {
          window.cancelAnimationFrame(scrollStep);
        } else {
          _this.scrollUpdating(scrollStep, action);
          scrollVal -= scrollStep;
          window.requestAnimationFrame(animate);
        }
      };
      animate();
    };
    HScroll2.prototype.touchHandler = function(e) {
      var ele = this.scrollEle;
      var distance = e.distanceX;
      if (this.ieCheck && this.contains(this.element, CLS_RTL)) {
        distance = -distance;
      }
      if (e.scrollDirection === "Left") {
        ele.scrollLeft = ele.scrollLeft + distance;
      } else if (e.scrollDirection === "Right") {
        ele.scrollLeft = ele.scrollLeft - distance;
      }
    };
    HScroll2.prototype.arrowDisabling = function(addDisable, removeDisable) {
      if (this.isDevice) {
        var arrowEle = isNullOrUndefined(addDisable) ? removeDisable : addDisable;
        var arrowIcon = arrowEle.querySelector("." + CLS_NAVARROW);
        if (isNullOrUndefined(addDisable)) {
          classList(arrowIcon, [CLS_NAVRIGHTARROW], [CLS_NAVLEFTARROW]);
        } else {
          classList(arrowIcon, [CLS_NAVLEFTARROW], [CLS_NAVRIGHTARROW]);
        }
      } else if (addDisable && removeDisable) {
        addDisable.classList.add(CLS_DISABLE);
        addDisable.setAttribute("aria-disabled", "true");
        addDisable.removeAttribute("tabindex");
        removeDisable.classList.remove(CLS_DISABLE);
        removeDisable.setAttribute("aria-disabled", "false");
        removeDisable.setAttribute("tabindex", "0");
      }
      this.repeatScroll();
    };
    HScroll2.prototype.scrollHandler = function(e) {
      var target = e.target;
      var width = target.offsetWidth;
      var rootEle = this.element;
      var navLeftEle = this.element.querySelector("." + CLS_HSCROLLNAVLEFT);
      var navRightEle = this.element.querySelector("." + CLS_HSCROLLNAVRIGHT);
      var leftOverlay = this.element.querySelector("." + CLS_LEFTOVERLAY);
      var rightOverlay = this.element.querySelector("." + CLS_RIGHTOVERLAY);
      var scrollLeft = target.scrollLeft;
      if (scrollLeft <= 0) {
        scrollLeft = -scrollLeft;
      }
      if (this.isDevice) {
        if (this.enableRtl && !(this.browserCheck || this.ieCheck)) {
          leftOverlay = this.element.querySelector("." + CLS_RIGHTOVERLAY);
          rightOverlay = this.element.querySelector("." + CLS_LEFTOVERLAY);
        }
        if (scrollLeft < OVERLAY_MAXWID) {
          leftOverlay.style.width = scrollLeft + "px";
        } else {
          leftOverlay.style.width = "40px";
        }
        if (target.scrollWidth - Math.ceil(width + scrollLeft) < OVERLAY_MAXWID) {
          rightOverlay.style.width = target.scrollWidth - Math.ceil(width + scrollLeft) + "px";
        } else {
          rightOverlay.style.width = "40px";
        }
      }
      if (scrollLeft === 0) {
        this.arrowDisabling(navLeftEle, navRightEle);
      } else if (Math.ceil(width + scrollLeft + 0.1) >= target.scrollWidth) {
        this.arrowDisabling(navRightEle, navLeftEle);
      } else {
        var disEle = this.element.querySelector("." + CLS_HSCROLLNAV + "." + CLS_DISABLE);
        if (disEle) {
          disEle.classList.remove(CLS_DISABLE);
          disEle.setAttribute("aria-disabled", "false");
          disEle.setAttribute("tabindex", "0");
        }
      }
    };
    HScroll2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "scrollStep":
            this.setScrollState();
            break;
          case "enableRtl":
            newProp.enableRtl ? this.element.classList.add(CLS_RTL) : this.element.classList.remove(CLS_RTL);
            break;
        }
      }
    };
    __decorate28([
      Property(null)
    ], HScroll2.prototype, "scrollStep", void 0);
    HScroll2 = __decorate28([
      NotifyPropertyChanges
    ], HScroll2);
    return HScroll2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/common/v-scroll.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT2 = "e-vscroll";
var CLS_RTL2 = "e-rtl";
var CLS_DISABLE2 = "e-overlay";
var CLS_VSCROLLBAR = "e-vscroll-bar";
var CLS_VSCROLLCON = "e-vscroll-content";
var CLS_NAVARROW2 = "e-nav-arrow";
var CLS_NAVUPARROW = "e-nav-up-arrow";
var CLS_NAVDOWNARROW = "e-nav-down-arrow";
var CLS_VSCROLLNAV = "e-scroll-nav";
var CLS_VSCROLLNAVUP = "e-scroll-up-nav";
var CLS_VSCROLLNAVDOWN = "e-scroll-down-nav";
var CLS_DEVICE2 = "e-scroll-device";
var CLS_OVERLAY2 = "e-scroll-overlay";
var CLS_UPOVERLAY = "e-scroll-up-overlay";
var CLS_DOWNOVERLAY = "e-scroll-down-overlay";
var OVERLAY_MAXWID2 = 40;
var VScroll = (
  /** @class */
  function(_super) {
    __extends29(VScroll2, _super);
    function VScroll2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    VScroll2.prototype.preRender = function() {
      this.browser = Browser.info.name;
      this.browserCheck = this.browser === "mozilla";
      this.isDevice = Browser.isDevice;
      this.customStep = true;
      var ele = this.element;
      this.ieCheck = this.browser === "edge" || this.browser === "msie";
      this.initialize();
      if (ele.id === "") {
        ele.id = getUniqueID("vscroll");
        this.uniqueId = true;
      }
      ele.style.display = "block";
      if (this.enableRtl) {
        ele.classList.add(CLS_RTL2);
      }
    };
    VScroll2.prototype.render = function() {
      this.touchModule = new Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
      EventHandler.add(this.scrollEle, "scroll", this.scrollEventHandler, this);
      if (!this.isDevice) {
        this.createNavIcon(this.element);
      } else {
        this.element.classList.add(CLS_DEVICE2);
        this.createOverlayElement(this.element);
      }
      this.setScrollState();
      EventHandler.add(this.element, "wheel", this.wheelEventHandler, this);
    };
    VScroll2.prototype.setScrollState = function() {
      if (isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
        this.scrollStep = this.scrollEle.offsetHeight;
        this.customStep = false;
      } else {
        this.customStep = true;
      }
    };
    VScroll2.prototype.initialize = function() {
      var scrollCnt = createElement("div", { className: CLS_VSCROLLCON });
      var scrollBar = createElement("div", { className: CLS_VSCROLLBAR });
      scrollBar.setAttribute("tabindex", "-1");
      var ele = this.element;
      var innerEle = [].slice.call(ele.children);
      for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
        var ele_1 = innerEle_1[_i];
        scrollCnt.appendChild(ele_1);
      }
      scrollBar.appendChild(scrollCnt);
      ele.appendChild(scrollBar);
      scrollBar.style.overflow = "hidden";
      this.scrollEle = scrollBar;
      this.scrollItems = scrollCnt;
    };
    VScroll2.prototype.getPersistData = function() {
      var keyEntity = ["scrollStep"];
      return this.addOnPersist(keyEntity);
    };
    VScroll2.prototype.getModuleName = function() {
      return "vScroll";
    };
    VScroll2.prototype.destroy = function() {
      var el = this.element;
      el.style.display = "";
      removeClass([this.element], [CLS_ROOT2, CLS_DEVICE2, CLS_RTL2]);
      var navs = selectAll(".e-" + el.id + "_nav." + CLS_VSCROLLNAV, el);
      var overlays = selectAll("." + CLS_OVERLAY2, el);
      [].slice.call(overlays).forEach(function(ele) {
        detach(ele);
      });
      for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
        var elem = _a[_i];
        el.appendChild(elem);
      }
      if (this.uniqueId) {
        this.element.removeAttribute("id");
      }
      detach(this.scrollEle);
      if (navs.length > 0) {
        detach(navs[0]);
        if (!isNullOrUndefined(navs[1])) {
          detach(navs[1]);
        }
      }
      EventHandler.remove(this.scrollEle, "scroll", this.scrollEventHandler);
      this.touchModule.destroy();
      this.touchModule = null;
      _super.prototype.destroy.call(this);
    };
    VScroll2.prototype.disable = function(value) {
      var navEle = selectAll(".e-scroll-nav:not(." + CLS_DISABLE2 + ")", this.element);
      if (value) {
        this.element.classList.add(CLS_DISABLE2);
      } else {
        this.element.classList.remove(CLS_DISABLE2);
      }
      [].slice.call(navEle).forEach(function(el) {
        el.setAttribute("tabindex", !value ? "0" : "-1");
      });
    };
    VScroll2.prototype.createOverlayElement = function(element2) {
      var id = element2.id.concat("_nav");
      var downOverlayEle = createElement("div", { className: CLS_OVERLAY2 + " " + CLS_DOWNOVERLAY });
      var clsDown = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVDOWN);
      var downEle = createElement("div", { id: id.concat("down"), className: clsDown });
      var navItem = createElement("div", { className: CLS_NAVDOWNARROW + " " + CLS_NAVARROW2 + " e-icons" });
      downEle.appendChild(navItem);
      var upEle = createElement("div", { className: CLS_OVERLAY2 + " " + CLS_UPOVERLAY });
      if (this.ieCheck) {
        downEle.classList.add("e-ie-align");
      }
      element2.appendChild(downOverlayEle);
      element2.appendChild(downEle);
      element2.insertBefore(upEle, element2.firstChild);
      this.eventBinding([downEle]);
    };
    VScroll2.prototype.createNavIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var clsDown = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVDOWN);
      var nav = createElement("div", { id: id.concat("_down"), className: clsDown });
      nav.setAttribute("aria-disabled", "false");
      var navItem = createElement("div", { className: CLS_NAVDOWNARROW + " " + CLS_NAVARROW2 + " e-icons" });
      var clsUp = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVUP);
      var navElement = createElement("div", { id: id.concat("_up"), className: clsUp + " " + CLS_DISABLE2 });
      navElement.setAttribute("aria-disabled", "true");
      var navUpItem = createElement("div", { className: CLS_NAVUPARROW + " " + CLS_NAVARROW2 + " e-icons" });
      navElement.appendChild(navUpItem);
      nav.appendChild(navItem);
      nav.setAttribute("tabindex", "0");
      element2.appendChild(nav);
      element2.insertBefore(navElement, element2.firstChild);
      if (this.ieCheck) {
        nav.classList.add("e-ie-align");
        navElement.classList.add("e-ie-align");
      }
      this.eventBinding([nav, navElement]);
    };
    VScroll2.prototype.onKeyPress = function(ev) {
      var _this = this;
      if (ev.key === "Enter") {
        var timeoutFun_1 = function() {
          _this.keyTimeout = true;
          _this.eleScrolling(10, ev.target, true);
        };
        this.keyTimer = window.setTimeout(function() {
          timeoutFun_1();
        }, 100);
      }
    };
    VScroll2.prototype.onKeyUp = function(ev) {
      if (ev.key !== "Enter") {
        return;
      }
      if (this.keyTimeout) {
        this.keyTimeout = false;
      } else {
        ev.target.click();
      }
      clearTimeout(this.keyTimer);
    };
    VScroll2.prototype.eventBinding = function(element2) {
      var _this = this;
      [].slice.call(element2).forEach(function(ele) {
        new Touch(ele, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
        ele.addEventListener("keydown", _this.onKeyPress.bind(_this));
        ele.addEventListener("keyup", _this.onKeyUp.bind(_this));
        ele.addEventListener("mouseup", _this.repeatScroll.bind(_this));
        ele.addEventListener("touchend", _this.repeatScroll.bind(_this));
        ele.addEventListener("contextmenu", function(e) {
          e.preventDefault();
        });
        EventHandler.add(ele, "click", _this.clickEventHandler, _this);
      });
    };
    VScroll2.prototype.repeatScroll = function() {
      clearInterval(this.timeout);
    };
    VScroll2.prototype.tabHoldHandler = function(ev) {
      var _this = this;
      var trgt = ev.originalEvent.target;
      trgt = this.contains(trgt, CLS_VSCROLLNAV) ? trgt.firstElementChild : trgt;
      var scrollDistance = 10;
      var timeoutFun = function() {
        _this.eleScrolling(scrollDistance, trgt, true);
      };
      this.timeout = window.setInterval(function() {
        timeoutFun();
      }, 50);
    };
    VScroll2.prototype.contains = function(element2, className) {
      return element2.classList.contains(className);
    };
    VScroll2.prototype.eleScrolling = function(scrollDis, trgt, isContinuous) {
      var classList2 = trgt.classList;
      if (classList2.contains(CLS_VSCROLLNAV)) {
        classList2 = trgt.querySelector("." + CLS_NAVARROW2).classList;
      }
      if (classList2.contains(CLS_NAVDOWNARROW)) {
        this.frameScrollRequest(scrollDis, "add", isContinuous);
      } else if (classList2.contains(CLS_NAVUPARROW)) {
        this.frameScrollRequest(scrollDis, "", isContinuous);
      }
    };
    VScroll2.prototype.clickEventHandler = function(event) {
      this.eleScrolling(this.scrollStep, event.target, false);
    };
    VScroll2.prototype.wheelEventHandler = function(e) {
      e.preventDefault();
      this.frameScrollRequest(this.scrollStep, e.deltaY > 0 ? "add" : "", false);
    };
    VScroll2.prototype.swipeHandler = function(e) {
      var swipeElement = this.scrollEle;
      var distance;
      if (e.velocity <= 1) {
        distance = e.distanceY / (e.velocity * 10);
      } else {
        distance = e.distanceY / e.velocity;
      }
      var start = 0.5;
      var animate = function() {
        var step = Math.sin(start);
        if (step <= 0) {
          window.cancelAnimationFrame(step);
        } else {
          if (e.swipeDirection === "Up") {
            swipeElement.scrollTop += distance * step;
          } else if (e.swipeDirection === "Down") {
            swipeElement.scrollTop -= distance * step;
          }
          start -= 0.02;
          window.requestAnimationFrame(animate);
        }
      };
      animate();
    };
    VScroll2.prototype.scrollUpdating = function(scrollVal, action) {
      if (action === "add") {
        this.scrollEle.scrollTop += scrollVal;
      } else {
        this.scrollEle.scrollTop -= scrollVal;
      }
    };
    VScroll2.prototype.frameScrollRequest = function(scrollValue, action, isContinuous) {
      var _this = this;
      var step = 10;
      if (isContinuous) {
        this.scrollUpdating(scrollValue, action);
        return;
      }
      if (!this.customStep) {
        [].slice.call(selectAll("." + CLS_OVERLAY2, this.element)).forEach(function(el) {
          scrollValue -= el.offsetHeight;
        });
      }
      var animate = function() {
        if (scrollValue < step) {
          window.cancelAnimationFrame(step);
        } else {
          _this.scrollUpdating(step, action);
          scrollValue -= step;
          window.requestAnimationFrame(animate);
        }
      };
      animate();
    };
    VScroll2.prototype.touchHandler = function(e) {
      var el = this.scrollEle;
      var distance = e.distanceY;
      if (e.scrollDirection === "Up") {
        el.scrollTop = el.scrollTop + distance;
      } else if (e.scrollDirection === "Down") {
        el.scrollTop = el.scrollTop - distance;
      }
    };
    VScroll2.prototype.arrowDisabling = function(addDisableCls, removeDisableCls) {
      if (this.isDevice) {
        var arrowEle = isNullOrUndefined(addDisableCls) ? removeDisableCls : addDisableCls;
        var arrowIcon = arrowEle.querySelector("." + CLS_NAVARROW2);
        if (isNullOrUndefined(addDisableCls)) {
          classList(arrowIcon, [CLS_NAVDOWNARROW], [CLS_NAVUPARROW]);
        } else {
          classList(arrowIcon, [CLS_NAVUPARROW], [CLS_NAVDOWNARROW]);
        }
      } else {
        addDisableCls.classList.add(CLS_DISABLE2);
        addDisableCls.setAttribute("aria-disabled", "true");
        addDisableCls.removeAttribute("tabindex");
        removeDisableCls.classList.remove(CLS_DISABLE2);
        removeDisableCls.setAttribute("aria-disabled", "false");
        removeDisableCls.setAttribute("tabindex", "0");
      }
      this.repeatScroll();
    };
    VScroll2.prototype.scrollEventHandler = function(e) {
      var target = e.target;
      var height = target.offsetHeight;
      var navUpEle = this.element.querySelector("." + CLS_VSCROLLNAVUP);
      var navDownEle = this.element.querySelector("." + CLS_VSCROLLNAVDOWN);
      var upOverlay = this.element.querySelector("." + CLS_UPOVERLAY);
      var downOverlay = this.element.querySelector("." + CLS_DOWNOVERLAY);
      var scrollTop = target.scrollTop;
      if (scrollTop <= 0) {
        scrollTop = -scrollTop;
      }
      if (this.isDevice) {
        if (scrollTop < OVERLAY_MAXWID2) {
          upOverlay.style.height = scrollTop + "px";
        } else {
          upOverlay.style.height = "40px";
        }
        if (target.scrollHeight - Math.ceil(height + scrollTop) < OVERLAY_MAXWID2) {
          downOverlay.style.height = target.scrollHeight - Math.ceil(height + scrollTop) + "px";
        } else {
          downOverlay.style.height = "40px";
        }
      }
      if (scrollTop === 0) {
        this.arrowDisabling(navUpEle, navDownEle);
      } else if (Math.ceil(height + scrollTop + 0.1) >= target.scrollHeight) {
        this.arrowDisabling(navDownEle, navUpEle);
      } else {
        var disEle = this.element.querySelector("." + CLS_VSCROLLNAV + "." + CLS_DISABLE2);
        if (disEle) {
          disEle.classList.remove(CLS_DISABLE2);
          disEle.setAttribute("aria-disabled", "false");
          disEle.setAttribute("tabindex", "0");
        }
      }
    };
    VScroll2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "scrollStep":
            this.setScrollState();
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.element.classList.add(CLS_RTL2);
            } else {
              this.element.classList.remove(CLS_RTL2);
            }
            break;
        }
      }
    };
    __decorate29([
      Property(null)
    ], VScroll2.prototype, "scrollStep", void 0);
    VScroll2 = __decorate29([
      NotifyPropertyChanges
    ], VScroll2);
    return VScroll2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/common/menu-scroll.js
function addScrolling(createElement2, container, content, scrollType, enableRtl, offset) {
  var containerOffset;
  var contentOffset;
  var parentElem = container.parentElement;
  if (scrollType === "vscroll") {
    containerOffset = offset || container.getBoundingClientRect().height;
    contentOffset = content.getBoundingClientRect().height;
  } else {
    containerOffset = container.getBoundingClientRect().width;
    contentOffset = content.getBoundingClientRect().width;
  }
  if (containerOffset < contentOffset) {
    return createScrollbar(createElement2, container, content, scrollType, enableRtl, offset);
  } else if (parentElem) {
    var width = parentElem.getBoundingClientRect().width;
    if (width < containerOffset && scrollType === "hscroll") {
      contentOffset = width;
      container.style.maxWidth = width + "px";
      return createScrollbar(createElement2, container, content, scrollType, enableRtl, offset);
    }
    return content;
  } else {
    return content;
  }
}
function createScrollbar(createElement2, container, content, scrollType, enableRtl, offset) {
  var scrollEle = createElement2("div", { className: "e-menu-" + scrollType });
  container.appendChild(scrollEle);
  scrollEle.appendChild(content);
  if (offset) {
    scrollEle.style.overflow = "hidden";
    scrollEle.style.height = offset + "px";
  } else {
    scrollEle.style.maxHeight = container.style.maxHeight;
    container.style.overflow = "hidden";
  }
  var scrollObj;
  if (scrollType === "vscroll") {
    scrollObj = new VScroll({ enableRtl }, scrollEle);
    scrollObj.scrollStep = select(".e-" + scrollType + "-bar", container).offsetHeight / 2;
  } else {
    scrollObj = new HScroll({ enableRtl }, scrollEle);
    scrollObj.scrollStep = select(".e-" + scrollType + "-bar", container).offsetWidth;
  }
  return scrollEle;
}
function destroyScroll(scrollObj, element2, skipEle) {
  if (scrollObj) {
    var menu = select(".e-menu-parent", element2);
    if (menu) {
      if (!skipEle || skipEle === menu) {
        scrollObj.destroy();
        element2.parentElement.appendChild(menu);
        detach(element2);
      }
    } else {
      scrollObj.destroy();
      detach(element2);
    }
  }
}

// node_modules/@syncfusion/ej2-data/src/query.js
var Query = (
  /** @class */
  function() {
    function Query2(from) {
      this.subQuery = null;
      this.isChild = false;
      this.distincts = [];
      this.queries = [];
      this.key = "";
      this.fKey = "";
      if (typeof from === "string") {
        this.fromTable = from;
      } else if (from && from instanceof Array) {
        this.lookups = from;
      }
      this.expands = [];
      this.sortedColumns = [];
      this.groupedColumns = [];
      this.subQuery = null;
      this.isChild = false;
      this.params = [];
      this.lazyLoad = [];
      return this;
    }
    Query2.prototype.setKey = function(field) {
      this.key = field;
      return this;
    };
    Query2.prototype.using = function(dataManager) {
      this.dataManager = dataManager;
      return this;
    };
    Query2.prototype.execute = function(dataManager, done, fail, always) {
      dataManager = dataManager || this.dataManager;
      if (dataManager) {
        return dataManager.executeQuery(this, done, fail, always);
      }
      return DataUtil.throwError('Query - execute() : dataManager needs to be is set using "using" function or should be passed as argument');
    };
    Query2.prototype.executeLocal = function(dataManager) {
      dataManager = dataManager || this.dataManager;
      if (dataManager) {
        return dataManager.executeLocal(this);
      }
      return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using "using" function or should be passed as argument');
    };
    Query2.prototype.clone = function() {
      var cloned = new Query2();
      cloned.queries = this.queries.slice(0);
      cloned.key = this.key;
      cloned.isChild = this.isChild;
      cloned.dataManager = this.dataManager;
      cloned.fromTable = this.fromTable;
      cloned.params = this.params.slice(0);
      cloned.expands = this.expands.slice(0);
      cloned.sortedColumns = this.sortedColumns.slice(0);
      cloned.groupedColumns = this.groupedColumns.slice(0);
      cloned.subQuerySelector = this.subQuerySelector;
      cloned.subQuery = this.subQuery;
      cloned.fKey = this.fKey;
      cloned.isCountRequired = this.isCountRequired;
      cloned.distincts = this.distincts.slice(0);
      cloned.lazyLoad = this.lazyLoad.slice(0);
      return cloned;
    };
    Query2.prototype.from = function(tableName) {
      this.fromTable = tableName;
      return this;
    };
    Query2.prototype.addParams = function(key, value) {
      if (typeof value === "function") {
        this.params.push({ key, fn: value });
      } else {
        this.params.push({ key, value });
      }
      return this;
    };
    Query2.prototype.distinct = function(fields) {
      if (typeof fields === "string") {
        this.distincts = [].slice.call([fields], 0);
      } else {
        this.distincts = fields.slice(0);
      }
      return this;
    };
    Query2.prototype.expand = function(tables) {
      if (typeof tables === "string") {
        this.expands = [].slice.call([tables], 0);
      } else {
        this.expands = tables.slice(0);
      }
      return this;
    };
    Query2.prototype.where = function(fieldName, operator, value, ignoreCase, ignoreAccent, matchCase) {
      operator = operator ? operator.toLowerCase() : null;
      var predicate = null;
      if (typeof fieldName === "string") {
        predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent, matchCase);
      } else if (fieldName instanceof Predicate) {
        predicate = fieldName;
      }
      this.queries.push({
        fn: "onWhere",
        e: predicate
      });
      return this;
    };
    Query2.prototype.search = function(searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {
      if (typeof fieldNames === "string") {
        fieldNames = [fieldNames];
      }
      if (!operator || operator === "none") {
        operator = "contains";
      }
      var comparer = DataUtil.fnOperators[operator];
      this.queries.push({
        fn: "onSearch",
        e: {
          fieldNames,
          operator,
          searchKey,
          ignoreCase,
          ignoreAccent,
          comparer
        }
      });
      return this;
    };
    Query2.prototype.sortBy = function(fieldName, comparer, isFromGroup) {
      return this.sortByForeignKey(fieldName, comparer, isFromGroup);
    };
    Query2.prototype.sortByForeignKey = function(fieldName, comparer, isFromGroup, direction) {
      var order = !isNullOrUndefined(direction) ? direction : "ascending";
      var sorts;
      var temp;
      if (typeof fieldName === "string" && DataUtil.endsWith(fieldName.toLowerCase(), " desc")) {
        fieldName = fieldName.replace(/ desc$/i, "");
        comparer = "descending";
      }
      if (!comparer || typeof comparer === "string") {
        order = comparer ? comparer.toLowerCase() : "ascending";
        comparer = DataUtil.fnSort(comparer);
      }
      if (isFromGroup) {
        sorts = Query2.filterQueries(this.queries, "onSortBy");
        for (var i = 0; i < sorts.length; i++) {
          temp = sorts[i].e.fieldName;
          if (typeof temp === "string") {
            if (temp === fieldName) {
              return this;
            }
          } else if (temp instanceof Array) {
            for (var j = 0; j < temp.length; j++) {
              if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + " desc") {
                return this;
              }
            }
          }
        }
      }
      this.queries.push({
        fn: "onSortBy",
        e: {
          fieldName,
          comparer,
          direction: order
        }
      });
      return this;
    };
    Query2.prototype.sortByDesc = function(fieldName) {
      return this.sortBy(fieldName, "descending");
    };
    Query2.prototype.group = function(fieldName, fn, format) {
      this.sortBy(fieldName, null, true);
      this.queries.push({
        fn: "onGroup",
        e: {
          fieldName,
          comparer: fn ? fn : null,
          format: format ? format : null
        }
      });
      return this;
    };
    Query2.prototype.page = function(pageIndex, pageSize) {
      this.queries.push({
        fn: "onPage",
        e: {
          pageIndex,
          pageSize
        }
      });
      return this;
    };
    Query2.prototype.range = function(start, end) {
      this.queries.push({
        fn: "onRange",
        e: {
          start,
          end
        }
      });
      return this;
    };
    Query2.prototype.take = function(nos) {
      this.queries.push({
        fn: "onTake",
        e: {
          nos
        }
      });
      return this;
    };
    Query2.prototype.skip = function(nos) {
      this.queries.push({
        fn: "onSkip",
        e: { nos }
      });
      return this;
    };
    Query2.prototype.select = function(fieldNames) {
      if (typeof fieldNames === "string") {
        fieldNames = [].slice.call([fieldNames], 0);
      }
      this.queries.push({
        fn: "onSelect",
        e: { fieldNames }
      });
      return this;
    };
    Query2.prototype.hierarchy = function(query, selectorFn) {
      this.subQuerySelector = selectorFn;
      this.subQuery = query;
      return this;
    };
    Query2.prototype.foreignKey = function(key) {
      this.fKey = key;
      return this;
    };
    Query2.prototype.requiresCount = function() {
      this.isCountRequired = true;
      return this;
    };
    Query2.prototype.aggregate = function(type, field) {
      this.queries.push({
        fn: "onAggregates",
        e: { field, type }
      });
      return this;
    };
    Query2.filterQueries = function(queries, name) {
      return queries.filter(function(q) {
        return q.fn === name;
      });
    };
    Query2.filterQueryLists = function(queries, singles) {
      var filtered = queries.filter(function(q) {
        return singles.indexOf(q.fn) !== -1;
      });
      var res = {};
      for (var i = 0; i < filtered.length; i++) {
        if (!res[filtered[i].fn]) {
          res[filtered[i].fn] = filtered[i].e;
        }
      }
      return res;
    };
    return Query2;
  }()
);
var Predicate = (
  /** @class */
  function() {
    function Predicate2(field, operator, value, ignoreCase, ignoreAccent, matchCase) {
      if (ignoreCase === void 0) {
        ignoreCase = false;
      }
      this.ignoreAccent = false;
      this.isComplex = false;
      if (typeof field === "string") {
        this.field = field;
        this.operator = operator.toLowerCase();
        this.value = value;
        this.matchCase = matchCase;
        this.ignoreCase = ignoreCase;
        this.ignoreAccent = ignoreAccent;
        this.isComplex = false;
        this.comparer = DataUtil.fnOperators.processOperator(this.operator);
      } else if (field instanceof Predicate2 && value instanceof Predicate2 || value instanceof Array) {
        this.isComplex = true;
        this.condition = operator.toLowerCase();
        this.predicates = [field];
        this.matchCase = field.matchCase;
        this.ignoreCase = field.ignoreCase;
        this.ignoreAccent = field.ignoreAccent;
        if (value instanceof Array) {
          [].push.apply(this.predicates, value);
        } else {
          this.predicates.push(value);
        }
      }
      return this;
    }
    Predicate2.and = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "and");
    };
    Predicate2.prototype.and = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "and", ignoreCase, ignoreAccent);
    };
    Predicate2.or = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "or");
    };
    Predicate2.prototype.or = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "or", ignoreCase, ignoreAccent);
    };
    Predicate2.ornot = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "or not");
    };
    Predicate2.prototype.ornot = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "ornot", ignoreCase, ignoreAccent);
    };
    Predicate2.andnot = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "and not");
    };
    Predicate2.prototype.andnot = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "andnot", ignoreCase, ignoreAccent);
    };
    Predicate2.fromJson = function(json) {
      if (json instanceof Array) {
        var res = [];
        for (var i = 0, len = json.length; i < len; i++) {
          res.push(this.fromJSONData(json[i]));
        }
        return res;
      }
      var pred = json;
      return this.fromJSONData(pred);
    };
    Predicate2.prototype.validate = function(record) {
      var predicate = this.predicates ? this.predicates : [];
      var ret;
      var isAnd;
      if (!this.isComplex && this.comparer) {
        if (this.condition && this.condition.indexOf("not") !== -1) {
          this.condition = this.condition.split("not")[0] === "" ? void 0 : this.condition.split("not")[0];
          return !this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
        } else {
          return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
        }
      }
      if (this.condition && this.condition.indexOf("not") !== -1) {
        isAnd = this.condition.indexOf("and") !== -1;
      } else {
        isAnd = this.condition === "and";
      }
      for (var i = 0; i < predicate.length; i++) {
        if (i > 0 && this.condition && this.condition.indexOf("not") !== -1) {
          predicate[i].condition = predicate[i].condition ? predicate[i].condition + "not" : "not";
        }
        ret = predicate[i].validate(record);
        if (isAnd) {
          if (!ret) {
            return false;
          }
        } else {
          if (ret) {
            return true;
          }
        }
      }
      return isAnd;
    };
    Predicate2.prototype.toJson = function() {
      var predicates;
      var p;
      if (this.isComplex) {
        predicates = [];
        p = this.predicates;
        for (var i = 0; i < p.length; i++) {
          predicates.push(p[i].toJson());
        }
      }
      return {
        isComplex: this.isComplex,
        field: this.field,
        operator: this.operator,
        value: this.value,
        ignoreCase: this.ignoreCase,
        ignoreAccent: this.ignoreAccent,
        condition: this.condition,
        predicates,
        matchCase: this.matchCase
      };
    };
    Predicate2.combinePredicates = function(predicates, operator) {
      if (predicates.length === 1) {
        if (!(predicates[0] instanceof Array)) {
          return predicates[0];
        }
        predicates = predicates[0];
      }
      return new Predicate2(predicates[0], operator, predicates.slice(1));
    };
    Predicate2.combine = function(pred, field, operator, value, condition, ignoreCase, ignoreAccent) {
      if (field instanceof Predicate2) {
        return Predicate2[condition](pred, field);
      }
      if (typeof field === "string") {
        return Predicate2[condition](pred, new Predicate2(field, operator, value, ignoreCase, ignoreAccent));
      }
      return DataUtil.throwError("Predicate - " + condition + " : invalid arguments");
    };
    Predicate2.fromJSONData = function(json) {
      var preds = json.predicates || [];
      var len = preds.length;
      var predicates = [];
      var result;
      for (var i = 0; i < len; i++) {
        predicates.push(this.fromJSONData(preds[i]));
      }
      if (!json.isComplex) {
        result = new Predicate2(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);
      } else {
        result = new Predicate2(predicates[0], json.condition, predicates.slice(1));
      }
      return result;
    };
    return Predicate2;
  }()
);

// node_modules/@syncfusion/ej2-data/src/util.js
var consts = { GroupGuid: "{271bbba0-1ee7}" };
var DataUtil = (
  /** @class */
  function() {
    function DataUtil2() {
    }
    DataUtil2.getValue = function(value, inst) {
      if (typeof value === "function") {
        return value.call(inst || {});
      }
      return value;
    };
    DataUtil2.endsWith = function(input, substr) {
      return input.slice && input.slice(-substr.length) === substr;
    };
    DataUtil2.notEndsWith = function(input, substr) {
      return input.slice && input.slice(-substr.length) !== substr;
    };
    DataUtil2.startsWith = function(input, start) {
      return input.slice(0, start.length) === start;
    };
    DataUtil2.notStartsWith = function(input, start) {
      return input.slice(0, start.length) !== start;
    };
    DataUtil2.wildCard = function(input, pattern) {
      var asteriskSplit;
      var optionalSplit;
      if (pattern.indexOf("[") !== -1) {
        pattern = pattern.split("[").join("[[]");
      }
      if (pattern.indexOf("(") !== -1) {
        pattern = pattern.split("(").join("[(]");
      }
      if (pattern.indexOf(")") !== -1) {
        pattern = pattern.split(")").join("[)]");
      }
      if (pattern.indexOf("\\") !== -1) {
        pattern = pattern.split("\\").join("[\\\\]");
      }
      if (pattern.indexOf("*") !== -1) {
        if (pattern.charAt(0) !== "*") {
          pattern = "^" + pattern;
        }
        if (pattern.charAt(pattern.length - 1) !== "*") {
          pattern = pattern + "$";
        }
        asteriskSplit = pattern.split("*");
        for (var i = 0; i < asteriskSplit.length; i++) {
          if (asteriskSplit[i].indexOf(".") === -1) {
            asteriskSplit[i] = asteriskSplit[i] + ".*";
          } else {
            asteriskSplit[i] = asteriskSplit[i] + "*";
          }
        }
        pattern = asteriskSplit.join("");
      }
      if (pattern.indexOf("%3f") !== -1 || pattern.indexOf("?") !== -1) {
        optionalSplit = pattern.indexOf("%3f") !== -1 ? pattern.split("%3f") : pattern.split("?");
        pattern = optionalSplit.join(".");
      }
      var regexPattern = new RegExp(pattern, "g");
      return regexPattern.test(input);
    };
    DataUtil2.like = function(input, pattern) {
      if (pattern.indexOf("%") !== -1) {
        if (pattern.charAt(0) === "%" && pattern.lastIndexOf("%") < 2) {
          pattern = pattern.substring(1, pattern.length);
          return DataUtil2.startsWith(DataUtil2.toLowerCase(input), DataUtil2.toLowerCase(pattern));
        } else if (pattern.charAt(pattern.length - 1) === "%" && pattern.indexOf("%") > pattern.length - 3) {
          pattern = pattern.substring(0, pattern.length - 1);
          return DataUtil2.endsWith(DataUtil2.toLowerCase(input), DataUtil2.toLowerCase(pattern));
        } else if (pattern.lastIndexOf("%") !== pattern.indexOf("%") && pattern.lastIndexOf("%") > pattern.indexOf("%") + 1) {
          pattern = pattern.substring(pattern.indexOf("%") + 1, pattern.lastIndexOf("%"));
          return input.indexOf(pattern) !== -1;
        } else {
          return input.indexOf(pattern) !== -1;
        }
      } else {
        return false;
      }
    };
    DataUtil2.fnSort = function(order) {
      order = order ? DataUtil2.toLowerCase(order) : "ascending";
      if (order === "ascending") {
        return this.fnAscending;
      }
      return this.fnDescending;
    };
    DataUtil2.fnAscending = function(x, y) {
      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
        return -1;
      }
      if (y === null || y === void 0) {
        return -1;
      }
      if (typeof x === "string") {
        return x.localeCompare(y);
      }
      if (x === null || x === void 0) {
        return 1;
      }
      return x - y;
    };
    DataUtil2.fnDescending = function(x, y) {
      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
        return -1;
      }
      if (y === null || y === void 0) {
        return 1;
      }
      if (typeof x === "string") {
        return x.localeCompare(y) * -1;
      }
      if (x === null || x === void 0) {
        return -1;
      }
      return y - x;
    };
    DataUtil2.extractFields = function(obj, fields) {
      var newObj = {};
      for (var i = 0; i < fields.length; i++) {
        newObj = this.setValue(fields[i], this.getObject(fields[i], obj), newObj);
      }
      return newObj;
    };
    DataUtil2.select = function(jsonArray, fields) {
      var newData = [];
      for (var i = 0; i < jsonArray.length; i++) {
        newData.push(this.extractFields(jsonArray[i], fields));
      }
      return newData;
    };
    DataUtil2.group = function(jsonArray, field, aggregates, level, groupDs, format, isLazyLoad) {
      level = level || 1;
      var jsonData = jsonArray;
      var guid = "GroupGuid";
      if (jsonData.GroupGuid === consts[guid]) {
        var _loop_1 = function(j2) {
          if (!isNullOrUndefined(groupDs)) {
            var indx = -1;
            var temp = groupDs.filter(function(e) {
              return e.key === jsonData[j2].key;
            });
            indx = groupDs.indexOf(temp[0]);
            jsonData[j2].items = this_1.group(jsonData[j2].items, field, aggregates, jsonData.level + 1, groupDs[indx].items, format, isLazyLoad);
            jsonData[j2].count = groupDs[indx].count;
          } else {
            jsonData[j2].items = this_1.group(jsonData[j2].items, field, aggregates, jsonData.level + 1, null, format, isLazyLoad);
            jsonData[j2].count = jsonData[j2].items.length;
          }
        };
        var this_1 = this;
        for (var j = 0; j < jsonData.length; j++) {
          _loop_1(j);
        }
        jsonData.childLevels += 1;
        return jsonData;
      }
      var grouped = {};
      var groupedArray = [];
      groupedArray.GroupGuid = consts[guid];
      groupedArray.level = level;
      groupedArray.childLevels = 0;
      groupedArray.records = jsonData;
      var _loop_2 = function(i2) {
        var val = this_2.getVal(jsonData, i2, field);
        if (!isNullOrUndefined(format)) {
          val = format(val, field);
        }
        if (!grouped[val]) {
          grouped[val] = {
            key: val,
            count: 0,
            items: [],
            aggregates: {},
            field
          };
          groupedArray.push(grouped[val]);
          if (!isNullOrUndefined(groupDs)) {
            var tempObj = groupDs.filter(function(e) {
              return e.key === grouped[val].key;
            });
            grouped[val].count = tempObj[0].count;
          }
        }
        grouped[val].count = !isNullOrUndefined(groupDs) ? grouped[val].count : grouped[val].count += 1;
        if (!isLazyLoad || isLazyLoad && aggregates.length) {
          grouped[val].items.push(jsonData[i2]);
        }
      };
      var this_2 = this;
      for (var i = 0; i < jsonData.length; i++) {
        _loop_2(i);
      }
      if (aggregates && aggregates.length) {
        var _loop_3 = function(i2) {
          var res = {};
          var fn = void 0;
          var aggs = aggregates;
          for (var j2 = 0; j2 < aggregates.length; j2++) {
            fn = DataUtil2.aggregates[aggregates[j2].type];
            if (!isNullOrUndefined(groupDs)) {
              var temp = groupDs.filter(function(e) {
                return e.key === groupedArray[i2].key;
              });
              if (fn) {
                res[aggs[j2].field + " - " + aggs[j2].type] = fn(temp[0].items, aggs[j2].field);
              }
            } else {
              if (fn) {
                res[aggs[j2].field + " - " + aggs[j2].type] = fn(groupedArray[i2].items, aggs[j2].field);
              }
            }
          }
          groupedArray[i2].aggregates = res;
        };
        for (var i = 0; i < groupedArray.length; i++) {
          _loop_3(i);
        }
      }
      if (isLazyLoad && groupedArray.length && aggregates.length) {
        for (var i = 0; i < groupedArray.length; i++) {
          groupedArray[i].items = [];
        }
      }
      return jsonData.length && groupedArray || jsonData;
    };
    DataUtil2.buildHierarchy = function(fKey, from, source, lookup, pKey) {
      var i;
      var grp = {};
      var temp;
      if (lookup.result) {
        lookup = lookup.result;
      }
      if (lookup.GroupGuid) {
        this.throwError("DataManager: Do not have support Grouping in hierarchy");
      }
      for (i = 0; i < lookup.length; i++) {
        var fKeyData = this.getObject(fKey, lookup[i]);
        temp = grp[fKeyData] || (grp[fKeyData] = []);
        temp.push(lookup[i]);
      }
      for (i = 0; i < source.length; i++) {
        var fKeyData = this.getObject(pKey || fKey, source[i]);
        source[i][from] = grp[fKeyData];
      }
    };
    DataUtil2.getFieldList = function(obj, fields, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      if (fields === void 0 || fields === null) {
        return this.getFieldList(obj, [], prefix);
      }
      var copyObj = obj;
      var keys = Object.keys(obj);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var prop = keys_1[_i];
        if (typeof copyObj[prop] === "object" && !(copyObj[prop] instanceof Array)) {
          this.getFieldList(copyObj[prop], fields, prefix + prop + ".");
        } else {
          fields.push(prefix + prop);
        }
      }
      return fields;
    };
    DataUtil2.getObject = function(nameSpace, from) {
      if (!nameSpace) {
        return from;
      }
      if (!from) {
        return void 0;
      }
      if (nameSpace.indexOf(".") === -1) {
        var lowerCaseNameSpace = nameSpace.charAt(0).toLowerCase() + nameSpace.slice(1);
        var upperCaseNameSpace = nameSpace.charAt(0).toUpperCase() + nameSpace.slice(1);
        if (!isNullOrUndefined(from[nameSpace])) {
          return from[nameSpace];
        } else {
          if (!isNullOrUndefined(from[lowerCaseNameSpace])) {
            return from[lowerCaseNameSpace];
          } else if (!isNullOrUndefined(from[upperCaseNameSpace])) {
            return from[upperCaseNameSpace];
          } else {
            return null;
          }
        }
      }
      var value = from;
      var splits = nameSpace.split(".");
      for (var i = 0; i < splits.length; i++) {
        if (value == null) {
          break;
        }
        value = value[splits[i]];
        if (value === void 0) {
          var casing = splits[i].charAt(0).toUpperCase() + splits[i].slice(1);
          value = from[casing] || from[casing.charAt(0).toLowerCase() + casing.slice(1)] || null;
        }
        from = value;
      }
      return value;
    };
    DataUtil2.setValue = function(nameSpace, value, obj) {
      var keys = nameSpace.toString().split(".");
      var start = obj || {};
      var fromObj = start;
      var i;
      var length = keys.length;
      var key;
      for (i = 0; i < length; i++) {
        key = keys[i];
        if (i + 1 === length) {
          fromObj[key] = value === void 0 ? void 0 : value;
        } else if (isNullOrUndefined(fromObj[key])) {
          fromObj[key] = {};
        }
        fromObj = fromObj[key];
      }
      return start;
    };
    DataUtil2.sort = function(ds, field, comparer) {
      if (ds.length <= 1) {
        return ds;
      }
      var middle = parseInt((ds.length / 2).toString(), 10);
      var left = ds.slice(0, middle);
      var right = ds.slice(middle);
      left = this.sort(left, field, comparer);
      right = this.sort(right, field, comparer);
      return this.merge(left, right, field, comparer);
    };
    DataUtil2.ignoreDiacritics = function(value) {
      if (typeof value !== "string") {
        return value;
      }
      var result = value.split("");
      var newValue = result.map(function(temp) {
        return temp in DataUtil2.diacritics ? DataUtil2.diacritics[temp] : temp;
      });
      return newValue.join("");
    };
    DataUtil2.merge = function(left, right, fieldName, comparer) {
      var result = [];
      var current;
      while (left.length > 0 || right.length > 0) {
        if (left.length > 0 && right.length > 0) {
          if (comparer) {
            current = comparer(this.getVal(left, 0, fieldName), this.getVal(right, 0, fieldName), left[0], right[0]) <= 0 ? left : right;
          } else {
            current = left[0][fieldName] < left[0][fieldName] ? left : right;
          }
        } else {
          current = left.length > 0 ? left : right;
        }
        result.push(current.shift());
      }
      return result;
    };
    DataUtil2.getVal = function(array, index, field) {
      return field ? this.getObject(field, array[index]) : array[index];
    };
    DataUtil2.toLowerCase = function(val) {
      return val ? typeof val === "string" ? val.toLowerCase() : val.toString() : val === 0 || val === false ? val.toString() : "";
    };
    DataUtil2.callAdaptorFunction = function(adaptor, fnName, param1, param2) {
      if (fnName in adaptor) {
        var res = adaptor[fnName](param1, param2);
        if (!isNullOrUndefined(res)) {
          param1 = res;
        }
      }
      return param1;
    };
    DataUtil2.getAddParams = function(adp, dm, query) {
      var req = {};
      DataUtil2.callAdaptorFunction(adp, "addParams", {
        dm,
        query,
        params: query.params,
        reqParams: req
      });
      return req;
    };
    DataUtil2.isPlainObject = function(obj) {
      return !!obj && obj.constructor === Object;
    };
    DataUtil2.isCors = function() {
      var xhr = null;
      var request = "XMLHttpRequest";
      try {
        xhr = new window[request]();
      } catch (e) {
      }
      return !!xhr && "withCredentials" in xhr;
    };
    DataUtil2.getGuid = function(prefix) {
      var hexs = "0123456789abcdef";
      var rand;
      return (prefix || "") + "00000000-0000-4000-0000-000000000000".replace(/0/g, function(val, i) {
        if ("crypto" in window && "getRandomValues" in crypto) {
          var arr = new Uint8Array(1);
          window.crypto.getRandomValues(arr);
          rand = arr[0] % 16 | 0;
        } else {
          rand = Math.random() * 16 | 0;
        }
        return hexs[i === 19 ? rand & 3 | 8 : rand];
      });
    };
    DataUtil2.isNull = function(val) {
      return val === void 0 || val === null;
    };
    DataUtil2.getItemFromComparer = function(array, field, comparer) {
      var keyVal;
      var current;
      var key;
      var i = 0;
      var castRequired = typeof DataUtil2.getVal(array, 0, field) === "string";
      if (array.length) {
        while (isNullOrUndefined(keyVal) && i < array.length) {
          keyVal = DataUtil2.getVal(array, i, field);
          key = array[i++];
        }
      }
      for (; i < array.length; i++) {
        current = DataUtil2.getVal(array, i, field);
        if (isNullOrUndefined(current)) {
          continue;
        }
        if (castRequired) {
          keyVal = +keyVal;
          current = +current;
        }
        if (comparer(keyVal, current) > 0) {
          keyVal = current;
          key = array[i];
        }
      }
      return key;
    };
    DataUtil2.distinct = function(json, fieldName, requiresCompleteRecord) {
      requiresCompleteRecord = isNullOrUndefined(requiresCompleteRecord) ? false : requiresCompleteRecord;
      var result = [];
      var val;
      var tmp = {};
      json.forEach(function(data, index) {
        val = typeof json[index] === "object" ? DataUtil2.getVal(json, index, fieldName) : json[index];
        if (!(val in tmp)) {
          result.push(!requiresCompleteRecord ? val : json[index]);
          tmp[val] = 1;
        }
      });
      return result;
    };
    DataUtil2.processData = function(dm, records) {
      var query = this.prepareQuery(dm);
      var sampledata = new DataManager(records);
      if (dm.requiresCounts) {
        query.requiresCount();
      }
      var result = sampledata.executeLocal(query);
      var returnValue = {
        result: dm.requiresCounts ? result.result : result,
        count: result.count,
        aggregates: JSON.stringify(result.aggregates)
      };
      return dm.requiresCounts ? returnValue : result;
    };
    DataUtil2.prepareQuery = function(dm) {
      var _this = this;
      var query = new Query();
      if (dm.select) {
        query.select(dm.select);
      }
      if (dm.where) {
        var where = DataUtil2.parse.parseJson(dm.where);
        where.filter(function(pred) {
          if (isNullOrUndefined(pred.condition)) {
            query.where(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent);
          } else {
            var predicateList = [];
            if (pred.field) {
              predicateList.push(new Predicate(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent));
            } else {
              predicateList = predicateList.concat(_this.getPredicate(pred.predicates));
            }
            if (pred.condition === "or") {
              query.where(Predicate.or(predicateList));
            } else if (pred.condition === "and") {
              query.where(Predicate.and(predicateList));
            }
          }
        });
      }
      if (dm.search) {
        var search = DataUtil2.parse.parseJson(dm.search);
        search.filter(function(e) {
          return query.search(
            e.key,
            e.fields,
            e["operator"],
            // tslint:disable-next-line:no-string-literal
            e["ignoreCase"],
            e["ignoreAccent"]
          );
        });
      }
      if (dm.aggregates) {
        dm.aggregates.filter(function(e) {
          return query.aggregate(e.type, e.field);
        });
      }
      if (dm.sorted) {
        dm.sorted.filter(function(e) {
          return query.sortBy(e.name, e.direction);
        });
      }
      if (dm.skip) {
        query.skip(dm.skip);
      }
      if (dm.take) {
        query.take(dm.take);
      }
      if (dm.group) {
        dm.group.filter(function(grp) {
          return query.group(grp);
        });
      }
      return query;
    };
    DataUtil2.getPredicate = function(pred) {
      var mainPred = [];
      for (var i = 0; i < pred.length; i++) {
        var e = pred[i];
        if (e.field) {
          mainPred.push(new Predicate(e.field, e.operator, e.value, e.ignoreCase, e.ignoreAccent));
        } else {
          var childPred = [];
          var cpre = this.getPredicate(e.predicates);
          for (var _i = 0, _a = Object.keys(cpre); _i < _a.length; _i++) {
            var prop = _a[_i];
            childPred.push(cpre[prop]);
          }
          mainPred.push(e.condition === "or" ? Predicate.or(childPred) : Predicate.and(childPred));
        }
      }
      return mainPred;
    };
    DataUtil2.serverTimezoneOffset = null;
    DataUtil2.timeZoneHandling = true;
    DataUtil2.throwError = function(error) {
      try {
        throw new Error(error);
      } catch (e) {
        throw e.message + "\n" + e.stack;
      }
    };
    DataUtil2.aggregates = {
      /**
       * Calculate sum of the given field in the data.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      sum: function(ds, field) {
        var result = 0;
        var val;
        var castRequired = typeof DataUtil2.getVal(ds, 0, field) !== "number";
        for (var i = 0; i < ds.length; i++) {
          val = DataUtil2.getVal(ds, i, field);
          if (!isNaN(val) && val !== null) {
            if (castRequired) {
              val = +val;
            }
            result += val;
          }
        }
        return result;
      },
      /**
       * Calculate average value of the given field in the data.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      average: function(ds, field) {
        return DataUtil2.aggregates.sum(ds, field) / ds.length;
      },
      /**
       * Returns the min value of the data based on the field.
       *
       * @param  {Object[]} ds
       * @param  {string|Function} field
       */
      min: function(ds, field) {
        var comparer;
        if (typeof field === "function") {
          comparer = field;
          field = null;
        }
        return DataUtil2.getObject(field, DataUtil2.getItemFromComparer(ds, field, comparer || DataUtil2.fnAscending));
      },
      /**
       * Returns the max value of the data based on the field.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       * @returns number
       */
      max: function(ds, field) {
        var comparer;
        if (typeof field === "function") {
          comparer = field;
          field = null;
        }
        return DataUtil2.getObject(field, DataUtil2.getItemFromComparer(ds, field, comparer || DataUtil2.fnDescending));
      },
      /**
       * Returns the total number of true value present in the data based on the given boolean field name.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      truecount: function(ds, field) {
        return new DataManager(ds).executeLocal(new Query().where(field, "equal", true, true)).length;
      },
      /**
       * Returns the total number of false value present in the data based on the given boolean field name.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      falsecount: function(ds, field) {
        return new DataManager(ds).executeLocal(new Query().where(field, "equal", false, true)).length;
      },
      /**
       * Returns the length of the given data.
       *
       * @param {Object[]} ds
       * @param {string} field?
       * @param field
       * @returns number
       */
      count: function(ds, field) {
        return ds.length;
      }
    };
    DataUtil2.operatorSymbols = {
      "<": "lessthan",
      ">": "greaterthan",
      "<=": "lessthanorequal",
      ">=": "greaterthanorequal",
      "==": "equal",
      "!=": "notequal",
      "*=": "contains",
      "$=": "endswith",
      "^=": "startswith"
    };
    DataUtil2.odBiOperator = {
      "<": " lt ",
      ">": " gt ",
      "<=": " le ",
      ">=": " ge ",
      "==": " eq ",
      "!=": " ne ",
      "lessthan": " lt ",
      "lessthanorequal": " le ",
      "greaterthan": " gt ",
      "greaterthanorequal": " ge ",
      "equal": " eq ",
      "notequal": " ne "
    };
    DataUtil2.odUniOperator = {
      "$=": "endswith",
      "^=": "startswith",
      "*=": "substringof",
      "endswith": "endswith",
      "startswith": "startswith",
      "contains": "substringof",
      "doesnotendwith": "not endswith",
      "doesnotstartwith": "not startswith",
      "doesnotcontain": "not substringof",
      "wildcard": "wildcard",
      "like": "like"
    };
    DataUtil2.odv4UniOperator = {
      "$=": "endswith",
      "^=": "startswith",
      "*=": "contains",
      "endswith": "endswith",
      "startswith": "startswith",
      "contains": "contains",
      "doesnotendwith": "not endswith",
      "doesnotstartwith": "not startswith",
      "doesnotcontain": "not contains",
      "wildcard": "wildcard",
      "like": "like"
    };
    DataUtil2.diacritics = {
      "Ⓐ": "A",
      "Ａ": "A",
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ầ": "A",
      "Ấ": "A",
      "Ẫ": "A",
      "Ẩ": "A",
      "Ã": "A",
      "Ā": "A",
      "Ă": "A",
      "Ằ": "A",
      "Ắ": "A",
      "Ẵ": "A",
      "Ẳ": "A",
      "Ȧ": "A",
      "Ǡ": "A",
      "Ä": "A",
      "Ǟ": "A",
      "Ả": "A",
      "Å": "A",
      "Ǻ": "A",
      "Ǎ": "A",
      "Ȁ": "A",
      "Ȃ": "A",
      "Ạ": "A",
      "Ậ": "A",
      "Ặ": "A",
      "Ḁ": "A",
      "Ą": "A",
      "Ⱥ": "A",
      "Ɐ": "A",
      "Ꜳ": "AA",
      "Æ": "AE",
      "Ǽ": "AE",
      "Ǣ": "AE",
      "Ꜵ": "AO",
      "Ꜷ": "AU",
      "Ꜹ": "AV",
      "Ꜻ": "AV",
      "Ꜽ": "AY",
      "Ⓑ": "B",
      "Ｂ": "B",
      "Ḃ": "B",
      "Ḅ": "B",
      "Ḇ": "B",
      "Ƀ": "B",
      "Ƃ": "B",
      "Ɓ": "B",
      "Ⓒ": "C",
      "Ｃ": "C",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "Ç": "C",
      "Ḉ": "C",
      "Ƈ": "C",
      "Ȼ": "C",
      "Ꜿ": "C",
      "Ⓓ": "D",
      "Ｄ": "D",
      "Ḋ": "D",
      "Ď": "D",
      "Ḍ": "D",
      "Ḑ": "D",
      "Ḓ": "D",
      "Ḏ": "D",
      "Đ": "D",
      "Ƌ": "D",
      "Ɗ": "D",
      "Ɖ": "D",
      "Ꝺ": "D",
      "Ǳ": "DZ",
      "Ǆ": "DZ",
      "ǲ": "Dz",
      "ǅ": "Dz",
      "Ⓔ": "E",
      "Ｅ": "E",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ề": "E",
      "Ế": "E",
      "Ễ": "E",
      "Ể": "E",
      "Ẽ": "E",
      "Ē": "E",
      "Ḕ": "E",
      "Ḗ": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ë": "E",
      "Ẻ": "E",
      "Ě": "E",
      "Ȅ": "E",
      "Ȇ": "E",
      "Ẹ": "E",
      "Ệ": "E",
      "Ȩ": "E",
      "Ḝ": "E",
      "Ę": "E",
      "Ḙ": "E",
      "Ḛ": "E",
      "Ɛ": "E",
      "Ǝ": "E",
      "Ⓕ": "F",
      "Ｆ": "F",
      "Ḟ": "F",
      "Ƒ": "F",
      "Ꝼ": "F",
      "Ⓖ": "G",
      "Ｇ": "G",
      "Ǵ": "G",
      "Ĝ": "G",
      "Ḡ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ǧ": "G",
      "Ģ": "G",
      "Ǥ": "G",
      "Ɠ": "G",
      "Ꞡ": "G",
      "Ᵹ": "G",
      "Ꝿ": "G",
      "Ⓗ": "H",
      "Ｈ": "H",
      "Ĥ": "H",
      "Ḣ": "H",
      "Ḧ": "H",
      "Ȟ": "H",
      "Ḥ": "H",
      "Ḩ": "H",
      "Ḫ": "H",
      "Ħ": "H",
      "Ⱨ": "H",
      "Ⱶ": "H",
      "Ɥ": "H",
      "Ⓘ": "I",
      "Ｉ": "I",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "İ": "I",
      "Ï": "I",
      "Ḯ": "I",
      "Ỉ": "I",
      "Ǐ": "I",
      "Ȉ": "I",
      "Ȋ": "I",
      "Ị": "I",
      "Į": "I",
      "Ḭ": "I",
      "Ɨ": "I",
      "Ⓙ": "J",
      "Ｊ": "J",
      "Ĵ": "J",
      "Ɉ": "J",
      "Ⓚ": "K",
      "Ｋ": "K",
      "Ḱ": "K",
      "Ǩ": "K",
      "Ḳ": "K",
      "Ķ": "K",
      "Ḵ": "K",
      "Ƙ": "K",
      "Ⱪ": "K",
      "Ꝁ": "K",
      "Ꝃ": "K",
      "Ꝅ": "K",
      "Ꞣ": "K",
      "Ⓛ": "L",
      "Ｌ": "L",
      "Ŀ": "L",
      "Ĺ": "L",
      "Ľ": "L",
      "Ḷ": "L",
      "Ḹ": "L",
      "Ļ": "L",
      "Ḽ": "L",
      "Ḻ": "L",
      "Ł": "L",
      "Ƚ": "L",
      "Ɫ": "L",
      "Ⱡ": "L",
      "Ꝉ": "L",
      "Ꝇ": "L",
      "Ꞁ": "L",
      "Ǉ": "LJ",
      "ǈ": "Lj",
      "Ⓜ": "M",
      "Ｍ": "M",
      "Ḿ": "M",
      "Ṁ": "M",
      "Ṃ": "M",
      "Ɱ": "M",
      "Ɯ": "M",
      "Ⓝ": "N",
      "Ｎ": "N",
      "Ǹ": "N",
      "Ń": "N",
      "Ñ": "N",
      "Ṅ": "N",
      "Ň": "N",
      "Ṇ": "N",
      "Ņ": "N",
      "Ṋ": "N",
      "Ṉ": "N",
      "Ƞ": "N",
      "Ɲ": "N",
      "Ꞑ": "N",
      "Ꞥ": "N",
      "Ǌ": "NJ",
      "ǋ": "Nj",
      "Ⓞ": "O",
      "Ｏ": "O",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Ồ": "O",
      "Ố": "O",
      "Ỗ": "O",
      "Ổ": "O",
      "Õ": "O",
      "Ṍ": "O",
      "Ȭ": "O",
      "Ṏ": "O",
      "Ō": "O",
      "Ṑ": "O",
      "Ṓ": "O",
      "Ŏ": "O",
      "Ȯ": "O",
      "Ȱ": "O",
      "Ö": "O",
      "Ȫ": "O",
      "Ỏ": "O",
      "Ő": "O",
      "Ǒ": "O",
      "Ȍ": "O",
      "Ȏ": "O",
      "Ơ": "O",
      "Ờ": "O",
      "Ớ": "O",
      "Ỡ": "O",
      "Ở": "O",
      "Ợ": "O",
      "Ọ": "O",
      "Ộ": "O",
      "Ǫ": "O",
      "Ǭ": "O",
      "Ø": "O",
      "Ǿ": "O",
      "Ɔ": "O",
      "Ɵ": "O",
      "Ꝋ": "O",
      "Ꝍ": "O",
      "Ƣ": "OI",
      "Ꝏ": "OO",
      "Ȣ": "OU",
      "Ⓟ": "P",
      "Ｐ": "P",
      "Ṕ": "P",
      "Ṗ": "P",
      "Ƥ": "P",
      "Ᵽ": "P",
      "Ꝑ": "P",
      "Ꝓ": "P",
      "Ꝕ": "P",
      "Ⓠ": "Q",
      "Ｑ": "Q",
      "Ꝗ": "Q",
      "Ꝙ": "Q",
      "Ɋ": "Q",
      "Ⓡ": "R",
      "Ｒ": "R",
      "Ŕ": "R",
      "Ṙ": "R",
      "Ř": "R",
      "Ȑ": "R",
      "Ȓ": "R",
      "Ṛ": "R",
      "Ṝ": "R",
      "Ŗ": "R",
      "Ṟ": "R",
      "Ɍ": "R",
      "Ɽ": "R",
      "Ꝛ": "R",
      "Ꞧ": "R",
      "Ꞃ": "R",
      "Ⓢ": "S",
      "Ｓ": "S",
      "ẞ": "S",
      "Ś": "S",
      "Ṥ": "S",
      "Ŝ": "S",
      "Ṡ": "S",
      "Š": "S",
      "Ṧ": "S",
      "Ṣ": "S",
      "Ṩ": "S",
      "Ș": "S",
      "Ş": "S",
      "Ȿ": "S",
      "Ꞩ": "S",
      "Ꞅ": "S",
      "Ⓣ": "T",
      "Ｔ": "T",
      "Ṫ": "T",
      "Ť": "T",
      "Ṭ": "T",
      "Ț": "T",
      "Ţ": "T",
      "Ṱ": "T",
      "Ṯ": "T",
      "Ŧ": "T",
      "Ƭ": "T",
      "Ʈ": "T",
      "Ⱦ": "T",
      "Ꞇ": "T",
      "Ꜩ": "TZ",
      "Ⓤ": "U",
      "Ｕ": "U",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ũ": "U",
      "Ṹ": "U",
      "Ū": "U",
      "Ṻ": "U",
      "Ŭ": "U",
      "Ü": "U",
      "Ǜ": "U",
      "Ǘ": "U",
      "Ǖ": "U",
      "Ǚ": "U",
      "Ủ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ǔ": "U",
      "Ȕ": "U",
      "Ȗ": "U",
      "Ư": "U",
      "Ừ": "U",
      "Ứ": "U",
      "Ữ": "U",
      "Ử": "U",
      "Ự": "U",
      "Ụ": "U",
      "Ṳ": "U",
      "Ų": "U",
      "Ṷ": "U",
      "Ṵ": "U",
      "Ʉ": "U",
      "Ⓥ": "V",
      "Ｖ": "V",
      "Ṽ": "V",
      "Ṿ": "V",
      "Ʋ": "V",
      "Ꝟ": "V",
      "Ʌ": "V",
      "Ꝡ": "VY",
      "Ⓦ": "W",
      "Ｗ": "W",
      "Ẁ": "W",
      "Ẃ": "W",
      "Ŵ": "W",
      "Ẇ": "W",
      "Ẅ": "W",
      "Ẉ": "W",
      "Ⱳ": "W",
      "Ⓧ": "X",
      "Ｘ": "X",
      "Ẋ": "X",
      "Ẍ": "X",
      "Ⓨ": "Y",
      "Ｙ": "Y",
      "Ỳ": "Y",
      "Ý": "Y",
      "Ŷ": "Y",
      "Ỹ": "Y",
      "Ȳ": "Y",
      "Ẏ": "Y",
      "Ÿ": "Y",
      "Ỷ": "Y",
      "Ỵ": "Y",
      "Ƴ": "Y",
      "Ɏ": "Y",
      "Ỿ": "Y",
      "Ⓩ": "Z",
      "Ｚ": "Z",
      "Ź": "Z",
      "Ẑ": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "Ẓ": "Z",
      "Ẕ": "Z",
      "Ƶ": "Z",
      "Ȥ": "Z",
      "Ɀ": "Z",
      "Ⱬ": "Z",
      "Ꝣ": "Z",
      "ⓐ": "a",
      "ａ": "a",
      "ẚ": "a",
      "à": "a",
      "á": "a",
      "â": "a",
      "ầ": "a",
      "ấ": "a",
      "ẫ": "a",
      "ẩ": "a",
      "ã": "a",
      "ā": "a",
      "ă": "a",
      "ằ": "a",
      "ắ": "a",
      "ẵ": "a",
      "ẳ": "a",
      "ȧ": "a",
      "ǡ": "a",
      "ä": "a",
      "ǟ": "a",
      "ả": "a",
      "å": "a",
      "ǻ": "a",
      "ǎ": "a",
      "ȁ": "a",
      "ȃ": "a",
      "ạ": "a",
      "ậ": "a",
      "ặ": "a",
      "ḁ": "a",
      "ą": "a",
      "ⱥ": "a",
      "ɐ": "a",
      "ꜳ": "aa",
      "æ": "ae",
      "ǽ": "ae",
      "ǣ": "ae",
      "ꜵ": "ao",
      "ꜷ": "au",
      "ꜹ": "av",
      "ꜻ": "av",
      "ꜽ": "ay",
      "ⓑ": "b",
      "ｂ": "b",
      "ḃ": "b",
      "ḅ": "b",
      "ḇ": "b",
      "ƀ": "b",
      "ƃ": "b",
      "ɓ": "b",
      "ⓒ": "c",
      "ｃ": "c",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "ç": "c",
      "ḉ": "c",
      "ƈ": "c",
      "ȼ": "c",
      "ꜿ": "c",
      "ↄ": "c",
      "ⓓ": "d",
      "ｄ": "d",
      "ḋ": "d",
      "ď": "d",
      "ḍ": "d",
      "ḑ": "d",
      "ḓ": "d",
      "ḏ": "d",
      "đ": "d",
      "ƌ": "d",
      "ɖ": "d",
      "ɗ": "d",
      "ꝺ": "d",
      "ǳ": "dz",
      "ǆ": "dz",
      "ⓔ": "e",
      "ｅ": "e",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ề": "e",
      "ế": "e",
      "ễ": "e",
      "ể": "e",
      "ẽ": "e",
      "ē": "e",
      "ḕ": "e",
      "ḗ": "e",
      "ĕ": "e",
      "ė": "e",
      "ë": "e",
      "ẻ": "e",
      "ě": "e",
      "ȅ": "e",
      "ȇ": "e",
      "ẹ": "e",
      "ệ": "e",
      "ȩ": "e",
      "ḝ": "e",
      "ę": "e",
      "ḙ": "e",
      "ḛ": "e",
      "ɇ": "e",
      "ɛ": "e",
      "ǝ": "e",
      "ⓕ": "f",
      "ｆ": "f",
      "ḟ": "f",
      "ƒ": "f",
      "ꝼ": "f",
      "ⓖ": "g",
      "ｇ": "g",
      "ǵ": "g",
      "ĝ": "g",
      "ḡ": "g",
      "ğ": "g",
      "ġ": "g",
      "ǧ": "g",
      "ģ": "g",
      "ǥ": "g",
      "ɠ": "g",
      "ꞡ": "g",
      "ᵹ": "g",
      "ꝿ": "g",
      "ⓗ": "h",
      "ｈ": "h",
      "ĥ": "h",
      "ḣ": "h",
      "ḧ": "h",
      "ȟ": "h",
      "ḥ": "h",
      "ḩ": "h",
      "ḫ": "h",
      "ẖ": "h",
      "ħ": "h",
      "ⱨ": "h",
      "ⱶ": "h",
      "ɥ": "h",
      "ƕ": "hv",
      "ⓘ": "i",
      "ｉ": "i",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "ï": "i",
      "ḯ": "i",
      "ỉ": "i",
      "ǐ": "i",
      "ȉ": "i",
      "ȋ": "i",
      "ị": "i",
      "į": "i",
      "ḭ": "i",
      "ɨ": "i",
      "ı": "i",
      "ⓙ": "j",
      "ｊ": "j",
      "ĵ": "j",
      "ǰ": "j",
      "ɉ": "j",
      "ⓚ": "k",
      "ｋ": "k",
      "ḱ": "k",
      "ǩ": "k",
      "ḳ": "k",
      "ķ": "k",
      "ḵ": "k",
      "ƙ": "k",
      "ⱪ": "k",
      "ꝁ": "k",
      "ꝃ": "k",
      "ꝅ": "k",
      "ꞣ": "k",
      "ⓛ": "l",
      "ｌ": "l",
      "ŀ": "l",
      "ĺ": "l",
      "ľ": "l",
      "ḷ": "l",
      "ḹ": "l",
      "ļ": "l",
      "ḽ": "l",
      "ḻ": "l",
      "ſ": "l",
      "ł": "l",
      "ƚ": "l",
      "ɫ": "l",
      "ⱡ": "l",
      "ꝉ": "l",
      "ꞁ": "l",
      "ꝇ": "l",
      "ǉ": "lj",
      "ⓜ": "m",
      "ｍ": "m",
      "ḿ": "m",
      "ṁ": "m",
      "ṃ": "m",
      "ɱ": "m",
      "ɯ": "m",
      "ⓝ": "n",
      "ｎ": "n",
      "ǹ": "n",
      "ń": "n",
      "ñ": "n",
      "ṅ": "n",
      "ň": "n",
      "ṇ": "n",
      "ņ": "n",
      "ṋ": "n",
      "ṉ": "n",
      "ƞ": "n",
      "ɲ": "n",
      "ŉ": "n",
      "ꞑ": "n",
      "ꞥ": "n",
      "ǌ": "nj",
      "ⓞ": "o",
      "ｏ": "o",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "ồ": "o",
      "ố": "o",
      "ỗ": "o",
      "ổ": "o",
      "õ": "o",
      "ṍ": "o",
      "ȭ": "o",
      "ṏ": "o",
      "ō": "o",
      "ṑ": "o",
      "ṓ": "o",
      "ŏ": "o",
      "ȯ": "o",
      "ȱ": "o",
      "ö": "o",
      "ȫ": "o",
      "ỏ": "o",
      "ő": "o",
      "ǒ": "o",
      "ȍ": "o",
      "ȏ": "o",
      "ơ": "o",
      "ờ": "o",
      "ớ": "o",
      "ỡ": "o",
      "ở": "o",
      "ợ": "o",
      "ọ": "o",
      "ộ": "o",
      "ǫ": "o",
      "ǭ": "o",
      "ø": "o",
      "ǿ": "o",
      "ɔ": "o",
      "ꝋ": "o",
      "ꝍ": "o",
      "ɵ": "o",
      "ƣ": "oi",
      "ȣ": "ou",
      "ꝏ": "oo",
      "ⓟ": "p",
      "ｐ": "p",
      "ṕ": "p",
      "ṗ": "p",
      "ƥ": "p",
      "ᵽ": "p",
      "ꝑ": "p",
      "ꝓ": "p",
      "ꝕ": "p",
      "ⓠ": "q",
      "ｑ": "q",
      "ɋ": "q",
      "ꝗ": "q",
      "ꝙ": "q",
      "ⓡ": "r",
      "ｒ": "r",
      "ŕ": "r",
      "ṙ": "r",
      "ř": "r",
      "ȑ": "r",
      "ȓ": "r",
      "ṛ": "r",
      "ṝ": "r",
      "ŗ": "r",
      "ṟ": "r",
      "ɍ": "r",
      "ɽ": "r",
      "ꝛ": "r",
      "ꞧ": "r",
      "ꞃ": "r",
      "ⓢ": "s",
      "ｓ": "s",
      "ß": "s",
      "ś": "s",
      "ṥ": "s",
      "ŝ": "s",
      "ṡ": "s",
      "š": "s",
      "ṧ": "s",
      "ṣ": "s",
      "ṩ": "s",
      "ș": "s",
      "ş": "s",
      "ȿ": "s",
      "ꞩ": "s",
      "ꞅ": "s",
      "ẛ": "s",
      "ⓣ": "t",
      "ｔ": "t",
      "ṫ": "t",
      "ẗ": "t",
      "ť": "t",
      "ṭ": "t",
      "ț": "t",
      "ţ": "t",
      "ṱ": "t",
      "ṯ": "t",
      "ŧ": "t",
      "ƭ": "t",
      "ʈ": "t",
      "ⱦ": "t",
      "ꞇ": "t",
      "ꜩ": "tz",
      "ⓤ": "u",
      "ｕ": "u",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ũ": "u",
      "ṹ": "u",
      "ū": "u",
      "ṻ": "u",
      "ŭ": "u",
      "ü": "u",
      "ǜ": "u",
      "ǘ": "u",
      "ǖ": "u",
      "ǚ": "u",
      "ủ": "u",
      "ů": "u",
      "ű": "u",
      "ǔ": "u",
      "ȕ": "u",
      "ȗ": "u",
      "ư": "u",
      "ừ": "u",
      "ứ": "u",
      "ữ": "u",
      "ử": "u",
      "ự": "u",
      "ụ": "u",
      "ṳ": "u",
      "ų": "u",
      "ṷ": "u",
      "ṵ": "u",
      "ʉ": "u",
      "ⓥ": "v",
      "ｖ": "v",
      "ṽ": "v",
      "ṿ": "v",
      "ʋ": "v",
      "ꝟ": "v",
      "ʌ": "v",
      "ꝡ": "vy",
      "ⓦ": "w",
      "ｗ": "w",
      "ẁ": "w",
      "ẃ": "w",
      "ŵ": "w",
      "ẇ": "w",
      "ẅ": "w",
      "ẘ": "w",
      "ẉ": "w",
      "ⱳ": "w",
      "ⓧ": "x",
      "ｘ": "x",
      "ẋ": "x",
      "ẍ": "x",
      "ⓨ": "y",
      "ｙ": "y",
      "ỳ": "y",
      "ý": "y",
      "ŷ": "y",
      "ỹ": "y",
      "ȳ": "y",
      "ẏ": "y",
      "ÿ": "y",
      "ỷ": "y",
      "ẙ": "y",
      "ỵ": "y",
      "ƴ": "y",
      "ɏ": "y",
      "ỿ": "y",
      "ⓩ": "z",
      "ｚ": "z",
      "ź": "z",
      "ẑ": "z",
      "ż": "z",
      "ž": "z",
      "ẓ": "z",
      "ẕ": "z",
      "ƶ": "z",
      "ȥ": "z",
      "ɀ": "z",
      "ⱬ": "z",
      "ꝣ": "z",
      "Ά": "Α",
      "Έ": "Ε",
      "Ή": "Η",
      "Ί": "Ι",
      "Ϊ": "Ι",
      "Ό": "Ο",
      "Ύ": "Υ",
      "Ϋ": "Υ",
      "Ώ": "Ω",
      "ά": "α",
      "έ": "ε",
      "ή": "η",
      "ί": "ι",
      "ϊ": "ι",
      "ΐ": "ι",
      "ό": "ο",
      "ύ": "υ",
      "ϋ": "υ",
      "ΰ": "υ",
      "ω": "ω",
      "ς": "σ"
    };
    DataUtil2.fnOperators = {
      /**
       * Returns true when the actual input is equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param {boolean} ignoreAccent?
       * @param ignoreCase
       * @param ignoreAccent
       */
      equal: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) === DataUtil2.toLowerCase(expected);
        }
        return actual === expected;
      },
      /**
       * Returns true when the actual input is not equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      notequal: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        return !DataUtil2.fnOperators.equal(actual, expected, ignoreCase);
      },
      /**
       * Returns true when the actual input is less than to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      lessthan: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) < DataUtil2.toLowerCase(expected);
        }
        if (isNullOrUndefined(actual)) {
          actual = void 0;
        }
        return actual < expected;
      },
      /**
       * Returns true when the actual input is greater than to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      greaterthan: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) > DataUtil2.toLowerCase(expected);
        }
        return actual > expected;
      },
      /**
       * Returns true when the actual input is less than or equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      lessthanorequal: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) <= DataUtil2.toLowerCase(expected);
        }
        if (isNullOrUndefined(actual)) {
          actual = void 0;
        }
        return actual <= expected;
      },
      /**
       * Returns true when the actual input is greater than or equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      greaterthanorequal: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) >= DataUtil2.toLowerCase(expected);
        }
        return actual >= expected;
      },
      /**
       * Returns true when the actual input contains the given string.
       *
       * @param {string|number} actual
       * @param {string|number} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      contains: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && DataUtil2.toLowerCase(actual).indexOf(DataUtil2.toLowerCase(expected)) !== -1;
        }
        return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && actual.toString().indexOf(expected) !== -1;
      },
      /**
       * Returns true when the actual input not contains the given string.
       *
       * @param  {string|number} actual
       * @param  {string|number} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotcontain: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && DataUtil2.toLowerCase(actual).indexOf(DataUtil2.toLowerCase(expected)) === -1;
        }
        return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && actual.toString().indexOf(expected) === -1;
      },
      /**
       * Returns true when the given input value is not null.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnotnull: function(actual) {
        return actual !== null && actual !== void 0;
      },
      /**
       * Returns true when the given input value is null.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnull: function(actual) {
        return actual === null || actual === void 0;
      },
      /**
       * Returns true when the actual input starts with the given string
       *
       * @param {string} actual
       * @param {string} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      startswith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.startsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.startsWith(actual, expected);
      },
      /**
       * Returns true when the actual input not starts with the given string
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotstartwith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.notStartsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.notStartsWith(actual, expected);
      },
      /**
       * Returns true when the actual input like with the given string.
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      like: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.like(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.like(actual, expected);
      },
      /**
       * Returns true when the given input value is empty.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isempty: function(actual) {
        return actual === void 0 || actual === "";
      },
      /**
       * Returns true when the given input value is not empty.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnotempty: function(actual) {
        return actual !== void 0 && actual !== "";
      },
      /**
       * Returns true when the actual input pattern(wildcard) matches with the given string.
       *
       * @param  {string|Date} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      wildcard: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return (actual || typeof actual === "boolean") && expected && typeof actual !== "object" && DataUtil2.wildCard(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return (actual || typeof actual === "boolean") && expected && DataUtil2.wildCard(actual, expected);
      },
      /**
       * Returns true when the actual input ends with the given string.
       *
       * @param {string} actual
       * @param {string} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      endswith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.endsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.endsWith(actual, expected);
      },
      /**
       * Returns true when the actual input not ends with the given string.
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotendwith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.notEndsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.notEndsWith(actual, expected);
      },
      /**
       * It will return the filter operator based on the filter symbol.
       *
       * @param  {string} operator
       * @hidden
       */
      processSymbols: function(operator) {
        var fnName = DataUtil2.operatorSymbols[operator];
        if (fnName) {
          var fn = DataUtil2.fnOperators[fnName];
          return fn;
        }
        return DataUtil2.throwError("Query - Process Operator : Invalid operator");
      },
      /**
       * It will return the valid filter operator based on the specified operators.
       *
       * @param  {string} operator
       * @hidden
       */
      processOperator: function(operator) {
        var fn = DataUtil2.fnOperators[operator];
        if (fn) {
          return fn;
        }
        return DataUtil2.fnOperators.processSymbols(operator);
      }
    };
    DataUtil2.parse = {
      /**
       * Parse the given string to the plain JavaScript object.
       *
       * @param  {string|Object|Object[]} jsonText
       */
      parseJson: function(jsonText) {
        if (typeof jsonText === "string" && (/^[\s]*\[|^[\s]*\{(.)+:/g.test(jsonText) || jsonText.indexOf('"') === -1)) {
          jsonText = JSON.parse(jsonText, DataUtil2.parse.jsonReviver);
        } else if (jsonText instanceof Array) {
          DataUtil2.parse.iterateAndReviveArray(jsonText);
        } else if (typeof jsonText === "object" && jsonText !== null) {
          DataUtil2.parse.iterateAndReviveJson(jsonText);
        }
        return jsonText;
      },
      /**
       * It will perform on array of values.
       *
       * @param  {string[]|Object[]} array
       * @hidden
       */
      iterateAndReviveArray: function(array) {
        for (var i = 0; i < array.length; i++) {
          if (typeof array[i] === "object" && array[i] !== null) {
            DataUtil2.parse.iterateAndReviveJson(array[i]);
          } else if (typeof array[i] === "string" && (!/^[\s]*\[|^[\s]*\{(.)+:|\"/g.test(array[i]) || array[i].toString().indexOf('"') === -1)) {
            array[i] = DataUtil2.parse.jsonReviver("", array[i]);
          } else {
            array[i] = DataUtil2.parse.parseJson(array[i]);
          }
        }
      },
      /**
       * It will perform on JSON values
       *
       * @param  {JSON} json
       * @hidden
       */
      iterateAndReviveJson: function(json) {
        var value;
        var keys = Object.keys(json);
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
          var prop = keys_2[_i];
          if (DataUtil2.startsWith(prop, "__")) {
            continue;
          }
          value = json[prop];
          if (typeof value === "object") {
            if (value instanceof Array) {
              DataUtil2.parse.iterateAndReviveArray(value);
            } else if (value) {
              DataUtil2.parse.iterateAndReviveJson(value);
            }
          } else {
            json[prop] = DataUtil2.parse.jsonReviver(json[prop], value);
          }
        }
      },
      /**
       * It will perform on JSON values
       *
       * @param  {string} field
       * @param  {string|Date} value
       * @hidden
       */
      jsonReviver: function(field, value) {
        if (typeof value === "string") {
          var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
          var offSet = DataUtil2.timeZoneHandling ? DataUtil2.serverTimezoneOffset : null;
          if (ms) {
            return DataUtil2.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), offSet, true);
          } else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
            var isUTC = value.indexOf("Z") > -1 || value.indexOf("z") > -1;
            var arr = value.split(/[^0-9.]/);
            if (isUTC) {
              if (arr[5].indexOf(".") > -1) {
                var secondsMs = arr[5].split(".");
                arr[5] = secondsMs[0];
                arr[6] = new Date(value).getUTCMilliseconds().toString();
              } else {
                arr[6] = "00";
              }
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : "00", 10), parseInt(arr[6], 10)), DataUtil2.serverTimezoneOffset, false);
            } else {
              var utcFormat = new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : "00", 10));
              var hrs = parseInt(arr[6], 10);
              var mins = parseInt(arr[7], 10);
              if (isNaN(hrs) && isNaN(mins)) {
                return utcFormat;
              }
              if (value.indexOf("+") > -1) {
                utcFormat.setHours(utcFormat.getHours() - hrs, utcFormat.getMinutes() - mins);
              } else {
                utcFormat.setHours(utcFormat.getHours() + hrs, utcFormat.getMinutes() + mins);
              }
              value = DataUtil2.dateParse.toTimeZone(utcFormat, DataUtil2.serverTimezoneOffset, false);
            }
            if (DataUtil2.serverTimezoneOffset == null) {
              value = DataUtil2.dateParse.addSelfOffset(value);
            }
          }
        }
        return value;
      },
      /**
       * Check wheather the given value is JSON or not.
       *
       * @param  {Object[]} jsonData
       */
      isJson: function(jsonData) {
        if (typeof jsonData[0] === "string") {
          return jsonData;
        }
        return DataUtil2.parse.parseJson(jsonData);
      },
      /**
       * Checks wheather the given value is GUID or not.
       *
       * @param  {string} value
       */
      isGuid: function(value) {
        var regex2 = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;
        var match = regex2.exec(value);
        return match != null;
      },
      /**
       * The method used to replace the value based on the type.
       *
       * @param  {Object} value
       * @param  {boolean} stringify
       * @hidden
       */
      replacer: function(value, stringify) {
        if (DataUtil2.isPlainObject(value)) {
          return DataUtil2.parse.jsonReplacer(value, stringify);
        }
        if (value instanceof Array) {
          return DataUtil2.parse.arrayReplacer(value);
        }
        if (value instanceof Date) {
          return DataUtil2.parse.jsonReplacer({ val: value }, stringify).val;
        }
        return value;
      },
      /**
       * It will replace the JSON value.
       *
       * @param {string} key
       * @param {Object} val
       * @param stringify
       * @hidden
       */
      jsonReplacer: function(val, stringify) {
        var value;
        var keys = Object.keys(val);
        for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
          var prop = keys_3[_i];
          value = val[prop];
          if (!(value instanceof Date)) {
            continue;
          }
          var d = value;
          if (DataUtil2.serverTimezoneOffset == null) {
            val[prop] = DataUtil2.dateParse.toTimeZone(d, null).toJSON();
          } else {
            d = new Date(+d + DataUtil2.serverTimezoneOffset * 36e5);
            val[prop] = DataUtil2.dateParse.toTimeZone(DataUtil2.dateParse.addSelfOffset(d), null).toJSON();
          }
        }
        return val;
      },
      /**
       * It will replace the Array of value.
       *
       * @param  {string} key
       * @param  {Object[]} val
       * @hidden
       */
      arrayReplacer: function(val) {
        for (var i = 0; i < val.length; i++) {
          if (DataUtil2.isPlainObject(val[i])) {
            val[i] = DataUtil2.parse.jsonReplacer(val[i]);
          } else if (val[i] instanceof Date) {
            val[i] = DataUtil2.parse.jsonReplacer({ date: val[i] }).date;
          }
        }
        return val;
      },
      /**
       * It will replace the Date object with respective to UTC format value.
       *
       * @param  {string} key
       * @param  {any} value
       * @hidden
       */
      /* eslint-disable @typescript-eslint/no-explicit-any */
      /* tslint:disable-next-line:no-any */
      jsonDateReplacer: function(key, value) {
        if (key === "value" && value) {
          if (typeof value === "string") {
            var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
            if (ms) {
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), null, true);
            } else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
              var arr = value.split(/[^0-9]/);
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), null, true);
            }
          }
          if (value instanceof Date) {
            value = DataUtil2.dateParse.addSelfOffset(value);
            if (DataUtil2.serverTimezoneOffset === null) {
              return DataUtil2.dateParse.toTimeZone(DataUtil2.dateParse.addSelfOffset(value), null).toJSON();
            } else {
              value = DataUtil2.dateParse.toTimeZone(value, value.getTimezoneOffset() / 60 - DataUtil2.serverTimezoneOffset, false);
              return value.toJSON();
            }
          }
        }
        return value;
      }
    };
    DataUtil2.dateParse = {
      addSelfOffset: function(input) {
        return new Date(+input - input.getTimezoneOffset() * 6e4);
      },
      toUTC: function(input) {
        return new Date(+input + input.getTimezoneOffset() * 6e4);
      },
      toTimeZone: function(input, offset, utc) {
        if (offset === null) {
          return input;
        }
        var unix = utc ? DataUtil2.dateParse.toUTC(input) : input;
        return new Date(+unix - offset * 36e5);
      },
      toLocalTime: function(input) {
        var datefn = input;
        var timeZone = -datefn.getTimezoneOffset();
        var differenceString = timeZone >= 0 ? "+" : "-";
        var localtimefn = function(num) {
          var norm = Math.floor(Math.abs(num));
          return (norm < 10 ? "0" : "") + norm;
        };
        var val = datefn.getFullYear() + "-" + localtimefn(datefn.getMonth() + 1) + "-" + localtimefn(datefn.getDate()) + "T" + localtimefn(datefn.getHours()) + ":" + localtimefn(datefn.getMinutes()) + ":" + localtimefn(datefn.getSeconds()) + differenceString + localtimefn(timeZone / 60) + ":" + localtimefn(timeZone % 60);
        return val;
      }
    };
    return DataUtil2;
  }()
);

// node_modules/@syncfusion/ej2-data/src/adaptors.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var consts2 = { GroupGuid: "{271bbba0-1ee7}" };
var Adaptor = (
  /** @class */
  function() {
    function Adaptor2(ds) {
      this.options = {
        from: "table",
        requestType: "json",
        sortBy: "sorted",
        select: "select",
        skip: "skip",
        group: "group",
        take: "take",
        search: "search",
        count: "requiresCounts",
        where: "where",
        aggregates: "aggregates",
        expand: "expand"
      };
      this.type = Adaptor2;
      this.dataSource = ds;
      this.pvt = {};
    }
    Adaptor2.prototype.processResponse = function(data, ds, query, xhr) {
      return data;
    };
    return Adaptor2;
  }()
);
var JsonAdaptor = (
  /** @class */
  function(_super) {
    __extends30(JsonAdaptor2, _super);
    function JsonAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonAdaptor2.prototype.processQuery = function(dataManager, query) {
      var result = dataManager.dataSource.json.slice(0);
      var count = result.length;
      var countFlg = true;
      var ret;
      var key;
      var lazyLoad = {};
      var keyCount = 0;
      var group = [];
      var sort = [];
      var page;
      for (var i = 0; i < query.lazyLoad.length; i++) {
        keyCount++;
        lazyLoad[query.lazyLoad[i].key] = query.lazyLoad[i].value;
      }
      var agg = {};
      var isGroupByFormat = false;
      if (query.lazyLoad.length) {
        for (var i = 0; i < query.queries.length; i++) {
          key = query.queries[i];
          if (key.fn === "onGroup" && !isNullOrUndefined(key.e.format)) {
            isGroupByFormat = true;
            break;
          }
        }
      }
      for (var i = 0; i < query.queries.length; i++) {
        key = query.queries[i];
        if ((key.fn === "onPage" || key.fn === "onGroup" || key.fn === "onSortBy" && !isGroupByFormat) && query.lazyLoad.length) {
          if (key.fn === "onGroup") {
            group.push(key.e);
          }
          if (key.fn === "onPage") {
            page = key.e;
          }
          if (key.fn === "onSortBy") {
            sort.unshift(key.e);
          }
          continue;
        }
        ret = this[key.fn].call(this, result, key.e, query);
        if (key.fn === "onAggregates") {
          agg[key.e.field + " - " + key.e.type] = ret;
        } else {
          result = ret !== void 0 ? ret : result;
        }
        if (key.fn === "onPage" || key.fn === "onSkip" || key.fn === "onTake" || key.fn === "onRange") {
          countFlg = false;
        }
        if (countFlg) {
          count = result.length;
        }
      }
      if (keyCount) {
        var args = {
          query,
          lazyLoad,
          result,
          group,
          page,
          sort
        };
        var lazyLoadData = this.lazyLoadGroup(args);
        result = lazyLoadData.result;
        count = lazyLoadData.count;
      }
      if (query.isCountRequired) {
        result = {
          result,
          count,
          aggregates: agg
        };
      }
      return result;
    };
    JsonAdaptor2.prototype.lazyLoadGroup = function(args) {
      var count = 0;
      var agg = this.getAggregate(args.query);
      var result = args.result;
      if (!isNullOrUndefined(args.lazyLoad.onDemandGroupInfo)) {
        var req = args.lazyLoad.onDemandGroupInfo;
        for (var i = req.where.length - 1; i >= 0; i--) {
          result = this.onWhere(result, req.where[i]);
        }
        if (args.group.length !== req.level) {
          var field = args.group[req.level].fieldName;
          result = DataUtil.group(result, field, agg, null, null, args.group[req.level].comparer, true);
          if (args.sort.length) {
            result = this.onSortBy(result, args.sort[parseInt(req.level.toString(), 10)], args.query, true);
          }
        } else {
          for (var i = args.sort.length - 1; i >= req.level; i--) {
            result = this.onSortBy(result, args.sort[parseInt(i.toString(), 10)], args.query, false);
          }
        }
        count = result.length;
        var data = result;
        result = result.slice(req.skip);
        result = result.slice(0, req.take);
        if (args.group.length !== req.level) {
          this.formGroupResult(result, data);
        }
      } else {
        var field_1 = args.group[0].fieldName;
        result = DataUtil.group(result, field_1, agg, null, null, args.group[0].comparer, true);
        count = result.length;
        var data = result;
        if (args.sort.length) {
          var sort = args.sort.length > 1 ? args.sort.filter(function(x) {
            return x.fieldName === field_1;
          })[0] : args.sort[0];
          result = this.onSortBy(result, sort, args.query, true);
        }
        if (args.page) {
          result = this.onPage(result, args.page, args.query);
        }
        this.formGroupResult(result, data);
      }
      return { result, count };
    };
    JsonAdaptor2.prototype.formGroupResult = function(result, data) {
      if (result.length && data.length) {
        var uid = "GroupGuid";
        var childLevel = "childLevels";
        var level = "level";
        var records = "records";
        result[uid] = data[uid];
        result[childLevel] = data[childLevel];
        result[level] = data[level];
        result[records] = data[records];
      }
      return result;
    };
    JsonAdaptor2.prototype.getAggregate = function(query) {
      var aggQuery = Query.filterQueries(query.queries, "onAggregates");
      var agg = [];
      if (aggQuery.length) {
        var tmp = void 0;
        for (var i = 0; i < aggQuery.length; i++) {
          tmp = aggQuery[i].e;
          agg.push({ type: tmp.type, field: DataUtil.getValue(tmp.field, query) });
        }
      }
      return agg;
    };
    JsonAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      var i;
      var deletedRecordsLen = changes.deletedRecords.length;
      for (i = 0; i < changes.addedRecords.length; i++) {
        this.insert(dm, changes.addedRecords[i]);
      }
      for (i = 0; i < changes.changedRecords.length; i++) {
        this.update(dm, e.key, changes.changedRecords[i]);
      }
      for (i = 0; i < deletedRecordsLen; i++) {
        this.remove(dm, e.key, changes.deletedRecords[i]);
      }
      return changes;
    };
    JsonAdaptor2.prototype.onWhere = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.filter(function(obj) {
        if (e) {
          return e.validate(obj);
        }
      });
    };
    JsonAdaptor2.prototype.onAggregates = function(ds, e) {
      var fn = DataUtil.aggregates[e.type];
      if (!ds || !fn || ds.length === 0) {
        return null;
      }
      return fn(ds, e.field);
    };
    JsonAdaptor2.prototype.onSearch = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      if (e.fieldNames.length === 0) {
        DataUtil.getFieldList(ds[0], e.fieldNames);
      }
      return ds.filter(function(obj) {
        for (var j = 0; j < e.fieldNames.length; j++) {
          if (e.comparer.call(obj, DataUtil.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase, e.ignoreAccent)) {
            return true;
          }
        }
        return false;
      });
    };
    JsonAdaptor2.prototype.onSortBy = function(ds, e, query, isLazyLoadGroupSort) {
      if (!ds || !ds.length) {
        return ds;
      }
      var fnCompare;
      var field = DataUtil.getValue(e.fieldName, query);
      if (!field) {
        return ds.sort(e.comparer);
      }
      if (field instanceof Array) {
        field = field.slice(0);
        for (var i = field.length - 1; i >= 0; i--) {
          if (!field[i]) {
            continue;
          }
          fnCompare = e.comparer;
          if (DataUtil.endsWith(field[i], " desc")) {
            fnCompare = DataUtil.fnSort("descending");
            field[i] = field[i].replace(" desc", "");
          }
          ds = DataUtil.sort(ds, field[i], fnCompare);
        }
        return ds;
      }
      return DataUtil.sort(ds, isLazyLoadGroupSort ? "key" : field, e.comparer);
    };
    JsonAdaptor2.prototype.onGroup = function(ds, e, query) {
      if (!ds || !ds.length) {
        return ds;
      }
      var agg = this.getAggregate(query);
      return DataUtil.group(ds, DataUtil.getValue(e.fieldName, query), agg, null, null, e.comparer);
    };
    JsonAdaptor2.prototype.onPage = function(ds, e, query) {
      var size = DataUtil.getValue(e.pageSize, query);
      var start = (DataUtil.getValue(e.pageIndex, query) - 1) * size;
      var end = start + size;
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(start, end);
    };
    JsonAdaptor2.prototype.onRange = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(DataUtil.getValue(e.start), DataUtil.getValue(e.end));
    };
    JsonAdaptor2.prototype.onTake = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(0, DataUtil.getValue(e.nos));
    };
    JsonAdaptor2.prototype.onSkip = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(DataUtil.getValue(e.nos));
    };
    JsonAdaptor2.prototype.onSelect = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return DataUtil.select(ds, DataUtil.getValue(e.fieldNames));
    };
    JsonAdaptor2.prototype.insert = function(dm, data, tableName, query, position) {
      if (isNullOrUndefined(position)) {
        return dm.dataSource.json.push(data);
      } else {
        return dm.dataSource.json.splice(position, 0, data);
      }
    };
    JsonAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      var ds = dm.dataSource.json;
      var i;
      if (typeof value === "object" && !(value instanceof Date)) {
        value = DataUtil.getObject(keyField, value);
      }
      for (i = 0; i < ds.length; i++) {
        if (DataUtil.getObject(keyField, ds[i]) === value) {
          break;
        }
      }
      return i !== ds.length ? ds.splice(i, 1) : null;
    };
    JsonAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      var ds = dm.dataSource.json;
      var i;
      var key;
      if (!isNullOrUndefined(keyField)) {
        key = getValue(keyField, value);
      }
      for (i = 0; i < ds.length; i++) {
        if (!isNullOrUndefined(keyField) && getValue(keyField, ds[i]) === key) {
          break;
        }
      }
      return i < ds.length ? merge(ds[i], value) : null;
    };
    return JsonAdaptor2;
  }(Adaptor)
);
var UrlAdaptor = (
  /** @class */
  function(_super) {
    __extends30(UrlAdaptor2, _super);
    function UrlAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    UrlAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var queries = this.getQueryRequest(query);
      var singles = Query.filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]);
      var params = query.params;
      var url = dm.dataSource.url;
      var temp;
      var skip;
      var take = null;
      var options = this.options;
      var request = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
      if ("onPage" in singles) {
        temp = singles.onPage;
        skip = DataUtil.getValue(temp.pageIndex, query);
        take = DataUtil.getValue(temp.pageSize, query);
        skip = (skip - 1) * take;
      } else if ("onRange" in singles) {
        temp = singles.onRange;
        skip = temp.start;
        take = temp.end - temp.start;
      }
      for (var i = 0; i < queries.sorts.length; i++) {
        temp = DataUtil.getValue(queries.sorts[i].e.fieldName, query);
        request.sorts.push(DataUtil.callAdaptorFunction(this, "onEachSort", { name: temp, direction: queries.sorts[i].e.direction }, query));
      }
      if (hierarchyFilters) {
        temp = this.getFiltersFrom(hierarchyFilters, query);
        if (temp) {
          request.filters.push(DataUtil.callAdaptorFunction(this, "onEachWhere", temp.toJson(), query));
        }
      }
      for (var i = 0; i < queries.filters.length; i++) {
        var res = DataUtil.callAdaptorFunction(this, "onEachWhere", queries.filters[i].e.toJson(), query);
        if (this.getModuleName && this.getModuleName() === "ODataV4Adaptor" && !isNullOrUndefined(queries.filters[i].e.key) && queries.filters.length > 1) {
          res = "(" + res + ")";
        }
        request.filters.push(res);
        var keys_3 = typeof request.filters[i] === "object" ? Object.keys(request.filters[i]) : [];
        for (var _i = 0, keys_1 = keys_3; _i < keys_1.length; _i++) {
          var prop = keys_1[_i];
          if (DataUtil.isNull(request[prop])) {
            delete request[prop];
          }
        }
      }
      for (var i = 0; i < queries.searches.length; i++) {
        temp = queries.searches[i].e;
        request.searches.push(DataUtil.callAdaptorFunction(this, "onEachSearch", {
          fields: temp.fieldNames,
          operator: temp.operator,
          key: temp.searchKey,
          ignoreCase: temp.ignoreCase
        }, query));
      }
      for (var i = 0; i < queries.groups.length; i++) {
        request.groups.push(DataUtil.getValue(queries.groups[i].e.fieldName, query));
      }
      for (var i = 0; i < queries.aggregates.length; i++) {
        temp = queries.aggregates[i].e;
        request.aggregates.push({ type: temp.type, field: DataUtil.getValue(temp.field, query) });
      }
      var req = {};
      this.getRequestQuery(options, query, singles, request, req);
      DataUtil.callAdaptorFunction(this, "addParams", { dm, query, params, reqParams: req });
      if (query.lazyLoad.length) {
        for (var i = 0; i < query.lazyLoad.length; i++) {
          req[query.lazyLoad[i].key] = query.lazyLoad[i].value;
        }
      }
      var keys = Object.keys(req);
      for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
        var prop = keys_2[_a];
        if (DataUtil.isNull(req[prop]) || req[prop] === "" || req[prop].length === 0) {
          delete req[prop];
        }
      }
      if (!(options.skip in req && options.take in req) && take !== null) {
        req[options.skip] = DataUtil.callAdaptorFunction(this, "onSkip", skip, query);
        req[options.take] = DataUtil.callAdaptorFunction(this, "onTake", take, query);
      }
      var p = this.pvt;
      this.pvt = {};
      if (this.options.requestType === "json") {
        return {
          data: JSON.stringify(req, DataUtil.parse.jsonDateReplacer),
          url,
          pvtData: p,
          type: "POST",
          contentType: "application/json; charset=utf-8"
        };
      }
      temp = this.convertToQueryString(req, query, dm);
      temp = (dm.dataSource.url.indexOf("?") !== -1 ? "&" : "/") + temp;
      return {
        type: "GET",
        url: temp.length ? url.replace(/\/*$/, temp) : url,
        pvtData: p
      };
    };
    UrlAdaptor2.prototype.getRequestQuery = function(options, query, singles, request, request1) {
      var param = "param";
      var req = request1;
      req[options.from] = query.fromTable;
      if (options.apply && query.distincts.length) {
        req[options.apply] = "onDistinct" in this ? DataUtil.callAdaptorFunction(this, "onDistinct", query.distincts) : "";
      }
      if (!query.distincts.length && options.expand) {
        req[options.expand] = "onExpand" in this && "onSelect" in singles ? DataUtil.callAdaptorFunction(this, "onExpand", { selects: DataUtil.getValue(singles.onSelect.fieldNames, query), expands: query.expands }, query) : query.expands;
      }
      req[options.select] = "onSelect" in singles && !query.distincts.length ? DataUtil.callAdaptorFunction(this, "onSelect", DataUtil.getValue(singles.onSelect.fieldNames, query), query) : "";
      req[options.count] = query.isCountRequired ? DataUtil.callAdaptorFunction(this, "onCount", query.isCountRequired, query) : "";
      req[options.search] = request.searches.length ? DataUtil.callAdaptorFunction(this, "onSearch", request.searches, query) : "";
      req[options.skip] = "onSkip" in singles ? DataUtil.callAdaptorFunction(this, "onSkip", DataUtil.getValue(singles.onSkip.nos, query), query) : "";
      req[options.take] = "onTake" in singles ? DataUtil.callAdaptorFunction(this, "onTake", DataUtil.getValue(singles.onTake.nos, query), query) : "";
      req[options.where] = request.filters.length || request.searches.length ? DataUtil.callAdaptorFunction(this, "onWhere", request.filters, query) : "";
      req[options.sortBy] = request.sorts.length ? DataUtil.callAdaptorFunction(this, "onSortBy", request.sorts, query) : "";
      req[options.group] = request.groups.length ? DataUtil.callAdaptorFunction(this, "onGroup", request.groups, query) : "";
      req[options.aggregates] = request.aggregates.length ? DataUtil.callAdaptorFunction(this, "onAggregates", request.aggregates, query) : "";
      req[param] = [];
    };
    UrlAdaptor2.prototype.convertToQueryString = function(request, query, dm) {
      return "";
    };
    UrlAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("application/json") !== -1) {
        var handleTimeZone = DataUtil.timeZoneHandling;
        if (ds && !ds.timeZoneHandling) {
          DataUtil.timeZoneHandling = false;
        }
        data = DataUtil.parse.parseJson(data);
        DataUtil.timeZoneHandling = handleTimeZone;
      }
      var requests = request;
      var pvt = requests.pvtData || {};
      var groupDs = data ? data.groupDs : [];
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("xml") !== -1) {
        return query.isCountRequired ? { result: [], count: 0 } : [];
      }
      var d = JSON.parse(requests.data);
      if (d && d.action === "batch" && data && data.addedRecords) {
        changes.addedRecords = data.addedRecords;
        return changes;
      }
      if (data && data.d) {
        data = data.d;
      }
      var args = {};
      if (data && "count" in data) {
        args.count = data.count;
      }
      args.result = data && data.result ? data.result : data;
      var isExpand = false;
      if (Array.isArray(data.result) && data.result.length) {
        var key = "key";
        var val = "value";
        var level = "level";
        if (!isNullOrUndefined(data.result[0][key])) {
          args.result = this.formRemoteGroupedData(args.result, 1, pvt.groups.length - 1);
        }
        if (query && query.lazyLoad.length && pvt.groups.length) {
          for (var i = 0; i < query.lazyLoad.length; i++) {
            if (query.lazyLoad[i][key] === "onDemandGroupInfo") {
              var value = query.lazyLoad[i][val][level];
              if (pvt.groups.length === value) {
                isExpand = true;
              }
            }
          }
        }
      }
      if (!isExpand) {
        this.getAggregateResult(pvt, data, args, groupDs, query);
      }
      return DataUtil.isNull(args.count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    UrlAdaptor2.prototype.formRemoteGroupedData = function(data, level, childLevel) {
      for (var i = 0; i < data.length; i++) {
        if (data[i].items.length && Object.keys(data[i].items[0]).indexOf("key") > -1) {
          this.formRemoteGroupedData(data[i].items, level + 1, childLevel - 1);
        }
      }
      var uid = "GroupGuid";
      var childLvl = "childLevels";
      var lvl = "level";
      var records = "records";
      data[uid] = consts2[uid];
      data[lvl] = level;
      data[childLvl] = childLevel;
      data[records] = data[0].items.length ? this.getGroupedRecords(data, !isNullOrUndefined(data[0].items[records])) : [];
      return data;
    };
    UrlAdaptor2.prototype.getGroupedRecords = function(data, hasRecords) {
      var childGroupedRecords = [];
      var records = "records";
      for (var i = 0; i < data.length; i++) {
        if (!hasRecords) {
          for (var j = 0; j < data[i].items.length; j++) {
            childGroupedRecords.push(data[i].items[j]);
          }
        } else {
          childGroupedRecords = childGroupedRecords.concat(data[i].items[records]);
        }
      }
      return childGroupedRecords;
    };
    UrlAdaptor2.prototype.onGroup = function(e) {
      this.pvt.groups = e;
      return e;
    };
    UrlAdaptor2.prototype.onAggregates = function(e) {
      this.pvt.aggregates = e;
    };
    UrlAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var url;
      var key;
      return {
        type: "POST",
        url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        data: JSON.stringify(extend({}, {
          changed: changes.changedRecords,
          added: changes.addedRecords,
          deleted: changes.deletedRecords,
          action: "batch",
          table: e[url],
          key: e[key]
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.beforeSend = function(dm, request) {
    };
    UrlAdaptor2.prototype.insert = function(dm, data, tableName, query) {
      return {
        url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: data,
          table: tableName,
          action: "insert"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.remove = function(dm, keyField, value, tableName, query) {
      return {
        type: "POST",
        url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          key: value,
          keyColumn: keyField,
          table: tableName,
          action: "remove"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.update = function(dm, keyField, value, tableName, query) {
      return {
        type: "POST",
        url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value,
          action: "update",
          keyColumn: keyField,
          key: DataUtil.getObject(keyField, value),
          table: tableName
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.getFiltersFrom = function(data, query) {
      var key = query.fKey;
      var value;
      var prop = key;
      var pKey = query.key;
      var predicats = [];
      if (typeof data[0] !== "object") {
        prop = null;
      }
      for (var i = 0; i < data.length; i++) {
        if (typeof data[0] === "object") {
          value = DataUtil.getObject(pKey || prop, data[i]);
        } else {
          value = data[i];
        }
        predicats.push(new Predicate(key, "equal", value));
      }
      return Predicate.or(predicats);
    };
    UrlAdaptor2.prototype.getAggregateResult = function(pvt, data, args, groupDs, query) {
      var pData = data;
      if (data && data.result) {
        pData = data.result;
      }
      if (pvt && pvt.aggregates && pvt.aggregates.length) {
        var agg = pvt.aggregates;
        var fn = void 0;
        var aggregateData = pData;
        var res = {};
        if (data.aggregate) {
          aggregateData = data.aggregate;
        }
        for (var i = 0; i < agg.length; i++) {
          fn = DataUtil.aggregates[agg[i].type];
          if (fn) {
            res[agg[i].field + " - " + agg[i].type] = fn(aggregateData, agg[i].field);
          }
        }
        args.aggregates = res;
      }
      var key = "key";
      var isServerGrouping = Array.isArray(data.result) && data.result.length && !isNullOrUndefined(data.result[0][key]);
      if (pvt && pvt.groups && pvt.groups.length && !isServerGrouping) {
        var groups = pvt.groups;
        for (var i = 0; i < groups.length; i++) {
          var level = null;
          if (!isNullOrUndefined(groupDs)) {
            groupDs = DataUtil.group(groupDs, groups[i]);
          }
          var groupQuery = Query.filterQueries(query.queries, "onGroup")[i].e;
          pData = DataUtil.group(pData, groups[i], pvt.aggregates, level, groupDs, groupQuery.comparer);
        }
        args.result = pData;
      }
      return args;
    };
    UrlAdaptor2.prototype.getQueryRequest = function(query) {
      var req = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
      req.sorts = Query.filterQueries(query.queries, "onSortBy");
      req.groups = Query.filterQueries(query.queries, "onGroup");
      req.filters = Query.filterQueries(query.queries, "onWhere");
      req.searches = Query.filterQueries(query.queries, "onSearch");
      req.aggregates = Query.filterQueries(query.queries, "onAggregates");
      return req;
    };
    UrlAdaptor2.prototype.addParams = function(options) {
      var req = options.reqParams;
      if (options.params.length) {
        req.params = {};
      }
      for (var _i = 0, _a = options.params; _i < _a.length; _i++) {
        var tmp = _a[_i];
        if (req[tmp.key]) {
          throw new Error("Query() - addParams: Custom Param is conflicting other request arguments");
        }
        req[tmp.key] = tmp.value;
        if (tmp.fn) {
          req[tmp.key] = tmp.fn.call(options.query, tmp.key, options.query, options.dm);
        }
        req.params[tmp.key] = req[tmp.key];
      }
    };
    return UrlAdaptor2;
  }(Adaptor)
);
var ODataAdaptor = (
  /** @class */
  function(_super) {
    __extends30(ODataAdaptor2, _super);
    function ODataAdaptor2(props) {
      var _this = _super.call(this) || this;
      _this.options = extend({}, _this.options, {
        requestType: "get",
        accept: "application/json;odata=light;q=1,application/json;odata=verbose;q=0.5",
        multipartAccept: "multipart/mixed",
        sortBy: "$orderby",
        select: "$select",
        skip: "$skip",
        take: "$top",
        count: "$inlinecount",
        where: "$filter",
        expand: "$expand",
        batch: "$batch",
        changeSet: "--changeset_",
        batchPre: "batch_",
        contentId: "Content-Id: ",
        batchContent: "Content-Type: multipart/mixed; boundary=",
        changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
        batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 ",
        updateType: "PUT"
      });
      extend(_this.options, props || {});
      return _this;
    }
    ODataAdaptor2.prototype.getModuleName = function() {
      return "ODataAdaptor";
    };
    ODataAdaptor2.prototype.onPredicate = function(predicate, query, requiresCast) {
      var returnValue = "";
      var operator;
      var guid;
      var val = predicate.value;
      var type = typeof val;
      var field = predicate.field ? ODataAdaptor2.getField(predicate.field) : null;
      if (val instanceof Date) {
        val = "datetime'" + DataUtil.parse.replacer(val) + "'";
      }
      if (type === "string") {
        val = val.replace(/'/g, "''");
        if (predicate.ignoreCase) {
          val = val.toLowerCase();
        }
        if (predicate.operator !== "like") {
          val = encodeURIComponent(val);
        }
        if (predicate.operator !== "wildcard" && predicate.operator !== "like") {
          val = "'" + val + "'";
        }
        if (requiresCast) {
          field = "cast(" + field + ", 'Edm.String')";
        }
        if (DataUtil.parse.isGuid(val)) {
          guid = "guid";
        }
        if (predicate.ignoreCase) {
          if (!guid) {
            field = "tolower(" + field + ")";
          }
          val = val.toLowerCase();
        }
      }
      if (predicate.operator === "isempty" || predicate.operator === "isnull" || predicate.operator === "isnotempty" || predicate.operator === "isnotnull") {
        operator = predicate.operator.indexOf("isnot") !== -1 ? DataUtil.odBiOperator["notequal"] : DataUtil.odBiOperator["equal"];
        val = predicate.operator === "isnull" || predicate.operator === "isnotnull" ? null : "''";
      } else {
        operator = DataUtil.odBiOperator[predicate.operator];
      }
      if (operator) {
        returnValue += field;
        returnValue += operator;
        if (guid) {
          returnValue += guid;
        }
        return returnValue + val;
      }
      if (!isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor") {
        operator = DataUtil.odv4UniOperator[predicate.operator];
      } else {
        operator = DataUtil.odUniOperator[predicate.operator];
      }
      if (operator === "like") {
        val = val;
        if (val.indexOf("%") !== -1) {
          if (val.charAt(0) === "%" && val.lastIndexOf("%") < 2) {
            val = val.substring(1, val.length);
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["startswith"] : DataUtil.odUniOperator["startswith"];
          } else if (val.charAt(val.length - 1) === "%" && val.indexOf("%") > val.length - 3) {
            val = val.substring(0, val.length - 1);
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["endswith"] : DataUtil.odUniOperator["endswith"];
          } else if (val.lastIndexOf("%") !== val.indexOf("%") && val.lastIndexOf("%") > val.indexOf("%") + 1) {
            val = val.substring(val.indexOf("%") + 1, val.lastIndexOf("%"));
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          } else {
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          }
        }
        val = encodeURIComponent(val);
        val = "'" + val + "'";
      } else if (operator === "wildcard") {
        val = val;
        if (val.indexOf("*") !== -1) {
          var splittedStringValue = val.split("*");
          var splittedValue = void 0;
          var count = 0;
          if (val.indexOf("*") !== 0 && splittedStringValue[0].indexOf("%3f") === -1 && splittedStringValue[0].indexOf("?") === -1) {
            splittedValue = splittedStringValue[0];
            splittedValue = "'" + splittedValue + "'";
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["startswith"] : DataUtil.odUniOperator["startswith"];
            returnValue += operator + "(";
            returnValue += field + ",";
            if (guid) {
              returnValue += guid;
            }
            returnValue += splittedValue + ")";
            count++;
          }
          if (val.lastIndexOf("*") !== val.length - 1 && splittedStringValue[splittedStringValue.length - 1].indexOf("%3f") === -1 && splittedStringValue[splittedStringValue.length - 1].indexOf("?") === -1) {
            splittedValue = splittedStringValue[splittedStringValue.length - 1];
            splittedValue = "'" + splittedValue + "'";
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["endswith"] : DataUtil.odUniOperator["endswith"];
            if (count > 0) {
              returnValue += " and ";
            }
            returnValue += operator + "(";
            returnValue += field + ",";
            if (guid) {
              returnValue += guid;
            }
            returnValue += splittedValue + ")";
            count++;
          }
          if (splittedStringValue.length > 2) {
            for (var i = 1; i < splittedStringValue.length - 1; i++) {
              if (splittedStringValue[i].indexOf("%3f") === -1 && splittedStringValue[i].indexOf("?") === -1) {
                splittedValue = splittedStringValue[i];
                splittedValue = "'" + splittedValue + "'";
                operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
                if (count > 0) {
                  returnValue += " and ";
                }
                if (operator === "substringof" || operator === "not substringof") {
                  var temp = splittedValue;
                  splittedValue = field;
                  field = temp;
                }
                returnValue += operator + "(";
                returnValue += field + ",";
                if (guid) {
                  returnValue += guid;
                }
                returnValue += splittedValue + ")";
                count++;
              }
            }
          }
          if (count === 0) {
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
            if (val.indexOf("?") !== -1 || val.indexOf("%3f") !== -1) {
              val = val.indexOf("?") !== -1 ? val.split("?").join("") : val.split("%3f").join("");
            }
            val = "'" + val + "'";
          } else {
            operator = "wildcard";
          }
        } else {
          operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          if (val.indexOf("?") !== -1 || val.indexOf("%3f") !== -1) {
            val = val.indexOf("?") !== -1 ? val.split("?").join("") : val.split("%3f").join("");
          }
          val = "'" + val + "'";
        }
      }
      if (operator === "substringof" || operator === "not substringof") {
        var temp = val;
        val = field;
        field = temp;
      }
      if (operator !== "wildcard") {
        returnValue += operator + "(";
        returnValue += field + ",";
        if (guid) {
          returnValue += guid;
        }
        returnValue += val + ")";
      }
      return returnValue;
    };
    ODataAdaptor2.prototype.addParams = function(options) {
      _super.prototype.addParams.call(this, options);
      delete options.reqParams.params;
    };
    ODataAdaptor2.prototype.onComplexPredicate = function(predicate, query, requiresCast) {
      var res = [];
      for (var i = 0; i < predicate.predicates.length; i++) {
        res.push("(" + this.onEachWhere(predicate.predicates[i], query, requiresCast) + ")");
      }
      return res.join(" " + predicate.condition + " ");
    };
    ODataAdaptor2.prototype.onEachWhere = function(filter, query, requiresCast) {
      return filter.isComplex ? this.onComplexPredicate(filter, query, requiresCast) : this.onPredicate(filter, query, requiresCast);
    };
    ODataAdaptor2.prototype.onWhere = function(filters) {
      if (this.pvt.search) {
        filters.push(this.onEachWhere(this.pvt.search, null, true));
      }
      return filters.join(" and ");
    };
    ODataAdaptor2.prototype.onEachSearch = function(e) {
      if (e.fields && e.fields.length === 0) {
        DataUtil.throwError("Query() - Search : oData search requires list of field names to search");
      }
      var filter = this.pvt.search || [];
      for (var i = 0; i < e.fields.length; i++) {
        filter.push(new Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));
      }
      this.pvt.search = filter;
    };
    ODataAdaptor2.prototype.onSearch = function(e) {
      this.pvt.search = Predicate.or(this.pvt.search);
      return "";
    };
    ODataAdaptor2.prototype.onEachSort = function(e) {
      var res = [];
      if (e.name instanceof Array) {
        for (var i = 0; i < e.name.length; i++) {
          res.push(ODataAdaptor2.getField(e.name[i]) + (e.direction === "descending" ? " desc" : ""));
        }
      } else {
        res.push(ODataAdaptor2.getField(e.name) + (e.direction === "descending" ? " desc" : ""));
      }
      return res.join(",");
    };
    ODataAdaptor2.prototype.onSortBy = function(e) {
      return e.reverse().join(",");
    };
    ODataAdaptor2.prototype.onGroup = function(e) {
      this.pvt.groups = e;
      return [];
    };
    ODataAdaptor2.prototype.onSelect = function(e) {
      for (var i = 0; i < e.length; i++) {
        e[i] = ODataAdaptor2.getField(e[i]);
      }
      return e.join(",");
    };
    ODataAdaptor2.prototype.onAggregates = function(e) {
      this.pvt.aggregates = e;
      return "";
    };
    ODataAdaptor2.prototype.onCount = function(e) {
      return e === true ? "allpages" : "";
    };
    ODataAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (DataUtil.endsWith(settings.url, this.options.batch) && settings.type.toLowerCase() === "post") {
        request.headers.set("Accept", this.options.multipartAccept);
        request.headers.set("DataServiceVersion", "2.0");
      } else {
        request.headers.set("Accept", this.options.accept);
      }
      request.headers.set("DataServiceVersion", "2.0");
      request.headers.set("MaxDataServiceVersion", "2.0");
    };
    ODataAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var metaCheck = "odata.metadata";
      if (request && request.type === "GET" && !this.rootUrl && data[metaCheck]) {
        var dataUrls = data[metaCheck].split("/$metadata#");
        this.rootUrl = dataUrls[0];
        this.resourceTableName = dataUrls[1];
      }
      var pvtData = "pvtData";
      if (!isNullOrUndefined(data.d)) {
        var dataCopy = query && query.isCountRequired ? data.d.results : data.d;
        var metaData = "__metadata";
        if (!isNullOrUndefined(dataCopy)) {
          for (var i = 0; i < dataCopy.length; i++) {
            if (!isNullOrUndefined(dataCopy[i][metaData])) {
              delete dataCopy[i][metaData];
            }
          }
        }
      }
      var pvt = request && request[pvtData];
      var emptyAndBatch = this.processBatchResponse(data, query, xhr, request, changes);
      if (emptyAndBatch) {
        return emptyAndBatch;
      }
      var versionCheck = xhr && request.fetchRequest.headers.get("DataServiceVersion");
      var count = null;
      var version = versionCheck && parseInt(versionCheck, 10) || 2;
      if (query && query.isCountRequired) {
        var oDataCount = "__count";
        if (data[oDataCount] || data["odata.count"]) {
          count = data[oDataCount] || data["odata.count"];
        }
        if (data.d) {
          data = data.d;
        }
        if (data[oDataCount] || data["odata.count"]) {
          count = data[oDataCount] || data["odata.count"];
        }
      }
      if (version === 3 && data.value) {
        data = data.value;
      }
      if (data.d) {
        data = data.d;
      }
      if (version < 3 && data.results) {
        data = data.results;
      }
      var args = {};
      args.count = count;
      args.result = data;
      this.getAggregateResult(pvt, data, args, null, query);
      return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    ODataAdaptor2.prototype.convertToQueryString = function(request, query, dm) {
      var res = [];
      var table = "table";
      var tableName = request[table] || "";
      var format = "$format";
      delete request[table];
      if (dm.dataSource.requiresFormat) {
        request[format] = "json";
      }
      var keys = Object.keys(request);
      for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
        var prop = keys_4[_i];
        res.push(prop + "=" + request[prop]);
      }
      res = res.join("&");
      if (dm.dataSource.url && dm.dataSource.url.indexOf("?") !== -1 && !tableName) {
        return res;
      }
      return res.length ? tableName + "?" + res : tableName || "";
    };
    ODataAdaptor2.prototype.localTimeReplacer = function(key, convertObj) {
      for (var _i = 0, _a = !isNullOrUndefined(convertObj) ? Object.keys(convertObj) : []; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (convertObj[prop] instanceof Date) {
          convertObj[prop] = DataUtil.dateParse.toLocalTime(convertObj[prop]);
        }
      }
      return convertObj;
    };
    ODataAdaptor2.prototype.insert = function(dm, data, tableName) {
      return {
        url: (dm.dataSource.insertUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : ""),
        data: JSON.stringify(data, this.options.localTime ? this.localTimeReplacer : null)
      };
    };
    ODataAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      var url;
      if (typeof value === "string" && !DataUtil.parse.isGuid(value)) {
        url = "('" + value + "')";
      } else {
        url = "(" + value + ")";
      }
      return {
        type: "DELETE",
        url: (dm.dataSource.removeUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : "") + url
      };
    };
    ODataAdaptor2.prototype.update = function(dm, keyField, value, tableName, query, original) {
      if (this.options.updateType === "PATCH" && !isNullOrUndefined(original)) {
        value = this.compareAndRemove(value, original, keyField);
      }
      var url;
      if (typeof value[keyField] === "string" && !DataUtil.parse.isGuid(value[keyField])) {
        url = "('" + value[keyField] + "')";
      } else {
        url = "(" + value[keyField] + ")";
      }
      return {
        type: this.options.updateType,
        url: (dm.dataSource.updateUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : "") + url,
        data: JSON.stringify(value, this.options.localTime ? this.localTimeReplacer : null),
        accept: this.options.accept
      };
    };
    ODataAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
      var url = dm.dataSource.batchUrl || this.rootUrl ? (dm.dataSource.batchUrl || this.rootUrl) + "/" + this.options.batch : (dm.dataSource.batchUrl || dm.dataSource.url).replace(/\/*$/, "/" + this.options.batch);
      e.url = this.resourceTableName ? this.resourceTableName : e.url;
      var args = {
        url: e.url,
        key: e.key,
        cid: 1,
        cSet: DataUtil.getGuid(this.options.changeSet)
      };
      var req = "--" + initialGuid + "\n";
      req += "Content-Type: multipart/mixed; boundary=" + args.cSet.replace("--", "") + "\n";
      this.pvt.changeSet = 0;
      req += this.generateInsertRequest(changes.addedRecords, args, dm);
      req += this.generateUpdateRequest(changes.changedRecords, args, dm, original ? original.changedRecords : []);
      req += this.generateDeleteRequest(changes.deletedRecords, args, dm);
      req += args.cSet + "--\n";
      req += "--" + initialGuid + "--";
      return {
        type: "POST",
        url,
        dataType: "json",
        contentType: "multipart/mixed; charset=UTF-8;boundary=" + initialGuid,
        data: req
      };
    };
    ODataAdaptor2.prototype.generateDeleteRequest = function(arr, e, dm) {
      if (!arr) {
        return "";
      }
      var req = "";
      var stat = {
        "method": "DELETE ",
        "url": function(data, i, key) {
          var url = DataUtil.getObject(key, data[i]);
          if (typeof url === "number" || DataUtil.parse.isGuid(url)) {
            return "(" + url + ")";
          } else if (url instanceof Date) {
            var dateTime = data[i][key];
            return "(" + dateTime.toJSON() + ")";
          } else {
            return "('" + url + "')";
          }
        },
        "data": function(data, i) {
          return "";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req + "\n";
    };
    ODataAdaptor2.prototype.generateInsertRequest = function(arr, e, dm) {
      if (!arr) {
        return "";
      }
      var req = "";
      var stat = {
        "method": "POST ",
        "url": function(data, i, key) {
          return "";
        },
        "data": function(data, i) {
          return JSON.stringify(data[i]) + "\n\n";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req;
    };
    ODataAdaptor2.prototype.generateUpdateRequest = function(arr, e, dm, org) {
      var _this = this;
      if (!arr) {
        return "";
      }
      var req = "";
      arr.forEach(function(change) {
        return change = _this.compareAndRemove(change, org.filter(function(o) {
          return DataUtil.getObject(e.key, o) === DataUtil.getObject(e.key, change);
        })[0], e.key);
      });
      var stat = {
        "method": this.options.updateType + " ",
        "url": function(data, i, key) {
          if (typeof data[i][key] === "number" || DataUtil.parse.isGuid(data[i][key])) {
            return "(" + data[i][key] + ")";
          } else if (data[i][key] instanceof Date) {
            var date = data[i][key];
            return "(" + date.toJSON() + ")";
          } else {
            return "('" + data[i][key] + "')";
          }
        },
        "data": function(data, i) {
          return JSON.stringify(data[i]) + "\n\n";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req;
    };
    ODataAdaptor2.getField = function(prop) {
      return prop.replace(/\./g, "/");
    };
    ODataAdaptor2.prototype.generateBodyContent = function(arr, e, stat, dm) {
      var req = "";
      for (var i = 0; i < arr.length; i++) {
        req += "\n" + e.cSet + "\n";
        req += this.options.changeSetContent + "\n\n";
        req += stat.method;
        if (stat.method === "POST ") {
          req += (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        } else if (stat.method === "PUT " || stat.method === "PATCH ") {
          req += (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        } else if (stat.method === "DELETE ") {
          req += (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        }
        req += "Accept: " + this.options.accept + "\n";
        req += "Content-Id: " + this.pvt.changeSet++ + "\n";
        req += this.options.batchChangeSetContentType + "\n";
        if (!isNullOrUndefined(arr[i]["@odata.etag"])) {
          req += "If-Match: " + arr[i]["@odata.etag"] + "\n\n";
          delete arr[i]["@odata.etag"];
        } else {
          req += "\n";
        }
        req += stat.data(arr, i);
      }
      return req;
    };
    ODataAdaptor2.prototype.processBatchResponse = function(data, query, xhr, request, changes) {
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("xml") !== -1) {
        return query.isCountRequired ? { result: [], count: 0 } : [];
      }
      if (request && this.options.batch && DataUtil.endsWith(request.url, this.options.batch) && request.type.toLowerCase() === "post") {
        var guid = xhr.headers.get("Content-Type");
        var cIdx = void 0;
        var jsonObj = void 0;
        var d = data + "";
        guid = guid.substring(guid.indexOf("=batchresponse") + 1);
        d = d.split(guid);
        if (d.length < 2) {
          return {};
        }
        d = d[1];
        var exVal = /(?:\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(d);
        if (exVal) {
          d.replace(exVal[0], "");
        }
        var changeGuid = exVal ? exVal[1] : "";
        d = d.split(changeGuid);
        for (var i = d.length; i > -1; i--) {
          if (!/\bContent-ID:/i.test(d[i]) || !/\bHTTP.+201/.test(d[i])) {
            continue;
          }
          cIdx = parseInt(/\bContent-ID: (\d+)/i.exec(d[i])[1], 10);
          if (changes.addedRecords[cIdx]) {
            jsonObj = DataUtil.parse.parseJson(/^\{.+\}/m.exec(d[i])[0]);
            extend({}, changes.addedRecords[cIdx], this.processResponse(jsonObj));
          }
        }
        return changes;
      }
      return null;
    };
    ODataAdaptor2.prototype.compareAndRemove = function(data, original, key) {
      var _this = this;
      if (isNullOrUndefined(original)) {
        return data;
      }
      Object.keys(data).forEach(function(prop) {
        if (prop !== key && prop !== "@odata.etag") {
          if (DataUtil.isPlainObject(data[prop])) {
            _this.compareAndRemove(data[prop], original[prop]);
            var final = Object.keys(data[prop]).filter(function(data2) {
              return data2 !== "@odata.etag";
            });
            if (final.length === 0) {
              delete data[prop];
            }
          } else if (data[prop] === original[prop]) {
            delete data[prop];
          } else if (data[prop] && original[prop] && data[prop].valueOf() === original[prop].valueOf()) {
            delete data[prop];
          }
        }
      });
      return data;
    };
    return ODataAdaptor2;
  }(UrlAdaptor)
);
var ODataV4Adaptor = (
  /** @class */
  function(_super) {
    __extends30(ODataV4Adaptor2, _super);
    function ODataV4Adaptor2(props) {
      var _this = _super.call(this, props) || this;
      _this.options = extend({}, _this.options, {
        requestType: "get",
        accept: "application/json, text/javascript, */*; q=0.01",
        multipartAccept: "multipart/mixed",
        sortBy: "$orderby",
        select: "$select",
        skip: "$skip",
        take: "$top",
        count: "$count",
        search: "$search",
        where: "$filter",
        expand: "$expand",
        batch: "$batch",
        changeSet: "--changeset_",
        batchPre: "batch_",
        contentId: "Content-Id: ",
        batchContent: "Content-Type: multipart/mixed; boundary=",
        changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
        batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 ",
        updateType: "PATCH",
        localTime: false,
        apply: "$apply"
      });
      extend(_this.options, props || {});
      return _this;
    }
    ODataV4Adaptor2.prototype.getModuleName = function() {
      return "ODataV4Adaptor";
    };
    ODataV4Adaptor2.prototype.onCount = function(e) {
      return e === true ? "true" : "";
    };
    ODataV4Adaptor2.prototype.onPredicate = function(predicate, query, requiresCast) {
      var returnValue = "";
      var val = predicate.value;
      var isDate = val instanceof Date;
      if (query instanceof Query) {
        var queries = this.getQueryRequest(query);
        for (var i = 0; i < queries.filters.length; i++) {
          if (queries.filters[i].e.key === predicate.value) {
            requiresCast = true;
          }
        }
      }
      returnValue = _super.prototype.onPredicate.call(this, predicate, query, requiresCast);
      if (isDate) {
        returnValue = returnValue.replace(/datetime'(.*)'$/, "$1");
      }
      if (DataUtil.parse.isGuid(val)) {
        returnValue = returnValue.replace("guid", "").replace(/'/g, "");
      }
      return returnValue;
    };
    ODataV4Adaptor2.prototype.onEachSearch = function(e) {
      var search = this.pvt.searches || [];
      search.push(e.key);
      this.pvt.searches = search;
    };
    ODataV4Adaptor2.prototype.onSearch = function(e) {
      return this.pvt.searches.join(" OR ");
    };
    ODataV4Adaptor2.prototype.onExpand = function(e) {
      var _this = this;
      var selected = {};
      var expanded = {};
      var expands = e.expands.slice();
      var exArr = [];
      var selects = e.selects.filter(function(item) {
        return item.indexOf(".") > -1;
      });
      selects.forEach(function(select2) {
        var splits = select2.split(".");
        if (!(splits[0] in selected)) {
          selected[splits[0]] = [];
        }
        if (splits.length === 2) {
          if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1) {
            if (selected[splits[0]][0].indexOf("$expand") !== -1 && selected[splits[0]][0].indexOf(";$select=") === -1) {
              selected[splits[0]][0] = selected[splits[0]][0] + ";$select=" + splits[1];
            } else {
              selected[splits[0]][0] = selected[splits[0]][0] + "," + splits[1];
            }
          } else {
            selected[splits[0]].push("$select=" + splits[1]);
          }
        } else {
          var sel = "$select=" + splits[splits.length - 1];
          var exp = "";
          var close_1 = "";
          for (var i = 1; i < splits.length - 1; i++) {
            exp = exp + "$expand=" + splits[i] + "(";
            close_1 = close_1 + ")";
          }
          var combineVal = exp + sel + close_1;
          if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1 && _this.expandQueryIndex(selected[splits[0]], true)) {
            var idx = _this.expandQueryIndex(selected[splits[0]]);
            selected[splits[0]][idx] = selected[splits[0]][idx] + combineVal.replace("$expand=", ",");
          } else {
            selected[splits[0]].push(combineVal);
          }
        }
      });
      Object.keys(selected).forEach(function(expand) {
        if (expands.indexOf(expand) === -1) {
          expands.push(expand);
        }
      });
      expands.forEach(function(expand) {
        expanded[expand] = expand in selected ? expand + "(" + selected[expand].join(";") + ")" : expand;
      });
      Object.keys(expanded).forEach(function(ex) {
        return exArr.push(expanded[ex]);
      });
      return exArr.join(",");
    };
    ODataV4Adaptor2.prototype.expandQueryIndex = function(query, isExpand) {
      for (var i = 0; i < query.length; i++) {
        if (query[i].indexOf("$expand") !== -1) {
          return isExpand ? true : i;
        }
      }
      return isExpand ? false : 0;
    };
    ODataV4Adaptor2.prototype.onDistinct = function(distinctFields) {
      var fields = distinctFields.map(function(field) {
        return ODataAdaptor.getField(field);
      }).join(",");
      return "groupby((" + fields + "))";
    };
    ODataV4Adaptor2.prototype.onSelect = function(e) {
      return _super.prototype.onSelect.call(this, e.filter(function(item) {
        return item.indexOf(".") === -1;
      }));
    };
    ODataV4Adaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (settings.type === "POST" || settings.type === "PUT" || settings.type === "PATCH") {
        request.headers.set("Prefer", "return=representation");
      }
      request.headers.set("Accept", this.options.accept);
    };
    ODataV4Adaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var metaName = "@odata.context";
      var metaV4Name = "@context";
      if (request && request.type === "GET" && !this.rootUrl && (data[metaName] || data[metaV4Name])) {
        var dataUrl = data[metaName] ? data[metaName].split("/$metadata#") : data[metaV4Name].split("/$metadata#");
        this.rootUrl = dataUrl[0];
        this.resourceTableName = dataUrl[1];
      }
      var pvtData = "pvtData";
      var pvt = request && request[pvtData];
      var emptyAndBatch = _super.prototype.processBatchResponse.call(this, data, query, xhr, request, changes);
      if (emptyAndBatch) {
        return emptyAndBatch;
      }
      var count = null;
      var dataCount = "@odata.count";
      var dataV4Count = "@count";
      if (query && query.isCountRequired) {
        if (dataCount in data) {
          count = data[dataCount];
        } else if (dataV4Count in data) {
          count = data[dataV4Count];
        }
      }
      data = !isNullOrUndefined(data.value) ? data.value : data;
      var args = {};
      args.count = count;
      args.result = data;
      this.getAggregateResult(pvt, data, args, null, query);
      return DataUtil.isNull(count) ? args.result : { result: args.result, count, aggregates: args.aggregates };
    };
    return ODataV4Adaptor2;
  }(ODataAdaptor)
);
var WebApiAdaptor = (
  /** @class */
  function(_super) {
    __extends30(WebApiAdaptor2, _super);
    function WebApiAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WebApiAdaptor2.prototype.getModuleName = function() {
      return "WebApiAdaptor";
    };
    WebApiAdaptor2.prototype.insert = function(dm, data, tableName) {
      return {
        type: "POST",
        url: dm.dataSource.url,
        data: JSON.stringify(data)
      };
    };
    WebApiAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      return {
        type: "DELETE",
        url: dm.dataSource.url + "/" + value,
        data: JSON.stringify(value)
      };
    };
    WebApiAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      return {
        type: "PUT",
        url: dm.dataSource.url,
        data: JSON.stringify(value)
      };
    };
    WebApiAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      var _this = this;
      var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
      var url = dm.dataSource.url.replace(/\/*$/, "/" + this.options.batch);
      e.url = this.resourceTableName ? this.resourceTableName : e.url;
      var req = [];
      var _loop_1 = function(i2, x2) {
        changes.addedRecords.forEach(function(j, d) {
          var stat = {
            "method": "POST ",
            "url": function(data, i3, key) {
              return "";
            },
            "data": function(data, i3) {
              return JSON.stringify(data[i3]) + "\n\n";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("POST /api/" + (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.addedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.addedRecords.length; i < x; i++) {
        _loop_1(i, x);
      }
      var _loop_2 = function(i2, x2) {
        changes.changedRecords.forEach(function(j, d) {
          var stat = {
            "method": _this.options.updateType + " ",
            "url": function(data, i3, key) {
              return "";
            },
            "data": function(data, i3) {
              return JSON.stringify(data[i3]) + "\n\n";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("PUT /api/" + (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.changedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.changedRecords.length; i < x; i++) {
        _loop_2(i, x);
      }
      var _loop_3 = function(i2, x2) {
        changes.deletedRecords.forEach(function(j, d) {
          var state = {
            "mtd": "DELETE ",
            "url": function(data, i3, key) {
              var url2 = DataUtil.getObject(key, data[i3]);
              if (typeof url2 === "number" || DataUtil.parse.isGuid(url2)) {
                return "/" + url2;
              } else if (url2 instanceof Date) {
                var datTime = data[i3][key];
                return "/" + datTime.toJSON();
              } else {
                return "/'" + url2 + "'";
              }
            },
            "data": function(data, i3) {
              return "";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("DELETE /api/" + (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + state.url(changes.deletedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.deletedRecords.length; i < x; i++) {
        _loop_3(i, x);
      }
      req.push("--" + initialGuid + "--", "");
      return {
        type: "POST",
        url,
        contentType: "multipart/mixed; boundary=" + initialGuid,
        data: req.join("\r\n")
      };
    };
    WebApiAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      request.headers.set("Accept", "application/json, text/javascript, */*; q=0.01");
    };
    WebApiAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var pvtData = "pvtData";
      var pvt = request && request[pvtData];
      var count = null;
      var args = {};
      if (request && request.type.toLowerCase() !== "post") {
        var versionCheck = xhr && request.fetchRequest.headers.get("DataServiceVersion");
        var version = versionCheck && parseInt(versionCheck, 10) || 2;
        if (query && query.isCountRequired) {
          if (!DataUtil.isNull(data.Count)) {
            count = data.Count;
          }
        }
        if (version < 3 && data.Items) {
          data = data.Items;
        }
        args.count = count;
        args.result = data;
        this.getAggregateResult(pvt, data, args, null, query);
      }
      args.result = args.result || data;
      return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    return WebApiAdaptor2;
  }(ODataAdaptor)
);
var WebMethodAdaptor = (
  /** @class */
  function(_super) {
    __extends30(WebMethodAdaptor2, _super);
    function WebMethodAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WebMethodAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var obj = new UrlAdaptor().processQuery(dm, query, hierarchyFilters);
      var getData = "data";
      var data = DataUtil.parse.parseJson(obj[getData]);
      var result = {};
      var value = "value";
      if (data.param) {
        for (var i = 0; i < data.param.length; i++) {
          var param = data.param[i];
          var key = Object.keys(param)[0];
          result[key] = param[key];
        }
      }
      result[value] = data;
      var pvtData = "pvtData";
      var url = "url";
      return {
        data: JSON.stringify(result, DataUtil.parse.jsonDateReplacer),
        url: obj[url],
        pvtData: obj[pvtData],
        type: "POST",
        contentType: "application/json; charset=utf-8"
      };
    };
    return WebMethodAdaptor2;
  }(UrlAdaptor)
);
var RemoteSaveAdaptor = (
  /** @class */
  function(_super) {
    __extends30(RemoteSaveAdaptor2, _super);
    function RemoteSaveAdaptor2() {
      var _this = _super.call(this) || this;
      setValue("beforeSend", UrlAdaptor.prototype.beforeSend, _this);
      return _this;
    }
    RemoteSaveAdaptor2.prototype.insert = function(dm, data, tableName, query, position) {
      this.pvt.position = position;
      this.updateType = "add";
      return {
        url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: data,
          table: tableName,
          action: "insert"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.remove = function(dm, keyField, val, tableName, query) {
      _super.prototype.remove.call(this, dm, keyField, val);
      return {
        type: "POST",
        url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          key: val,
          keyColumn: keyField,
          table: tableName,
          action: "remove"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.update = function(dm, keyField, val, tableName, query) {
      this.updateType = "update";
      this.updateKey = keyField;
      return {
        type: "POST",
        url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: val,
          action: "update",
          keyColumn: keyField,
          key: val[keyField],
          table: tableName
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes, e) {
      var i;
      var newData = request ? JSON.parse(request.data) : data;
      data = newData.action === "batch" ? DataUtil.parse.parseJson(data) : data;
      if (this.updateType === "add") {
        _super.prototype.insert.call(this, ds, data, null, null, this.pvt.position);
      }
      if (this.updateType === "update") {
        _super.prototype.update.call(this, ds, this.updateKey, data);
      }
      this.updateType = void 0;
      if (data.added) {
        for (i = 0; i < data.added.length; i++) {
          _super.prototype.insert.call(this, ds, data.added[i]);
        }
      }
      if (data.changed) {
        for (i = 0; i < data.changed.length; i++) {
          _super.prototype.update.call(this, ds, e.key, data.changed[i]);
        }
      }
      if (data.deleted) {
        for (i = 0; i < data.deleted.length; i++) {
          _super.prototype.remove.call(this, ds, e.key, data.deleted[i]);
        }
      }
      return data;
    };
    RemoteSaveAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      return {
        type: "POST",
        url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        data: JSON.stringify(extend({}, {
          changed: changes.changedRecords,
          added: changes.addedRecords,
          deleted: changes.deletedRecords,
          action: "batch",
          table: e.url,
          key: e.key
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.addParams = function(options) {
      var urlParams = new UrlAdaptor();
      urlParams.addParams(options);
    };
    return RemoteSaveAdaptor2;
  }(JsonAdaptor)
);
var CustomDataAdaptor = (
  /** @class */
  function(_super) {
    __extends30(CustomDataAdaptor2, _super);
    function CustomDataAdaptor2(props) {
      var _this = _super.call(this) || this;
      _this.options = extend({}, _this.options, {
        getData: new Function(),
        addRecord: new Function(),
        updateRecord: new Function(),
        deleteRecord: new Function(),
        batchUpdate: new Function()
      });
      extend(_this.options, props || {});
      return _this;
    }
    CustomDataAdaptor2.prototype.getModuleName = function() {
      return "CustomDataAdaptor";
    };
    return CustomDataAdaptor2;
  }(UrlAdaptor)
);
var GraphQLAdaptor = (
  /** @class */
  function(_super) {
    __extends30(GraphQLAdaptor2, _super);
    function GraphQLAdaptor2(options) {
      var _this = _super.call(this) || this;
      _this.opt = options;
      _this.schema = _this.opt.response;
      _this.query = _this.opt.query;
      _this.getVariables = _this.opt.getVariables ? _this.opt.getVariables : function() {
      };
      _this.getQuery = function() {
        return _this.query;
      };
      return _this;
    }
    GraphQLAdaptor2.prototype.getModuleName = function() {
      return "GraphQLAdaptor";
    };
    GraphQLAdaptor2.prototype.processQuery = function(datamanager, query) {
      var urlQuery = _super.prototype.processQuery.apply(this, arguments);
      var dm = JSON.parse(urlQuery.data);
      var keys = [
        "skip",
        "take",
        "sorted",
        "table",
        "select",
        "where",
        "search",
        "requiresCounts",
        "aggregates",
        "params"
      ];
      var temp = {};
      var str = "searchwhereparams";
      keys.filter(function(e) {
        temp[e] = str.indexOf(e) > -1 ? JSON.stringify(dm[e]) : dm[e];
      });
      var vars = this.getVariables() || {};
      vars["datamanager"] = temp;
      var data = JSON.stringify({
        query: this.getQuery(),
        variables: vars
      });
      urlQuery.data = data;
      return urlQuery;
    };
    GraphQLAdaptor2.prototype.processResponse = function(resData, ds, query, xhr, request) {
      var res = resData;
      var count;
      var aggregates;
      var result = getValue(this.schema.result, res.data);
      if (this.schema.count) {
        count = getValue(this.schema.count, res.data);
      }
      if (this.schema.aggregates) {
        aggregates = getValue(this.schema.aggregates, res.data);
        aggregates = !isNullOrUndefined(aggregates) ? DataUtil.parse.parseJson(aggregates) : aggregates;
      }
      var pvt = request.pvtData || {};
      var args = { result, aggregates };
      var data = args;
      if (pvt && pvt.groups && pvt.groups.length) {
        this.getAggregateResult(pvt, data, args, null, query);
      }
      return !isNullOrUndefined(count) ? { result: args.result, count, aggregates } : args.result;
    };
    GraphQLAdaptor2.prototype.insert = function() {
      var inserted = _super.prototype.insert.apply(this, arguments);
      return this.generateCrudData(inserted, "insert");
    };
    GraphQLAdaptor2.prototype.update = function() {
      var inserted = _super.prototype.update.apply(this, arguments);
      return this.generateCrudData(inserted, "update");
    };
    GraphQLAdaptor2.prototype.remove = function() {
      var inserted = _super.prototype.remove.apply(this, arguments);
      return this.generateCrudData(inserted, "remove");
    };
    GraphQLAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var batch = _super.prototype.batchRequest.apply(this, arguments);
      var bData = JSON.parse(batch.data);
      bData.key = e.key;
      batch.data = JSON.stringify(bData);
      return this.generateCrudData(batch, "batch");
    };
    GraphQLAdaptor2.prototype.generateCrudData = function(crudData, action) {
      var parsed = JSON.parse(crudData.data);
      crudData.data = JSON.stringify({
        query: this.opt.getMutation(action),
        variables: parsed
      });
      return crudData;
    };
    return GraphQLAdaptor2;
  }(UrlAdaptor)
);
var CacheAdaptor = (
  /** @class */
  function(_super) {
    __extends30(CacheAdaptor2, _super);
    function CacheAdaptor2(adaptor, timeStamp, pageSize) {
      var _this = _super.call(this) || this;
      _this.isCrudAction = false;
      _this.isInsertAction = false;
      if (!isNullOrUndefined(adaptor)) {
        _this.cacheAdaptor = adaptor;
      }
      _this.pageSize = pageSize;
      _this.guidId = DataUtil.getGuid("cacheAdaptor");
      var obj = { keys: [], results: [] };
      window.localStorage.setItem(_this.guidId, JSON.stringify(obj));
      var guid = _this.guidId;
      if (!isNullOrUndefined(timeStamp)) {
        setInterval(function() {
          var data = DataUtil.parse.parseJson(window.localStorage.getItem(guid));
          var forDel = [];
          for (var i = 0; i < data.results.length; i++) {
            var currentTime = +/* @__PURE__ */ new Date();
            var requestTime = +new Date(data.results[i].timeStamp);
            data.results[i].timeStamp = currentTime - requestTime;
            if (currentTime - requestTime > timeStamp) {
              forDel.push(i);
            }
          }
          for (var i = 0; i < forDel.length; i++) {
            data.results.splice(forDel[i], 1);
            data.keys.splice(forDel[i], 1);
          }
          window.localStorage.removeItem(guid);
          window.localStorage.setItem(guid, JSON.stringify(data));
        }, timeStamp);
      }
      return _this;
    }
    CacheAdaptor2.prototype.generateKey = function(url, query) {
      var queries = this.getQueryRequest(query);
      var singles = Query.filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]);
      var key = url;
      var page = "onPage";
      if (page in singles) {
        key += singles[page].pageIndex;
      }
      queries.sorts.forEach(function(obj) {
        key += obj.e.direction + obj.e.fieldName;
      });
      queries.groups.forEach(function(obj) {
        key += obj.e.fieldName;
      });
      queries.searches.forEach(function(obj) {
        key += obj.e.searchKey;
      });
      for (var filter = 0; filter < queries.filters.length; filter++) {
        var currentFilter = queries.filters[filter];
        if (currentFilter.e.isComplex) {
          var newQuery = query.clone();
          newQuery.queries = [];
          for (var i = 0; i < currentFilter.e.predicates.length; i++) {
            newQuery.queries.push({ fn: "onWhere", e: currentFilter.e.predicates[i], filter: query.queries.filter });
          }
          key += currentFilter.e.condition + this.generateKey(url, newQuery);
        } else {
          key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;
        }
      }
      return key;
    };
    CacheAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var key = this.generateKey(dm.dataSource.url, query);
      var cachedItems = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
      var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;
      if (data != null && !this.isCrudAction && !this.isInsertAction) {
        return data;
      }
      this.isCrudAction = null;
      this.isInsertAction = null;
      return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
    };
    CacheAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      if (this.isInsertAction || request && this.cacheAdaptor.options.batch && DataUtil.endsWith(request.url, this.cacheAdaptor.options.batch) && request.type.toLowerCase() === "post") {
        return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);
      }
      data = this.cacheAdaptor.processResponse.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
      var key = query ? this.generateKey(ds.dataSource.url, query) : ds.dataSource.url;
      var obj = {};
      obj = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
      var index = obj.keys.indexOf(key);
      if (index !== -1) {
        obj.results.splice(index, 1);
        obj.keys.splice(index, 1);
      }
      obj.results[obj.keys.push(key) - 1] = { keys: key, result: data.result, timeStamp: /* @__PURE__ */ new Date(), count: data.count };
      while (obj.results.length > this.pageSize) {
        obj.results.splice(0, 1);
        obj.keys.splice(0, 1);
      }
      window.localStorage.setItem(this.guidId, JSON.stringify(obj));
      return data;
    };
    CacheAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (!isNullOrUndefined(this.cacheAdaptor.options.batch) && DataUtil.endsWith(settings.url, this.cacheAdaptor.options.batch) && settings.type.toLowerCase() === "post") {
        request.headers.set("Accept", this.cacheAdaptor.options.multipartAccept);
      }
      if (!dm.dataSource.crossDomain) {
        request.headers.set("Accept", this.cacheAdaptor.options.accept);
      }
    };
    CacheAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      this.isCrudAction = true;
      return this.cacheAdaptor.update(dm, keyField, value, tableName);
    };
    CacheAdaptor2.prototype.insert = function(dm, data, tableName) {
      this.isInsertAction = true;
      return this.cacheAdaptor.insert(dm, data, tableName);
    };
    CacheAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      this.isCrudAction = true;
      return this.cacheAdaptor.remove(dm, keyField, value, tableName);
    };
    CacheAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      return this.cacheAdaptor.batchRequest(dm, changes, e);
    };
    return CacheAdaptor2;
  }(UrlAdaptor)
);

// node_modules/@syncfusion/ej2-data/src/manager.js
var DataManager = (
  /** @class */
  function() {
    function DataManager2(dataSource, query, adaptor) {
      var _this = this;
      this.dateParse = true;
      this.timeZoneHandling = true;
      this.persistQuery = {};
      this.isInitialLoad = false;
      this.requests = [];
      this.isInitialLoad = true;
      if (!dataSource && !this.dataSource) {
        dataSource = [];
      }
      adaptor = adaptor || dataSource.adaptor;
      if (dataSource && dataSource.timeZoneHandling === false) {
        this.timeZoneHandling = dataSource.timeZoneHandling;
      }
      var data;
      if (dataSource instanceof Array) {
        data = {
          json: dataSource,
          offline: true
        };
      } else if (typeof dataSource === "object") {
        if (!dataSource.json) {
          dataSource.json = [];
        }
        if (!dataSource.enablePersistence) {
          dataSource.enablePersistence = false;
        }
        if (!dataSource.id) {
          dataSource.id = "";
        }
        if (!dataSource.ignoreOnPersist) {
          dataSource.ignoreOnPersist = [];
        }
        data = {
          url: dataSource.url,
          insertUrl: dataSource.insertUrl,
          removeUrl: dataSource.removeUrl,
          updateUrl: dataSource.updateUrl,
          crudUrl: dataSource.crudUrl,
          batchUrl: dataSource.batchUrl,
          json: dataSource.json,
          headers: dataSource.headers,
          accept: dataSource.accept,
          data: dataSource.data,
          timeTillExpiration: dataSource.timeTillExpiration,
          cachingPageSize: dataSource.cachingPageSize,
          enableCaching: dataSource.enableCaching,
          requestType: dataSource.requestType,
          key: dataSource.key,
          crossDomain: dataSource.crossDomain,
          jsonp: dataSource.jsonp,
          dataType: dataSource.dataType,
          offline: dataSource.offline !== void 0 ? dataSource.offline : dataSource.adaptor instanceof RemoteSaveAdaptor || dataSource.adaptor instanceof CustomDataAdaptor ? false : dataSource.url ? false : true,
          requiresFormat: dataSource.requiresFormat,
          enablePersistence: dataSource.enablePersistence,
          id: dataSource.id,
          ignoreOnPersist: dataSource.ignoreOnPersist
        };
      } else {
        DataUtil.throwError("DataManager: Invalid arguments");
      }
      if (data.requiresFormat === void 0 && !DataUtil.isCors()) {
        data.requiresFormat = isNullOrUndefined(data.crossDomain) ? true : data.crossDomain;
      }
      if (data.dataType === void 0) {
        data.dataType = "json";
      }
      this.dataSource = data;
      this.defaultQuery = query;
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        window.addEventListener("unload", this.setPersistData.bind(this));
      }
      if (data.url && data.offline && !data.json.length) {
        this.isDataAvailable = false;
        this.adaptor = adaptor || new ODataAdaptor();
        this.dataSource.offline = false;
        this.ready = this.executeQuery(query || new Query());
        this.ready.then(function(e) {
          _this.dataSource.offline = true;
          _this.isDataAvailable = true;
          data.json = e.result;
          _this.adaptor = new JsonAdaptor();
        });
      } else {
        this.adaptor = data.offline ? new JsonAdaptor() : new ODataAdaptor();
      }
      if (!data.jsonp && this.adaptor instanceof ODataAdaptor) {
        data.jsonp = "callback";
      }
      this.adaptor = adaptor || this.adaptor;
      if (data.enableCaching) {
        this.adaptor = new CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);
      }
      return this;
    }
    DataManager2.prototype.getPersistedData = function(id) {
      var persistedData = localStorage.getItem(id || this.dataSource.id);
      return JSON.parse(persistedData);
    };
    DataManager2.prototype.setPersistData = function(e, id, persistData) {
      localStorage.setItem(id || this.dataSource.id, JSON.stringify(persistData || this.persistQuery));
    };
    DataManager2.prototype.setPersistQuery = function(query) {
      var _this = this;
      var persistedQuery = this.getPersistedData();
      if (this.isInitialLoad && persistedQuery && Object.keys(persistedQuery).length) {
        this.persistQuery = persistedQuery;
        this.persistQuery.queries = this.persistQuery.queries.filter(function(query2) {
          if (_this.dataSource.ignoreOnPersist && _this.dataSource.ignoreOnPersist.length) {
            if (query2.fn && _this.dataSource.ignoreOnPersist.some(function(keyword) {
              return query2.fn === keyword;
            })) {
              return false;
            }
          }
          if (query2.fn === "onWhere") {
            var e = query2.e;
            if (e && e.isComplex && e.predicates instanceof Array) {
              var allPredicates = e.predicates.map(function(predicateObj) {
                if (predicateObj.predicates && predicateObj.predicates instanceof Array) {
                  var nestedPredicates = predicateObj.predicates.map(function(nestedPredicate) {
                    var field2 = nestedPredicate.field, operator2 = nestedPredicate.operator, value2 = nestedPredicate.value, ignoreCase2 = nestedPredicate.ignoreCase, ignoreAccent2 = nestedPredicate.ignoreAccent, matchCase2 = nestedPredicate.matchCase;
                    return new Predicate(field2, operator2, value2, ignoreCase2, ignoreAccent2, matchCase2);
                  });
                  return predicateObj.condition === "and" ? Predicate.and(nestedPredicates) : Predicate.or(nestedPredicates);
                } else {
                  var field = predicateObj.field, operator = predicateObj.operator, value = predicateObj.value, ignoreCase = predicateObj.ignoreCase, ignoreAccent = predicateObj.ignoreAccent, matchCase = predicateObj.matchCase;
                  return new Predicate(field, operator, value, ignoreCase, ignoreAccent, matchCase);
                }
              });
              query2.e = new Predicate(allPredicates[0], e.condition, allPredicates.slice(1));
            }
          }
          return true;
        });
        var newQuery = extend(new Query(), this.persistQuery);
        this.isInitialLoad = false;
        return newQuery;
      } else {
        this.persistQuery = query;
        this.isInitialLoad = false;
        return query;
      }
    };
    DataManager2.prototype.setDefaultQuery = function(query) {
      this.defaultQuery = query;
      return this;
    };
    DataManager2.prototype.executeLocal = function(query) {
      if (!this.defaultQuery && !(query instanceof Query)) {
        DataUtil.throwError("DataManager - executeLocal() : A query is required to execute");
      }
      if (!this.dataSource.json) {
        DataUtil.throwError("DataManager - executeLocal() : Json data is required to execute");
      }
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        query = this.setPersistQuery(query);
      }
      query = query || this.defaultQuery;
      var result = this.adaptor.processQuery(this, query);
      if (query.subQuery) {
        var from = query.subQuery.fromTable;
        var lookup = query.subQuery.lookups;
        var res = query.isCountRequired ? result.result : result;
        if (lookup && lookup instanceof Array) {
          DataUtil.buildHierarchy(query.subQuery.fKey, from, res, lookup, query.subQuery.key);
        }
        for (var j = 0; j < res.length; j++) {
          if (res[j][from] instanceof Array) {
            res[j] = extend({}, {}, res[j]);
            res[j][from] = this.adaptor.processResponse(query.subQuery.using(new DataManager2(res[j][from].slice(0))).executeLocal(), this, query);
          }
        }
      }
      return this.adaptor.processResponse(result, this, query);
    };
    DataManager2.prototype.executeQuery = function(query, done, fail, always) {
      var _this = this;
      var makeRequest = "makeRequest";
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        query = this.setPersistQuery(query);
      }
      if (typeof query === "function") {
        always = fail;
        fail = done;
        done = query;
        query = null;
      }
      if (!query) {
        query = this.defaultQuery;
      }
      if (!(query instanceof Query)) {
        DataUtil.throwError("DataManager - executeQuery() : A query is required to execute");
      }
      var deffered = new Deferred2();
      var args = { query };
      if (!this.dataSource.offline && (this.dataSource.url !== void 0 && this.dataSource.url !== "") || !isNullOrUndefined(this.adaptor[makeRequest]) || this.isCustomDataAdaptor(this.adaptor)) {
        var result = this.adaptor.processQuery(this, query);
        if (!isNullOrUndefined(this.adaptor[makeRequest])) {
          this.adaptor[makeRequest](result, deffered, args, query);
        } else if (!isNullOrUndefined(result.url) || this.isCustomDataAdaptor(this.adaptor)) {
          this.requests = [];
          this.makeRequest(result, deffered, args, query);
        } else {
          args = DataManager2.getDeferedArgs(query, result, args);
          deffered.resolve(args);
        }
      } else {
        DataManager2.nextTick(function() {
          var res = _this.executeLocal(query);
          args = DataManager2.getDeferedArgs(query, res, args);
          deffered.resolve(args);
        });
      }
      if (done || fail) {
        deffered.promise.then(done, fail);
      }
      if (always) {
        deffered.promise.then(always, always);
      }
      return deffered.promise;
    };
    DataManager2.getDeferedArgs = function(query, result, args) {
      if (query.isCountRequired) {
        args.result = result.result;
        args.count = result.count;
        args.aggregates = result.aggregates;
      } else {
        args.result = result;
      }
      return args;
    };
    DataManager2.nextTick = function(fn) {
      (window.setImmediate || window.setTimeout)(fn, 0);
    };
    DataManager2.prototype.extendRequest = function(url, fnSuccess, fnFail) {
      return extend({}, {
        type: "GET",
        dataType: this.dataSource.dataType,
        crossDomain: this.dataSource.crossDomain,
        jsonp: this.dataSource.jsonp,
        cache: true,
        processData: false,
        onSuccess: fnSuccess,
        onFailure: fnFail
      }, url);
    };
    DataManager2.prototype.makeRequest = function(url, deffered, args, query) {
      var _this = this;
      var isSelector = !!query.subQuerySelector;
      var fnFail = function(e) {
        args.error = e;
        deffered.reject(args);
      };
      var process = function(data, count, xhr, request2, actual, aggregates, virtualSelectRecords) {
        args.xhr = xhr;
        args.count = count ? parseInt(count.toString(), 10) : 0;
        args.result = data;
        args.request = request2;
        args.aggregates = aggregates;
        args.actual = actual;
        args.virtualSelectRecords = virtualSelectRecords;
        deffered.resolve(args);
      };
      var fnQueryChild = function(data, selector) {
        var subDeffer = new Deferred2();
        var childArgs = { parent: args };
        query.subQuery.isChild = true;
        var subUrl = _this.adaptor.processQuery(_this, query.subQuery, data ? _this.adaptor.processResponse(data) : selector);
        var childReq = _this.makeRequest(subUrl, subDeffer, childArgs, query.subQuery);
        if (!isSelector) {
          subDeffer.then(function(subData) {
            if (data) {
              DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, data, subData, query.subQuery.key);
              process(data, subData.count, subData.xhr);
            }
          }, fnFail);
        }
        return childReq;
      };
      var fnSuccess = function(data, request2) {
        if (_this.isGraphQLAdaptor(_this.adaptor)) {
          if (!isNullOrUndefined(data["errors"])) {
            return fnFail(data["errors"], request2);
          }
        }
        if (_this.isCustomDataAdaptor(_this.adaptor)) {
          request2 = extend({}, _this.fetchReqOption, request2);
        }
        if (request2.contentType.indexOf("xml") === -1 && _this.dateParse) {
          data = DataUtil.parse.parseJson(data);
        }
        var result = _this.adaptor.processResponse(data, _this, query, request2.fetchRequest, request2);
        var count = 0;
        var aggregates = null;
        var virtualSelectRecords = "virtualSelectRecords";
        var virtualRecords = data[virtualSelectRecords];
        if (query.isCountRequired) {
          count = result.count;
          aggregates = result.aggregates;
          result = result.result;
        }
        if (!query.subQuery) {
          process(result, count, request2.fetchRequest, request2.type, data, aggregates, virtualRecords);
          return;
        }
        if (!isSelector) {
          fnQueryChild(result, request2);
        }
      };
      var req = this.extendRequest(url, fnSuccess, fnFail);
      if (!this.isCustomDataAdaptor(this.adaptor)) {
        var fetch_1 = new Fetch(req);
        fetch_1.beforeSend = function() {
          _this.beforeSend(fetch_1.fetchRequest, fetch_1);
        };
        req = fetch_1.send();
        req.catch(function(e) {
          return true;
        });
        this.requests.push(fetch_1);
      } else {
        this.fetchReqOption = req;
        var request = req;
        this.adaptor.options.getData({
          data: request.data,
          onSuccess: request.onSuccess,
          onFailure: request.onFailure
        });
      }
      if (isSelector) {
        var promise = void 0;
        var res = query.subQuerySelector.call(this, { query: query.subQuery, parent: query });
        if (res && res.length) {
          promise = Promise.all([req, fnQueryChild(null, res)]);
          promise.then(function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            var result = args2[0];
            var pResult = _this.adaptor.processResponse(result[0], _this, query, _this.requests[0].fetchRequest, _this.requests[0]);
            var count = 0;
            if (query.isCountRequired) {
              count = pResult.count;
              pResult = pResult.result;
            }
            var cResult = _this.adaptor.processResponse(result[1], _this, query.subQuery, _this.requests[1].fetchRequest, _this.requests[1]);
            count = 0;
            if (query.subQuery.isCountRequired) {
              count = cResult.count;
              cResult = cResult.result;
            }
            DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, pResult, cResult, query.subQuery.key);
            isSelector = false;
            process(pResult, count, _this.requests[0].fetchRequest);
          });
        } else {
          isSelector = false;
        }
      }
      return req;
    };
    DataManager2.prototype.beforeSend = function(request, settings) {
      this.adaptor.beforeSend(this, request, settings);
      var headers = this.dataSource.headers;
      var props;
      for (var i = 0; headers && i < headers.length; i++) {
        props = [];
        var keys = Object.keys(headers[i]);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var prop = keys_1[_i];
          props.push(prop);
          request.headers.set(prop, headers[i][prop]);
        }
      }
    };
    DataManager2.prototype.saveChanges = function(changes, key, tableName, query, original) {
      var _this = this;
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var args = {
        url: tableName,
        key: key || this.dataSource.key
      };
      var req = this.adaptor.batchRequest(this, changes, args, query || new Query(), original);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return req;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](req);
      } else if (!this.isCustomDataAdaptor(this.adaptor)) {
        var deff_1 = new Deferred2();
        var fetch_2 = new Fetch(req);
        fetch_2.beforeSend = function() {
          _this.beforeSend(fetch_2.fetchRequest, fetch_2);
        };
        fetch_2.onSuccess = function(data, request) {
          if (_this.isGraphQLAdaptor(_this.adaptor)) {
            if (!isNullOrUndefined(data["errors"])) {
              fetch_2.onFailure(JSON.stringify(data["errors"]));
            }
          }
          deff_1.resolve(_this.adaptor.processResponse(data, _this, null, request.fetchRequest, request, changes, args));
        };
        fetch_2.onFailure = function(e) {
          deff_1.reject([{ error: e }]);
        };
        fetch_2.send().catch(function(e) {
          return true;
        });
        return deff_1.promise;
      } else {
        return this.dofetchRequest(req, this.adaptor.options.batchUpdate);
      }
    };
    DataManager2.prototype.insert = function(data, tableName, query, position) {
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var req = this.adaptor.insert(this, data, tableName, query, position);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return req;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](req);
      } else {
        return this.dofetchRequest(req, this.adaptor.options.addRecord);
      }
    };
    DataManager2.prototype.remove = function(keyField, value, tableName, query) {
      if (typeof value === "object") {
        value = DataUtil.getObject(keyField, value);
      }
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var res = this.adaptor.remove(this, keyField, value, tableName, query);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return res;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](res);
      } else {
        var remove2 = this.adaptor.options.deleteRecord;
        return this.dofetchRequest(res, remove2);
      }
    };
    DataManager2.prototype.update = function(keyField, value, tableName, query, original) {
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var res = this.adaptor.update(this, keyField, value, tableName, query, original);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return res;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](res);
      } else {
        var update = this.adaptor.options.updateRecord;
        return this.dofetchRequest(res, update);
      }
    };
    DataManager2.prototype.isCustomDataAdaptor = function(dataSource) {
      return this.adaptor.getModuleName && this.adaptor.getModuleName() === "CustomDataAdaptor";
    };
    DataManager2.prototype.isGraphQLAdaptor = function(dataSource) {
      return this.adaptor.getModuleName && this.adaptor.getModuleName() === "GraphQLAdaptor";
    };
    DataManager2.prototype.successFunc = function(record, request) {
      if (this.isGraphQLAdaptor(this.adaptor)) {
        var data = typeof record === "object" ? record : JSON.parse(record);
        if (!isNullOrUndefined(data["errors"])) {
          this.failureFunc(JSON.stringify(data["errors"]));
        }
      }
      if (this.isCustomDataAdaptor(this.adaptor)) {
        request = extend({}, this.fetchReqOption, request);
      }
      try {
        DataUtil.parse.parseJson(record);
      } catch (e) {
        record = [];
      }
      record = this.adaptor.processResponse(DataUtil.parse.parseJson(record), this, null, request.fetchRequest, request);
      this.fetchDeffered.resolve(record);
    };
    DataManager2.prototype.failureFunc = function(e) {
      this.fetchDeffered.reject([{ error: e }]);
    };
    DataManager2.prototype.dofetchRequest = function(res, fetchFunc) {
      var _this = this;
      res = extend({}, {
        type: "POST",
        contentType: "application/json; charset=utf-8",
        processData: false
      }, res);
      this.fetchDeffered = new Deferred2();
      if (!this.isCustomDataAdaptor(this.adaptor)) {
        var fetch_3 = new Fetch(res);
        fetch_3.beforeSend = function() {
          _this.beforeSend(fetch_3.fetchRequest, fetch_3);
        };
        fetch_3.onSuccess = this.successFunc.bind(this);
        fetch_3.onFailure = this.failureFunc.bind(this);
        fetch_3.send().catch(function(e) {
          return true;
        });
      } else {
        this.fetchReqOption = res;
        fetchFunc.call(this, {
          data: res.data,
          onSuccess: this.successFunc.bind(this),
          onFailure: this.failureFunc.bind(this)
        });
      }
      return this.fetchDeffered.promise;
    };
    DataManager2.prototype.clearPersistence = function() {
      window.removeEventListener("unload", this.setPersistData.bind(this));
      this.dataSource.enablePersistence = false;
      this.persistQuery = {};
      window.localStorage.setItem(this.dataSource.id, "[]");
    };
    return DataManager2;
  }()
);
var Deferred2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function Deferred3() {
      var _this = this;
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      this.then = this.promise.then.bind(this.promise);
      this.catch = this.promise.catch.bind(this.promise);
    }
    return Deferred3;
  }()
);

// node_modules/@syncfusion/ej2-lists/src/common/list-base.js
var cssClass = {
  li: "e-list-item",
  ul: "e-list-parent e-ul",
  group: "e-list-group-item",
  icon: "e-list-icon",
  text: "e-list-text",
  check: "e-list-check",
  checked: "e-checked",
  selected: "e-selected",
  expanded: "e-expanded",
  textContent: "e-text-content",
  hasChild: "e-has-child",
  level: "e-level",
  url: "e-list-url",
  collapsible: "e-icon-collapsible",
  disabled: "e-disabled",
  image: "e-list-img",
  iconWrapper: "e-icon-wrapper",
  anchorWrap: "e-anchor-wrap",
  navigable: "e-navigable"
};
var ListBase;
(function(ListBase2) {
  ListBase2.defaultMappedFields = {
    id: "id",
    text: "text",
    url: "url",
    value: "value",
    isChecked: "isChecked",
    enabled: "enabled",
    expanded: "expanded",
    selected: "selected",
    iconCss: "iconCss",
    child: "child",
    isVisible: "isVisible",
    hasChildren: "hasChildren",
    tooltip: "tooltip",
    htmlAttributes: "htmlAttributes",
    urlAttributes: "urlAttributes",
    imageAttributes: "imageAttributes",
    imageUrl: "imageUrl",
    groupBy: null,
    sortBy: null
  };
  var defaultAriaAttributes = {
    level: 1,
    listRole: "presentation",
    itemRole: "presentation",
    groupItemRole: "group",
    itemText: "list-item",
    wrapperRole: "presentation"
  };
  var defaultListBaseOptions = {
    showCheckBox: false,
    showIcon: false,
    enableHtmlSanitizer: false,
    expandCollapse: false,
    fields: ListBase2.defaultMappedFields,
    ariaAttributes: defaultAriaAttributes,
    listClass: "",
    itemClass: "",
    processSubChild: false,
    sortOrder: "None",
    template: null,
    groupTemplate: null,
    headerTemplate: null,
    expandIconClass: "e-icon-collapsible",
    moduleName: "list",
    expandIconPosition: "Right",
    itemNavigable: false
  };
  function createList(createElement2, dataSource, options, isSingleLevel, componentInstance) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
    var type = typeofData(dataSource).typeof;
    if (type === "string" || type === "number") {
      return createListFromArray(createElement2, dataSource, isSingleLevel, options, componentInstance);
    } else {
      return createListFromJson(createElement2, dataSource, options, ariaAttributes.level, isSingleLevel, componentInstance);
    }
  }
  ListBase2.createList = createList;
  function createListFromArray(createElement2, dataSource, isSingleLevel, options, componentInstance) {
    var subChild = createListItemFromArray(createElement2, dataSource, isSingleLevel, options, componentInstance);
    return generateUL(createElement2, subChild, null, options);
  }
  ListBase2.createListFromArray = createListFromArray;
  function createListItemFromArray(createElement2, dataSource, isSingleLevel, options, componentInstance) {
    var subChild = [];
    var curOpt = extend({}, defaultListBaseOptions, options);
    cssClass = getModuleClass(curOpt.moduleName);
    var id = generateId();
    for (var i = 0; i < dataSource.length; i++) {
      if (isNullOrUndefined(dataSource[i])) {
        continue;
      }
      var li = void 0;
      if (curOpt.itemCreating && typeof curOpt.itemCreating === "function") {
        var curData = {
          dataSource,
          curData: dataSource[i],
          text: dataSource[i],
          options: curOpt
        };
        curOpt.itemCreating(curData);
      }
      if (isSingleLevel) {
        li = generateSingleLevelLI(createElement2, dataSource[i], void 0, null, null, [], null, id, i, options);
      } else {
        li = generateLI(createElement2, dataSource[i], void 0, null, null, options, componentInstance);
      }
      if (curOpt.itemCreated && typeof curOpt.itemCreated === "function") {
        var curData = {
          dataSource,
          curData: dataSource[i],
          text: dataSource[i],
          item: li,
          options: curOpt
        };
        curOpt.itemCreated(curData);
      }
      subChild.push(li);
    }
    return subChild;
  }
  ListBase2.createListItemFromArray = createListItemFromArray;
  function createListItemFromJson(createElement2, dataSource, options, level, isSingleLevel, componentInstance) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    cssClass = getModuleClass(curOpt.moduleName);
    var fields = componentInstance && (componentInstance.getModuleName() === "listview" || componentInstance.getModuleName() === "multiselect") ? curOpt.fields : extend({}, ListBase2.defaultMappedFields, curOpt.fields);
    var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
    var id;
    var checkboxElement = [];
    if (level) {
      ariaAttributes.level = level;
    }
    var child = [];
    var li;
    var anchorElement;
    if (dataSource && dataSource.length && !isNullOrUndefined(typeofData(dataSource).item) && !Object.prototype.hasOwnProperty.call(typeofData(dataSource).item, fields.id)) {
      id = generateId();
    }
    for (var i = 0; i < dataSource.length; i++) {
      var fieldData = getFieldValues(dataSource[i], fields);
      if (isNullOrUndefined(dataSource[i])) {
        continue;
      }
      if (curOpt.itemCreating && typeof curOpt.itemCreating === "function") {
        var curData = {
          dataSource,
          curData: dataSource[i],
          text: fieldData[fields.text],
          options: curOpt,
          fields
        };
        curOpt.itemCreating(curData);
      }
      var curItem = dataSource[i];
      if (curOpt.itemCreating && typeof curOpt.itemCreating === "function") {
        fieldData = getFieldValues(dataSource[i], fields);
      }
      if (Object.prototype.hasOwnProperty.call(fieldData, fields.id) && !isNullOrUndefined(fieldData[fields.id])) {
        id = fieldData[fields.id];
      }
      var innerEle = [];
      if (curOpt.showCheckBox) {
        if (curOpt.itemNavigable && (fieldData[fields.url] || fieldData[fields.urlAttributes])) {
          checkboxElement.push(createElement2("input", { className: cssClass.check, attrs: { type: "checkbox" } }));
        } else {
          innerEle.push(createElement2("input", { className: cssClass.check, attrs: { type: "checkbox" } }));
        }
      }
      if (isSingleLevel === true) {
        if (curOpt.showIcon && Object.prototype.hasOwnProperty.call(fieldData, fields.iconCss) && !isNullOrUndefined(fieldData[fields.iconCss])) {
          innerEle.push(createElement2("span", { className: cssClass.icon + " " + fieldData[fields.iconCss] }));
        }
        li = generateSingleLevelLI(createElement2, curItem, fieldData, fields, curOpt.itemClass, innerEle, Object.prototype.hasOwnProperty.call(curItem, "isHeader") && curItem.isHeader ? true : false, id, i, options);
        anchorElement = li.querySelector("." + cssClass.anchorWrap);
        if (curOpt.itemNavigable && checkboxElement.length) {
          prepend(checkboxElement, li.firstElementChild);
        }
      } else {
        li = generateLI(createElement2, curItem, fieldData, fields, curOpt.itemClass, options, componentInstance);
        li.classList.add(cssClass.level + "-" + ariaAttributes.level);
        li.setAttribute("aria-level", ariaAttributes.level.toString());
        if (ariaAttributes.groupItemRole === "presentation" || ariaAttributes.itemRole === "presentation") {
          li.removeAttribute("aria-level");
        }
        anchorElement = li.querySelector("." + cssClass.anchorWrap);
        if (Object.prototype.hasOwnProperty.call(fieldData, fields.tooltip)) {
          var tooltipText = fieldData[fields.tooltip];
          if (options && options.enableHtmlSanitizer) {
            tooltipText = SanitizeHtmlHelper.sanitize(tooltipText);
          } else {
            var tooltipTextElement = createElement2("span", { innerHTML: tooltipText });
            tooltipText = tooltipTextElement.innerText;
            tooltipTextElement = null;
          }
          li.setAttribute("title", tooltipText);
        }
        if (Object.prototype.hasOwnProperty.call(fieldData, fields.htmlAttributes) && fieldData[fields.htmlAttributes]) {
          var htmlAttributes = fieldData[fields.htmlAttributes];
          if ("class" in htmlAttributes && typeof htmlAttributes["class"] === "string" && htmlAttributes["class"].trim() === "") {
            delete htmlAttributes["class"];
          }
          setAttribute(li, htmlAttributes);
        }
        if (Object.prototype.hasOwnProperty.call(fieldData, fields.enabled) && fieldData[fields.enabled] === false) {
          li.classList.add(cssClass.disabled);
        }
        if (Object.prototype.hasOwnProperty.call(fieldData, fields.isVisible) && fieldData[fields.isVisible] === false) {
          li.style.display = "none";
        }
        if (Object.prototype.hasOwnProperty.call(fieldData, fields.imageUrl) && !isNullOrUndefined(fieldData[fields.imageUrl]) && !curOpt.template) {
          var attr = { src: fieldData[fields.imageUrl], alt: !isNullOrUndefined(fieldData.name) ? "Displaying " + fieldData.name + " Image" : "Displaying Image" };
          merge(attr, fieldData[fields.imageAttributes]);
          var imageElemnt = createElement2("img", { className: cssClass.image, attrs: attr });
          if (anchorElement) {
            anchorElement.insertAdjacentElement("afterbegin", imageElemnt);
          } else {
            prepend([imageElemnt], li.firstElementChild);
          }
        }
        if (curOpt.showIcon && Object.prototype.hasOwnProperty.call(fieldData, fields.iconCss) && !isNullOrUndefined(fieldData[fields.iconCss]) && !curOpt.template) {
          var iconElement = createElement2("div", { className: cssClass.icon + " " + fieldData[fields.iconCss] });
          if (anchorElement) {
            anchorElement.insertAdjacentElement("afterbegin", iconElement);
          } else {
            prepend([iconElement], li.firstElementChild);
          }
        }
        if (innerEle.length) {
          prepend(innerEle, li.firstElementChild);
        }
        if (curOpt.itemNavigable && checkboxElement.length) {
          prepend(checkboxElement, li.firstElementChild);
        }
        processSubChild(createElement2, fieldData, fields, dataSource, curOpt, li, ariaAttributes.level);
      }
      if (anchorElement) {
        addClass([li], [cssClass.navigable]);
      }
      if (curOpt.itemCreated && typeof curOpt.itemCreated === "function") {
        var curData = {
          dataSource,
          curData: dataSource[i],
          text: fieldData[fields.text],
          item: li,
          options: curOpt,
          fields
        };
        curOpt.itemCreated(curData);
      }
      checkboxElement = [];
      child.push(li);
    }
    return child;
  }
  ListBase2.createListItemFromJson = createListItemFromJson;
  function createListFromJson(createElement2, dataSource, options, level, isSingleLevel, componentInstance) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var li = createListItemFromJson(createElement2, dataSource, options, level, isSingleLevel, componentInstance);
    return generateUL(createElement2, li, curOpt.listClass, options);
  }
  ListBase2.createListFromJson = createListFromJson;
  function getSiblingLI(elementArray, element2, isPrevious) {
    cssClass = getModuleClass(defaultListBaseOptions.moduleName);
    if (!elementArray || !elementArray.length) {
      return void 0;
    }
    var siblingLI;
    var liIndex;
    var liCollections = Array.prototype.slice.call(elementArray);
    if (element2) {
      liIndex = indexOf(element2, liCollections);
    } else {
      liIndex = isPrevious === true ? liCollections.length : -1;
    }
    siblingLI = liCollections[liIndex + (isPrevious === true ? -1 : 1)];
    while (siblingLI && (!isVisible(siblingLI) || siblingLI.classList.contains(cssClass.disabled))) {
      liIndex = liIndex + (isPrevious === true ? -1 : 1);
      siblingLI = liCollections[liIndex];
    }
    return siblingLI;
  }
  ListBase2.getSiblingLI = getSiblingLI;
  function indexOf(item, elementArray) {
    if (!elementArray || !item) {
      return void 0;
    } else {
      var liCollections = elementArray;
      liCollections = Array.prototype.slice.call(elementArray);
      return liCollections.indexOf(item);
    }
  }
  ListBase2.indexOf = indexOf;
  function groupDataSource(dataSource, fields, sortOrder) {
    if (sortOrder === void 0) {
      sortOrder = "None";
    }
    var curFields = extend({}, ListBase2.defaultMappedFields, fields);
    var cusQuery = new Query().group(curFields.groupBy);
    cusQuery = addSorting(sortOrder, "key", cusQuery);
    var ds = getDataSource(dataSource, cusQuery);
    dataSource = [];
    for (var j = 0; j < ds.length; j++) {
      var itemObj = ds[j].items;
      var grpItem = {};
      var hdr = "isHeader";
      grpItem[curFields.text] = ds[j].key;
      grpItem["" + hdr] = true;
      var newtext = curFields.text;
      if (newtext === "id") {
        newtext = "text";
        grpItem["" + newtext] = ds[j].key;
      }
      grpItem._id = "group-list-item-" + (ds[j].key ? ds[j].key.toString().trim() : "undefined");
      grpItem.items = itemObj;
      dataSource.push(grpItem);
      for (var k = 0; k < itemObj.length; k++) {
        dataSource.push(itemObj[k]);
      }
    }
    return dataSource;
  }
  ListBase2.groupDataSource = groupDataSource;
  function addSorting(sortOrder, sortBy, query) {
    if (query === void 0) {
      query = new Query();
    }
    if (sortOrder === "Ascending") {
      query.sortBy(sortBy, "ascending", true);
    } else if (sortOrder === "Descending") {
      query.sortBy(sortBy, "descending", true);
    } else {
      for (var i = 0; i < query.queries.length; i++) {
        if (query.queries[i].fn === "onSortBy") {
          query.queries.splice(i, 1);
        }
      }
    }
    return query;
  }
  ListBase2.addSorting = addSorting;
  function getDataSource(dataSource, query) {
    return new DataManager(dataSource).executeLocal(query);
  }
  ListBase2.getDataSource = getDataSource;
  function createJsonFromElement(element2, options) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var fields = extend({}, ListBase2.defaultMappedFields, curOpt.fields);
    var curEle = element2.cloneNode(true);
    var jsonAr = [];
    curEle.classList.add("json-parent");
    var childs = curEle.querySelectorAll(".json-parent>li");
    curEle.classList.remove("json-parent");
    for (var i = 0; i < childs.length; i++) {
      var li = childs[i];
      var anchor = li.querySelector("a");
      var ul = li.querySelector("ul");
      var json = {};
      var childNodes = anchor ? anchor.childNodes : li.childNodes;
      var keys = Object.keys(childNodes);
      for (var i_1 = 0; i_1 < childNodes.length; i_1++) {
        if (!childNodes[Number(keys[i_1])].hasChildNodes()) {
          json[fields.text] = childNodes[Number(keys[i_1])].textContent;
        }
      }
      var attributes_1 = getAllAttributes(li);
      if (attributes_1.id) {
        json[fields.id] = attributes_1.id;
        delete attributes_1.id;
      } else {
        json[fields.id] = generateId();
      }
      if (Object.keys(attributes_1).length) {
        json[fields.htmlAttributes] = attributes_1;
      }
      if (anchor) {
        attributes_1 = getAllAttributes(anchor);
        if (Object.keys(attributes_1).length) {
          json[fields.urlAttributes] = attributes_1;
        }
      }
      if (ul) {
        json[fields.child] = createJsonFromElement(ul, options);
      }
      jsonAr.push(json);
    }
    return jsonAr;
  }
  ListBase2.createJsonFromElement = createJsonFromElement;
  function typeofData(data) {
    var match = { typeof: null, item: null };
    for (var i = 0; i < data.length; i++) {
      if (!isNullOrUndefined(data[i])) {
        return match = { typeof: typeof data[i], item: data[i] };
      }
    }
    return match;
  }
  function setAttribute(element2, elementAttributes) {
    var attr = {};
    merge(attr, elementAttributes);
    if (attr.class) {
      addClass([element2], attr.class.split(" "));
      delete attr.class;
    }
    attributes(element2, attr);
  }
  function getAllAttributes(element2) {
    var attributes2 = {};
    var attr = element2.attributes;
    for (var index = 0; index < attr.length; index++) {
      attributes2[attr[index].nodeName] = attr[index].nodeValue;
    }
    return attributes2;
  }
  function renderContentTemplate(createElement2, template, dataSource, fields, options, componentInstance) {
    cssClass = getModuleClass(defaultListBaseOptions.moduleName);
    var ulElement = createElement2("ul", { className: cssClass.ul, attrs: { role: "presentation" } });
    var curOpt = extend({}, defaultListBaseOptions, options);
    var curFields = extend({}, ListBase2.defaultMappedFields, fields);
    var compiledString = compileTemplate(template);
    var liCollection = [];
    var value;
    var id = generateId();
    for (var i = 0; i < dataSource.length; i++) {
      var fieldData = getFieldValues(dataSource[i], curFields);
      var curItem = dataSource[i];
      var isHeader = curItem.isHeader;
      if (typeof dataSource[i] === "string" || typeof dataSource[i] === "number") {
        value = curItem;
      } else {
        value = fieldData[curFields.value];
      }
      if (curOpt.itemCreating && typeof curOpt.itemCreating === "function") {
        var curData = {
          dataSource,
          curData: curItem,
          text: value,
          options: curOpt,
          fields: curFields
        };
        curOpt.itemCreating(curData);
      }
      if (curOpt.itemCreating && typeof curOpt.itemCreating === "function") {
        fieldData = getFieldValues(dataSource[i], curFields);
        if (typeof dataSource[i] === "string" || typeof dataSource[i] === "number") {
          value = curItem;
        } else {
          value = fieldData[curFields.value];
        }
      }
      var li = createElement2("li", {
        id: id + "-" + i,
        className: isHeader ? cssClass.group : cssClass.li,
        attrs: { role: "presentation" }
      });
      if (isHeader) {
        if (typeof dataSource[i] === "string" || typeof dataSource[i] === "number") {
          li.innerText = curItem;
        } else {
          li.innerText = fieldData[curFields.text];
        }
      } else {
        var currentID = isHeader ? curOpt.groupTemplateID : curOpt.templateID;
        if (isHeader) {
          if (componentInstance && componentInstance.getModuleName() !== "listview") {
            var compiledElement = compiledString(curItem, componentInstance, "headerTemplate", currentID, !!curOpt.isStringTemplate, null, li);
            if (compiledElement) {
              append(compiledElement, li);
            }
          } else {
            append(compiledString(curItem, componentInstance, "headerTemplate", currentID, !!curOpt.isStringTemplate), li);
          }
        } else {
          if (componentInstance && componentInstance.getModuleName() !== "listview") {
            var compiledElement = compiledString(curItem, componentInstance, "template", currentID, !!curOpt.isStringTemplate, null, li);
            if (compiledElement) {
              append(compiledElement, li);
            }
          } else {
            append(compiledString(curItem, componentInstance, "template", currentID, !!curOpt.isStringTemplate), li);
          }
        }
        li.setAttribute("data-value", isNullOrUndefined(value) ? "null" : value);
        li.setAttribute("role", "option");
      }
      if (curOpt.itemCreated && typeof curOpt.itemCreated === "function") {
        var curData = {
          dataSource,
          curData: curItem,
          text: value,
          item: li,
          options: curOpt,
          fields: curFields
        };
        curOpt.itemCreated(curData);
      }
      liCollection.push(li);
    }
    append(liCollection, ulElement);
    return ulElement;
  }
  ListBase2.renderContentTemplate = renderContentTemplate;
  function renderGroupTemplate(groupTemplate, groupDataSource2, fields, headerItems, options, componentInstance) {
    var compiledString = compileTemplate(groupTemplate);
    var curFields = extend({}, ListBase2.defaultMappedFields, fields);
    var curOpt = extend({}, defaultListBaseOptions, options);
    var category = curFields.groupBy;
    for (var _i = 0, headerItems_1 = headerItems; _i < headerItems_1.length; _i++) {
      var header = headerItems_1[_i];
      var headerData = {};
      headerData["" + category] = header.textContent;
      header.innerHTML = "";
      if (componentInstance && componentInstance.getModuleName() !== "listview") {
        var compiledElement = compiledString(headerData, componentInstance, "groupTemplate", curOpt.groupTemplateID, !!curOpt.isStringTemplate, null, header);
        if (compiledElement) {
          append(compiledElement, header);
        }
      } else {
        append(compiledString(headerData, componentInstance, "groupTemplate", curOpt.groupTemplateID, !!curOpt.isStringTemplate), header);
      }
    }
    return headerItems;
  }
  ListBase2.renderGroupTemplate = renderGroupTemplate;
  function generateId() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  ListBase2.generateId = generateId;
  function processSubChild(createElement2, fieldData, fields, ds, options, element2, level) {
    var subDS = fieldData[fields.child] || [];
    var hasChildren = fieldData[fields.hasChildren];
    if (subDS.length) {
      hasChildren = true;
      element2.classList.add(cssClass.hasChild);
      if (options.processSubChild) {
        var subLi = createListFromJson(createElement2, subDS, options, ++level);
        element2.appendChild(subLi);
      }
    }
    if (!!options.expandCollapse && hasChildren && !options.template) {
      element2.firstElementChild.classList.add(cssClass.iconWrapper);
      var expandElement = options.expandIconPosition === "Left" ? prepend : append;
      expandElement([createElement2("div", { className: "e-icons " + options.expandIconClass })], element2.querySelector("." + cssClass.textContent));
    }
  }
  function generateSingleLevelLI(createElement2, item, fieldData, fields, className, innerElements, grpLI, id, index, options) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
    var text = item;
    var value = item;
    var dataSource;
    if (typeof item !== "string" && typeof item !== "number" && typeof item !== "boolean") {
      dataSource = item;
      text = typeof fieldData[fields.text] === "boolean" || typeof fieldData[fields.text] === "number" ? fieldData[fields.text] : fieldData[fields.text] || "";
      value = fieldData[fields.value];
    }
    var elementID;
    if (!isNullOrUndefined(dataSource) && !isNullOrUndefined(fieldData[fields.id]) && fieldData[fields.id] !== "") {
      elementID = id;
    } else {
      elementID = id + "-" + index;
    }
    var li = createElement2("li", {
      className: (grpLI === true ? cssClass.group : cssClass.li) + " " + (isNullOrUndefined(className) ? "" : className),
      id: elementID,
      attrs: ariaAttributes.groupItemRole !== "" && ariaAttributes.itemRole !== "" ? { role: grpLI === true ? ariaAttributes.groupItemRole : ariaAttributes.itemRole } : {}
    });
    if (dataSource && Object.prototype.hasOwnProperty.call(fieldData, fields.enabled) && fieldData[fields.enabled].toString() === "false") {
      li.classList.add(cssClass.disabled);
    }
    if (grpLI) {
      li.innerText = text;
    } else {
      li.setAttribute("data-value", isNullOrUndefined(value) ? "null" : value);
      li.setAttribute("role", "option");
      if (dataSource && Object.prototype.hasOwnProperty.call(fieldData, fields.htmlAttributes) && fieldData[fields.htmlAttributes]) {
        setAttribute(li, fieldData[fields.htmlAttributes]);
      }
      if (innerElements.length && !curOpt.itemNavigable) {
        append(innerElements, li);
      }
      if (dataSource && (fieldData[fields.url] || fieldData[fields.urlAttributes] && fieldData[fields.urlAttributes].href)) {
        li.appendChild(anchorTag(createElement2, dataSource, fields, text, innerElements, curOpt.itemNavigable));
      } else {
        if (innerElements.length && curOpt.itemNavigable) {
          append(innerElements, li);
        }
        li.appendChild(document.createTextNode(text));
      }
    }
    return li;
  }
  function getModuleClass(moduleName) {
    var moduleClass;
    return moduleClass = {
      li: "e-" + moduleName + "-item",
      ul: "e-" + moduleName + "-parent e-ul",
      group: "e-" + moduleName + "-group-item",
      icon: "e-" + moduleName + "-icon",
      text: "e-" + moduleName + "-text",
      check: "e-" + moduleName + "-check",
      checked: "e-checked",
      selected: "e-selected",
      expanded: "e-expanded",
      textContent: "e-text-content",
      hasChild: "e-has-child",
      level: "e-level",
      url: "e-" + moduleName + "-url",
      collapsible: "e-icon-collapsible",
      disabled: "e-disabled",
      image: "e-" + moduleName + "-img",
      iconWrapper: "e-icon-wrapper",
      anchorWrap: "e-anchor-wrap",
      navigable: "e-navigable"
    };
  }
  function anchorTag(createElement2, dataSource, fields, text, innerElements, isFullNavigation) {
    var fieldData = getFieldValues(dataSource, fields);
    var attr = { href: fieldData[fields.url] };
    if (Object.prototype.hasOwnProperty.call(fieldData, fields.urlAttributes) && fieldData[fields.urlAttributes]) {
      merge(attr, fieldData[fields.urlAttributes]);
      attr.href = fieldData[fields.url] ? fieldData[fields.url] : fieldData[fields.urlAttributes].href;
    }
    var anchorTag2;
    if (!isFullNavigation) {
      anchorTag2 = createElement2("a", { className: cssClass.text + " " + cssClass.url, innerHTML: text });
    } else {
      anchorTag2 = createElement2("a", { className: cssClass.text + " " + cssClass.url });
      var anchorWrapper = createElement2("div", { className: cssClass.anchorWrap });
      if (innerElements && innerElements.length) {
        append(innerElements, anchorWrapper);
      }
      anchorWrapper.appendChild(document.createTextNode(text));
      append([anchorWrapper], anchorTag2);
    }
    setAttribute(anchorTag2, attr);
    return anchorTag2;
  }
  function generateLI(createElement2, item, fieldData, fields, className, options, componentInstance) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
    var text = item;
    var uID;
    var grpLI;
    var dataSource;
    if (typeof item !== "string" && typeof item !== "number") {
      dataSource = item;
      text = fieldData[fields.text] || "";
      uID = isNullOrUndefined(fieldData["_id"]) ? fieldData[fields.id] : fieldData["_id"];
      grpLI = Object.prototype.hasOwnProperty.call(item, "isHeader") && item.isHeader ? true : false;
    }
    if (options && options.enableHtmlSanitizer) {
      text = text;
    }
    var li = createElement2("li", {
      className: (grpLI === true ? cssClass.group : cssClass.li) + " " + (isNullOrUndefined(className) ? "" : className),
      attrs: ariaAttributes.groupItemRole !== "" && ariaAttributes.itemRole !== "" ? { role: grpLI === true ? ariaAttributes.groupItemRole : ariaAttributes.itemRole } : {}
    });
    if (!isNullOrUndefined(uID) === true) {
      li.setAttribute("data-uid", uID);
    } else {
      li.setAttribute("data-uid", generateId());
    }
    if (grpLI && options && options.groupTemplate) {
      var compiledString = compileTemplate(options.groupTemplate);
      if (componentInstance && componentInstance.getModuleName() !== "listview") {
        var compiledElement = compiledString(item, componentInstance, "groupTemplate", curOpt.groupTemplateID, !!curOpt.isStringTemplate, null, li);
        if (compiledElement) {
          append(compiledElement, li);
        }
      } else {
        append(compiledString(item, componentInstance, "groupTemplate", curOpt.groupTemplateID, !!curOpt.isStringTemplate), li);
      }
    } else if (!grpLI && options && options.template) {
      var compiledString = compileTemplate(options.template);
      if (componentInstance && componentInstance.getModuleName() !== "listview") {
        var compiledElement = compiledString(item, componentInstance, "template", curOpt.templateID, !!curOpt.isStringTemplate, null, li);
        if (compiledElement) {
          append(compiledElement, li);
        }
      } else {
        append(compiledString(item, componentInstance, "template", curOpt.templateID, !!curOpt.isStringTemplate), li);
      }
    } else {
      var innerDiv = createElement2("div", {
        className: cssClass.textContent,
        attrs: ariaAttributes.wrapperRole !== "" ? { role: ariaAttributes.wrapperRole } : {}
      });
      if (dataSource && (fieldData[fields.url] || fieldData[fields.urlAttributes] && fieldData[fields.urlAttributes].href)) {
        innerDiv.appendChild(anchorTag(createElement2, dataSource, fields, text, null, curOpt.itemNavigable));
      } else {
        var element2 = createElement2("span", {
          className: cssClass.text,
          attrs: ariaAttributes.itemText !== "" ? { role: ariaAttributes.itemText } : {}
        });
        if (options && options.enableHtmlSanitizer) {
          element2.innerText = SanitizeHtmlHelper.sanitize(text);
        } else {
          element2.innerHTML = text;
        }
        innerDiv.appendChild(element2);
      }
      li.appendChild(innerDiv);
    }
    return li;
  }
  function generateUL(createElement2, liElement, className, options) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
    cssClass = getModuleClass(curOpt.moduleName);
    var ulElement = createElement2("ul", {
      className: cssClass.ul + " " + (isNullOrUndefined(className) ? "" : className),
      attrs: ariaAttributes.listRole !== "" ? { role: ariaAttributes.listRole } : {}
    });
    append(liElement, ulElement);
    return ulElement;
  }
  ListBase2.generateUL = generateUL;
  function generateIcon(createElement2, liElement, className, options) {
    var curOpt = extend({}, defaultListBaseOptions, options);
    cssClass = getModuleClass(curOpt.moduleName);
    var expandElement = curOpt.expandIconPosition === "Left" ? prepend : append;
    expandElement([createElement2("div", {
      className: "e-icons " + curOpt.expandIconClass + " " + (isNullOrUndefined(className) ? "" : className)
    })], liElement.querySelector("." + cssClass.textContent));
    return liElement;
  }
  ListBase2.generateIcon = generateIcon;
})(ListBase || (ListBase = {}));
function getFieldValues(dataItem, fields) {
  var fieldData = {};
  if (isNullOrUndefined(dataItem) || typeof dataItem === "string" || typeof dataItem === "number" || !isNullOrUndefined(dataItem.isHeader)) {
    return dataItem;
  } else {
    for (var _i = 0, _a = Object.keys(fields); _i < _a.length; _i++) {
      var field = _a[_i];
      var dataField = fields["" + field];
      var value = !isNullOrUndefined(dataField) && typeof dataField === "string" ? getValue(dataField, dataItem) : void 0;
      if (!isNullOrUndefined(value)) {
        fieldData["" + dataField] = value;
      }
    }
  }
  return fieldData;
}
function compileTemplate(template) {
  if (template) {
    try {
      if (typeof template !== "function" && document.querySelector(template)) {
        return compile(document.querySelector(template).innerHTML.trim());
      } else {
        return compile(template);
      }
    } catch (e) {
      return compile(template);
    }
  }
  return void 0;
}

// node_modules/@syncfusion/ej2-lists/src/list-view/list-view.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var effectsConfig = {
  "None": [],
  "SlideLeft": ["SlideRightOut", "SlideLeftOut", "SlideLeftIn", "SlideRightIn"],
  "SlideDown": ["SlideTopOut", "SlideBottomOut", "SlideBottomIn", "SlideTopIn"],
  "Zoom": ["FadeOut", "FadeZoomOut", "FadeZoomIn", "FadeIn"],
  "Fade": ["FadeOut", "FadeOut", "FadeIn", "FadeIn"]
};
var effectsRTLConfig = {
  "None": [],
  "SlideLeft": ["SlideLeftOut", "SlideRightOut", "SlideRightIn", "SlideLeftIn"],
  "SlideDown": ["SlideBottomOut", "SlideTopOut", "SlideTopIn", "SlideBottomIn"],
  "Zoom": ["FadeZoomOut", "FadeOut", "FadeIn", "FadeZoomIn"],
  "Fade": ["FadeOut", "FadeOut", "FadeIn", "FadeIn"]
};
var classNames4 = {
  root: "e-listview",
  hover: "e-hover",
  selected: "e-active",
  focused: "e-focused",
  parentItem: "e-list-parent",
  listItem: "e-list-item",
  listIcon: "e-list-icon",
  textContent: "e-text-content",
  listItemText: "e-list-text",
  groupListItem: "e-list-group-item",
  hasChild: "e-has-child",
  view: "e-view",
  header: "e-list-header",
  headerText: "e-headertext",
  headerTemplateText: "e-headertemplate-text",
  text: "e-text",
  disable: "e-disabled",
  container: "e-list-container",
  icon: "e-icons",
  backIcon: "e-icon-back",
  backButton: "e-back-button",
  checkboxWrapper: "e-checkbox-wrapper",
  checkbox: "e-checkbox",
  checked: "e-check",
  checklist: "e-checklist",
  checkboxIcon: "e-frame",
  checkboxRight: "e-checkbox-right",
  checkboxLeft: "e-checkbox-left",
  listviewCheckbox: "e-listview-checkbox",
  itemCheckList: "e-checklist",
  virtualElementContainer: "e-list-virtualcontainer"
};
var LISTVIEW_TEMPLATE_PROPERTY = "Template";
var LISTVIEW_GROUPTEMPLATE_PROPERTY = "GroupTemplate";
var LISTVIEW_HEADERTEMPLATE_PROPERTY = "HeaderTemplate";
var swipeVelocity = 0.5;
var FieldSettings = (
  /** @class */
  function(_super) {
    __extends31(FieldSettings3, _super);
    function FieldSettings3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate30([
      Property("id")
    ], FieldSettings3.prototype, "id", void 0);
    __decorate30([
      Property("text")
    ], FieldSettings3.prototype, "text", void 0);
    __decorate30([
      Property("isChecked")
    ], FieldSettings3.prototype, "isChecked", void 0);
    __decorate30([
      Property("isVisible")
    ], FieldSettings3.prototype, "isVisible", void 0);
    __decorate30([
      Property("enabled")
    ], FieldSettings3.prototype, "enabled", void 0);
    __decorate30([
      Property("iconCss")
    ], FieldSettings3.prototype, "iconCss", void 0);
    __decorate30([
      Property("child")
    ], FieldSettings3.prototype, "child", void 0);
    __decorate30([
      Property("tooltip")
    ], FieldSettings3.prototype, "tooltip", void 0);
    __decorate30([
      Property("groupBy")
    ], FieldSettings3.prototype, "groupBy", void 0);
    __decorate30([
      Property("text")
    ], FieldSettings3.prototype, "sortBy", void 0);
    __decorate30([
      Property("htmlAttributes")
    ], FieldSettings3.prototype, "htmlAttributes", void 0);
    __decorate30([
      Property("tableName")
    ], FieldSettings3.prototype, "tableName", void 0);
    return FieldSettings3;
  }(ChildProperty)
);
var ListView = (
  /** @class */
  function(_super) {
    __extends31(ListView2, _super);
    function ListView2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.previousSelectedItems = [];
      _this.hiddenItems = [];
      _this.enabledItems = [];
      _this.disabledItems = [];
      return _this;
    }
    ListView2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "htmlAttributes":
            this.setHTMLAttribute();
            break;
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
          case "enable":
            this.setEnable();
            break;
          case "width":
          case "height":
            this.setSize();
            break;
          case "enableRtl":
            this.setEnableRTL();
            break;
          case "fields":
            this.listBaseOption.fields = this.fields.properties;
            if (this.enableVirtualization) {
              this.virtualizationModule.reRenderUiVirtualization();
            } else {
              this.reRender();
            }
            break;
          case "headerTitle":
            if (!this.curDSLevel.length) {
              this.header(this.headerTitle, false, "header");
            }
            break;
          case "query":
            if (this.enableVirtualization) {
              this.virtualizationModule.reRenderUiVirtualization();
            } else {
              this.reRender();
            }
            break;
          case "showHeader":
            this.header(this.headerTitle, false, "header");
            break;
          case "enableVirtualization":
            if (!isNullOrUndefined(this.contentContainer)) {
              detach(this.contentContainer);
            }
            this.refresh();
            break;
          case "showCheckBox":
          case "checkBoxPosition":
            if (this.enableVirtualization) {
              this.virtualizationModule.reRenderUiVirtualization();
            } else {
              this.setCheckbox();
            }
            break;
          case "dataSource":
            if (this.enableVirtualization) {
              this.virtualizationModule.reRenderUiVirtualization();
            } else {
              this.reRender();
            }
            break;
          case "sortOrder":
          case "template":
            if (!this.enableVirtualization) {
              this.refresh();
            }
            break;
          case "showIcon":
            if (this.enableVirtualization) {
              this.virtualizationModule.reRenderUiVirtualization();
            } else {
              this.listBaseOption.showIcon = this.showIcon;
              this.curViewDS = this.getSubDS();
              this.resetCurrentList();
            }
            break;
          default:
            break;
        }
      }
    };
    ListView2.prototype.setHTMLAttribute = function() {
      if (!isNullOrUndefined(this.htmlAttributes) && Object.keys(this.htmlAttributes).length) {
        attributes(this.element, this.htmlAttributes);
      }
    };
    ListView2.prototype.setCSSClass = function(oldCSSClass) {
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" ").filter(function(css) {
          return css;
        }));
      }
      if (oldCSSClass) {
        removeClass([this.element], oldCSSClass.split(" ").filter(function(css) {
          return css;
        }));
      }
    };
    ListView2.prototype.setSize = function() {
      this.element.style.height = formatUnit(this.height);
      this.element.style.width = formatUnit(this.width);
      this.isWindow = this.element.clientHeight ? false : true;
    };
    ListView2.prototype.setEnable = function() {
      this.enableElement(this.element, this.enable);
    };
    ListView2.prototype.setEnableRTL = function() {
      if (this.enableRtl) {
        this.element.classList.add("e-rtl");
      } else {
        this.element.classList.remove("e-rtl");
      }
    };
    ListView2.prototype.enableElement = function(element2, isEnabled) {
      if (isEnabled) {
        element2.classList.remove(classNames4.disable);
      } else {
        element2.classList.add(classNames4.disable);
      }
    };
    ListView2.prototype.header = function(text, showBack, prop) {
      if (this.headerEle === void 0 && this.showHeader) {
        this.headerEle = this.createElement("div", { className: classNames4.header });
        var innerHeaderEle = this.createElement("span", { className: classNames4.headerText });
        if (this.enableHtmlSanitizer) {
          this.setProperties({ headerTitle: SanitizeHtmlHelper.sanitize(this.headerTitle) }, true);
          innerHeaderEle.innerText = this.headerTitle;
        } else {
          innerHeaderEle.innerHTML = this.headerTitle;
        }
        var textEle = this.createElement("div", { className: classNames4.text, innerHTML: innerHeaderEle.outerHTML });
        var hedBackButton = this.createElement("div", {
          className: classNames4.icon + " " + classNames4.backIcon + " " + classNames4.backButton,
          attrs: { style: "display:none;" }
        });
        this.headerEle.appendChild(hedBackButton);
        this.headerEle.appendChild(textEle);
        if (this.headerTemplate) {
          var compiledString = compile(this.headerTemplate);
          var headerTemplateEle = this.createElement("div", { className: classNames4.headerTemplateText });
          var compiledElement = compiledString({}, this, prop, this.LISTVIEW_HEADERTEMPLATE_ID, null, null, this.headerEle);
          if (compiledElement) {
            append(compiledElement, headerTemplateEle);
          }
          append([headerTemplateEle], this.headerEle);
          if (this.isReact) {
            this.renderReactTemplates();
          }
        }
        if (this.headerTemplate && this.headerTitle) {
          textEle.classList.add("header");
        }
        this.element.classList.add("e-has-header");
        prepend([this.headerEle], this.element);
      } else if (this.headerEle) {
        if (this.showHeader) {
          this.headerEle.style.display = "";
          var textEle = this.headerEle.querySelector("." + classNames4.headerText);
          var hedBackButton = this.headerEle.querySelector("." + classNames4.backIcon);
          if (this.enableHtmlSanitizer) {
            text = SanitizeHtmlHelper.sanitize(text);
          }
          textEle.innerHTML = text;
          if (this.headerTemplate && showBack) {
            textEle.parentElement.classList.remove("header");
            this.headerEle.querySelector("." + classNames4.headerTemplateText).classList.add("nested-header");
          }
          if (this.headerTemplate && !showBack) {
            textEle.parentElement.classList.add("header");
            this.headerEle.querySelector("." + classNames4.headerTemplateText).classList.remove("nested-header");
            this.headerEle.querySelector("." + classNames4.headerTemplateText).classList.add("header");
          }
          if (showBack === true) {
            hedBackButton.style.display = "";
          } else {
            hedBackButton.style.display = "none";
          }
        } else {
          this.headerEle.style.display = "none";
        }
      }
    };
    ListView2.prototype.switchView = function(fromView, toView, reverse) {
      var _this = this;
      if (fromView && toView) {
        var fPos_1 = fromView.style.position;
        var overflow_1 = this.element.style.overflow !== "hidden" ? this.element.style.overflow : "";
        fromView.style.position = "absolute";
        fromView.classList.add("e-view");
        var anim = void 0;
        var duration = this.animation.duration;
        if (this.animation.effect) {
          anim = this.enableRtl ? effectsRTLConfig[this.animation.effect] : effectsConfig[this.animation.effect];
        } else {
          var slideLeft = "SlideLeft";
          anim = effectsConfig["" + slideLeft];
          reverse = this.enableRtl;
          duration = 0;
        }
        this.element.style.overflow = "hidden";
        this.aniObj.animate(fromView, {
          name: reverse === true ? anim[0] : anim[1],
          duration: duration === 0 && animationMode === "Enable" ? 400 : duration,
          timingFunction: this.animation.easing,
          end: function() {
            fromView.style.display = "none";
            _this.element.style.overflow = overflow_1;
            fromView.style.position = fPos_1;
            fromView.classList.remove("e-view");
          }
        });
        toView.style.display = "";
        this.aniObj.animate(toView, {
          name: reverse === true ? anim[2] : anim[3],
          duration: duration === 0 && animationMode === "Enable" ? 400 : duration,
          timingFunction: this.animation.easing,
          end: function() {
            _this.trigger("actionComplete");
          }
        });
        this.curUL = toView;
      }
    };
    ListView2.prototype.preRender = function() {
      if (this.template) {
        try {
          if (typeof this.template !== "function" && document.querySelectorAll(this.template).length) {
            this.setProperties({ template: document.querySelector(this.template).innerHTML.trim() }, true);
          }
        } catch (e) {
          compile(this.template);
        }
      }
      this.listBaseOption = {
        template: this.template,
        headerTemplate: this.headerTemplate,
        groupTemplate: this.groupTemplate,
        expandCollapse: true,
        listClass: "",
        ariaAttributes: {
          itemRole: "listitem",
          listRole: "list",
          itemText: "",
          groupItemRole: "presentation",
          wrapperRole: "presentation"
        },
        fields: this.fields.properties,
        sortOrder: this.sortOrder,
        showIcon: this.showIcon,
        itemCreated: this.renderCheckbox.bind(this),
        templateID: "" + this.element.id + LISTVIEW_TEMPLATE_PROPERTY,
        groupTemplateID: "" + this.element.id + LISTVIEW_GROUPTEMPLATE_PROPERTY,
        enableHtmlSanitizer: this.enableHtmlSanitizer
      };
      this.initialization();
    };
    ListView2.prototype.initialization = function() {
      this.curDSLevel = [];
      this.animateOptions = {};
      this.curViewDS = [];
      this.currentLiElements = [];
      this.isNestedList = false;
      this.selectedData = [];
      this.selectedId = this.enablePersistence ? this.selectedId : [];
      this.LISTVIEW_TEMPLATE_ID = "" + this.element.id + LISTVIEW_TEMPLATE_PROPERTY;
      this.LISTVIEW_GROUPTEMPLATE_ID = "" + this.element.id + LISTVIEW_GROUPTEMPLATE_PROPERTY;
      this.LISTVIEW_HEADERTEMPLATE_ID = "" + this.element.id + LISTVIEW_HEADERTEMPLATE_PROPERTY;
      this.aniObj = new Animation(this.animateOptions);
      this.removeElement(this.curUL);
      this.removeElement(this.ulElement);
      this.removeElement(this.headerEle);
      this.removeElement(this.contentContainer);
      this.curUL = this.ulElement = this.liCollection = this.headerEle = this.contentContainer = void 0;
    };
    ListView2.prototype.renderCheckbox = function(args) {
      var _this = this;
      if (args.item.classList.contains(classNames4.hasChild)) {
        this.isNestedList = true;
      }
      if (this.showCheckBox && args.item.classList.contains(classNames4.listItem)) {
        var fieldData_1;
        var checkboxElement = createCheckBox(this.createElement, false, {
          checked: false,
          enableRtl: this.enableRtl,
          cssClass: classNames4.listviewCheckbox
        });
        checkboxElement.setAttribute("role", "checkbox");
        var frameElement_1 = checkboxElement.querySelector("." + classNames4.checkboxIcon);
        args.item.classList.add(classNames4.itemCheckList);
        args.item.firstElementChild.classList.add(classNames4.checkbox);
        if (typeof this.dataSource[0] !== "string" && typeof this.dataSource[0] !== "number") {
          fieldData_1 = getFieldValues(args.curData, this.listBaseOption.fields);
          if (this.enablePersistence && !isNullOrUndefined(this.selectedId)) {
            var index = this.selectedId.findIndex(function(e) {
              return e === fieldData_1[_this.listBaseOption.fields.id].toString();
            });
            if (index !== -1) {
              this.checkInternally(args, checkboxElement);
            }
          } else if (fieldData_1[this.listBaseOption.fields.isChecked]) {
            this.checkInternally(args, checkboxElement);
          }
        } else if ((typeof this.dataSource[0] === "string" || typeof this.dataSource[0] === "number") && this.selectedData.indexOf(args.text) !== -1) {
          this.checkInternally(args, checkboxElement);
        }
        checkboxElement.setAttribute("aria-checked", frameElement_1.classList.contains(classNames4.checked) ? "true" : "false");
        checkboxElement.setAttribute("aria-label", args.text);
        if (this.checkBoxPosition === "Left") {
          checkboxElement.classList.add(classNames4.checkboxLeft);
          args.item.firstElementChild.classList.add(classNames4.checkboxLeft);
          args.item.firstElementChild.insertBefore(checkboxElement, args.item.firstElementChild.childNodes[0]);
        } else {
          checkboxElement.classList.add(classNames4.checkboxRight);
          args.item.firstElementChild.classList.add(classNames4.checkboxRight);
          args.item.firstElementChild.appendChild(checkboxElement);
        }
        this.currentLiElements.push(args.item);
        if (this.checkBoxPosition === "Left") {
          this.virtualCheckBox = args.item.firstElementChild.children[0];
        } else {
          this.virtualCheckBox = args.item.firstElementChild.lastElementChild;
        }
      }
    };
    ListView2.prototype.checkInternally = function(args, checkboxElement) {
      args.item.classList.add(classNames4.selected);
      checkboxElement.querySelector("." + classNames4.checkboxIcon).classList.add(classNames4.checked);
      checkboxElement.setAttribute("aria-checked", "true");
    };
    ListView2.prototype.checkItem = function(item) {
      this.toggleCheckBase(item, true);
    };
    ListView2.prototype.toggleCheckBase = function(item, checked) {
      if (this.showCheckBox) {
        var liElement = item;
        if (item instanceof Object && item.constructor !== HTMLLIElement) {
          liElement = this.getLiFromObjOrElement(item);
        }
        if (!isNullOrUndefined(liElement)) {
          var checkboxIcon = liElement.querySelector("." + classNames4.checkboxIcon);
          if (checked === true) {
            liElement.classList.add(classNames4.selected);
          } else {
            liElement.classList.remove(classNames4.selected);
          }
          if (checked === true) {
            checkboxIcon.classList.add(classNames4.checked);
          } else {
            checkboxIcon.classList.remove(classNames4.checked);
          }
          checkboxIcon.parentElement.setAttribute("aria-checked", checked ? "true" : "false");
        }
        this.setSelectedItemData(liElement);
        this.updateSelectedId();
      }
    };
    ListView2.prototype.uncheckItem = function(item) {
      this.toggleCheckBase(item, false);
    };
    ListView2.prototype.checkAllItems = function() {
      this.toggleAllCheckBase(true);
    };
    ListView2.prototype.uncheckAllItems = function() {
      this.toggleAllCheckBase(false);
    };
    ListView2.prototype.toggleAllCheckBase = function(checked) {
      if (this.showCheckBox) {
        for (var i = 0; i < this.liCollection.length; i++) {
          var checkIcon = this.liCollection[i].querySelector("." + classNames4.checkboxIcon);
          if (checkIcon) {
            if (checked) {
              if (!checkIcon.classList.contains(classNames4.checked)) {
                this.checkItem(this.liCollection[i]);
              }
            } else {
              if (checkIcon.classList.contains(classNames4.checked)) {
                this.uncheckItem(this.liCollection[i]);
              }
            }
          }
        }
        if (this.enableVirtualization) {
          this.virtualizationModule.checkedItem(checked);
        }
        this.updateSelectedId();
      }
    };
    ListView2.prototype.setCheckbox = function() {
      if (this.showCheckBox) {
        var liCollection = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames4.listItem));
        var args = {
          item: void 0,
          curData: void 0,
          dataSource: void 0,
          fields: void 0,
          options: void 0,
          text: ""
        };
        for (var i = 0; i < liCollection.length; i++) {
          var element2 = liCollection[i];
          args.item = element2;
          args.curData = this.getItemData(element2);
          if (element2.querySelector("." + classNames4.checkboxWrapper)) {
            this.removeElement(element2.querySelector("." + classNames4.checkboxWrapper));
          }
          this.renderCheckbox(args);
          if (args.item.classList.contains(classNames4.selected)) {
            this.checkInternally(args, args.item.querySelector("." + classNames4.checkboxWrapper));
          }
        }
      } else {
        var liCollection = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames4.itemCheckList));
        for (var i = 0; i < liCollection.length; i++) {
          var element2 = liCollection[i];
          element2.classList.remove(classNames4.selected);
          element2.firstElementChild.classList.remove(classNames4.checkbox);
          this.removeElement(element2.querySelector("." + classNames4.checkboxWrapper));
        }
        if (this.selectedItems) {
          this.selectedItems.item.classList.add(classNames4.selected);
        }
      }
    };
    ListView2.prototype.refreshItemHeight = function() {
      if (this.virtualizationModule) {
        this.virtualizationModule.refreshItemHeight();
      }
    };
    ListView2.prototype.clickHandler = function(e) {
      if (Array.isArray(this.dataSource) && this.dataSource.length === 0) {
        return;
      }
      var target = e.target;
      this.targetElement = target;
      var classList2 = target.classList;
      var closestElement;
      if (classList2.contains(classNames4.backIcon) || classList2.contains(classNames4.headerText)) {
        if (this.showCheckBox && this.curDSLevel[this.curDSLevel.length - 1]) {
          this.uncheckAllItems();
        }
        this.back();
      } else {
        var li = closest(target.parentNode, "." + classNames4.listItem);
        if (li === null) {
          li = target;
        }
        this.removeFocus();
        if (this.enable && this.showCheckBox && this.isValidLI(li)) {
          if (e.target.classList.contains(classNames4.checkboxIcon)) {
            li.classList.add(classNames4.focused);
            if (isNullOrUndefined(li.querySelector("." + classNames4.checked))) {
              var args = {
                curData: void 0,
                dataSource: void 0,
                fields: void 0,
                options: void 0,
                text: void 0,
                item: li
              };
              this.checkInternally(args, args.item.querySelector("." + classNames4.checkboxWrapper));
            } else {
              this.uncheckItem(li);
              li.classList.add(classNames4.focused);
            }
            if (this.enableVirtualization) {
              this.virtualizationModule.setCheckboxLI(li, e);
            }
            if (e) {
              var eventArgs = this.selectEventData(li, e);
              var checkIcon = li.querySelector("." + classNames4.checkboxIcon);
              merge(eventArgs, { isChecked: checkIcon.classList.contains(classNames4.checked) });
              this.trigger("select", eventArgs);
            }
          } else if (li.classList.contains(classNames4.hasChild)) {
            this.removeHover();
            this.removeSelect();
            this.removeSelect(li);
            this.setSelectLI(li, e);
            li.classList.remove(classNames4.selected);
          } else {
            this.setCheckboxLI(li, e);
            if (target.nodeName === "INPUT" || target.nodeName === "TEXTAREA") {
              target.classList.add("e-focused");
              this.targetElement = target;
            }
          }
        } else {
          this.setSelectLI(li, e);
          if (target.nodeName === "INPUT" || target.nodeName === "TEXTAREA") {
            target.classList.add("e-focused");
            this.targetElement = target;
          }
        }
        closestElement = closest(e.target, "li");
        if (!isNullOrUndefined(closestElement)) {
          if (closestElement.classList.contains("e-has-child") && !e.target.parentElement.classList.contains("e-listview-checkbox")) {
            closestElement.classList.add(classNames4.disable);
          }
        }
      }
      this.updateSelectedId();
    };
    ListView2.prototype.removeElement = function(element2) {
      return element2 && element2.parentNode && element2.parentNode.removeChild(element2);
    };
    ListView2.prototype.hoverHandler = function(e) {
      var curLi = closest(e.target.parentNode, "." + classNames4.listItem);
      this.setHoverLI(curLi);
    };
    ListView2.prototype.leaveHandler = function() {
      this.removeHover();
    };
    ListView2.prototype.homeKeyHandler = function(e, end) {
      e.preventDefault();
      if (Object.keys(this.dataSource).length && this.curUL) {
        var li = this.curUL.querySelectorAll("." + classNames4.listItem);
        var focusedElement = this.curUL.querySelector("." + classNames4.focused) || this.curUL.querySelector("." + classNames4.selected);
        if (focusedElement) {
          focusedElement.classList.remove(classNames4.focused);
          if (!this.showCheckBox) {
            focusedElement.classList.remove(classNames4.selected);
          }
        }
        var index = !end ? 0 : li.length - 1;
        if (li[index].classList.contains(classNames4.hasChild) || this.showCheckBox) {
          li[index].classList.add(classNames4.focused);
        } else {
          this.setSelectLI(li[index], e);
        }
        if (li[index]) {
          this.element.setAttribute("aria-activedescendant", li[index].id.toString());
        } else {
          this.element.removeAttribute("aria-activedescendant");
        }
      }
    };
    ListView2.prototype.onArrowKeyDown = function(e, prev) {
      var siblingLI;
      var li;
      var hasChild = !isNullOrUndefined(this.curUL.querySelector("." + classNames4.hasChild)) ? true : false;
      if (hasChild || this.showCheckBox) {
        li = this.curUL.querySelector("." + classNames4.focused) || this.curUL.querySelector("." + classNames4.selected);
        siblingLI = ListBase.getSiblingLI(this.curUL.querySelectorAll("." + classNames4.listItem), li, prev);
        if (!isNullOrUndefined(siblingLI)) {
          if (li) {
            li.classList.remove(classNames4.focused);
            if (!this.showCheckBox) {
              li.classList.remove(classNames4.selected);
            }
          }
          if (siblingLI.classList.contains(classNames4.hasChild) || this.showCheckBox) {
            siblingLI.classList.add(classNames4.focused);
          } else {
            this.setSelectLI(siblingLI, e);
          }
        }
      } else {
        li = this.curUL.querySelector("." + classNames4.selected);
        siblingLI = ListBase.getSiblingLI(this.curUL.querySelectorAll("." + classNames4.listItem), li, prev);
        this.setSelectLI(siblingLI, e);
      }
      if (siblingLI) {
        this.element.setAttribute("aria-activedescendant", siblingLI.id.toString());
      } else {
        this.element.removeAttribute("aria-activedescendant");
      }
      return siblingLI;
    };
    ListView2.prototype.arrowKeyHandler = function(e, prev) {
      var _this = this;
      e.preventDefault();
      if (Object.keys(this.dataSource).length && this.curUL) {
        var siblingLI = this.onArrowKeyDown(e, prev);
        var elementTop = this.element.getBoundingClientRect().top;
        var elementHeight = this.element.getBoundingClientRect().height;
        var firstItemBounds = this.curUL.querySelector("." + classNames4.listItem).getBoundingClientRect();
        var heightDiff = void 0;
        var groupItemBounds = void 0;
        if (this.fields.groupBy) {
          groupItemBounds = this.curUL.querySelector("." + classNames4.groupListItem).getBoundingClientRect();
        }
        if (siblingLI) {
          var siblingTop = siblingLI.getBoundingClientRect().top;
          var siblingHeight = siblingLI.getBoundingClientRect().height;
          if (!prev) {
            var height = this.isWindow ? window.innerHeight : elementHeight;
            heightDiff = this.isWindow ? siblingTop + siblingHeight : siblingTop - elementTop + siblingHeight;
            if (heightDiff > height) {
              if (this.isWindow === true) {
                window.scroll(0, pageYOffset + (heightDiff - height));
              } else {
                this.element.scrollTop = this.element.scrollTop + (heightDiff - height);
              }
            }
          } else {
            heightDiff = this.isWindow ? siblingTop : siblingTop - elementTop;
            if (heightDiff < 0) {
              if (this.isWindow === true) {
                window.scroll(0, pageYOffset + heightDiff);
              } else {
                this.element.scrollTop = this.element.scrollTop + heightDiff;
              }
            }
          }
        } else if (this.enableVirtualization && prev && this.virtualizationModule.uiFirstIndex) {
          this.onUIScrolled = function() {
            _this.onArrowKeyDown(e, prev);
            _this.onUIScrolled = void 0;
          };
          heightDiff = this.virtualizationModule.listItemHeight;
          if (this.isWindow === true) {
            window.scroll(0, pageYOffset - heightDiff);
          } else {
            this.element.scrollTop = this.element.scrollTop - heightDiff;
          }
        } else if (prev) {
          if (this.showHeader && this.headerEle) {
            var topHeight = groupItemBounds ? groupItemBounds.top : firstItemBounds.top;
            var headerBounds = this.headerEle.getBoundingClientRect();
            heightDiff = headerBounds.top < 0 ? headerBounds.height - topHeight : 0;
            if (this.isWindow === true) {
              window.scroll(0, pageYOffset - heightDiff);
            } else {
              this.element.scrollTop = 0;
            }
          } else if (this.fields.groupBy) {
            heightDiff = this.isWindow ? groupItemBounds.top < 0 ? groupItemBounds.top : 0 : elementTop - firstItemBounds.top + groupItemBounds.height;
            if (this.isWindow === true) {
              window.scroll(0, pageYOffset + heightDiff);
            } else {
              this.element.scrollTop = this.element.scrollTop - heightDiff;
            }
          }
        }
      }
    };
    ListView2.prototype.enterKeyHandler = function(e) {
      if (Object.keys(this.dataSource).length && this.curUL) {
        var hasChild = !isNullOrUndefined(this.curUL.querySelector("." + classNames4.hasChild)) ? true : false;
        var li = this.curUL.querySelector("." + classNames4.focused);
        if (hasChild && li) {
          li.classList.remove(classNames4.focused);
          if (this.showCheckBox) {
            this.removeSelect();
            this.removeSelect(li);
            this.removeHover();
          }
          this.setSelectLI(li, e);
        }
      }
    };
    ListView2.prototype.spaceKeyHandler = function(e) {
      if (this.enable && this.showCheckBox && Object.keys(this.dataSource).length && this.curUL) {
        e.preventDefault();
        var li = this.curUL.querySelector("." + classNames4.focused);
        var checkboxElement = void 0;
        var checkIcon = void 0;
        if (!isNullOrUndefined(li) && isNullOrUndefined(li.querySelector("." + classNames4.checked))) {
          var args = {
            curData: void 0,
            dataSource: void 0,
            fields: void 0,
            options: void 0,
            text: void 0,
            item: li
          };
          checkboxElement = args.item.querySelector("." + classNames4.checkboxWrapper);
          this.checkInternally(args, checkboxElement);
          checkIcon = checkboxElement.querySelector("." + classNames4.checkboxIcon + "." + classNames4.icon);
        } else {
          this.uncheckItem(li);
        }
        var eventArgs = this.selectEventData(li, e);
        merge(eventArgs, { isChecked: checkIcon ? checkIcon.classList.contains(classNames4.checked) : false });
        this.trigger("select", eventArgs);
        this.updateSelectedId();
      }
    };
    ListView2.prototype.keyActionHandler = function(e) {
      switch (e.keyCode) {
        case 36:
          this.homeKeyHandler(e);
          break;
        case 35:
          this.homeKeyHandler(e, true);
          break;
        case 40:
          this.arrowKeyHandler(e);
          break;
        case 38:
          this.arrowKeyHandler(e, true);
          break;
        case 13:
          this.enterKeyHandler(e);
          break;
        case 8:
          if (this.showCheckBox && this.curDSLevel[this.curDSLevel.length - 1]) {
            this.uncheckAllItems();
          }
          this.back();
          break;
        case 32:
          if (isNullOrUndefined(this.targetElement) || !this.targetElement.classList.contains("e-focused")) {
            this.spaceKeyHandler(e);
          }
          break;
      }
    };
    ListView2.prototype.swipeActionHandler = function(e) {
      if (e.swipeDirection === "Right" && e.velocity > swipeVelocity && e.originalEvent.type === "touchend") {
        if (this.showCheckBox && this.curDSLevel[this.curDSLevel.length - 1]) {
          this.uncheckAllItems();
        }
        this.back();
      }
    };
    ListView2.prototype.focusout = function() {
      if (Object.keys(this.dataSource).length && this.curUL) {
        var focusedElement = this.curUL.querySelector("." + classNames4.focused);
        if (focusedElement) {
          focusedElement.classList.remove(classNames4.focused);
          if (!this.showCheckBox && !isNullOrUndefined(this.selectedLI)) {
            this.selectedLI.classList.add(classNames4.selected);
          }
        }
      }
    };
    ListView2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "keydown", this.keyActionHandler, this);
      EventHandler.add(this.element, "click", this.clickHandler, this);
      EventHandler.add(this.element, "mouseover", this.hoverHandler, this);
      EventHandler.add(this.element, "mouseout", this.leaveHandler, this);
      EventHandler.add(this.element, "focusout", this.focusout, this);
      this.touchModule = new Touch(this.element, { swipe: this.swipeActionHandler.bind(this) });
      if (!isNullOrUndefined(this.scroll)) {
        EventHandler.add(this.element, "scroll", this.onListScroll, this);
      }
    };
    ListView2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "keydown", this.keyActionHandler);
      EventHandler.remove(this.element, "click", this.clickHandler);
      EventHandler.remove(this.element, "mouseover", this.hoverHandler);
      EventHandler.remove(this.element, "mouseout", this.leaveHandler);
      EventHandler.remove(this.element, "mouseover", this.hoverHandler);
      EventHandler.remove(this.element, "mouseout", this.leaveHandler);
      EventHandler.remove(this.element, "focusout", this.focusout);
      if (!isNullOrUndefined(this.scroll)) {
        EventHandler.remove(this.element, "scroll", this.onListScroll);
      }
      if (this.touchModule)
        this.touchModule.destroy();
      this.touchModule = null;
    };
    ListView2.prototype.removeFocus = function() {
      var focusedLI = this.element.querySelectorAll("." + classNames4.focused);
      for (var _i = 0, focusedLI_1 = focusedLI; _i < focusedLI_1.length; _i++) {
        var ele = focusedLI_1[_i];
        ele.classList.remove(classNames4.focused);
      }
    };
    ListView2.prototype.removeHover = function() {
      var hoverLI = this.element.querySelector("." + classNames4.hover);
      if (hoverLI) {
        hoverLI.classList.remove(classNames4.hover);
      }
    };
    ListView2.prototype.removeSelect = function(li) {
      if (isNullOrUndefined(li)) {
        var selectedLI = this.element.querySelectorAll("." + classNames4.selected);
        for (var _i = 0, selectedLI_1 = selectedLI; _i < selectedLI_1.length; _i++) {
          var ele = selectedLI_1[_i];
          if (this.showCheckBox && ele.querySelector("." + classNames4.checked)) {
            continue;
          } else {
            ele.classList.remove(classNames4.selected);
          }
        }
      } else {
        li.classList.remove(classNames4.selected);
      }
    };
    ListView2.prototype.isValidLI = function(li) {
      return li && li.classList.contains(classNames4.listItem) && !li.classList.contains(classNames4.groupListItem) && !li.classList.contains(classNames4.disable);
    };
    ListView2.prototype.setCheckboxLI = function(li, e) {
      if (this.isValidLI(li) && this.enable && this.showCheckBox) {
        if (this.curUL.querySelector("." + classNames4.focused)) {
          this.curUL.querySelector("." + classNames4.focused).classList.remove(classNames4.focused);
        }
        var textAreaFocus = li.querySelector("textarea") || li.querySelector("input");
        li.classList.add(classNames4.focused);
        if (!isNullOrUndefined(e)) {
          if (e.target === textAreaFocus) {
            textAreaFocus.classList.add("e-focused");
          }
        }
        var checkboxElement = li.querySelector("." + classNames4.checkboxWrapper);
        var checkIcon = checkboxElement.querySelector("." + classNames4.checkboxIcon + "." + classNames4.icon);
        this.removeHover();
        if (!checkIcon.classList.contains(classNames4.checked)) {
          checkIcon.classList.add(classNames4.checked);
          li.classList.add(classNames4.selected);
        } else {
          checkIcon.classList.remove(classNames4.checked);
          li.classList.remove(classNames4.selected);
        }
        checkboxElement.setAttribute("aria-checked", checkIcon.classList.contains(classNames4.checked) ? "true" : "false");
        var eventArgs = this.selectEventData(li, e);
        merge(eventArgs, { isChecked: checkIcon.classList.contains(classNames4.checked) });
        if (this.enableVirtualization) {
          this.virtualizationModule.setCheckboxLI(li, e);
        }
        this.trigger("select", eventArgs);
        this.setSelectedItemData(li);
        this.renderSubList(li);
      }
    };
    ListView2.prototype.selectEventData = function(li, e) {
      var data = this.getItemData(li);
      var fieldData = getFieldValues(data, this.listBaseOption.fields);
      var selectedItem;
      if (!isNullOrUndefined(data) && typeof this.dataSource[0] === "string" || typeof this.dataSource[0] === "number") {
        selectedItem = { item: li, text: li && li.innerText.trim(), data: this.dataSource };
      } else {
        selectedItem = {
          item: li,
          text: fieldData && fieldData[this.listBaseOption.fields.text],
          data
        };
      }
      var eventArgs = {};
      merge(eventArgs, selectedItem);
      if (e) {
        merge(eventArgs, {
          isInteracted: true,
          event: e,
          cancel: false,
          index: this.curUL && Array.prototype.indexOf.call(this.curUL.children, li)
        });
      }
      return eventArgs;
    };
    ListView2.prototype.setSelectedItemData = function(li) {
      var data = this.getItemData(li);
      var fieldData = getFieldValues(data, this.listBaseOption.fields);
      if (!isNullOrUndefined(data) && (typeof this.dataSource[0] === "string" || typeof this.dataSource[0] === "number")) {
        this.selectedItems = {
          item: li,
          text: li && li.innerText.trim(),
          data: this.dataSource
        };
      } else {
        this.selectedItems = {
          item: li,
          text: fieldData && fieldData[this.listBaseOption.fields.text],
          data
        };
      }
    };
    ListView2.prototype.setSelectLI = function(li, e) {
      var _this = this;
      if (this.isValidLI(li) && !li.classList.contains(classNames4.selected) && this.enable) {
        if (!this.showCheckBox) {
          this.removeSelect();
        }
        li.classList.add(classNames4.selected);
        this.removeHover();
        this.setSelectedItemData(li);
        if (this.enableVirtualization) {
          this.virtualizationModule.setSelectLI(li, e);
        }
        var eventArgs = this.selectEventData(li, e);
        this.trigger("select", eventArgs, function(observedArgs) {
          if (!observedArgs.cancel) {
            _this.selectedLI = li;
            _this.renderSubList(li);
          }
        });
      }
    };
    ListView2.prototype.setHoverLI = function(li) {
      if (this.isValidLI(li) && !li.classList.contains(classNames4.hover) && this.enable) {
        var lastLi = this.element.querySelectorAll("." + classNames4.hover);
        if (lastLi && lastLi.length) {
          removeClass(lastLi, classNames4.hover);
        }
        if (!li.classList.contains(classNames4.selected) || this.showCheckBox) {
          li.classList.add(classNames4.hover);
        }
      }
    };
    ListView2.prototype.getSubDS = function() {
      var levelKeys = this.curDSLevel;
      if (levelKeys.length) {
        var ds = this.localData;
        for (var _i = 0, levelKeys_1 = levelKeys; _i < levelKeys_1.length; _i++) {
          var key = levelKeys_1[_i];
          var field = {};
          field[this.fields.id] = key;
          this.curDSJSON = this.findItemFromDS(ds, field);
          var fieldData = getFieldValues(this.curDSJSON, this.listBaseOption.fields);
          ds = this.curDSJSON ? fieldData[this.fields.child] : ds;
        }
        return ds;
      }
      return this.localData;
    };
    ListView2.prototype.getItemData = function(li) {
      var dataSource = this.dataSource instanceof DataManager ? this.localData : this.dataSource;
      var fields = this.getElementUID(li);
      var curDS;
      if (isNullOrUndefined(this.element.querySelector("." + classNames4.hasChild)) && this.fields.groupBy) {
        curDS = this.curViewDS;
      } else {
        curDS = dataSource;
      }
      return this.findItemFromDS(curDS, fields);
    };
    ListView2.prototype.findItemFromDS = function(dataSource, fields, parent) {
      var _this = this;
      var resultJSON;
      if (dataSource && dataSource.length && fields) {
        dataSource.some(function(data) {
          var fieldData = getFieldValues(data, _this.listBaseOption.fields);
          if ((fields[_this.fields.id] || fields[_this.fields.text]) && (!fields[_this.fields.id] || (!isNullOrUndefined(fieldData[_this.fields.id]) && fieldData[_this.fields.id].toString()) === fields[_this.fields.id].toString()) && (!fields[_this.fields.text] || fieldData[_this.fields.text] === fields[_this.fields.text])) {
            resultJSON = parent ? dataSource : data;
          } else if (typeof data !== "object" && dataSource.indexOf(data) !== -1) {
            resultJSON = parent ? dataSource : data;
          } else if (!isNullOrUndefined(fields[_this.fields.id]) && isNullOrUndefined(fieldData[_this.fields.id])) {
            var li = _this.element.querySelector('[data-uid="' + fields[_this.fields.id] + '"]');
            if (li && li.innerText.trim() === fieldData[_this.fields.text]) {
              resultJSON = data;
            }
          } else if (Object.prototype.hasOwnProperty.call(fieldData, _this.fields.child) && fieldData[_this.fields.child].length) {
            resultJSON = _this.findItemFromDS(fieldData[_this.fields.child], fields, parent);
          }
          return !!resultJSON;
        });
      } else {
        resultJSON = dataSource;
      }
      return resultJSON;
    };
    ListView2.prototype.getQuery = function() {
      var columns = [];
      var query = this.query ? this.query : new Query();
      if (!this.query) {
        for (var _i = 0, _a = Object.keys(this.fields.properties); _i < _a.length; _i++) {
          var column = _a[_i];
          if (column !== "tableName" && !!this.fields["" + column] && this.fields["" + column] !== ListBase.defaultMappedFields["" + column] && columns.indexOf(this.fields["" + column]) === -1) {
            columns.push(this.fields["" + column]);
          }
        }
        query.select(columns);
        if (Object.prototype.hasOwnProperty.call(this.fields.properties, "tableName")) {
          query.from(this.fields.tableName);
        }
      }
      return query;
    };
    ListView2.prototype.setViewDataSource = function(dataSource) {
      if (dataSource === void 0) {
        dataSource = this.localData;
      }
      var fieldValue = isNullOrUndefined(this.fields.sortBy) ? this.fields.text : this.fields.sortBy;
      var query = ListBase.addSorting(this.sortOrder, fieldValue);
      if (dataSource && this.fields.groupBy) {
        if (this.sortOrder !== "None") {
          this.curViewDS = ListBase.groupDataSource(ListBase.getDataSource(dataSource, query), this.listBaseOption.fields, this.sortOrder);
        } else {
          this.curViewDS = ListBase.groupDataSource(dataSource, this.listBaseOption.fields, this.sortOrder);
        }
      } else if (dataSource && this.sortOrder !== "None") {
        this.curViewDS = ListBase.getDataSource(dataSource, query);
      } else {
        this.curViewDS = dataSource;
      }
    };
    ListView2.prototype.isInAnimation = function() {
      return this.curUL.classList.contains(".e-animate");
    };
    ListView2.prototype.renderRemoteLists = function(e, listViewComponent) {
      if (this.isDestroyed) {
        return;
      }
      this.localData = e.result;
      listViewComponent.removeElement(listViewComponent.contentContainer);
      this.renderList();
      this.trigger("actionComplete", e);
    };
    ListView2.prototype.triggerActionFailure = function(e) {
      if (this.isDestroyed) {
        return;
      }
      this.trigger("actionFailure", e);
    };
    ListView2.prototype.setLocalData = function() {
      var _this = this;
      this.trigger("actionBegin");
      if (this.dataSource instanceof DataManager) {
        if (this.dataSource.ready) {
          this.dataSource.ready.then(function(e) {
            _this.isOffline = _this.dataSource.dataSource.offline;
            if (_this.dataSource instanceof DataManager && _this.isOffline) {
              _this.renderRemoteLists(e, _this);
            }
          }).catch(function(e) {
            _this.triggerActionFailure(e);
          });
        } else {
          this.dataSource.executeQuery(this.getQuery()).then(function(e) {
            _this.renderRemoteLists(e, _this);
          }).catch(function(e) {
            _this.triggerActionFailure(e);
          });
        }
      } else if (!this.dataSource || !this.dataSource.length) {
        var ul = this.element.querySelector("ul");
        if (ul) {
          remove(ul);
          this.setProperties({ dataSource: ListBase.createJsonFromElement(ul) }, true);
          this.localData = this.dataSource;
          this.renderList();
          this.trigger("actionComplete", { data: this.localData });
        }
      } else {
        this.localData = this.dataSource;
        this.renderList();
        this.trigger("actionComplete", { data: this.localData });
      }
    };
    ListView2.prototype.reRender = function() {
      this.removeElement(this.headerEle);
      this.removeElement(this.ulElement);
      this.removeElement(this.contentContainer);
      if (this.isReact) {
        this.clearTemplate();
      }
      if (Object.keys(window).indexOf("ejsInterop") === -1) {
        this.element.innerHTML = "";
      }
      this.headerEle = this.ulElement = this.liCollection = void 0;
      this.header();
      this.setLocalData();
    };
    ListView2.prototype.resetCurrentList = function() {
      this.setViewDataSource(this.curViewDS);
      this.contentContainer.innerHTML = "";
      this.createList();
      this.renderIntoDom(this.curUL);
    };
    ListView2.prototype.setAttributes = function(liElements) {
      for (var i = 0; i < liElements.length; i++) {
        var element2 = liElements[parseInt(i.toString(), 10)];
        if (element2.classList.contains("e-list-item")) {
          element2.setAttribute("id", this.element.id + "_" + element2.getAttribute("data-uid"));
          element2.setAttribute("tabindex", "-1");
        }
      }
    };
    ListView2.prototype.createList = function() {
      this.currentLiElements = [];
      this.isNestedList = false;
      this.ulElement = this.curUL = ListBase.createList(this.createElement, this.curViewDS, this.listBaseOption, null, this);
      this.liCollection = this.curUL.querySelectorAll("." + classNames4.listItem);
      this.setAttributes(this.liCollection);
    };
    ListView2.prototype.renderSubList = function(li) {
      this.liElement = li;
      var uID = li.getAttribute("data-uid");
      if (li.classList.contains(classNames4.hasChild) && uID) {
        var ul = closest(li.parentNode, "." + classNames4.parentItem);
        var ele = this.element.querySelector("[pid='" + uID + "']");
        this.curDSLevel.push(uID);
        this.setViewDataSource(this.getSubDS());
        if (!ele) {
          var data = this.curViewDS;
          ele = ListBase.createListFromJson(this.createElement, data, this.listBaseOption, this.curDSLevel.length, null, this);
          if (this.isReact) {
            this.renderReactTemplates();
          }
          var lists = ele.querySelectorAll("." + classNames4.listItem);
          this.setAttributes(lists);
          ele.setAttribute("pID", uID);
          ele.style.display = "none";
          this.renderIntoDom(ele);
        }
        this.switchView(ul, ele);
        this.liCollection = this.curUL.querySelectorAll("." + classNames4.listItem);
        if (this.selectedItems) {
          var fieldData = getFieldValues(this.selectedItems.data, this.listBaseOption.fields);
          this.header(fieldData[this.listBaseOption.fields.text], true, "header");
        }
        this.selectedLI = void 0;
      }
    };
    ListView2.prototype.renderIntoDom = function(ele) {
      this.contentContainer.appendChild(ele);
    };
    ListView2.prototype.renderList = function(data) {
      this.setViewDataSource(data);
      if (this.enableVirtualization) {
        if (Object.keys(this.dataSource).length) {
          if ((this.template || this.groupTemplate) && !this.virtualizationModule.isNgTemplate()) {
            this.listBaseOption.itemCreated = this.virtualizationModule.createUIItem.bind(this.virtualizationModule);
          }
        }
        this.virtualizationModule.uiVirtualization();
      } else {
        this.createList();
        this.contentContainer = this.createElement("div", { className: classNames4.container });
        this.element.appendChild(this.contentContainer);
        this.renderIntoDom(this.ulElement);
        if (this.isReact) {
          this.renderReactTemplates();
        }
      }
    };
    ListView2.prototype.getElementUID = function(obj) {
      var fields = {};
      if (obj instanceof Element) {
        fields[this.fields.id] = obj.getAttribute("data-uid");
      } else {
        fields = obj;
      }
      return fields;
    };
    ListView2.prototype.render = function() {
      this.element.classList.add(classNames4.root);
      attributes(this.element, { tabindex: "0" });
      this.setCSSClass();
      this.setEnableRTL();
      this.setEnable();
      this.setSize();
      this.wireEvents();
      this.header();
      this.setLocalData();
      this.setHTMLAttribute();
      this.rippleFn = rippleEffect(this.element, {
        selector: "." + classNames4.listItem
      });
      this.renderComplete();
      this.previousScrollTop = this.element.scrollTop;
    };
    ListView2.prototype.destroy = function() {
      if (this.isReact) {
        this.clearTemplate();
      }
      this.unWireEvents();
      var classAr = [
        classNames4.root,
        classNames4.disable,
        "e-rtl",
        "e-has-header",
        "e-lib"
      ].concat(this.cssClass ? this.cssClass.split(" ").filter(function(css) {
        return css;
      }) : []);
      removeClass([this.element], classAr);
      this.element.removeAttribute("role");
      this.element.removeAttribute("tabindex");
      this.curUL = this.ulElement = this.liCollection = this.headerEle = void 0;
      this.element.innerHTML = "";
      this.contentContainer = null;
      this.selectedItems = null;
      this.selectedLI = null;
      this.liElement = null;
      this.targetElement = null;
      this.currentLiElements = null;
      this.virtualCheckBox = null;
      _super.prototype.destroy.call(this);
    };
    ListView2.prototype.back = function() {
      var pID = this.curDSLevel[this.curDSLevel.length - 1];
      if (pID === void 0 || this.isInAnimation()) {
        return;
      }
      this.curDSLevel.pop();
      this.setViewDataSource(this.getSubDS());
      var toUL = this.element.querySelector("[data-uid='" + pID + "']");
      var fromUL = this.curUL;
      if (!toUL) {
        this.createList();
        this.renderIntoDom(this.ulElement);
        toUL = this.curUL;
      } else {
        toUL = toUL.parentElement;
      }
      var fieldData = getFieldValues(this.curDSJSON, this.listBaseOption.fields);
      var text = fieldData[this.fields.text];
      this.switchView(fromUL, toUL, true);
      this.removeFocus();
      var li = this.element.querySelector("[data-uid='" + pID + "']");
      li.classList.remove(classNames4.disable);
      li.classList.add(classNames4.focused);
      if (!(this.showCheckBox && li.querySelector("." + classNames4.checkboxIcon).classList.contains(classNames4.checked))) {
        li.classList.remove(classNames4.selected);
      }
      this.liCollection = this.curUL.querySelectorAll("." + classNames4.listItem);
      if (this.enableHtmlSanitizer) {
        this.setProperties({ headerTitle: SanitizeHtmlHelper.sanitize(this.headerTitle) }, true);
      }
      this.header(this.curDSLevel.length ? text : this.headerTitle, this.curDSLevel.length ? true : false, "header");
    };
    ListView2.prototype.selectItem = function(item) {
      if (this.enableVirtualization) {
        this.virtualizationModule.selectItem(item);
      } else if (this.showCheckBox) {
        this.setCheckboxLI(this.getLiFromObjOrElement(item));
      } else {
        if (isNullOrUndefined(item) === true) {
          this.removeSelect();
        } else {
          this.setSelectLI(this.getLiFromObjOrElement(item));
        }
      }
    };
    ListView2.prototype.unselectItem = function(item) {
      if (isNullOrUndefined(item)) {
        this.removeSelect();
      } else {
        var li = this.getLiFromObjOrElement(item);
        if (!isNullOrUndefined(li)) {
          this.removeSelect(li);
        }
      }
    };
    ListView2.prototype.getLiFromObjOrElement = function(obj) {
      var li;
      var dataSource = this.dataSource instanceof DataManager ? this.localData : this.dataSource;
      if (!isNullOrUndefined(obj)) {
        if (typeof dataSource[0] === "string" || typeof dataSource[0] === "number") {
          if (obj instanceof Element) {
            var uid = obj.getAttribute("data-uid").toString();
            for (var i = 0; i < this.liCollection.length; i++) {
              if (this.liCollection[parseInt(i.toString(), 10)].getAttribute("data-uid").toString() === uid) {
                li = this.liCollection[parseInt(i.toString(), 10)];
                break;
              }
            }
          } else {
            Array.prototype.some.call(this.curUL.querySelectorAll("." + classNames4.listItem), function(item) {
              if (item.innerText.trim() === obj.toString()) {
                li = item;
                return true;
              } else {
                return false;
              }
            });
          }
        } else {
          var resultJSON = this.getItemData(obj);
          var fieldData = getFieldValues(resultJSON, this.listBaseOption.fields);
          if (resultJSON) {
            li = this.element.querySelector('[data-uid="' + fieldData[this.fields.id] + '"]');
            if (!this.enableVirtualization && isNullOrUndefined(li)) {
              var curLi = this.element.querySelectorAll("." + classNames4.listItem);
              for (var i = 0; i < curLi.length; i++) {
                if (curLi[parseInt(i.toString(), 10)].innerText.trim() === fieldData[this.fields.text]) {
                  li = curLi[parseInt(i.toString(), 10)];
                }
              }
            }
          }
        }
      }
      return li;
    };
    ListView2.prototype.selectMultipleItems = function(item) {
      if (!isNullOrUndefined(item)) {
        for (var i = 0; i < item.length; i++) {
          if (!isNullOrUndefined(item[parseInt(i.toString(), 10)])) {
            this.selectItem(item[parseInt(i.toString(), 10)]);
          }
        }
      }
    };
    ListView2.prototype.getParentId = function() {
      var parentId = [];
      if (this.isNestedList) {
        for (var i = this.curDSLevel.length - 1; i >= 0; i--) {
          parentId.push(this.curDSLevel[parseInt(i.toString(), 10)]);
        }
      }
      return parentId;
    };
    ListView2.prototype.updateSelectedId = function() {
      this.selectedId = [];
      var liCollection = this.curUL.getElementsByClassName(classNames4.selected);
      for (var i = 0; i < liCollection.length; i++) {
        var tempData = this.getItemData(liCollection[parseInt(i.toString(), 10)]);
        if (!isNullOrUndefined(tempData) && tempData[this.listBaseOption.fields.id]) {
          this.selectedId.push(tempData[this.listBaseOption.fields.id]);
        }
      }
    };
    ListView2.prototype.getSelectedItems = function() {
      var finalValue;
      var isCompleted = false;
      this.selectedId = [];
      var dataSource = this.dataSource instanceof DataManager ? this.localData : this.dataSource;
      if (this.enableVirtualization && !isCompleted) {
        finalValue = this.virtualizationModule.getSelectedItems();
        isCompleted = true;
      } else if (this.showCheckBox && !isCompleted) {
        var liCollection = this.curUL.getElementsByClassName(classNames4.selected);
        var liTextCollection = [];
        var liDataCollection = [];
        this.selectedId = [];
        var dataParent = [];
        for (var i = 0; i < liCollection.length; i++) {
          if (typeof dataSource[0] === "string" || typeof dataSource[0] === "number") {
            liTextCollection.push(liCollection[parseInt(i.toString(), 10)].innerText.trim());
          } else {
            var tempData = this.getItemData(liCollection[parseInt(i.toString(), 10)]);
            var fieldData = getFieldValues(tempData, this.listBaseOption.fields);
            if (this.isNestedList) {
              dataParent.push({ data: tempData, parentId: this.getParentId() });
            } else {
              liDataCollection.push(tempData);
            }
            if (fieldData) {
              liTextCollection.push(fieldData[this.listBaseOption.fields.text]);
              this.selectedId.push(fieldData[this.listBaseOption.fields.id]);
            } else {
              liTextCollection.push(void 0);
              this.selectedId.push(void 0);
            }
          }
        }
        if ((typeof dataSource[0] === "string" || typeof dataSource[0] === "number") && !isCompleted) {
          finalValue = { item: liCollection, data: dataSource, text: liTextCollection };
          isCompleted = true;
        }
        if (this.isNestedList && !isCompleted) {
          finalValue = { item: liCollection, data: dataParent, text: liTextCollection };
          isCompleted = true;
        } else if (!isCompleted) {
          finalValue = { item: liCollection, data: liDataCollection, text: liTextCollection };
          isCompleted = true;
        }
      } else if (!isCompleted) {
        var liElement = this.element.getElementsByClassName(classNames4.selected)[0];
        var fieldData = getFieldValues(this.getItemData(liElement), this.listBaseOption.fields);
        if ((typeof dataSource[0] === "string" || typeof dataSource[0] === "number") && !isCompleted) {
          finalValue = !isNullOrUndefined(liElement) ? {
            item: liElement,
            data: dataSource,
            text: liElement.innerText.trim()
          } : void 0;
          isCompleted = true;
        } else if (!isCompleted) {
          if (isNullOrUndefined(fieldData) || isNullOrUndefined(liElement)) {
            finalValue = void 0;
            isCompleted = true;
          } else {
            this.selectedId.push(fieldData[this.listBaseOption.fields.id]);
            finalValue = {
              text: fieldData[this.listBaseOption.fields.text],
              item: liElement,
              data: this.getItemData(liElement)
            };
            isCompleted = true;
          }
        }
      }
      return finalValue;
    };
    ListView2.prototype.findItem = function(item) {
      return this.getItemData(item);
    };
    ListView2.prototype.enableItem = function(item) {
      this.setItemState(item, true);
      if (this.enableVirtualization) {
        this.virtualizationModule.enableItem(item);
      }
    };
    ListView2.prototype.disableItem = function(item) {
      this.setItemState(item, false);
      if (this.enableVirtualization) {
        this.virtualizationModule.disableItem(item);
      }
    };
    ListView2.prototype.setItemState = function(item, isEnable) {
      var resultJSON = this.getItemData(item);
      var fieldData = getFieldValues(resultJSON, this.listBaseOption.fields);
      if (resultJSON) {
        var li = this.element.querySelector('[data-uid="' + fieldData[this.fields.id] + '"]');
        if (isEnable) {
          if (li) {
            li.classList.remove(classNames4.disable);
          }
          delete resultJSON[this.fields.enabled];
        } else if (!isEnable) {
          if (li) {
            li.classList.add(classNames4.disable);
          }
          resultJSON[this.fields.enabled] = false;
        }
      }
    };
    ListView2.prototype.showItem = function(item) {
      this.showHideItem(item, false, "");
      if (this.enableVirtualization) {
        this.virtualizationModule.showItem(item);
      }
    };
    ListView2.prototype.hideItem = function(item) {
      this.showHideItem(item, true, "none");
      if (this.enableVirtualization) {
        this.virtualizationModule.hideItem(item);
      }
    };
    ListView2.prototype.showHideItem = function(obj, isHide, display) {
      var resultJSON = this.getItemData(obj);
      var fieldData = getFieldValues(resultJSON, this.listBaseOption.fields);
      if (resultJSON) {
        var li = this.element.querySelector('[data-uid="' + fieldData[this.fields.id] + '"]');
        if (li) {
          li.style.display = display;
        }
        if (isHide) {
          resultJSON[this.fields.isVisible] = false;
        } else {
          delete resultJSON[this.fields.isVisible];
        }
      }
    };
    ListView2.prototype.addItem = function(data, fields, index) {
      if (fields === void 0) {
        fields = void 0;
      }
      var dataSource = this.dataSource instanceof DataManager ? this.localData : this.dataSource;
      this.addItemInternally(data, fields, dataSource, index);
    };
    ListView2.prototype.addItemInternally = function(data, fields, dataSource, index) {
      if (data instanceof Array) {
        if (this.enableVirtualization) {
          this.virtualizationModule.addItem(data, fields, dataSource, index);
        } else {
          var ds = this.findItemFromDS(dataSource, fields);
          var child = void 0;
          if (ds) {
            var fieldData = getFieldValues(ds, this.listBaseOption.fields);
            child = fieldData[this.fields.child];
            if (!child) {
              child = [];
            }
            child = child.concat(data);
          }
          if (ds instanceof Array) {
            for (var i = 0; i < data.length; i++) {
              dataSource = this.addItemAtIndex(index, dataSource, data[parseInt(i.toString(), 10)]);
              this.setViewDataSource(dataSource);
              var targetUL = this.contentContainer ? this.contentContainer.children[0] : null;
              if (this.contentContainer && targetUL) {
                this.addItemIntoDom(data[parseInt(i.toString(), 10)], targetUL, this.curViewDS);
              } else {
                this.reRender();
              }
            }
            this.liCollection = this.curUL.querySelectorAll("." + classNames4.listItem);
          } else {
            if (ds) {
              ds[this.fields.child] = child;
              this.addItemInNestedList(ds, data);
            }
          }
        }
      }
    };
    ListView2.prototype.addItemAtIndex = function(index, newDataSource, itemData) {
      var isIndexValid = !isNullOrUndefined(index) && index >= 0 && index < newDataSource.length && isNullOrUndefined(this.listBaseOption.fields.groupBy);
      if (isIndexValid) {
        newDataSource.splice(index, 0, itemData);
      } else {
        newDataSource.push(itemData);
      }
      return newDataSource;
    };
    ListView2.prototype.addItemInNestedList = function(targetItemData, itemQueue) {
      var targetItemId = targetItemData[this.fields.id];
      var targetChildDS = targetItemData[this.fields.child];
      var isAlreadyRenderedUL = this.element.querySelector("[pid='" + targetItemId + "']");
      var targetLi = this.element.querySelector("[data-uid='" + targetItemId + "']");
      var targetUL = isAlreadyRenderedUL ? isAlreadyRenderedUL : targetLi ? closest(targetLi, "ul") : null;
      var targetDS = isAlreadyRenderedUL ? targetChildDS : [targetItemData];
      var isTargetEmptyChild = targetLi ? !targetLi.classList.contains(classNames4.hasChild) : false;
      if (isTargetEmptyChild) {
        var targetRefreshedElement = ListBase.createListItemFromJson(this.createElement, targetDS, this.listBaseOption, null, null, this);
        this.setAttributes(targetRefreshedElement);
        targetUL.insertBefore(targetRefreshedElement[0], targetLi);
        detach(targetLi);
      }
      if (isAlreadyRenderedUL && itemQueue) {
        for (var i = 0; i < itemQueue.length; i++) {
          targetDS.push(itemQueue[parseInt(i.toString(), 10)]);
          this.addItemIntoDom(itemQueue[parseInt(i.toString(), 10)], targetUL, targetDS);
        }
      }
    };
    ListView2.prototype.addItemIntoDom = function(currentItem, targetUL, curViewDS) {
      var index = curViewDS.indexOf(currentItem);
      this.addListItem(currentItem, index, targetUL, curViewDS);
      var curItemDS = curViewDS[index - 1];
      if (curItemDS && curItemDS.isHeader && curItemDS.items.length === 1) {
        this.addListItem(curItemDS, index - 1, targetUL, curViewDS);
      }
    };
    ListView2.prototype.addListItem = function(dataSource, index, ulElement, curViewDS) {
      var target = this.getLiFromObjOrElement(curViewDS[index + 1]) || this.getLiFromObjOrElement(curViewDS[index + 2]) || null;
      var li = ListBase.createListItemFromJson(this.createElement, [dataSource], this.listBaseOption, null, null, this);
      this.setAttributes(li);
      if (this.template && this.isReact) {
        this.renderReactTemplates();
      }
      if (this.fields.groupBy && curViewDS[index + 1] && curViewDS[index + 1].isHeader) {
        var targetEle = this.getLiFromObjOrElement(curViewDS[index - 1]);
        if (targetEle) {
          target = targetEle.nextElementSibling;
        }
      }
      ulElement.insertBefore(li[0], target);
    };
    ListView2.prototype.removeItem = function(item) {
      var listDataSource = this.dataSource instanceof DataManager ? this.localData : this.dataSource;
      if (this.enableVirtualization) {
        this.virtualizationModule.removeItem(item);
      } else {
        this.removeItemFromList(item, listDataSource);
      }
    };
    ListView2.prototype.removeItemFromList = function(obj, listDataSource) {
      var _this = this;
      var curViewDS = this.curViewDS;
      var fields = obj instanceof Element ? this.getElementUID(obj) : obj;
      var dataSource = this.findItemFromDS(listDataSource, fields, true);
      if (dataSource) {
        var data_1 = this.findItemFromDS(dataSource, fields);
        var index = curViewDS.indexOf(data_1);
        var li = this.getLiFromObjOrElement(obj);
        var groupLi = void 0;
        this.validateNestedView(li);
        if (this.fields.groupBy && this.curViewDS[index - 1] && curViewDS[index - 1].isHeader && curViewDS[index - 1].items.length === 1) {
          if (li && li.previousElementSibling.classList.contains(classNames4.groupListItem) && (isNullOrUndefined(li.nextElementSibling) || li.nextElementSibling && li.nextElementSibling.classList.contains(classNames4.groupListItem))) {
            groupLi = li.previousElementSibling;
          }
        }
        if (li) {
          detach(li);
        }
        if (groupLi) {
          detach(groupLi);
        }
        var foundData = dataSource.length - 1 <= 0 ? this.findParent(this.localData, this.fields.id, function(value) {
          return value === data_1[_this.fields.id];
        }, null) : null;
        var dsIndex = dataSource.indexOf(data_1);
        dataSource.splice(dsIndex, 1);
        this.setViewDataSource(listDataSource);
        if (foundData && foundData.parent && Array.isArray(foundData.parent[this.fields.child]) && foundData.parent[this.fields.child].length <= 0) {
          var parentLi = this.getLiFromObjOrElement(foundData.parent);
          if (parentLi) {
            var li_1 = ListBase.createListItemFromJson(this.createElement, [foundData.parent], this.listBaseOption, null, null, this);
            this.setAttributes(li_1);
            parentLi.parentElement.insertBefore(li_1[0], parentLi);
            parentLi.parentElement.removeChild(parentLi);
          }
        }
        if (dataSource.length <= 0) {
          this.back();
        }
        this.liCollection = Array.prototype.slice.call(this.element.querySelectorAll("." + classNames4.listItem));
      }
    };
    ListView2.prototype.validateNestedView = function(li) {
      var liID = li ? li.getAttribute("data-uid").toString().toLowerCase() : null;
      if (liID && this.curDSLevel && this.curDSLevel.length > 0) {
        while (this.curDSLevel.some(function(id) {
          return id.toString().toLowerCase() === liID;
        })) {
          this.back();
        }
      }
    };
    ListView2.prototype.removeMultipleItems = function(item) {
      if (item.length) {
        for (var i = 0; i < item.length; i++) {
          this.removeItem(item[parseInt(i.toString(), 10)]);
        }
      }
    };
    ListView2.prototype.findParent = function(dataSource, id, callback, parent) {
      if (Object.prototype.hasOwnProperty.call(dataSource, id) && callback(dataSource[id]) === true) {
        return extend({}, dataSource);
      }
      for (var i = 0; i < Object.keys(dataSource).length; i++) {
        if (dataSource[Object.keys(dataSource)[parseInt(i.toString(), 10)]] && typeof dataSource[Object.keys(dataSource)[parseInt(i.toString(), 10)]] === "object") {
          var result = this.findParent(dataSource[Object.keys(dataSource)[parseInt(i.toString(), 10)]], id, callback, dataSource);
          if (result != null) {
            if (!result.parent) {
              result.parent = parent;
            }
            return result;
          }
        }
      }
      return null;
    };
    ListView2.prototype.getModuleName = function() {
      return "listview";
    };
    ListView2.prototype.requiredModules = function() {
      var modules = [];
      if (this.enableVirtualization) {
        modules.push({ args: [this], member: "virtualization", name: "Virtualization" });
      }
      return modules;
    };
    ListView2.prototype.onListScroll = function(e) {
      var args = { originalEvent: e, scrollDirection: "Bottom", distanceY: this.element.scrollHeight - this.element.scrollTop };
      var currentScrollTop = this.element.scrollTop;
      if (currentScrollTop > this.previousScrollTop) {
        args.scrollDirection = "Bottom";
        args.distanceY = this.element.scrollHeight - this.element.clientHeight - this.element.scrollTop;
        this.trigger("scroll", args);
      } else if (this.previousScrollTop > currentScrollTop) {
        args.scrollDirection = "Top";
        args.distanceY = this.element.scrollTop;
        this.trigger("scroll", args);
      }
      this.previousScrollTop = currentScrollTop;
    };
    ListView2.prototype.getPersistData = function() {
      return this.addOnPersist([
        "cssClass",
        "enableRtl",
        "htmlAttributes",
        "enable",
        "fields",
        "animation",
        "headerTitle",
        "sortOrder",
        "showIcon",
        "height",
        "width",
        "showCheckBox",
        "checkBoxPosition",
        "selectedId"
      ]);
    };
    __decorate30([
      Property("")
    ], ListView2.prototype, "cssClass", void 0);
    __decorate30([
      Property(false)
    ], ListView2.prototype, "enableVirtualization", void 0);
    __decorate30([
      Property({})
    ], ListView2.prototype, "htmlAttributes", void 0);
    __decorate30([
      Property(true)
    ], ListView2.prototype, "enable", void 0);
    __decorate30([
      Property([])
    ], ListView2.prototype, "dataSource", void 0);
    __decorate30([
      Property()
    ], ListView2.prototype, "query", void 0);
    __decorate30([
      Complex(ListBase.defaultMappedFields, FieldSettings)
    ], ListView2.prototype, "fields", void 0);
    __decorate30([
      Property({ effect: "SlideLeft", duration: 400, easing: "ease" })
    ], ListView2.prototype, "animation", void 0);
    __decorate30([
      Property("None")
    ], ListView2.prototype, "sortOrder", void 0);
    __decorate30([
      Property(false)
    ], ListView2.prototype, "showIcon", void 0);
    __decorate30([
      Property(false)
    ], ListView2.prototype, "showCheckBox", void 0);
    __decorate30([
      Property("Left")
    ], ListView2.prototype, "checkBoxPosition", void 0);
    __decorate30([
      Property("")
    ], ListView2.prototype, "headerTitle", void 0);
    __decorate30([
      Property(false)
    ], ListView2.prototype, "showHeader", void 0);
    __decorate30([
      Property(true)
    ], ListView2.prototype, "enableHtmlSanitizer", void 0);
    __decorate30([
      Property("")
    ], ListView2.prototype, "height", void 0);
    __decorate30([
      Property("")
    ], ListView2.prototype, "width", void 0);
    __decorate30([
      Property(null)
    ], ListView2.prototype, "template", void 0);
    __decorate30([
      Property(null)
    ], ListView2.prototype, "headerTemplate", void 0);
    __decorate30([
      Property(null)
    ], ListView2.prototype, "groupTemplate", void 0);
    __decorate30([
      Event()
    ], ListView2.prototype, "select", void 0);
    __decorate30([
      Event()
    ], ListView2.prototype, "actionBegin", void 0);
    __decorate30([
      Event()
    ], ListView2.prototype, "actionComplete", void 0);
    __decorate30([
      Event()
    ], ListView2.prototype, "actionFailure", void 0);
    __decorate30([
      Event()
    ], ListView2.prototype, "scroll", void 0);
    ListView2 = __decorate30([
      NotifyPropertyChanges
    ], ListView2);
    return ListView2;
  }(Component)
);

// node_modules/@syncfusion/ej2-lists/src/list-view/virtualization.js
var listElementCount = 1.5;
var windowElementCount = 3;
var Virtualization = (
  /** @class */
  function() {
    function Virtualization2(instance) {
      this.elementDifference = 0;
      this.listViewInstance = instance;
    }
    Virtualization2.prototype.isNgTemplate = function() {
      return !isNullOrUndefined(this.listViewInstance.templateRef) && typeof this.listViewInstance.templateRef !== "string";
    };
    Virtualization2.prototype.isVueFunctionTemplate = function() {
      return this.listViewInstance.isVue && typeof this.listViewInstance.template === "function";
    };
    Virtualization2.prototype.uiVirtualization = function() {
      this.wireScrollEvent(false);
      var curViewDS = this.listViewInstance.curViewDS;
      var firstDs = curViewDS.slice(0, 1);
      this.listViewInstance.ulElement = this.listViewInstance.curUL = ListBase.createList(this.listViewInstance.createElement, firstDs, this.listViewInstance.listBaseOption, null, this.listViewInstance);
      this.listViewInstance.contentContainer = this.listViewInstance.createElement("div", { className: classNames4.container });
      this.listViewInstance.element.appendChild(this.listViewInstance.contentContainer);
      this.listViewInstance.contentContainer.appendChild(this.listViewInstance.ulElement);
      this.listItemHeight = this.listViewInstance.ulElement.firstElementChild.getBoundingClientRect().height;
      this.expectedDomItemCount = this.ValidateItemCount(1e4);
      this.domItemCount = this.ValidateItemCount(Object.keys(this.listViewInstance.curViewDS).length);
      this.uiFirstIndex = 0;
      this.uiLastIndex = this.domItemCount - 1;
      var otherDs = curViewDS.slice(1, this.domItemCount);
      var listItems = ListBase.createListItemFromJson(this.listViewInstance.createElement, otherDs, this.listViewInstance.listBaseOption, null, null, this.listViewInstance);
      append(listItems, this.listViewInstance.ulElement);
      this.listViewInstance.liCollection = this.listViewInstance.curUL.querySelectorAll("li");
      this.topElement = this.listViewInstance.createElement("div");
      this.listViewInstance.ulElement.insertBefore(this.topElement, this.listViewInstance.ulElement.firstElementChild);
      this.bottomElement = this.listViewInstance.createElement("div");
      this.listViewInstance.ulElement.insertBefore(this.bottomElement, null);
      this.totalHeight = Object.keys(curViewDS).length * this.listItemHeight - this.domItemCount * this.listItemHeight;
      this.topElement.style.height = "0px";
      this.bottomElement.style.height = this.totalHeight + "px";
      this.topElementHeight = 0;
      this.bottomElementHeight = this.totalHeight;
      this.listDiff = 0;
      this.uiIndicesInitialization();
    };
    Virtualization2.prototype.wireScrollEvent = function(destroy3) {
      if (!destroy3) {
        if (this.listViewInstance.isWindow) {
          this.onVirtualScroll = this.onVirtualUiScroll.bind(this);
          window.addEventListener("scroll", this.onVirtualScroll);
        } else {
          EventHandler.add(this.listViewInstance.element, "scroll", this.onVirtualUiScroll, this);
        }
      } else {
        if (this.listViewInstance.isWindow === true) {
          window.removeEventListener("scroll", this.onVirtualScroll);
          window.removeEventListener("scroll", this.updateUl);
        } else {
          EventHandler.remove(this.listViewInstance.element, "scroll", this.onVirtualUiScroll);
        }
      }
    };
    Virtualization2.prototype.ValidateItemCount = function(dataSourceLength) {
      var height = parseFloat(formatUnit(this.listViewInstance.height));
      var itemCount;
      if (this.listViewInstance.isWindow) {
        itemCount = Math.round(window.innerHeight / this.listItemHeight * windowElementCount);
      } else {
        if (typeof this.listViewInstance.height === "string" && this.listViewInstance.height.indexOf("%") !== -1) {
          itemCount = Math.round(this.listViewInstance.element.getBoundingClientRect().height / this.listItemHeight * listElementCount);
        } else {
          itemCount = Math.round(height / this.listItemHeight * listElementCount);
        }
      }
      if (itemCount > dataSourceLength) {
        itemCount = dataSourceLength;
      }
      return itemCount;
    };
    Virtualization2.prototype.uiIndicesInitialization = function() {
      this.uiIndices = { "activeIndices": [], "disabledItemIndices": [], "hiddenItemIndices": [] };
      var data = this.listViewInstance.curViewDS;
      for (var i = 0; i < data.length; i++) {
        if (this.listViewInstance.showCheckBox && data[i][this.listViewInstance.fields.isChecked]) {
          this.uiIndices.activeIndices.push(i);
        }
        if (!isNullOrUndefined(data[parseInt(i.toString(), 10)][this.listViewInstance.fields.enabled]) && !data[i][this.listViewInstance.fields.enabled]) {
          this.uiIndices.disabledItemIndices.push(i);
        }
      }
      if (this.isNgTemplate()) {
        var items = this.listViewInstance.element.querySelectorAll("." + classNames4.listItem);
        for (var index = 0; index < items.length; index++) {
          items[index].context = this.listViewInstance.viewContainerRef.get(index).context;
        }
      }
    };
    Virtualization2.prototype.refreshItemHeight = function() {
      if (this.listViewInstance.curViewDS.length) {
        var curViewDS = this.listViewInstance.curViewDS;
        this.listItemHeight = this.topElement.nextSibling.getBoundingClientRect().height;
        this.totalHeight = Object.keys(curViewDS).length * this.listItemHeight - this.domItemCount * this.listItemHeight;
        this.bottomElementHeight = this.totalHeight;
        this.bottomElement.style.height = this.totalHeight + "px";
      }
    };
    Virtualization2.prototype.getscrollerHeight = function(startingHeight) {
      return this.listViewInstance.isWindow ? pageYOffset - startingHeight <= 0 ? 0 : pageYOffset - startingHeight : this.listViewInstance.element.scrollTop - startingHeight <= 0 ? 0 : this.listViewInstance.element.scrollTop - startingHeight;
    };
    Virtualization2.prototype.onVirtualUiScroll = function() {
      var _a;
      var startingHeight;
      var curViewDS = this.listViewInstance.curViewDS;
      this.listItemHeight = select(".e-list-item", this.listViewInstance.element).getBoundingClientRect().height;
      this.totalHeight = Object.keys(curViewDS).length * this.listItemHeight - this.domItemCount * this.listItemHeight;
      if (this.listViewInstance.isWindow) {
        startingHeight = this.listViewInstance.ulElement.getBoundingClientRect().top - document.documentElement.getBoundingClientRect().top;
      } else {
        startingHeight = this.listViewInstance.headerEle ? this.listViewInstance.headerEle.getBoundingClientRect().height : 0;
      }
      this.scrollPosition = isNullOrUndefined(this.scrollPosition) ? 0 : this.scrollPosition;
      var scroll = this.getscrollerHeight(startingHeight);
      this.topElementHeight = this.listItemHeight * Math.floor(scroll / this.listItemHeight);
      this.bottomElementHeight = this.totalHeight - this.topElementHeight;
      _a = scroll <= this.totalHeight ? [this.topElementHeight, this.bottomElementHeight] : [this.totalHeight, 0], this.topElementHeight = _a[0], this.bottomElementHeight = _a[1];
      if (this.topElementHeight !== parseFloat(this.topElement.style.height)) {
        this.topElement.style.height = this.topElementHeight + "px";
        this.bottomElement.style.height = this.bottomElementHeight + "px";
        if (scroll > this.scrollPosition) {
          var listDiff = Math.round(this.topElementHeight / this.listItemHeight - this.listDiff);
          if (listDiff > this.expectedDomItemCount + 5) {
            this.onLongScroll(listDiff, true);
          } else {
            this.onNormalScroll(listDiff, true);
          }
        } else {
          var listDiff = Math.round(this.listDiff - this.topElementHeight / this.listItemHeight);
          if (listDiff > this.expectedDomItemCount + 5) {
            this.onLongScroll(listDiff, false);
          } else {
            this.onNormalScroll(listDiff, false);
          }
        }
      }
      this.listDiff = Math.round(this.topElementHeight / this.listItemHeight);
      if (typeof this.listViewInstance.onUIScrolled === "function") {
        this.listViewInstance.onUIScrolled();
      }
      this.scrollPosition = scroll;
    };
    Virtualization2.prototype.onLongScroll = function(listDiff, isScrollingDown) {
      var index = isScrollingDown ? this.uiFirstIndex + listDiff : this.uiFirstIndex - listDiff;
      var elements = this.listViewInstance.ulElement.querySelectorAll("li");
      for (var i = 0; i < elements.length; i++) {
        this.updateUI(elements[i], index);
        index++;
      }
      this.uiLastIndex = isScrollingDown ? this.uiLastIndex + listDiff : this.uiLastIndex - listDiff;
      this.uiFirstIndex = isScrollingDown ? this.uiFirstIndex + listDiff : this.uiFirstIndex - listDiff;
    };
    Virtualization2.prototype.onNormalScroll = function(listDiff, isScrollingDown) {
      if (isScrollingDown) {
        for (var i = 0; i < listDiff; i++) {
          var index = ++this.uiLastIndex;
          this.updateUI(this.topElement.nextElementSibling, index, this.bottomElement);
          this.uiFirstIndex++;
        }
      } else {
        for (var i = 0; i < listDiff; i++) {
          var index = --this.uiFirstIndex;
          var target = this.topElement.nextSibling;
          this.updateUI(this.bottomElement.previousElementSibling, index, target);
          this.uiLastIndex--;
        }
      }
    };
    Virtualization2.prototype.updateUiContent = function(element2, index) {
      var curViewDs = this.listViewInstance.curViewDS;
      if (typeof this.listViewInstance.dataSource[0] === "string" || typeof this.listViewInstance.dataSource[0] === "number") {
        element2.dataset.uid = ListBase.generateId();
        element2.getElementsByClassName(classNames4.listItemText)[0].innerHTML = this.listViewInstance.curViewDS[index].toString();
      } else {
        element2.dataset.uid = curViewDs[parseInt(index.toString(), 10)][this.listViewInstance.fields.id] ? curViewDs[parseInt(index.toString(), 10)][this.listViewInstance.fields.id] : ListBase.generateId();
        element2.getElementsByClassName(classNames4.listItemText)[0].innerHTML = curViewDs[parseInt(index.toString(), 10)][this.listViewInstance.fields.text];
      }
      if (this.listViewInstance.showIcon) {
        if (element2.querySelector("." + classNames4.listIcon)) {
          detach(element2.querySelector("." + classNames4.listIcon));
        }
        if (this.listViewInstance.curViewDS[index][this.listViewInstance.fields.iconCss]) {
          var textContent = element2.querySelector("." + classNames4.textContent);
          var curViewDS = this.listViewInstance.curViewDS[index];
          var iconCss = curViewDS[this.listViewInstance.fields.iconCss].toString();
          var target = this.listViewInstance.createElement("div", {
            className: classNames4.listIcon + " " + iconCss
          });
          textContent.insertBefore(target, element2.querySelector("." + classNames4.listItemText));
        }
      }
      if (this.listViewInstance.showCheckBox && this.listViewInstance.fields.groupBy) {
        if (!this.checkListWrapper) {
          this.checkListWrapper = this.listViewInstance.curUL.querySelector("." + classNames4.checkboxWrapper).cloneNode(true);
        }
        var textContent = element2.querySelector("." + classNames4.textContent);
        if (this.listViewInstance.curViewDS[index].isHeader) {
          if (element2.querySelector("." + classNames4.checkboxWrapper)) {
            element2.classList.remove(classNames4.checklist);
            textContent.classList.remove(classNames4.checkbox);
            detach(element2.querySelector("." + classNames4.checkboxWrapper));
          }
        } else {
          if (!element2.querySelector("." + classNames4.checkboxWrapper)) {
            element2.classList.add(classNames4.checklist);
            textContent.classList.add(classNames4.checkbox);
            if (this.listViewInstance.checkBoxPosition === "Left") {
              textContent.classList.add("e-checkbox-left");
            } else {
              textContent.classList.add("e-checkbox-right");
            }
            textContent.append(this.checkListWrapper.cloneNode(true));
          }
        }
      }
    };
    Virtualization2.prototype.changeElementAttributes = function(element2, index) {
      element2.classList.remove(classNames4.disable);
      if (this.uiIndices.disabledItemIndices.length && this.uiIndices.disabledItemIndices.indexOf(index) !== -1) {
        element2.classList.add(classNames4.disable);
      }
      element2.style.display = "";
      if (this.uiIndices.hiddenItemIndices.length && this.uiIndices.hiddenItemIndices.indexOf(index) !== -1) {
        element2.style.display = "none";
      }
      if (this.listViewInstance.showCheckBox) {
        var checklistElement = element2.querySelector("." + classNames4.checkboxWrapper);
        element2.classList.remove(classNames4.selected);
        element2.classList.remove(classNames4.focused);
        if (checklistElement) {
          checklistElement.removeAttribute("aria-checked");
          checklistElement.firstElementChild.classList.remove(classNames4.checked);
        }
        if (this.uiIndices.activeIndices.length && this.uiIndices.activeIndices.indexOf(index) !== -1 && !this.listViewInstance.curUL.querySelector(classNames4.selected)) {
          element2.classList.add(classNames4.selected);
          checklistElement.firstElementChild.classList.add(classNames4.checked);
          checklistElement.setAttribute("aria-checked", "true");
          if (this.activeIndex === index) {
            element2.classList.add(classNames4.focused);
          }
        }
      } else {
        element2.classList.remove(classNames4.selected);
        element2.removeAttribute("aria-selected");
        if (!isNullOrUndefined(this.activeIndex) && this.activeIndex === index && !this.listViewInstance.curUL.querySelector(classNames4.selected)) {
          element2.classList.add(classNames4.selected);
          element2.setAttribute("aria-selected", "true");
        }
      }
      if (this.listViewInstance.fields.groupBy) {
        if (this.listViewInstance.curViewDS[index].isHeader) {
          if (element2.classList.contains(classNames4.listItem)) {
            element2.classList.remove(classNames4.listItem);
            element2.setAttribute("role", "group");
            element2.classList.add(classNames4.groupListItem);
          }
        } else {
          if (element2.classList.contains(classNames4.groupListItem)) {
            element2.classList.remove(classNames4.groupListItem);
            element2.setAttribute("role", "listitem");
            element2.classList.add(classNames4.listItem);
          }
        }
      }
    };
    Virtualization2.prototype.findDSAndIndexFromId = function(ds, fields) {
      var _this = this;
      var resultJSON = {};
      fields = this.listViewInstance.getElementUID(fields);
      if (!isNullOrUndefined(fields)) {
        ds.some(function(data, index) {
          if (fields[_this.listViewInstance.fields.id] && fields[_this.listViewInstance.fields.id] === (data[_this.listViewInstance.fields.id] && data[_this.listViewInstance.fields.id]) || fields === data) {
            resultJSON.index = index;
            resultJSON.data = data;
            return true;
          } else {
            return false;
          }
        });
      }
      return resultJSON;
    };
    Virtualization2.prototype.getSelectedItems = function() {
      var _this = this;
      if (!isNullOrUndefined(this.activeIndex) || this.listViewInstance.showCheckBox && this.uiIndices.activeIndices.length) {
        var dataCollection = [];
        var textCollection = [];
        if (typeof this.listViewInstance.dataSource[0] === "string" || typeof this.listViewInstance.dataSource[0] === "number") {
          var curViewDS_1 = this.listViewInstance.curViewDS;
          if (this.listViewInstance.showCheckBox) {
            var indices = this.uiIndices.activeIndices;
            for (var i = 0; i < indices.length; i++) {
              dataCollection.push(curViewDS_1[indices[i]]);
            }
            return {
              text: dataCollection,
              data: dataCollection,
              index: this.uiIndices.activeIndices.map(function(index) {
                return _this.listViewInstance.dataSource.indexOf(curViewDS_1[index]);
              })
            };
          } else {
            return {
              text: curViewDS_1[this.activeIndex],
              data: curViewDS_1[this.activeIndex],
              index: this.listViewInstance.dataSource.indexOf(curViewDS_1[this.activeIndex])
            };
          }
        } else {
          var curViewDS_2 = this.listViewInstance.curViewDS;
          var text = this.listViewInstance.fields.text;
          if (this.listViewInstance.showCheckBox) {
            var indexArray = this.uiIndices.activeIndices;
            for (var i = 0; i < indexArray.length; i++) {
              textCollection.push(curViewDS_2[indexArray[i]]["" + text]);
              dataCollection.push(curViewDS_2[indexArray[parseInt(i.toString(), 10)]]);
            }
            var dataSource_1 = this.listViewInstance.dataSource instanceof DataManager ? curViewDS_2 : this.listViewInstance.dataSource;
            return {
              text: textCollection,
              data: dataCollection,
              index: this.uiIndices.activeIndices.map(function(index) {
                return dataSource_1.indexOf(curViewDS_2[index]);
              })
            };
          } else {
            var dataSource = this.listViewInstance.dataSource instanceof DataManager ? curViewDS_2 : this.listViewInstance.dataSource;
            return {
              text: curViewDS_2[this.activeIndex][this.listViewInstance.fields.text],
              data: curViewDS_2[this.activeIndex],
              index: dataSource.indexOf(curViewDS_2[this.activeIndex])
            };
          }
        }
      } else {
        return void 0;
      }
    };
    Virtualization2.prototype.selectItem = function(obj) {
      var resutJSON = this.findDSAndIndexFromId(this.listViewInstance.curViewDS, obj);
      if (Object.keys(resutJSON).length) {
        var isSelected = this.activeIndex === resutJSON.index;
        var isChecked = void 0;
        this.activeIndex = resutJSON.index;
        if (this.listViewInstance.showCheckBox) {
          if (this.uiIndices.activeIndices.indexOf(resutJSON.index) === -1) {
            isChecked = true;
            this.uiIndices.activeIndices.push(resutJSON.index);
          } else {
            isChecked = false;
            this.uiIndices.activeIndices.splice(this.uiIndices.activeIndices.indexOf(resutJSON.index), 1);
          }
          if (this.listViewInstance.curUL.querySelector("." + classNames4.focused)) {
            this.listViewInstance.curUL.querySelector("." + classNames4.focused).classList.remove(classNames4.focused);
          }
        }
        if (this.listViewInstance.getLiFromObjOrElement(obj)) {
          if (this.listViewInstance.showCheckBox) {
            this.listViewInstance.setCheckboxLI(this.listViewInstance.getLiFromObjOrElement(obj));
          } else {
            this.listViewInstance.setSelectLI(this.listViewInstance.getLiFromObjOrElement(obj));
          }
        } else {
          var eventArgs = void 0;
          if (typeof this.listViewInstance.dataSource[0] === "string" || typeof this.listViewInstance.dataSource[0] === "number") {
            eventArgs = {
              text: this.listViewInstance.curViewDS[this.activeIndex],
              data: this.listViewInstance.curViewDS[this.activeIndex],
              index: this.activeIndex
            };
          } else {
            var curViewDS = this.listViewInstance.curViewDS;
            eventArgs = {
              text: curViewDS[this.activeIndex][this.listViewInstance.fields.text],
              data: curViewDS[this.activeIndex],
              index: this.activeIndex
            };
          }
          if (this.listViewInstance.showCheckBox) {
            eventArgs.isChecked = isChecked;
            this.listViewInstance.trigger("select", eventArgs);
          } else if (!isSelected) {
            this.listViewInstance.removeSelect();
            this.listViewInstance.trigger("select", eventArgs);
          }
        }
      } else if (isNullOrUndefined(obj) && !this.listViewInstance.showCheckBox) {
        this.listViewInstance.removeSelect();
        this.activeIndex = void 0;
      }
    };
    Virtualization2.prototype.enableItem = function(obj) {
      var resutJSON = this.findDSAndIndexFromId(this.listViewInstance.curViewDS, obj);
      if (Object.keys(resutJSON).length) {
        this.uiIndices.disabledItemIndices.splice(this.uiIndices.disabledItemIndices.indexOf(resutJSON.index), 1);
      }
    };
    Virtualization2.prototype.disableItem = function(obj) {
      var resutJSON = this.findDSAndIndexFromId(this.listViewInstance.curViewDS, obj);
      if (Object.keys(resutJSON).length && this.uiIndices.disabledItemIndices.indexOf(resutJSON.index) === -1) {
        this.uiIndices.disabledItemIndices.push(resutJSON.index);
      }
    };
    Virtualization2.prototype.showItem = function(obj) {
      var resutJSON = this.findDSAndIndexFromId(this.listViewInstance.curViewDS, obj);
      if (Object.keys(resutJSON).length) {
        this.uiIndices.hiddenItemIndices.splice(this.uiIndices.hiddenItemIndices.indexOf(resutJSON.index), 1);
      }
    };
    Virtualization2.prototype.hideItem = function(obj) {
      var resutJSON = this.findDSAndIndexFromId(this.listViewInstance.curViewDS, obj);
      if (Object.keys(resutJSON).length && this.uiIndices.hiddenItemIndices.indexOf(resutJSON.index) === -1) {
        this.uiIndices.hiddenItemIndices.push(resutJSON.index);
      }
    };
    Virtualization2.prototype.removeItem = function(obj) {
      var dataSource;
      var curViewDS = this.listViewInstance.curViewDS;
      var resutJSON = this.findDSAndIndexFromId(curViewDS, obj);
      if (Object.keys(resutJSON).length) {
        dataSource = resutJSON.data;
        if (curViewDS[resutJSON.index - 1] && curViewDS[resutJSON.index - 1].isHeader && curViewDS[resutJSON.index - 1].items.length === 1) {
          this.removeUiItem(resutJSON.index - 1);
          this.removeUiItem(resutJSON.index - 1);
        } else {
          this.removeUiItem(resutJSON.index);
        }
      }
      var listDataSource = this.listViewInstance.dataSource instanceof DataManager ? this.listViewInstance.localData : this.listViewInstance.dataSource;
      var index = listDataSource.indexOf(dataSource);
      if (index !== -1) {
        listDataSource.splice(index, 1);
        this.listViewInstance.setViewDataSource(listDataSource);
      }
      this.listViewInstance.liCollection = this.listViewInstance.curUL.querySelectorAll("li");
    };
    Virtualization2.prototype.setCheckboxLI = function(li, e) {
      var index = Array.prototype.indexOf.call(this.listViewInstance.curUL.querySelectorAll("li"), li) + this.uiFirstIndex;
      this.activeIndex = Array.prototype.indexOf.call(this.listViewInstance.curUL.querySelectorAll("li"), li) + this.uiFirstIndex;
      if (li.classList.contains(classNames4.selected)) {
        if (this.uiIndices.activeIndices.indexOf(index) === -1) {
          this.uiIndices.activeIndices.push(index);
        }
      } else {
        this.uiIndices.activeIndices.splice(this.uiIndices.activeIndices.indexOf(index), 1);
      }
    };
    Virtualization2.prototype.setSelectLI = function(li, e) {
      this.activeIndex = Array.prototype.indexOf.call(this.listViewInstance.curUL.querySelectorAll("li"), li) + this.uiFirstIndex;
    };
    Virtualization2.prototype.checkedItem = function(checked) {
      if (checked) {
        this.uiIndices.activeIndices = [];
        this.activeIndex = void 0;
        var data = this.listViewInstance.curViewDS;
        for (var index = 0; index < data.length; index++) {
          if (!data[index].isHeader) {
            this.uiIndices.activeIndices.push(index);
          }
        }
      } else {
        this.activeIndex = void 0;
        this.uiIndices.activeIndices = [];
      }
    };
    Virtualization2.prototype.addUiItem = function(index) {
      var curViewDs = this.listViewInstance.curViewDS;
      this.changeUiIndices(index, true);
      if (this.activeIndex && this.activeIndex >= index) {
        this.activeIndex++;
      }
      if (this.listViewInstance.showCheckBox && curViewDs[index][this.listViewInstance.fields.isChecked]) {
        this.uiIndices.activeIndices.push(index);
      }
      if (!parseFloat(this.bottomElement.style.height) && !parseFloat(this.topElement.style.height)) {
        this.bottomElement.style.height = parseFloat(this.bottomElement.style.height) + this.listItemHeight + "px";
      }
      if (parseFloat(this.bottomElement.style.height)) {
        var liItem = this.listViewInstance.curUL.lastElementChild.previousSibling;
        var target = this.listViewInstance.getLiFromObjOrElement(curViewDs[index + 1]) || this.listViewInstance.getLiFromObjOrElement(curViewDs[index + 2]);
        if (target) {
          this.bottomElement.style.height = parseFloat(this.bottomElement.style.height) + this.listItemHeight + "px";
          this.updateUI(liItem, index, target);
        }
      } else {
        var liItem = this.listViewInstance.curUL.firstElementChild.nextSibling;
        var target = void 0;
        if (Object.keys(this.listViewInstance.curViewDS).length - 1 === index) {
          target = this.listViewInstance.curUL.lastElementChild;
        } else {
          target = this.listViewInstance.getLiFromObjOrElement(curViewDs[index + 1]) || this.listViewInstance.getLiFromObjOrElement(curViewDs[index + 2]);
        }
        this.topElement.style.height = parseFloat(this.topElement.style.height) + this.listItemHeight + "px";
        this.uiFirstIndex++;
        this.uiLastIndex++;
        if (target) {
          this.updateUI(liItem, index, target);
          if (this.listViewInstance.isWindow === true) {
            window.scrollTo(0, pageYOffset + this.listItemHeight);
          } else {
            this.listViewInstance.element.scrollTop += this.listItemHeight;
          }
        }
      }
      this.totalHeight += this.listItemHeight;
      this.listDiff = Math.round(parseFloat(this.topElement.style.height) / this.listItemHeight);
    };
    Virtualization2.prototype.removeUiItem = function(index) {
      this.totalHeight -= this.listItemHeight;
      var curViewDS = this.listViewInstance.curViewDS[index];
      var liItem = this.listViewInstance.getLiFromObjOrElement(curViewDS);
      this.listViewInstance.curViewDS.splice(index, 1);
      if (this.activeIndex && this.activeIndex >= index) {
        this.activeIndex--;
      }
      if (liItem) {
        if (this.domItemCount > Object.keys(this.listViewInstance.curViewDS).length) {
          detach(liItem);
          this.domItemCount--;
          this.uiLastIndex--;
          this.totalHeight = 0;
        } else {
          if (liItem.classList.contains(classNames4.disable)) {
            liItem.classList.remove(classNames4.disable);
            this.uiIndices.disabledItemIndices.splice(this.uiIndices.disabledItemIndices.indexOf(index), 1);
          }
          if (liItem.style.display === "none") {
            liItem.style.display = "";
            this.uiIndices.hiddenItemIndices.splice(this.uiIndices.hiddenItemIndices.indexOf(index), 1);
          }
          if (this.listViewInstance.showCheckBox && liItem.classList.contains(classNames4.selected)) {
            this.listViewInstance.removeSelect();
            this.uiIndices.activeIndices.splice(this.uiIndices.activeIndices.indexOf(index), 1);
            var checklistElement = liItem.querySelector("." + classNames4.checkboxWrapper);
            checklistElement.removeAttribute("aria-checked");
            checklistElement.firstElementChild.classList.remove(classNames4.checked);
            if (liItem.classList.contains(classNames4.focused)) {
              liItem.classList.remove(classNames4.focused);
              this.activeIndex = void 0;
            }
          } else if (liItem.classList.contains(classNames4.selected)) {
            this.listViewInstance.removeSelect();
            this.activeIndex = void 0;
          }
          if (!parseFloat(this.bottomElement.style.height) && !parseFloat(this.topElement.style.height)) {
            this.updateUI(liItem, this.uiLastIndex, this.bottomElement);
          } else if (parseFloat(this.bottomElement.style.height)) {
            this.bottomElement.style.height = parseFloat(this.bottomElement.style.height) - this.listItemHeight + "px";
            this.updateUI(liItem, this.uiLastIndex, this.bottomElement);
          } else {
            this.topElement.style.height = parseFloat(this.topElement.style.height) - this.listItemHeight + "px";
            this.updateUI(liItem, this.uiFirstIndex - 1, this.topElement.nextSibling);
            this.uiLastIndex--;
            this.uiFirstIndex--;
          }
        }
      }
      this.changeUiIndices(index, false);
      this.listDiff = Math.round(parseFloat(this.topElement.style.height) / this.listItemHeight);
    };
    Virtualization2.prototype.changeUiIndices = function(index, increment) {
      var keys = Object.keys(this.uiIndices);
      for (var ind = 0; ind < keys.length; ind++) {
        this.uiIndices[keys[ind]] = this.uiIndices[keys[ind]].map(function(i) {
          if (i >= index) {
            return increment ? ++i : --i;
          } else {
            return i;
          }
        });
      }
    };
    Virtualization2.prototype.addItem = function(data, fields, dataSource, index) {
      for (var i = 0; i < data.length; i++) {
        var currentItem = data[i];
        dataSource = this.listViewInstance.addItemAtIndex(index, dataSource, currentItem);
        this.listViewInstance.setViewDataSource(dataSource);
        if (!this.domItemCount) {
          if ((this.listViewInstance.template || this.listViewInstance.groupTemplate) && !this.isNgTemplate()) {
            this.listViewInstance.listBaseOption.template = null;
            this.listViewInstance.listBaseOption.groupTemplate = null;
            this.listViewInstance.listBaseOption.itemCreated = this.createUIItem.bind(this);
          }
          this.uiVirtualization();
        } else if (this.domItemCount < this.expectedDomItemCount) {
          var ds = this.listViewInstance.findItemFromDS(dataSource, fields);
          if (ds instanceof Array) {
            if (this.listViewInstance.ulElement) {
              var index_1 = this.listViewInstance.curViewDS.indexOf(currentItem);
              this.createAndInjectNewItem(currentItem, index_1);
              var curViewDS = this.listViewInstance.curViewDS[index_1 - 1];
              if (curViewDS && curViewDS.isHeader && curViewDS.items.length === 1) {
                --index_1;
                this.createAndInjectNewItem(curViewDS, index_1);
              }
            }
            this.listViewInstance.liCollection = this.listViewInstance.curUL.querySelectorAll("li");
          }
        } else {
          var index_2 = this.listViewInstance.curViewDS.indexOf(currentItem);
          this.addUiItem(index_2);
          var curViewDS = this.listViewInstance.curViewDS[index_2 - 1];
          if (curViewDS && curViewDS.isHeader && curViewDS.items.length === 1) {
            this.addUiItem(index_2 - 1);
          }
        }
      }
    };
    Virtualization2.prototype.createAndInjectNewItem = function(itemData, index) {
      var target;
      var li = ListBase.createListItemFromJson(this.listViewInstance.createElement, [itemData], this.listViewInstance.listBaseOption, null, null, this.listViewInstance);
      if (Object.keys(this.listViewInstance.curViewDS).length - 1 === index) {
        target = this.listViewInstance.curUL.lastElementChild;
      } else {
        target = this.listViewInstance.getLiFromObjOrElement(this.listViewInstance.curViewDS[index + 1]) || this.listViewInstance.getLiFromObjOrElement(this.listViewInstance.curViewDS[index + 2]);
      }
      if (this.listViewInstance.fields.groupBy && this.listViewInstance.curViewDS[index + 1] && this.listViewInstance.curViewDS[index + 1].isHeader) {
        var targetEle = this.listViewInstance.getLiFromObjOrElement(this.listViewInstance.curViewDS[index - 1]);
        if (targetEle) {
          target = targetEle.nextElementSibling;
        }
      }
      this.listViewInstance.ulElement.insertBefore(li[0], target);
      this.domItemCount++;
      if (this.bottomElementHeight <= 0) {
        this.uiLastIndex++;
      }
      this.refreshItemHeight();
    };
    Virtualization2.prototype.createUIItem = function(args) {
      if (!args.item.classList.contains("e-list-group-item")) {
        this.templateData = args.curData.isHeader ? args.curData.items[0] : args.curData;
        if (this.listViewInstance.showCheckBox) {
          this.listViewInstance.renderCheckbox(args);
          if (!isNullOrUndefined(this.listViewInstance.virtualCheckBox) && !isNullOrUndefined(this.listViewInstance.virtualCheckBox.outerHTML)) {
            var div_1 = document.createElement("div");
            var commonTemplate = '<div class="e-text-content" role="presentation"> <span class="e-list-text"> ${' + this.listViewInstance.fields.text + "} </span></div>";
            var templateFunction = compile(this.listViewInstance.template || commonTemplate, this.listViewInstance);
            var nodes = templateFunction(this.templateData, this.listViewInstance);
            if (this.listViewInstance.template && this.listViewInstance.isReact) {
              this.listViewInstance.renderReactTemplates();
            }
            [].slice.call(nodes).forEach(function(ele) {
              div_1.appendChild(ele);
            });
            if (div_1.children && div_1.children[0]) {
              div_1.children[0].classList.add("e-checkbox");
              if (this.listViewInstance.checkBoxPosition === "Left") {
                div_1.children[0].classList.add("e-checkbox-left");
              } else {
                div_1.children[0].classList.add("e-checkbox-right");
              }
              if (this.listViewInstance.checkBoxPosition === "Left") {
                div_1.children[0].insertBefore(this.listViewInstance.virtualCheckBox, div_1.childNodes[0].children[0]);
              } else {
                div_1.children[0].appendChild(this.listViewInstance.virtualCheckBox);
              }
              while (args.item.lastChild) {
                args.item.removeChild(args.item.lastChild);
              }
              [].slice.call(div_1.children).forEach(function(ele) {
                args.item.appendChild(ele);
              });
            }
          }
        }
      }
    };
    Virtualization2.prototype.reRenderUiVirtualization = function() {
      this.wireScrollEvent(true);
      if (this.listViewInstance.contentContainer) {
        detach(this.listViewInstance.contentContainer);
      }
      this.listViewInstance.preRender();
      this.domItemCount = 0;
      this.listViewInstance.header();
      this.listViewInstance.setLocalData();
    };
    Virtualization2.prototype.updateUI = function(element2, index, targetElement2) {
      var onChange = this.isNgTemplate() ? this.onNgChange : this.onChange;
      if (this.listViewInstance.template || this.listViewInstance.groupTemplate) {
        var curViewDS = this.listViewInstance.curViewDS[index];
        element2.dataset.uid = curViewDS[this.listViewInstance.fields.id] ? curViewDS[this.listViewInstance.fields.id] : ListBase.generateId();
        onChange(curViewDS, element2, this);
      } else {
        this.updateUiContent(element2, index);
      }
      this.changeElementAttributes(element2, index);
      if (targetElement2) {
        this.listViewInstance.ulElement.insertBefore(element2, targetElement2);
      }
    };
    Virtualization2.prototype.onChange = function(newData, listElement, virtualThis) {
      var liItem = ListBase.createListItemFromJson(virtualThis.listViewInstance.createElement, [newData], virtualThis.listViewInstance.listBaseOption, null, null, virtualThis.listViewInstance);
      if (virtualThis.listViewInstance.isReact) {
        virtualThis.listViewInstance.renderReactTemplates();
      }
      while (listElement.lastChild) {
        listElement.removeChild(listElement.lastChild);
      }
      [].slice.call(liItem[0].children).forEach(function(ele) {
        listElement.appendChild(ele);
      });
    };
    Virtualization2.prototype.onNgChange = function(newData, listElement, virtualThis) {
      var templateCompiler = compile(virtualThis.listViewInstance.template);
      var resultElement = templateCompiler(newData);
      while (listElement.lastChild) {
        listElement.removeChild(listElement.lastChild);
      }
      listElement.appendChild(resultElement[0]);
    };
    Virtualization2.prototype.getModuleName = function() {
      return "virtualization";
    };
    Virtualization2.prototype.destroy = function() {
      this.wireScrollEvent(true);
      this.topElement = null;
      this.bottomElement = null;
    };
    return Virtualization2;
  }()
);

// node_modules/@syncfusion/ej2-lists/src/sortable/sortable.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sortable = (
  /** @class */
  function(_super) {
    __extends32(Sortable2, _super);
    function Sortable2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.getHelper = function(e) {
        var target = _this.getSortableElement(e.sender.target);
        if (!_this.isValidTarget(target, _this)) {
          return false;
        }
        var element3;
        if (_this.helper) {
          element3 = _this.helper({ sender: target, element: e.element });
        } else {
          element3 = target.cloneNode(true);
          element3.style.width = target.offsetWidth + "px";
          element3.style.height = target.offsetHeight + "px";
        }
        addClass([element3], ["e-sortableclone"]);
        document.body.appendChild(element3);
        return element3;
      };
      _this.onDrag = function(e) {
        if (!e.target) {
          return;
        }
        _this.trigger("drag", { event: e.event, element: _this.element, target: e.target });
        var newInst = _this.getSortableInstance(e.target);
        var target = _this.getSortableElement(e.target, newInst);
        if ((_this.isValidTarget(target, newInst) || e.target && typeof e.target.className === "string" && e.target.className.indexOf("e-list-group-item") > -1) && (_this.curTarget !== target || !isNullOrUndefined(newInst.placeHolder)) && (newInst.placeHolderElement ? newInst.placeHolderElement !== e.target : true)) {
          if (e.target.classList.contains("e-list-group-item")) {
            target = e.target;
          }
          _this.curTarget = target;
          if (_this.target === target) {
            return;
          }
          var oldIdx = _this.getIndex(newInst.placeHolderElement, newInst);
          var placeHolder = _this.getPlaceHolder(target, newInst);
          var newIdx = void 0;
          if (placeHolder) {
            oldIdx = isNullOrUndefined(oldIdx) ? _this.getIndex(_this.target) : oldIdx;
            newIdx = _this.getIndex(target, newInst, e.event);
            var isPlaceHolderPresent = _this.isPlaceHolderPresent(newInst);
            if (isPlaceHolderPresent && oldIdx === newIdx) {
              return;
            }
            if (isPlaceHolderPresent) {
              remove(newInst.placeHolderElement);
            }
            newInst.placeHolderElement = placeHolder;
            if (e.target && typeof e.target.className === "string" && e.target.className.indexOf("e-list-group-item") > -1) {
              newInst.element.insertBefore(newInst.placeHolderElement, newInst.element.children[newIdx]);
            } else if (newInst.element !== _this.element && newIdx === newInst.element.childElementCount) {
              newInst.element.appendChild(newInst.placeHolderElement);
            } else {
              newInst.element.insertBefore(newInst.placeHolderElement, newInst.element.children[newIdx]);
            }
            _this.refreshDisabled(oldIdx, newIdx, newInst);
          } else {
            oldIdx = isNullOrUndefined(oldIdx) ? _this.getIndex(_this.target) : _this.getIndex(target, newInst) < oldIdx || !oldIdx ? oldIdx : oldIdx - 1;
            newIdx = _this.getIndex(target, newInst);
            var idx = newInst.element !== _this.element ? newIdx : oldIdx < newIdx ? newIdx + 1 : newIdx;
            _this.updateItemClass(newInst);
            newInst.element.insertBefore(_this.target, newInst.element.children[idx]);
            _this.refreshDisabled(oldIdx, newIdx, newInst);
            _this.curTarget = _this.target;
            _this.trigger("drop", {
              droppedElement: _this.target,
              element: newInst.element,
              previousIndex: oldIdx,
              currentIndex: newIdx,
              target: e.target,
              helper: document.getElementsByClassName("e-sortableclone")[0],
              event: e.event,
              scope: _this.scope
            });
          }
        } else if (_this.curTarget !== _this.target && _this.scope && _this.curTarget !== target && !isNullOrUndefined(newInst.placeHolder)) {
          remove(_this.getSortableInstance(_this.curTarget).placeHolderElement);
          _this.curTarget = _this.target;
        }
        newInst = _this.getSortableInstance(_this.curTarget);
        if (isNullOrUndefined(target) && e.target !== newInst.placeHolderElement) {
          if (_this.isPlaceHolderPresent(newInst)) {
            _this.removePlaceHolder(newInst);
          }
        } else {
          var placeHolders = [].slice.call(document.getElementsByClassName("e-sortable-placeholder"));
          var inst_1;
          placeHolders.forEach(function(placeHolder2) {
            inst_1 = _this.getSortableInstance(placeHolder2);
            if (inst_1.element && inst_1 !== newInst) {
              _this.removePlaceHolder(inst_1);
            }
          });
        }
      };
      _this.onDragStart = function(e) {
        _this.target = _this.getSortableElement(e.target);
        var cancelDrag = false;
        _this.target.classList.add("e-grabbed");
        _this.curTarget = _this.target;
        e.helper = document.getElementsByClassName("e-sortableclone")[0];
        var args = { cancel: false, element: _this.element, target: _this.target };
        _this.trigger("beforeDragStart", args, function(observedArgs) {
          if (observedArgs.cancel) {
            cancelDrag = observedArgs.cancel;
            _this.onDragStop(e);
          }
        });
        if (cancelDrag) {
          return;
        }
        if (isBlazor) {
          _this.trigger("dragStart", {
            event: e.event,
            element: _this.element,
            target: _this.target,
            bindEvents: e.bindEvents,
            dragElement: e.dragElement
          });
        } else {
          _this.trigger("dragStart", { event: e.event, element: _this.element, target: _this.target });
        }
      };
      _this.onDragStop = function(e) {
        var dropInst = _this.getSortableInstance(_this.curTarget);
        var curIdx;
        var prevIdx;
        var handled;
        prevIdx = _this.getIndex(_this.target);
        var isPlaceHolderPresent = _this.isPlaceHolderPresent(dropInst);
        if (isPlaceHolderPresent) {
          var curIdx_1 = _this.getIndex(dropInst.placeHolderElement, dropInst);
          var args = {
            previousIndex: prevIdx,
            currentIndex: curIdx_1,
            target: e.target,
            droppedElement: _this.target,
            helper: e.helper,
            cancel: false,
            handled: false
          };
          _this.trigger("beforeDrop", args, function(observedArgs) {
            if (!observedArgs.cancel) {
              handled = observedArgs.handled;
              _this.updateItemClass(dropInst);
              if (observedArgs.handled) {
                var ele = _this.target.cloneNode(true);
                _this.target.classList.remove("e-grabbed");
                _this.target = ele;
              }
              dropInst.element.insertBefore(_this.target, dropInst.placeHolderElement);
              var curIdx_2 = _this.getIndex(_this.target, dropInst);
              prevIdx = _this === dropInst && prevIdx - curIdx_2 > 1 ? prevIdx - 1 : prevIdx;
              _this.trigger("drop", {
                event: e.event,
                element: dropInst.element,
                previousIndex: prevIdx,
                currentIndex: curIdx_2,
                target: e.target,
                helper: e.helper,
                droppedElement: _this.target,
                scopeName: _this.scope,
                handled
              });
            }
            remove(dropInst.placeHolderElement);
          });
        }
        dropInst = _this.getSortableInstance(e.target);
        curIdx = dropInst.element.childElementCount;
        prevIdx = _this.getIndex(_this.target);
        if (dropInst.element.querySelector(".e-list-nrt")) {
          curIdx = curIdx - 1;
        }
        if (_this.curTarget === _this.target && e.target === _this.curTarget) {
          curIdx = prevIdx;
        }
        if (dropInst.element === e.target || !isPlaceHolderPresent && _this.curTarget === _this.target) {
          var beforeDropArgs = {
            previousIndex: prevIdx,
            currentIndex: curIdx,
            target: e.target,
            droppedElement: _this.target,
            helper: e.helper,
            cancel: false
          };
          _this.trigger("beforeDrop", beforeDropArgs, function(observedArgs) {
            if ((dropInst.element === e.target || typeof e.target.className === "string" && e.target.className.indexOf("e-list-nrt") > -1 || typeof e.target.className === "string" && e.target.className.indexOf("e-list-nr-template") > -1 || e.target.closest(".e-list-nr-template")) && !observedArgs.cancel) {
              _this.updateItemClass(dropInst);
              dropInst.element.appendChild(_this.target);
              _this.trigger("drop", {
                event: e.event,
                element: dropInst.element,
                previousIndex: prevIdx,
                currentIndex: curIdx,
                target: e.target,
                helper: e.helper,
                droppedElement: _this.target,
                scopeName: _this.scope
              });
            }
          });
        }
        _this.target.classList.remove("e-grabbed");
        _this.target = null;
        _this.curTarget = null;
        remove(e.helper);
        getComponent(_this.element, "draggable").intDestroy(e.event);
      };
      _this.bind();
      return _this;
    }
    Sortable_1 = Sortable2;
    Sortable2.prototype.bind = function() {
      if (!this.element.id) {
        this.element.id = getUniqueID("sortable");
      }
      if (!this.itemClass) {
        this.itemClass = "e-sort-item";
        this.dataBind();
      }
      this.initializeDraggable();
    };
    Sortable2.prototype.initializeDraggable = function() {
      new Draggable(this.element, {
        helper: this.getHelper,
        dragStart: this.onDragStart,
        drag: this.onDrag,
        dragStop: this.onDragStop,
        dragTarget: "." + this.itemClass,
        enableTapHold: true,
        tapHoldThreshold: 200,
        queryPositionInfo: this.queryPositionInfo,
        distance: 1
      });
      this.wireEvents();
    };
    Sortable2.prototype.wireEvents = function() {
      var wrapper = this.element;
      EventHandler.add(wrapper, "keydown", this.keyDownHandler, this);
    };
    Sortable2.prototype.unwireEvents = function() {
      var wrapper = this.element;
      EventHandler.remove(wrapper, "keydown", this.keyDownHandler);
    };
    Sortable2.prototype.keyDownHandler = function(e) {
      if (e.keyCode === 27) {
        var dragStop = getComponent(this.element, "draggable");
        if (dragStop) {
          dragStop.intDestroy(null);
        }
        var dragWrapper = document.getElementsByClassName("e-sortableclone")[0];
        if (dragWrapper) {
          dragWrapper.remove();
        }
        var dragPlaceholder = document.getElementsByClassName("e-sortable-placeholder")[0];
        if (dragPlaceholder) {
          dragPlaceholder.remove();
        }
      }
    };
    Sortable2.prototype.getPlaceHolder = function(target, instance) {
      if (instance.placeHolder) {
        var placeHolderElement = instance.placeHolder({ element: instance.element, grabbedElement: this.target, target });
        placeHolderElement.classList.add("e-sortable-placeholder");
        return placeHolderElement;
      }
      return null;
    };
    Sortable2.prototype.isValidTarget = function(target, instance) {
      return target && compareElementParent(target, instance.element) && target.classList.contains(instance.itemClass) && !target.classList.contains("e-disabled");
    };
    Sortable2.prototype.removePlaceHolder = function(instance) {
      remove(instance.placeHolderElement);
      instance.placeHolderElement = null;
    };
    Sortable2.prototype.updateItemClass = function(instance) {
      if (this !== instance) {
        this.target.classList.remove(this.itemClass);
        this.target.classList.add(instance.itemClass);
      }
    };
    Sortable2.prototype.getSortableInstance = function(element2) {
      element2 = closest(element2, ".e-" + this.getModuleName());
      if (element2) {
        var inst = getComponent(element2, Sortable_1);
        return inst.scope && this.scope && inst.scope === this.scope ? inst : this;
      } else {
        return this;
      }
    };
    Sortable2.prototype.refreshDisabled = function(oldIdx, newIdx, instance) {
      if (instance === this) {
        var element2 = void 0;
        var increased = oldIdx < newIdx;
        var disabledIdx = void 0;
        var start = increased ? oldIdx : newIdx;
        var end = increased ? newIdx : oldIdx;
        while (start <= end) {
          element2 = this.element.children[start];
          if (element2.classList.contains("e-disabled")) {
            disabledIdx = this.getIndex(element2);
            this.element.insertBefore(element2, this.element.children[increased ? disabledIdx + 2 : disabledIdx - 1]);
            start = increased ? disabledIdx + 2 : disabledIdx + 1;
          } else {
            start++;
          }
        }
      }
    };
    Sortable2.prototype.getIndex = function(target, instance, e) {
      if (instance === void 0) {
        instance = this;
      }
      var idx;
      var placeHolderPresent;
      [].slice.call(instance.element.children).forEach(function(element2, index) {
        if (element2.classList.contains("e-sortable-placeholder")) {
          placeHolderPresent = true;
        }
        if (element2 === target) {
          idx = index;
          if (!isNullOrUndefined(e)) {
            if (placeHolderPresent) {
              idx -= 1;
            }
            var offset = target.getBoundingClientRect();
            var clientY = offset.bottom - (offset.bottom - offset.top) / 2;
            var cltY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            idx = cltY <= clientY ? idx : idx + 1;
          }
          return;
        }
      });
      return idx;
    };
    Sortable2.prototype.getSortableElement = function(element2, instance) {
      if (instance === void 0) {
        instance = this;
      }
      return closest(element2, "." + instance.itemClass);
    };
    Sortable2.prototype.queryPositionInfo = function(value) {
      value.left = pageXOffset ? parseFloat(value.left) - pageXOffset + "px" : value.left;
      value.top = pageYOffset ? parseFloat(value.top) - pageYOffset + "px" : value.top;
      return value;
    };
    Sortable2.prototype.isPlaceHolderPresent = function(instance) {
      return instance.placeHolderElement && !!closest(instance.placeHolderElement, "#" + instance.element.id);
    };
    Sortable2.prototype.moveTo = function(destination, targetIndexes, insertBefore) {
      moveTo(this.element, destination, targetIndexes, insertBefore);
    };
    Sortable2.prototype.destroy = function() {
      this.unwireEvents();
      if (this.itemClass === "e-sort-item") {
        this.itemClass = null;
        this.dataBind();
      }
      getComponent(this.element, Draggable).destroy();
      _super.prototype.destroy.call(this);
    };
    Sortable2.prototype.getModuleName = function() {
      return "sortable";
    };
    Sortable2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "itemClass":
            [].slice.call(this.element.children).forEach(function(element2) {
              if (element2.classList.contains(oldProp.itemClass)) {
                element2.classList.remove(oldProp.itemClass);
              }
              if (newProp.itemClass) {
                element2.classList.add(newProp.itemClass);
              }
            });
            break;
        }
      }
    };
    var Sortable_1;
    __decorate31([
      Property(false)
    ], Sortable2.prototype, "enableAnimation", void 0);
    __decorate31([
      Property(null)
    ], Sortable2.prototype, "itemClass", void 0);
    __decorate31([
      Property(null)
    ], Sortable2.prototype, "scope", void 0);
    __decorate31([
      Property()
    ], Sortable2.prototype, "helper", void 0);
    __decorate31([
      Property()
    ], Sortable2.prototype, "placeHolder", void 0);
    __decorate31([
      Event()
    ], Sortable2.prototype, "drag", void 0);
    __decorate31([
      Event()
    ], Sortable2.prototype, "beforeDragStart", void 0);
    __decorate31([
      Event()
    ], Sortable2.prototype, "dragStart", void 0);
    __decorate31([
      Event()
    ], Sortable2.prototype, "beforeDrop", void 0);
    __decorate31([
      Event()
    ], Sortable2.prototype, "drop", void 0);
    Sortable2 = Sortable_1 = __decorate31([
      NotifyPropertyChanges
    ], Sortable2);
    return Sortable2;
  }(Base)
);
function moveTo(from, to, targetIndexes, insertBefore) {
  var targetElements = [];
  if (!to) {
    to = from;
  }
  if (targetIndexes && targetIndexes.length) {
    targetIndexes.forEach(function(index) {
      targetElements.push(from.children[index]);
    });
  } else {
    targetElements = [].slice.call(from.children);
  }
  if (isNullOrUndefined(insertBefore)) {
    targetElements.forEach(function(target) {
      to.appendChild(target);
    });
  } else {
    var insertElement_1 = to.children[insertBefore];
    targetElements.forEach(function(target) {
      to.insertBefore(target, insertElement_1);
    });
  }
}

// node_modules/@syncfusion/ej2-navigations/src/common/menu-base.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ENTER = "enter";
var ESCAPE = "escape";
var FOCUSED = "e-focused";
var HEADER = "e-menu-header";
var SELECTED2 = "e-selected";
var SEPARATOR = "e-separator";
var UPARROW = "uparrow";
var DOWNARROW = "downarrow";
var LEFTARROW = "leftarrow";
var RIGHTARROW = "rightarrow";
var HOME = "home";
var END = "end";
var TAB = "tab";
var CARET = "e-caret";
var ITEM = "e-menu-item";
var DISABLED7 = "e-disabled";
var HIDE = "e-menu-hide";
var ICONS = "e-icons";
var RTL11 = "e-rtl";
var POPUP = "e-menu-popup";
var TEMPLATE_PROPERTY = "Template";
var FieldSettings2 = (
  /** @class */
  function(_super) {
    __extends33(FieldSettings3, _super);
    function FieldSettings3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate32([
      Property("id")
    ], FieldSettings3.prototype, "itemId", void 0);
    __decorate32([
      Property("parentId")
    ], FieldSettings3.prototype, "parentId", void 0);
    __decorate32([
      Property("text")
    ], FieldSettings3.prototype, "text", void 0);
    __decorate32([
      Property("iconCss")
    ], FieldSettings3.prototype, "iconCss", void 0);
    __decorate32([
      Property("url")
    ], FieldSettings3.prototype, "url", void 0);
    __decorate32([
      Property("separator")
    ], FieldSettings3.prototype, "separator", void 0);
    __decorate32([
      Property("items")
    ], FieldSettings3.prototype, "children", void 0);
    return FieldSettings3;
  }(ChildProperty)
);
var MenuItem = (
  /** @class */
  function(_super) {
    __extends33(MenuItem2, _super);
    function MenuItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate32([
      Property(null)
    ], MenuItem2.prototype, "iconCss", void 0);
    __decorate32([
      Property("")
    ], MenuItem2.prototype, "id", void 0);
    __decorate32([
      Property(false)
    ], MenuItem2.prototype, "separator", void 0);
    __decorate32([
      Collection([], MenuItem2)
    ], MenuItem2.prototype, "items", void 0);
    __decorate32([
      Property("")
    ], MenuItem2.prototype, "text", void 0);
    __decorate32([
      Property("")
    ], MenuItem2.prototype, "url", void 0);
    return MenuItem2;
  }(ChildProperty)
);
var MenuAnimationSettings = (
  /** @class */
  function(_super) {
    __extends33(MenuAnimationSettings2, _super);
    function MenuAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate32([
      Property("SlideDown")
    ], MenuAnimationSettings2.prototype, "effect", void 0);
    __decorate32([
      Property(400)
    ], MenuAnimationSettings2.prototype, "duration", void 0);
    __decorate32([
      Property("ease")
    ], MenuAnimationSettings2.prototype, "easing", void 0);
    return MenuAnimationSettings2;
  }(ChildProperty)
);
var MenuBase = (
  /** @class */
  function(_super) {
    __extends33(MenuBase2, _super);
    function MenuBase2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.navIdx = [];
      _this.animation = new Animation({});
      _this.isTapHold = false;
      _this.tempItem = [];
      _this.showSubMenuOn = "Auto";
      return _this;
    }
    MenuBase2.prototype.preRender = function() {
      if (!this.isMenu) {
        var ul = void 0;
        if (this.element.tagName === "EJS-CONTEXTMENU") {
          ul = this.createElement("ul", {
            id: getUniqueID(this.getModuleName()),
            className: "e-control e-lib e-" + this.getModuleName()
          });
          var ejInst = getValue("ej2_instances", this.element);
          removeClass([this.element], ["e-control", "e-lib", "e-" + this.getModuleName()]);
          this.clonedElement = this.element;
          this.element = ul;
          setValue("ej2_instances", ejInst, this.element);
        } else {
          ul = this.createElement("ul", { id: getUniqueID(this.getModuleName()) });
          append([].slice.call(this.element.cloneNode(true).children), ul);
          var refEle = this.element.nextElementSibling;
          if (refEle) {
            this.element.parentElement.insertBefore(ul, refEle);
          } else {
            this.element.parentElement.appendChild(ul);
          }
          this.clonedElement = ul;
        }
        this.clonedElement.style.display = "none";
      }
      if (this.element.tagName === "EJS-MENU") {
        var ele = this.element;
        var ejInstance = getValue("ej2_instances", ele);
        var ul = this.createElement("ul");
        var wrapper = this.createElement("EJS-MENU", { className: "e-" + this.getModuleName() + "-wrapper" });
        for (var idx = 0, len = ele.attributes.length; idx < len; idx++) {
          ul.setAttribute(ele.attributes[idx].nodeName, ele.attributes[idx].nodeValue);
        }
        ele.parentNode.insertBefore(wrapper, ele);
        detach(ele);
        ele = ul;
        wrapper.appendChild(ele);
        setValue("ej2_instances", ejInstance, ele);
        this.clonedElement = wrapper;
        this.element = ele;
        if (!this.element.id) {
          this.element.id = getUniqueID(this.getModuleName());
        }
      }
    };
    MenuBase2.prototype.render = function() {
      var _this = this;
      this.initialize();
      this.renderItems();
      this.wireEvents();
      this.renderComplete();
      var wrapper = this.getWrapper();
      if (this.template && this.enableScrolling && (this.isReact || this.isAngular)) {
        requestAnimationFrame(function() {
          addScrolling(_this.createElement, wrapper, _this.element, "hscroll", _this.enableRtl);
        });
      }
    };
    MenuBase2.prototype.initialize = function() {
      var wrapper = this.getWrapper();
      if (!wrapper) {
        wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-wrapper" });
        if (this.isMenu) {
          this.element.parentElement.insertBefore(wrapper, this.element);
        } else {
          document.body.appendChild(wrapper);
        }
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.enableRtl) {
        wrapper.classList.add(RTL11);
      }
      wrapper.appendChild(this.element);
      if (this.isMenu && this.hamburgerMode) {
        if (!this.target) {
          this.createHeaderContainer(wrapper);
        }
      }
      this.defaultOption = this.showItemOnClick;
    };
    MenuBase2.prototype.renderItems = function() {
      if (!this.items.length) {
        var items = ListBase.createJsonFromElement(this.element, { fields: { child: "items" } });
        this.setProperties({ items }, true);
        if (isBlazor() && !this.isMenu) {
          this.element = this.removeChildElement(this.element);
        } else {
          this.element.innerHTML = "";
        }
      }
      var ul = this.createItems(this.items);
      append(Array.prototype.slice.call(ul.children), this.element);
      this.element.classList.add("e-menu-parent");
      if (this.isMenu) {
        if (!this.hamburgerMode && this.element.classList.contains("e-vertical")) {
          this.setBlankIconStyle(this.element);
        }
        if (this.enableScrolling) {
          var wrapper = this.getWrapper();
          if (this.element.classList.contains("e-vertical")) {
            addScrolling(this.createElement, wrapper, this.element, "vscroll", this.enableRtl);
          } else {
            addScrolling(this.createElement, wrapper, this.element, "hscroll", this.enableRtl);
          }
        }
      } else {
        this.element.parentElement.setAttribute("role", "dialog");
        this.element.parentElement.setAttribute("aria-label", "context menu");
      }
    };
    MenuBase2.prototype.wireEvents = function() {
      var wrapper = this.getWrapper();
      if (this.target) {
        var target = void 0;
        var targetElems = selectAll(this.target);
        for (var i = 0, len = targetElems.length; i < len; i++) {
          target = targetElems[i];
          if (this.isMenu) {
            EventHandler.add(target, "click", this.menuHeaderClickHandler, this);
          } else {
            if (Browser.isIos) {
              new Touch(target, { tapHold: this.touchHandler.bind(this) });
            } else {
              EventHandler.add(target, "contextmenu", this.cmenuHandler, this);
            }
          }
        }
        this.targetElement = target;
        if (!this.isMenu) {
          EventHandler.add(this.targetElement, "scroll", this.scrollHandler, this);
          for (var _i = 0, _a = getScrollableParent(this.targetElement); _i < _a.length; _i++) {
            var parent_1 = _a[_i];
            EventHandler.add(parent_1, "scroll", this.scrollHandler, this);
          }
        }
      }
      if (!Browser.isDevice) {
        this.delegateMoverHandler = this.moverHandler.bind(this);
        this.delegateMouseDownHandler = this.mouseDownHandler.bind(this);
        EventHandler.add(this.isMenu ? document : wrapper, "mouseover", this.delegateMoverHandler, this);
        EventHandler.add(document, "mousedown", this.delegateMouseDownHandler, this);
      }
      this.delegateClickHandler = this.clickHandler.bind(this);
      EventHandler.add(document, "click", this.delegateClickHandler, this);
      this.wireKeyboardEvent(wrapper);
      this.rippleFn = rippleEffect(wrapper, { selector: "." + ITEM });
    };
    MenuBase2.prototype.wireKeyboardEvent = function(element2) {
      var keyConfigs = {
        downarrow: DOWNARROW,
        uparrow: UPARROW,
        enter: ENTER,
        leftarrow: LEFTARROW,
        rightarrow: RIGHTARROW,
        escape: ESCAPE
      };
      if (this.isMenu) {
        keyConfigs.home = HOME;
        keyConfigs.end = END;
        keyConfigs.tab = TAB;
      }
      new KeyboardEvents(element2, {
        keyAction: this.keyBoardHandler.bind(this),
        keyConfigs
      });
    };
    MenuBase2.prototype.mouseDownHandler = function(e) {
      if (closest(e.target, ".e-" + this.getModuleName() + "-wrapper") !== this.getWrapper() && !closest(e.target, ".e-" + this.getModuleName() + "-popup")) {
        this.closeMenu(this.isMenu ? null : this.navIdx.length, e);
      }
    };
    MenuBase2.prototype.keyHandler = function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        if (e.target && (e.target.classList.contains("e-contextmenu") || e.target.classList.contains("e-menu-item"))) {
          e.preventDefault();
        }
      }
    };
    MenuBase2.prototype.keyBoardHandler = function(e) {
      var actionName = "";
      var trgt = e.target;
      var actionNeeded = this.isMenu && !this.hamburgerMode && !this.element.classList.contains("e-vertical") && this.navIdx.length < 1;
      e.preventDefault();
      if (this.enableScrolling && e.keyCode === 13 && trgt.classList.contains("e-scroll-nav")) {
        this.removeLIStateByClass([FOCUSED, SELECTED2], [closest(trgt, ".e-" + this.getModuleName() + "-wrapper")]);
      }
      if (actionNeeded) {
        switch (e.action) {
          case RIGHTARROW:
            actionName = RIGHTARROW;
            e.action = DOWNARROW;
            break;
          case LEFTARROW:
            actionName = LEFTARROW;
            e.action = UPARROW;
            break;
          case DOWNARROW:
            actionName = DOWNARROW;
            e.action = RIGHTARROW;
            break;
          case UPARROW:
            actionName = UPARROW;
            e.action = "";
            break;
        }
      } else if (this.enableRtl) {
        switch (e.action) {
          case LEFTARROW:
            actionNeeded = true;
            actionName = LEFTARROW;
            e.action = RIGHTARROW;
            break;
          case RIGHTARROW:
            actionNeeded = true;
            actionName = RIGHTARROW;
            e.action = LEFTARROW;
            break;
        }
      }
      switch (e.action) {
        case DOWNARROW:
        case UPARROW:
        case END:
        case HOME:
        case TAB:
          this.upDownKeyHandler(e);
          break;
        case RIGHTARROW:
          this.rightEnterKeyHandler(e);
          break;
        case LEFTARROW:
          this.leftEscKeyHandler(e);
          break;
        case ENTER:
          if (this.hamburgerMode && trgt.tagName === "SPAN" && trgt.classList.contains("e-menu-icon")) {
            this.menuHeaderClickHandler(e);
          } else {
            this.rightEnterKeyHandler(e);
          }
          break;
        case ESCAPE:
          this.leftEscKeyHandler(e);
          break;
      }
      if (actionNeeded) {
        e.action = actionName;
      }
    };
    MenuBase2.prototype.upDownKeyHandler = function(e) {
      var cul = this.getUlByNavIdx();
      var defaultIdx = e.action === DOWNARROW || e.action === HOME || e.action === TAB ? 0 : cul.childElementCount - 1;
      var fliIdx = defaultIdx;
      var fli = this.getLIByClass(cul, FOCUSED);
      if (fli) {
        if (e.action !== END && e.action !== HOME) {
          fliIdx = this.getIdx(cul, fli);
        }
        fli.classList.remove(FOCUSED);
        if (e.action !== END && e.action !== HOME) {
          if (e.action === DOWNARROW) {
            fliIdx++;
          } else {
            fliIdx--;
          }
          if (fliIdx === (e.action === DOWNARROW ? cul.childElementCount : -1)) {
            fliIdx = defaultIdx;
          }
        }
      }
      var cli = cul.children[fliIdx];
      fliIdx = this.isValidLI(cli, fliIdx, e.action);
      cul.children[fliIdx].classList.add(FOCUSED);
      cul.children[fliIdx].focus();
    };
    MenuBase2.prototype.isValidLI = function(cli, index, action) {
      var cul = this.getUlByNavIdx();
      var defaultIdx = action === DOWNARROW || action === HOME || action === TAB ? 0 : cul.childElementCount - 1;
      if (cli.classList.contains(SEPARATOR) || cli.classList.contains(DISABLED7) || cli.classList.contains(HIDE)) {
        if (action === DOWNARROW && index === cul.childElementCount - 1) {
          index = defaultIdx;
        } else if (action === UPARROW && index === 0) {
          index = defaultIdx;
        } else if (action === DOWNARROW || action === RIGHTARROW) {
          index++;
        } else if (action === "tab" && cli.classList.contains(SEPARATOR)) {
          index++;
        } else {
          index--;
        }
      }
      cli = cul.children[index];
      if (cli && (cli.classList.contains(SEPARATOR) || cli.classList.contains(DISABLED7) || cli.classList.contains(HIDE))) {
        index = this.isValidLI(cli, index, action);
      }
      return index;
    };
    MenuBase2.prototype.getUlByNavIdx = function(navIdxLen) {
      var _this = this;
      if (navIdxLen === void 0) {
        navIdxLen = this.navIdx.length;
      }
      if (this.isMenu) {
        var popup = [this.getWrapper()].concat([].slice.call(selectAll("." + POPUP)))[navIdxLen];
        var popups_1 = [];
        var allPopup = selectAll("." + POPUP);
        allPopup.forEach(function(elem) {
          if (_this.element.id === elem.id.split("-")[2] || elem.id.split("-")[2] + "-" + elem.id.split("-")[3]) {
            popups_1.push(elem);
          }
        });
        popup = [this.getWrapper()].concat([].slice.call(popups_1))[navIdxLen];
        return isNullOrUndefined(popup) ? null : select(".e-menu-parent", popup);
      } else {
        if (!document.body.contains(this.element) && navIdxLen === 0) {
          return null;
        }
        return this.getWrapper().children[navIdxLen];
      }
    };
    MenuBase2.prototype.rightEnterKeyHandler = function(e) {
      var eventArgs;
      var cul = this.getUlByNavIdx();
      var fli = this.getLIByClass(cul, FOCUSED);
      if (fli) {
        var fliIdx = this.getIdx(cul, fli);
        var navIdx = this.navIdx.concat(fliIdx);
        var item = this.getItem(navIdx);
        if (item.items.length) {
          this.navIdx.push(fliIdx);
          this.keyType = "right";
          this.action = e.action;
          this.openMenu(fli, item, -1, -1, e);
        } else {
          if (e.action === ENTER) {
            if (this.isMenu && this.navIdx.length === 0) {
              this.removeLIStateByClass([SELECTED2], [this.getWrapper()]);
            } else {
              fli.classList.remove(FOCUSED);
            }
            fli.classList.add(SELECTED2);
            eventArgs = { element: fli, item, event: e };
            this.trigger("select", eventArgs);
            var aEle = fli.querySelector(".e-menu-url");
            if (item.url && aEle) {
              switch (aEle.getAttribute("target")) {
                case "_blank":
                  window.open(item.url, "_blank");
                  break;
                case "_parent":
                  window.parent.location.href = item.url;
                  break;
                default:
                  window.location.href = item.url;
              }
            }
            this.closeMenu(null, e);
            var sli = this.getLIByClass(this.getUlByNavIdx(), SELECTED2);
            if (sli) {
              sli.classList.add(FOCUSED);
              sli.focus();
            }
          }
        }
      }
    };
    MenuBase2.prototype.leftEscKeyHandler = function(e) {
      if (this.navIdx.length) {
        this.keyType = "left";
        this.closeMenu(this.navIdx.length, e);
      } else {
        if (e.action === ESCAPE) {
          this.closeMenu(null, e);
        }
      }
    };
    MenuBase2.prototype.scrollHandler = function(e) {
      this.closeMenu(null, e);
    };
    MenuBase2.prototype.touchHandler = function(e) {
      this.isTapHold = true;
      this.cmenuHandler(e.originalEvent);
    };
    MenuBase2.prototype.cmenuHandler = function(e) {
      e.preventDefault();
      this.currentTarget = e.target;
      this.isCMenu = true;
      this.pageX = e.changedTouches ? e.changedTouches[0].pageX + 1 : e.pageX + 1;
      this.pageY = e.changedTouches ? e.changedTouches[0].pageY + 1 : e.pageY + 1;
      this.closeMenu(null, e);
      if (this.isCMenu) {
        if (this.canOpen(e.target)) {
          this.openMenu(null, null, this.pageY, this.pageX, e);
        }
        this.isCMenu = false;
      }
    };
    MenuBase2.prototype.closeMenu = function(ulIndex, e, isIterated) {
      var _this = this;
      if (ulIndex === void 0) {
        ulIndex = 0;
      }
      if (e === void 0) {
        e = null;
      }
      if (this.isMenuVisible()) {
        var sli = void 0;
        var item_1;
        var wrapper_1 = this.getWrapper();
        var beforeCloseArgs = void 0;
        var items_1;
        var popups = this.getPopups();
        var isClose = false;
        var cnt = this.isMenu ? popups.length + 1 : wrapper_1.childElementCount;
        var ul_1 = this.isMenu && cnt !== 1 ? select(".e-ul", popups[cnt - 2]) : selectAll(".e-menu-parent", wrapper_1)[cnt - 1];
        if (this.isMenu && ul_1.classList.contains("e-menu")) {
          sli = this.getLIByClass(ul_1, SELECTED2);
          if (sli) {
            sli.classList.remove(SELECTED2);
          }
          isClose = true;
        }
        if (!isClose) {
          var liElem_1 = e && e.target && this.getLI(e.target);
          if (liElem_1) {
            this.cli = liElem_1;
          } else {
            this.cli = ul_1.children[0];
          }
          item_1 = this.navIdx.length ? this.getItem(this.navIdx) : null;
          items_1 = item_1 ? item_1.items : this.items;
          beforeCloseArgs = { element: ul_1, parentItem: item_1, items: items_1, event: e, cancel: false, isFocused: true };
          this.trigger("beforeClose", beforeCloseArgs, function(observedCloseArgs) {
            var popupEle;
            var closeArgs;
            var popupId = "";
            var popupObj;
            var isOpen = !observedCloseArgs.cancel;
            if (isOpen || _this.isCMenu) {
              if (_this.isMenu) {
                popupEle = closest(ul_1, "." + POPUP);
                if (_this.hamburgerMode) {
                  popupEle.parentElement.style.minHeight = "";
                  closest(ul_1, ".e-menu-item").setAttribute("aria-expanded", "false");
                }
                _this.unWireKeyboardEvent(popupEle);
                destroyScroll(getInstance(popupEle.children[0], VScroll), popupEle.children[0]);
                popupObj = getInstance(popupEle, Popup);
                popupObj.hide();
                popupId = popupEle.id;
                popupObj.destroy();
                detach(popupEle);
              } else {
                _this.toggleAnimation(ul_1, false);
              }
              closeArgs = { element: ul_1, parentItem: item_1, items: items_1 };
              _this.trigger("onClose", closeArgs);
              _this.navIdx.pop();
              if (_this.navIdx.length === 0 && e && e.type === "keyup") {
                _this.showSubMenu = false;
              }
              if (!_this.isMenu) {
                EventHandler.remove(ul_1, "keydown", _this.keyHandler);
                if (_this.keyType === "right") {
                  _this.keyType = "";
                }
              }
            }
            _this.updateReactTemplate();
            var trgtliId;
            var closedLi;
            var trgtLi;
            var trgtpopUp = _this.getWrapper() && _this.getUlByNavIdx();
            if (_this.isCMenu) {
              if (_this.canOpen(e.target)) {
                _this.openMenu(null, null, _this.pageY, _this.pageX, e);
              }
              _this.isCMenu = false;
            }
            if (_this.isMenu && trgtpopUp && popupId.length) {
              var regExp = RegExp;
              trgtliId = new regExp("(.*)-ej2menu-" + _this.element.id + "-popup").exec(popupId)[1];
              closedLi = trgtpopUp.querySelector('[id="' + trgtliId + '"]');
              trgtLi = liElem_1 && trgtpopUp.querySelector('[id="' + liElem_1.id + '"]');
            } else if (trgtpopUp) {
              closedLi = trgtpopUp.querySelector(".e-menu-item.e-selected");
              trgtLi = liElem_1 && trgtpopUp.querySelector('[id="' + liElem_1.id + '"]');
            }
            var submenus = liElem_1 && liElem_1.querySelectorAll(".e-menu-item");
            if (isOpen && _this.hamburgerMode && ulIndex && !submenus.length) {
              _this.afterCloseMenu(e);
            } else if (isOpen && !_this.hamburgerMode && closedLi && !trgtLi && _this.keyType !== "left" && (_this.navIdx.length || !_this.isMenu && _this.navIdx.length === 0)) {
              var ele = e && (e.target.classList.contains("e-vscroll") || e.target.classList.contains("e-scroll-nav")) ? closest(e.target, ".e-menu-wrapper") : null;
              if (ele) {
                ele = ele.querySelector(".e-menu-item");
                if (_this.showItemOnClick || ele && _this.getIndex(ele.id, true).length <= _this.navIdx.length) {
                  _this.closeMenu(_this.navIdx[_this.navIdx.length - 1], e, true);
                }
              } else {
                if (!(e && e.target.classList.contains("e-nav-arrow"))) {
                  _this.closeMenu(_this.navIdx[_this.navIdx.length - 1], e);
                }
              }
            } else if (isOpen && !isIterated && !ulIndex && (_this.hamburgerMode && _this.navIdx.length || _this.navIdx.length === 1 && liElem_1 && trgtpopUp !== liElem_1.parentElement)) {
              _this.closeMenu(null, e);
            } else if (isOpen && isNullOrUndefined(ulIndex) && _this.navIdx.length) {
              _this.closeMenu(null, e);
            } else if (isOpen && !_this.isMenu && !ulIndex && _this.navIdx.length === 0 && !_this.isMenusClosed && !_this.isCmenuHover) {
              _this.isMenusClosed = true;
              _this.closeMenu(0, e);
            } else if (isOpen && _this.isMenu && e && e.target && _this.navIdx.length !== 0 && closest(e.target, ".e-menu-parent.e-control")) {
              _this.closeMenu(0, e);
            } else if (isOpen && !_this.isMenu && selectAll(".e-menu-parent", wrapper_1)[ulIndex - 1] && e.which === 3) {
              _this.closeMenu(null, e);
            } else {
              if (isOpen && (_this.keyType === "right" || _this.keyType === "click")) {
                _this.afterCloseMenu(e);
              } else {
                var cul = _this.getUlByNavIdx();
                var sli_1 = _this.getLIByClass(cul, SELECTED2);
                if (sli_1) {
                  sli_1.setAttribute("aria-expanded", "false");
                  sli_1.classList.remove(SELECTED2);
                  if (observedCloseArgs.isFocused && liElem_1 || _this.keyType === "left") {
                    sli_1.classList.add(FOCUSED);
                    if (!e.target || !e.target.classList.contains("e-edit-template")) {
                      sli_1.focus();
                    }
                  }
                }
                if (!isOpen && _this.hamburgerMode && liElem_1 && liElem_1.getAttribute("aria-expanded") === "false" && liElem_1.getAttribute("aria-haspopup") === "true") {
                  if (closest(liElem_1, ".e-menu-parent.e-control")) {
                    _this.navIdx = [];
                  } else {
                    _this.navIdx.pop();
                  }
                  _this.navIdx.push(_this.cliIdx);
                  var item_2 = _this.getItem(_this.navIdx);
                  liElem_1.setAttribute("aria-expanded", "true");
                  _this.openMenu(liElem_1, item_2, -1, -1, e);
                }
              }
              if (_this.navIdx.length < 1) {
                if (_this.showSubMenuOn === "Hover" || _this.showSubMenuOn === "Click") {
                  _this.showItemOnClick = _this.defaultOption;
                  _this.showSubMenuOn = "Auto";
                }
              }
            }
            _this.removeStateWrapper();
          });
        }
      }
    };
    MenuBase2.prototype.updateReactTemplate = function() {
      if (this.isReact && this.template && this.navIdx.length === 0) {
        var portals = this.portals.splice(0, this.items.length);
        this.clearTemplate(["template"]);
        this.portals = portals;
        this.renderReactTemplates();
      }
    };
    MenuBase2.prototype.getMenuItemModel = function(item, level) {
      if (isNullOrUndefined(item)) {
        return null;
      }
      if (isNullOrUndefined(level)) {
        level = 0;
      }
      var fields = this.getFields(level);
      return {
        text: item[fields.text],
        id: item[fields.id],
        items: item[fields.child],
        separator: item[fields.separator],
        iconCss: item[fields.iconCss],
        url: item[fields.url]
      };
    };
    MenuBase2.prototype.getPopups = function() {
      var _this = this;
      var popups = [];
      [].slice.call(document.querySelectorAll("." + POPUP)).forEach(function(elem) {
        if (!isNullOrUndefined(elem.querySelector("." + ITEM)) && _this.getIndex(elem.querySelector("." + ITEM).id, true).length) {
          popups.push(elem);
        }
      });
      return popups;
    };
    MenuBase2.prototype.isMenuVisible = function() {
      return this.navIdx.length > 0 || this.element.classList.contains("e-contextmenu") && isVisible(this.element).valueOf();
    };
    MenuBase2.prototype.canOpen = function(target) {
      var canOpen = true;
      if (this.filter) {
        canOpen = false;
        var filter = this.filter.split(" ");
        for (var i = 0, len = filter.length; i < len; i++) {
          if (closest(target, "." + filter[i])) {
            canOpen = true;
            break;
          }
        }
      }
      return canOpen;
    };
    MenuBase2.prototype.openMenu = function(li, item, top, left, e, target) {
      var _this = this;
      if (top === void 0) {
        top = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      if (e === void 0) {
        e = null;
      }
      if (target === void 0) {
        target = this.targetElement;
      }
      var wrapper = this.getWrapper();
      this.lItem = li;
      var elemId = this.element.id !== "" ? this.element.id : "menu";
      this.isMenusClosed = false;
      if (isNullOrUndefined(top)) {
        top = -1;
      }
      if (isNullOrUndefined(left)) {
        left = -1;
      }
      if (li) {
        this.uList = this.createItems(item[this.getField("children", this.navIdx.length - 1)]);
        if (!this.isMenu && Browser.isDevice) {
          wrapper.lastChild.style.display = "none";
          var data = {
            text: item[this.getField("text")].toString(),
            iconCss: ICONS + " e-previous"
          };
          var hdata = new MenuItem(this.items[0], "items", data, true);
          var hli = this.createItems([hdata]).children[0];
          hli.classList.add(HEADER);
          this.uList.insertBefore(hli, this.uList.children[0]);
        }
        if (this.isMenu) {
          this.popupWrapper = this.createElement("div", {
            className: "e-" + this.getModuleName() + "-wrapper " + POPUP,
            id: li.id + "-ej2menu-" + elemId + "-popup"
          });
          if (this.hamburgerMode) {
            top = li.offsetHeight;
            li.appendChild(this.popupWrapper);
          } else {
            document.body.appendChild(this.popupWrapper);
          }
          this.isNestedOrVertical = this.element.classList.contains("e-vertical") || this.navIdx.length !== 1;
          this.popupObj = this.generatePopup(this.popupWrapper, this.uList, li, this.isNestedOrVertical);
          if (this.template) {
            this.renderReactTemplates();
          }
          if (this.hamburgerMode) {
            this.calculateIndentSize(this.uList, li);
          } else {
            if (this.cssClass) {
              addClass([this.popupWrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            this.popupObj.hide();
          }
          if (!this.hamburgerMode && !this.showItemOnClick && this.hoverDelay) {
            window.clearInterval(this.timer);
            this.timer = window.setTimeout(function() {
              _this.triggerBeforeOpen(li, _this.uList, item, e, 0, 0, "menu");
            }, this.hoverDelay);
          } else {
            this.triggerBeforeOpen(li, this.uList, item, e, 0, 0, "menu");
          }
        } else {
          this.uList.style.zIndex = this.element.style.zIndex;
          wrapper.appendChild(this.uList);
          if (!this.showItemOnClick && this.hoverDelay) {
            window.clearInterval(this.timer);
            this.timer = window.setTimeout(function() {
              _this.triggerBeforeOpen(li, _this.uList, item, e, top, left, "none");
            }, this.hoverDelay);
          } else {
            this.triggerBeforeOpen(li, this.uList, item, e, top, left, "none");
          }
        }
      } else {
        this.uList = this.element;
        this.uList.style.zIndex = getZindexPartial(target ? target : this.element).toString();
        if (isNullOrUndefined(e)) {
          var ev = document.createEvent("MouseEvents");
          ev.initEvent("click", true, false);
          var targetEvent = this.copyObject(ev, {});
          targetEvent.target = targetEvent.srcElement = target;
          targetEvent.currentTarget = target;
          this.triggerBeforeOpen(li, this.uList, item, targetEvent, top, left, "none");
        } else {
          this.triggerBeforeOpen(li, this.uList, item, e, top, left, "none");
        }
      }
    };
    MenuBase2.prototype.copyObject = function(source, destination) {
      for (var prop in source) {
        destination["" + prop] = source["" + prop];
      }
      return destination;
    };
    MenuBase2.prototype.calculateIndentSize = function(ul, li) {
      var liStyle = getComputedStyle(li);
      var liIndent = parseInt(liStyle.textIndent, 10);
      if (this.navIdx.length < 2 && !li.classList.contains("e-blankicon")) {
        liIndent *= 2;
      } else {
        liIndent += liIndent / 4;
      }
      ul.style.textIndent = liIndent + "px";
      var blankIconElem = ul.querySelectorAll(".e-blankicon");
      if (blankIconElem && blankIconElem.length) {
        var menuIconElem = ul.querySelector(".e-menu-icon");
        var menuIconElemStyle = getComputedStyle(menuIconElem);
        var blankIconIndent = parseInt(menuIconElemStyle.marginRight, 10) + menuIconElem.offsetWidth + liIndent;
        for (var i = 0; i < blankIconElem.length; i++) {
          blankIconElem[i].style.textIndent = blankIconIndent + "px";
        }
      }
    };
    MenuBase2.prototype.generatePopup = function(popupWrapper, ul, li, isNestedOrVertical) {
      var _this = this;
      var popupObj = new Popup(popupWrapper, {
        actionOnScroll: this.hamburgerMode ? "none" : "reposition",
        relateTo: li,
        collision: this.hamburgerMode ? { X: "none", Y: "none" } : { X: isNestedOrVertical || this.enableRtl ? "none" : "flip", Y: "fit" },
        position: isNestedOrVertical && !this.hamburgerMode ? { X: "right", Y: "top" } : { X: "left", Y: "bottom" },
        targetType: "relative",
        enableRtl: this.enableRtl,
        content: ul,
        open: function() {
          var scrollEle = select(".e-menu-vscroll", popupObj.element);
          if (scrollEle) {
            scrollEle.style.height = "inherit";
            scrollEle.style.maxHeight = "";
          }
          var ul2 = select(".e-ul", popupObj.element);
          popupObj.element.style.maxHeight = "";
          ul2.focus();
          _this.triggerOpen(ul2);
        }
      });
      return popupObj;
    };
    MenuBase2.prototype.createHeaderContainer = function(wrapper) {
      wrapper = wrapper || this.getWrapper();
      var spanElem = this.createElement("span", { className: "e-" + this.getModuleName() + "-header" });
      var tempTitle = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(this.title) : this.title;
      var spanTitle = this.createElement("span", {
        className: "e-" + this.getModuleName() + "-title",
        innerHTML: tempTitle
      });
      var spanIcon = this.createElement("span", {
        className: "e-icons e-" + this.getModuleName() + "-icon",
        attrs: { "tabindex": "0" }
      });
      spanElem.appendChild(spanTitle);
      spanElem.appendChild(spanIcon);
      wrapper.insertBefore(spanElem, this.element);
    };
    MenuBase2.prototype.openHamburgerMenu = function(e) {
      if (this.hamburgerMode) {
        this.triggerBeforeOpen(null, this.element, null, e, 0, 0, "hamburger");
      }
    };
    MenuBase2.prototype.closeHamburgerMenu = function(e) {
      var _this = this;
      var beforeCloseArgs = {
        element: this.element,
        parentItem: null,
        event: e,
        items: this.items,
        cancel: false
      };
      this.trigger("beforeClose", beforeCloseArgs, function(observedHamburgerCloseArgs) {
        if (!observedHamburgerCloseArgs.cancel) {
          _this.closeMenu(null, e);
          _this.element.classList.add("e-hide-menu");
          _this.trigger("onClose", { element: _this.element, parentItem: null, items: _this.items });
        }
      });
    };
    MenuBase2.prototype.callFit = function(element2, x, y, top, left) {
      return fit(element2, null, { X: x, Y: y }, { top, left });
    };
    MenuBase2.prototype.triggerBeforeOpen = function(li, ul, item, e, top, left, type) {
      var _this = this;
      var items = li ? item[this.getField("children", this.navIdx.length - 1)] : this.items;
      var eventArgs = {
        element: ul,
        items,
        parentItem: item,
        event: e,
        cancel: false,
        top,
        left,
        showSubMenuOn: "Auto"
      };
      var menuType = type;
      this.trigger("beforeOpen", eventArgs, function(observedOpenArgs) {
        switch (menuType) {
          case "menu":
            if (!_this.hamburgerMode) {
              if (observedOpenArgs.showSubMenuOn !== "Auto") {
                _this.showItemOnClick = !_this.defaultOption;
                _this.showSubMenuOn = observedOpenArgs.showSubMenuOn;
              }
              _this.top = observedOpenArgs.top;
              _this.left = observedOpenArgs.left;
            }
            _this.popupWrapper.style.display = "block";
            if (!_this.hamburgerMode) {
              _this.popupWrapper.style.maxHeight = _this.popupWrapper.getBoundingClientRect().height + "px";
              if (_this.enableScrolling) {
                addScrolling(_this.createElement, _this.popupWrapper, _this.uList, "vscroll", _this.enableRtl);
              }
              _this.checkScrollOffset(e);
            }
            if (!_this.hamburgerMode && !_this.left && !_this.top) {
              _this.popupObj.refreshPosition(_this.lItem, true);
              _this.left = parseInt(_this.popupWrapper.style.left, 10);
              _this.top = parseInt(_this.popupWrapper.style.top, 10);
              if (_this.enableRtl) {
                _this.left = _this.isNestedOrVertical ? _this.left - _this.popupWrapper.offsetWidth - _this.lItem.parentElement.offsetWidth + 2 : _this.left - _this.popupWrapper.offsetWidth + _this.lItem.offsetWidth;
              }
              if (_this.template && (_this.isReact || _this.isAngular)) {
                requestAnimationFrame(function() {
                  _this.collision();
                  _this.popupWrapper.style.display = "";
                });
              } else {
                _this.collision();
                _this.popupWrapper.style.display = "";
              }
            } else {
              _this.popupObj.collision = { X: "none", Y: "none" };
              _this.popupWrapper.style.display = "";
            }
            break;
          case "none":
            _this.top = observedOpenArgs.top;
            _this.left = observedOpenArgs.left;
            break;
          case "hamburger":
            if (!observedOpenArgs.cancel) {
              _this.element.classList.remove("e-hide-menu");
              _this.triggerOpen(_this.element);
            }
            break;
        }
        if (menuType !== "hamburger") {
          if (observedOpenArgs.cancel) {
            if (_this.isMenu) {
              _this.popupObj.destroy();
              detach(_this.popupWrapper);
            } else if (ul.className.indexOf("e-ul") > -1) {
              detach(ul);
            }
            _this.navIdx.pop();
          } else {
            if (_this.isMenu) {
              if (_this.hamburgerMode) {
                _this.popupWrapper.style.top = _this.top + "px";
                _this.popupWrapper.style.left = "0px";
                _this.toggleAnimation(_this.popupWrapper);
              } else {
                _this.setBlankIconStyle(_this.popupWrapper);
                _this.wireKeyboardEvent(_this.popupWrapper);
                rippleEffect(_this.popupWrapper, { selector: "." + ITEM });
                _this.popupWrapper.style.left = _this.left + "px";
                _this.popupWrapper.style.top = _this.top + "px";
                var animationOptions = _this.animationSettings.effect !== "None" ? {
                  name: _this.animationSettings.effect,
                  duration: _this.animationSettings.duration,
                  timingFunction: _this.animationSettings.easing
                } : null;
                _this.popupObj.show(animationOptions, _this.lItem);
              }
            } else {
              _this.setBlankIconStyle(_this.uList);
              _this.setPosition(_this.lItem, _this.uList, _this.top, _this.left);
              _this.toggleAnimation(_this.uList);
            }
          }
        }
        if (_this.keyType === "right") {
          var cul = _this.getUlByNavIdx();
          li.classList.remove(FOCUSED);
          if (_this.isMenu && _this.navIdx.length === 1) {
            _this.removeLIStateByClass([SELECTED2], [_this.getWrapper()]);
          }
          li.classList.add(SELECTED2);
          if (_this.action === ENTER) {
            var eventArgs_1 = { element: li, item, event: e };
            _this.trigger("select", eventArgs_1);
          }
          li.focus();
          cul = _this.getUlByNavIdx();
          var index = _this.isValidLI(cul.children[0], 0, _this.action);
          cul.children[index].classList.add(FOCUSED);
          cul.children[index].focus();
        }
      });
    };
    MenuBase2.prototype.collision = function() {
      var collide;
      collide = isCollide(this.popupWrapper, null, this.left, this.top);
      if ((this.isNestedOrVertical || this.enableRtl) && (collide.indexOf("right") > -1 || collide.indexOf("left") > -1)) {
        this.popupObj.collision.X = "none";
        var offWidth = closest(this.lItem, ".e-" + this.getModuleName() + "-wrapper").offsetWidth;
        this.left = this.enableRtl ? calculatePosition(this.lItem, this.isNestedOrVertical ? "right" : "left", "top").left : this.left - this.popupWrapper.offsetWidth - offWidth + 2;
      }
      collide = isCollide(this.popupWrapper, null, this.left, this.top);
      if (collide.indexOf("left") > -1 || collide.indexOf("right") > -1) {
        this.left = this.callFit(this.popupWrapper, true, false, this.top, this.left).left;
      }
      this.popupWrapper.style.left = this.left + "px";
    };
    MenuBase2.prototype.setBlankIconStyle = function(menu) {
      var blankIconList = [].slice.call(menu.getElementsByClassName("e-blankicon"));
      if (!blankIconList.length) {
        return;
      }
      var iconLi = menu.querySelector(".e-menu-item:not(.e-blankicon):not(.e-separator)");
      if (!iconLi) {
        return;
      }
      var icon = iconLi.querySelector(".e-menu-icon");
      if (!icon) {
        return;
      }
      var cssProp = this.enableRtl ? { padding: "paddingRight", margin: "marginLeft" } : { padding: "paddingLeft", margin: "marginRight" };
      var iconCssProps = getComputedStyle(icon);
      var iconSize = parseInt(iconCssProps.fontSize, 10);
      if (!!parseInt(iconCssProps.width, 10) && parseInt(iconCssProps.width, 10) > iconSize) {
        iconSize = parseInt(iconCssProps.width, 10);
      }
      var size = iconSize + parseInt(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        iconCssProps[cssProp.margin],
        10
      ) + parseInt(getComputedStyle(iconLi)[cssProp.padding], 10) + "px";
      blankIconList.forEach(function(li) {
        li.style[cssProp.padding] = size;
      });
    };
    MenuBase2.prototype.checkScrollOffset = function(e) {
      var wrapper = this.getWrapper();
      if (wrapper.children[0].classList.contains("e-menu-hscroll") && this.navIdx.length === 1) {
        var trgt = isNullOrUndefined(e) ? this.element : closest(e.target, "." + ITEM);
        var offsetEle = select(".e-hscroll-bar", wrapper);
        if (offsetEle.scrollLeft > trgt.offsetLeft) {
          offsetEle.scrollLeft -= offsetEle.scrollLeft - trgt.offsetLeft;
        }
        var offsetLeft = offsetEle.scrollLeft + offsetEle.offsetWidth;
        var offsetRight = trgt.offsetLeft + trgt.offsetWidth;
        if (offsetLeft < offsetRight) {
          offsetEle.scrollLeft += offsetRight - offsetLeft;
        }
      }
    };
    MenuBase2.prototype.setPosition = function(li, ul, top, left) {
      var px = "px";
      this.toggleVisiblity(ul);
      if (ul === this.element || left > -1 && top > -1) {
        var collide = isCollide(ul, null, left, top);
        if (collide.indexOf("right") > -1) {
          left = left - ul.offsetWidth;
        }
        if (collide.indexOf("bottom") > -1) {
          var offset = this.callFit(ul, false, true, top, left);
          top = offset.top - 20;
          if (top < 0) {
            var newTop = pageYOffset + document.documentElement.clientHeight - ul.getBoundingClientRect().height;
            if (newTop > -1) {
              top = newTop;
            }
          }
        }
        collide = isCollide(ul, null, left, top);
        if (collide.indexOf("left") > -1) {
          var offset = this.callFit(ul, true, false, top, left);
          left = offset.left;
        }
      } else {
        if (Browser.isDevice) {
          top = Number(this.element.style.top.replace(px, ""));
          left = Number(this.element.style.left.replace(px, ""));
        } else {
          var x = this.enableRtl ? "left" : "right";
          var offset = calculatePosition(li, x, "top");
          top = offset.top;
          left = offset.left;
          var collide = isCollide(ul, null, this.enableRtl ? left - ul.offsetWidth : left, top);
          var xCollision = collide.indexOf("left") > -1 || collide.indexOf("right") > -1;
          if (xCollision) {
            offset = calculatePosition(li, this.enableRtl ? "right" : "left", "top");
            left = offset.left;
          }
          if (this.enableRtl || xCollision) {
            left = this.enableRtl && xCollision ? left : left - ul.offsetWidth;
          }
          if (collide.indexOf("bottom") > -1) {
            offset = this.callFit(ul, false, true, top, left);
            top = offset.top;
          }
        }
      }
      this.toggleVisiblity(ul, false);
      ul.style.top = top + px;
      ul.style.left = left + px;
    };
    MenuBase2.prototype.toggleVisiblity = function(ul, isVisible2) {
      if (isVisible2 === void 0) {
        isVisible2 = true;
      }
      ul.style.visibility = isVisible2 ? "hidden" : "";
      ul.style.display = isVisible2 ? "block" : "none";
    };
    MenuBase2.prototype.createItems = function(items) {
      var _this = this;
      var level = this.navIdx ? this.navIdx.length : 0;
      var fields = this.getFields(level);
      var showIcon = this.hasField(items, this.getField("iconCss", level));
      var listBaseOptions = {
        showIcon,
        moduleName: "menu",
        fields,
        template: this.template,
        itemNavigable: true,
        itemCreating: function(args) {
          if (!args.curData[args.fields[fields.id]]) {
            args.curData[args.fields[fields.id]] = getUniqueID("menuitem");
          }
          if (isNullOrUndefined(args.curData.htmlAttributes)) {
            args.curData.htmlAttributes = {};
          }
          if (Browser.isIE) {
            args.curData.htmlAttributes.role = "menuitem";
            args.curData.htmlAttributes.tabindex = "-1";
          } else {
            Object.assign(args.curData.htmlAttributes, { role: "menuitem", tabindex: "-1" });
          }
          if (_this.isMenu && !args.curData[_this.getField("separator", level)]) {
            args.curData.htmlAttributes["aria-label"] = args.curData[args.fields.text] ? args.curData[args.fields.text] : args.curData[args.fields.id];
          }
          if (args.curData[args.fields[fields.iconCss]] === "") {
            args.curData[args.fields[fields.iconCss]] = null;
          }
        },
        itemCreated: function(args) {
          if (args.curData[_this.getField("separator", level)]) {
            args.item.classList.add(SEPARATOR);
            args.item.setAttribute("role", "separator");
          }
          if (showIcon && !args.curData[args.fields.iconCss] && !args.curData[_this.getField("separator", level)]) {
            args.item.classList.add("e-blankicon");
          }
          if (args.curData[args.fields.child] && args.curData[args.fields.child].length) {
            var span = _this.createElement("span", { className: ICONS + " " + CARET });
            args.item.appendChild(span);
            args.item.setAttribute("aria-haspopup", "true");
            args.item.setAttribute("aria-expanded", "false");
            args.item.classList.add("e-menu-caret-icon");
          }
          if (_this.isMenu && _this.template) {
            args.item.setAttribute("id", args.curData[args.fields.id].toString());
            args.item.removeAttribute("data-uid");
            if (args.item.classList.contains("e-level-1")) {
              args.item.classList.remove("e-level-1");
            }
            if (args.item.classList.contains("e-has-child")) {
              args.item.classList.remove("e-has-child");
            }
            args.item.removeAttribute("aria-level");
          }
          var eventArgs = { item: args.curData, element: args.item };
          _this.trigger("beforeItemRender", eventArgs);
        }
      };
      this.setProperties({ "items": this.items }, true);
      if (this.isMenu) {
        listBaseOptions.templateID = this.element.id + TEMPLATE_PROPERTY;
      }
      var ul = ListBase.createList(this.createElement, items, listBaseOptions, !this.template, this);
      ul.setAttribute("tabindex", "0");
      if (this.isMenu) {
        ul.setAttribute("role", "menu");
      } else {
        ul.setAttribute("role", "menubar");
      }
      return ul;
    };
    MenuBase2.prototype.moverHandler = function(e) {
      var trgt = e.target;
      this.liTrgt = trgt;
      if (!this.isMenu) {
        this.isCmenuHover = true;
      }
      var cli = this.getLI(trgt);
      var wrapper = cli ? closest(cli, ".e-" + this.getModuleName() + "-wrapper") : this.getWrapper();
      var hdrWrapper = this.getWrapper();
      var regex2 = new RegExp("-ej2menu-(.*)-popup");
      var ulId;
      var isDifferentElem = false;
      if (!wrapper) {
        return;
      }
      if (wrapper.id !== "") {
        ulId = regex2.exec(wrapper.id)[1];
      } else {
        ulId = wrapper.querySelector("ul").id;
      }
      if (ulId !== this.element.id) {
        this.removeLIStateByClass([FOCUSED, SELECTED2], [this.getWrapper()]);
        if (this.navIdx.length) {
          isDifferentElem = true;
        } else {
          return;
        }
      }
      if (cli && closest(cli, ".e-" + this.getModuleName() + "-wrapper") && !isDifferentElem) {
        this.removeLIStateByClass([FOCUSED], this.isMenu ? [wrapper].concat(this.getPopups()) : [wrapper]);
        this.removeLIStateByClass([FOCUSED], this.isMenu ? [hdrWrapper].concat(this.getPopups()) : [hdrWrapper]);
        cli.classList.add(FOCUSED);
        if (!this.showItemOnClick) {
          this.clickHandler(e);
        }
      } else if (this.isMenu && this.showItemOnClick && !isDifferentElem) {
        this.removeLIStateByClass([FOCUSED], [wrapper].concat(this.getPopups()));
      }
      if (this.isMenu) {
        if (!this.showItemOnClick && (trgt.parentElement !== wrapper && !closest(trgt, ".e-" + this.getModuleName() + "-popup")) && (!cli || cli && !this.getIndex(cli.id, true).length) && this.showSubMenuOn !== "Hover") {
          this.removeLIStateByClass([FOCUSED], [wrapper]);
          if (this.navIdx.length) {
            this.isClosed = true;
            this.closeMenu(null, e);
          }
        } else if (isDifferentElem && !this.showItemOnClick) {
          if (this.navIdx.length) {
            this.isClosed = true;
            this.closeMenu(null, e);
          }
        }
        if (!this.isClosed) {
          this.removeStateWrapper();
        }
        this.isClosed = false;
      }
      if (!this.isMenu) {
        this.isCmenuHover = false;
      }
    };
    MenuBase2.prototype.removeStateWrapper = function() {
      if (this.liTrgt) {
        var wrapper = closest(this.liTrgt, ".e-menu-vscroll");
        if (this.liTrgt.tagName === "DIV" && wrapper) {
          this.removeLIStateByClass([FOCUSED, SELECTED2], [wrapper]);
        }
      }
    };
    MenuBase2.prototype.removeLIStateByClass = function(classList2, element2) {
      var li;
      var _loop_1 = function(i2) {
        classList2.forEach(function(className) {
          li = select("." + className, element2[i2]);
          if (li) {
            li.classList.remove(className);
          }
        });
      };
      for (var i = 0; i < element2.length; i++) {
        _loop_1(i);
      }
    };
    MenuBase2.prototype.getField = function(propName, level) {
      if (level === void 0) {
        level = 0;
      }
      var fieldName = this.fields["" + propName];
      return typeof fieldName === "string" ? fieldName : !fieldName[level] ? fieldName[fieldName.length - 1].toString() : fieldName[level].toString();
    };
    MenuBase2.prototype.getFields = function(level) {
      if (level === void 0) {
        level = 0;
      }
      return {
        id: this.getField("itemId", level),
        iconCss: this.getField("iconCss", level),
        text: this.getField("text", level),
        url: this.getField("url", level),
        child: this.getField("children", level),
        separator: this.getField("separator", level)
      };
    };
    MenuBase2.prototype.hasField = function(items, field) {
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]["" + field]) {
          return true;
        }
      }
      return false;
    };
    MenuBase2.prototype.menuHeaderClickHandler = function(e) {
      var menuWrapper = closest(e.target, ".e-menu-wrapper");
      if (menuWrapper && menuWrapper.querySelector("ul.e-menu-parent").id !== this.element.id) {
        return;
      }
      if (this.element.className.indexOf("e-hide-menu") > -1) {
        this.openHamburgerMenu(e);
      } else {
        this.closeHamburgerMenu(e);
      }
    };
    MenuBase2.prototype.clickHandler = function(e) {
      this.isTapHold = this.isTapHold ? false : this.isTapHold;
      var wrapper = this.getWrapper();
      var trgt = e.target;
      var cli = this.cli = this.getLI(trgt);
      var regex2 = new RegExp("-ej2menu-(.*)-popup");
      var cliWrapper = cli ? closest(cli, ".e-" + this.getModuleName() + "-wrapper") : null;
      var isInstLI = cli && cliWrapper && (this.isMenu ? this.getIndex(cli.id, true).length > 0 : wrapper.firstElementChild.id === cliWrapper.firstElementChild.id);
      if (Browser.isDevice && this.isMenu) {
        this.removeLIStateByClass([FOCUSED], [wrapper].concat(this.getPopups()));
        this.mouseDownHandler(e);
      }
      if (cli && cliWrapper && this.isMenu) {
        var cliWrapperId = cliWrapper.id ? regex2.exec(cliWrapper.id)[1] : cliWrapper.querySelector(".e-menu-parent").id;
        if (this.element.id !== cliWrapperId) {
          return;
        }
      }
      if (isInstLI && e.type === "click" && !cli.classList.contains(HEADER)) {
        this.setLISelected(cli);
        var navIdx = this.getIndex(cli.id, true);
        var item = this.getItem(navIdx);
        var eventArgs = { element: cli, item, event: e };
        this.trigger("select", eventArgs);
      }
      if (isInstLI && (e.type === "mouseover" || Browser.isDevice || this.showItemOnClick)) {
        var ul = void 0;
        if (cli.classList.contains(HEADER)) {
          ul = wrapper.children[this.navIdx.length - 1];
          this.toggleAnimation(ul);
          var sli = this.getLIByClass(ul, SELECTED2);
          if (sli) {
            sli.classList.remove(SELECTED2);
          }
          detach(cli.parentNode);
          this.navIdx.pop();
        } else {
          if (!cli.classList.contains(SEPARATOR)) {
            this.showSubMenu = true;
            var cul = cli.parentNode;
            if (isNullOrUndefined(cul)) {
              return;
            }
            this.cliIdx = this.getIdx(cul, cli);
            if (this.isMenu || !Browser.isDevice) {
              var culIdx = this.isMenu ? Array.prototype.indexOf.call([wrapper].concat(this.getPopups()), closest(cul, ".e-" + this.getModuleName() + "-wrapper")) : this.getIdx(wrapper, cul);
              if (this.navIdx[culIdx] === this.cliIdx) {
                this.showSubMenu = false;
              }
              if (culIdx !== this.navIdx.length && (e.type !== "mouseover" || this.showSubMenu)) {
                var sli = this.getLIByClass(cul, SELECTED2);
                if (sli) {
                  sli.classList.remove(SELECTED2);
                }
                this.isClosed = true;
                this.keyType = "click";
                if (this.showItemOnClick) {
                  this.setLISelected(cli);
                  if (!this.isMenu) {
                    this.isCmenuHover = true;
                  }
                }
                this.closeMenu(culIdx + 1, e);
                if (this.showItemOnClick) {
                  this.setLISelected(cli);
                  if (!this.isMenu) {
                    this.isCmenuHover = false;
                  }
                }
              }
            }
            if (!this.isClosed) {
              this.afterCloseMenu(e);
            }
            this.isClosed = false;
          }
        }
      } else {
        if (this.isMenu && trgt.tagName === "DIV" && this.navIdx.length && closest(trgt, ".e-menu-vscroll")) {
          var popupEle = closest(trgt, "." + POPUP);
          var cIdx = Array.prototype.indexOf.call(this.getPopups(), popupEle) + 1;
          if (cIdx < this.navIdx.length) {
            this.closeMenu(cIdx + 1, e);
            if (popupEle) {
              this.removeLIStateByClass([FOCUSED, SELECTED2], [popupEle]);
            }
          }
        } else if (this.isMenu && this.hamburgerMode && trgt.tagName === "SPAN" && trgt.classList.contains("e-menu-icon")) {
          this.menuHeaderClickHandler(e);
        } else {
          if (trgt.tagName !== "UL" || (this.isMenu ? trgt.parentElement.classList.contains("e-menu-wrapper") && !this.getIndex(trgt.querySelector("." + ITEM).id, true).length : trgt.parentElement !== wrapper)) {
            if (!cli) {
              this.removeLIStateByClass([SELECTED2], [wrapper]);
            }
            if (!cli || !cli.querySelector("." + CARET)) {
              this.closeMenu(null, e);
            }
          }
        }
      }
    };
    MenuBase2.prototype.afterCloseMenu = function(e) {
      if (isNullOrUndefined(e)) {
        return;
      }
      var isHeader;
      if (this.showSubMenu) {
        if (this.showItemOnClick && this.navIdx.length === 0) {
          isHeader = closest(e.target, ".e-menu-parent.e-control");
        } else {
          isHeader = closest(this.element, ".e-menu-parent.e-control");
        }
        var idx = this.navIdx.concat(this.cliIdx);
        var item = this.getItem(idx);
        if (item && item[this.getField("children", idx.length - 1)] && item[this.getField("children", idx.length - 1)].length) {
          if (e.type === "mouseover" || Browser.isDevice && this.isMenu) {
            this.setLISelected(this.cli);
          }
          if (!this.hamburgerMode && isHeader || this.hamburgerMode && this.cli.getAttribute("aria-expanded") === "false") {
            this.cli.setAttribute("aria-expanded", "true");
            this.navIdx.push(this.cliIdx);
            this.openMenu(this.cli, item, null, null, e);
          }
        } else {
          if (e.type !== "mouseover") {
            this.closeMenu(null, e);
          }
        }
        if (!isHeader) {
          var cul = this.getUlByNavIdx();
          var sli = this.getLIByClass(cul, SELECTED2);
          if (sli) {
            sli.setAttribute("aria-expanded", "false");
            sli.classList.remove(SELECTED2);
          }
        }
      }
      this.keyType = "";
    };
    MenuBase2.prototype.setLISelected = function(li) {
      var sli = this.getLIByClass(li.parentElement, SELECTED2);
      if (sli) {
        sli.classList.remove(SELECTED2);
      }
      if (!this.isMenu) {
        li.classList.remove(FOCUSED);
      }
      li.classList.add(SELECTED2);
    };
    MenuBase2.prototype.getLIByClass = function(ul, classname) {
      if (ul && ul.children) {
        for (var i = 0, len = ul.children.length; i < len; i++) {
          if (ul.children[i].classList.contains(classname)) {
            return ul.children[i];
          }
        }
      }
      return null;
    };
    MenuBase2.prototype.getItemIndex = function(item, isUniqueId) {
      var idx;
      if (typeof item === "string") {
        idx = item;
      } else {
        idx = item.id;
      }
      var isText = isUniqueId === false ? false : true;
      var navIdx = this.getIndex(idx, isText);
      return navIdx;
    };
    MenuBase2.prototype.setItem = function(item, id, isUniqueId) {
      var idx;
      if (isUniqueId) {
        idx = id ? id : item.id;
      } else {
        idx = id ? id : item.text;
      }
      var navIdx = this.getIndex(idx, isUniqueId);
      var newItem = this.getItem(navIdx);
      Object.assign(newItem, item);
    };
    MenuBase2.prototype.getItem = function(navIdx) {
      navIdx = navIdx.slice();
      var idx = navIdx.pop();
      var items = this.getItems(navIdx);
      return items[idx];
    };
    MenuBase2.prototype.getItems = function(navIdx) {
      var items = this.items;
      for (var i = 0; i < navIdx.length; i++) {
        items = items[navIdx[i]][this.getField("children", i)];
      }
      return items;
    };
    MenuBase2.prototype.setItems = function(newItems, navIdx) {
      var items = this.getItems(navIdx);
      items.splice(0, items.length);
      for (var i = 0; i < newItems.length; i++) {
        items.splice(i, 0, newItems[i]);
      }
    };
    MenuBase2.prototype.getIdx = function(ul, li, skipHdr) {
      if (skipHdr === void 0) {
        skipHdr = true;
      }
      var idx = Array.prototype.indexOf.call(ul.children, li);
      if (skipHdr && ul.children[0].classList.contains(HEADER)) {
        idx--;
      }
      return idx;
    };
    MenuBase2.prototype.getLI = function(elem) {
      if (elem.tagName === "LI" && elem.classList.contains("e-menu-item")) {
        return elem;
      }
      return closest(elem, "li.e-menu-item");
    };
    MenuBase2.prototype.updateItemsByNavIdx = function() {
      var items = this.items;
      var count = 0;
      for (var index = 0; index < this.navIdx.length; index++) {
        items = items[index].items;
        if (!items) {
          break;
        }
        count++;
        var ul = this.getUlByNavIdx(count);
        if (!ul) {
          break;
        }
        this.updateItem(ul, items);
      }
    };
    MenuBase2.prototype.removeChildElement = function(elem) {
      while (elem.firstElementChild) {
        elem.removeChild(elem.firstElementChild);
      }
      return elem;
    };
    MenuBase2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      var wrapper = this.getWrapper();
      var _loop_2 = function(prop2) {
        switch (prop2) {
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([wrapper], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([wrapper], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "enableRtl":
            if (this_1.enableRtl) {
              wrapper.classList.add(RTL11);
            } else {
              wrapper.classList.remove(RTL11);
            }
            break;
          case "showItemOnClick":
            this_1.unWireEvents();
            this_1.showItemOnClick = newProp.showItemOnClick;
            this_1.wireEvents();
            break;
          case "enableScrolling":
            if (newProp.enableScrolling) {
              var ul_2;
              if (this_1.element.classList.contains("e-vertical")) {
                addScrolling(this_1.createElement, wrapper, this_1.element, "vscroll", this_1.enableRtl);
              } else {
                addScrolling(this_1.createElement, wrapper, this_1.element, "hscroll", this_1.enableRtl);
              }
              this_1.getPopups().forEach(function(wrapper2) {
                ul_2 = select(".e-ul", wrapper2);
                addScrolling(_this.createElement, wrapper2, ul_2, "vscroll", _this.enableRtl);
              });
            } else {
              var ul_3 = wrapper.children[0];
              if (this_1.element.classList.contains("e-vertical")) {
                destroyScroll(getInstance(ul_3, VScroll), ul_3);
              } else {
                destroyScroll(getInstance(ul_3, HScroll), ul_3);
              }
              wrapper.style.overflow = "";
              wrapper.appendChild(this_1.element);
              this_1.getPopups().forEach(function(wrapper2) {
                ul_3 = wrapper2.children[0];
                destroyScroll(getInstance(ul_3, VScroll), ul_3);
                wrapper2.style.overflow = "";
              });
            }
            break;
          case "items": {
            var idx = void 0;
            var navIdx = void 0;
            var item = void 0;
            if (this_1.isReact && this_1.template) {
              this_1.clearTemplate(["template"]);
            }
            if (!Object.keys(oldProp.items).length) {
              this_1.updateItem(this_1.element, this_1.items);
              if (this_1.enableScrolling && this_1.element.parentElement.classList.contains("e-custom-scroll")) {
                if (this_1.element.classList.contains("e-vertical")) {
                  addScrolling(this_1.createElement, wrapper, this_1.element, "vscroll", this_1.enableRtl);
                } else {
                  addScrolling(this_1.createElement, wrapper, this_1.element, "hscroll", this_1.enableRtl);
                }
              }
              if (!this_1.hamburgerMode) {
                for (var i = 1, count = wrapper.childElementCount; i < count; i++) {
                  detach(wrapper.lastElementChild);
                }
              }
              this_1.navIdx = [];
            } else {
              var keys = Object.keys(newProp.items);
              for (var i = 0; i < keys.length; i++) {
                navIdx = this_1.getChangedItemIndex(newProp, [], Number(keys[i]));
                if (navIdx.length <= this_1.getWrapper().children.length) {
                  idx = navIdx.pop();
                  item = this_1.getItems(navIdx);
                  this_1.insertAfter([item[idx]], item[idx].text);
                  this_1.removeItem(item, navIdx, idx);
                  this_1.setItems(item, navIdx);
                }
                navIdx.length = 0;
              }
            }
            break;
          }
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        _loop_2(prop);
      }
    };
    MenuBase2.prototype.updateItem = function(ul, items) {
      if (isBlazor() && !this.isMenu) {
        ul = this.removeChildElement(ul);
      } else {
        if (this.enableScrolling) {
          var wrapper1 = this.getWrapper();
          var ul1 = wrapper1.children[0];
          if (this.element.classList.contains("e-vertical")) {
            destroyScroll(getInstance(ul1, VScroll), ul1);
          } else {
            destroyScroll(getInstance(ul1, HScroll), ul1);
          }
        }
        ul.innerHTML = "";
      }
      var lis = [].slice.call(this.createItems(items).children);
      lis.forEach(function(li) {
        ul.appendChild(li);
      });
    };
    MenuBase2.prototype.getChangedItemIndex = function(newProp, index, idx) {
      index.push(idx);
      var key = Object.keys(newProp.items[idx]).pop();
      if (key === "items") {
        var item = newProp.items[idx];
        var popStr = Object.keys(item.items).pop();
        if (popStr) {
          this.getChangedItemIndex(item, index, Number(popStr));
        }
      } else {
        if (key === "isParentArray" && index.length > 1) {
          index.pop();
        }
      }
      return index;
    };
    MenuBase2.prototype.removeItem = function(item, navIdx, idx) {
      item.splice(idx, 1);
      var uls = this.getWrapper().children;
      if (navIdx.length < uls.length) {
        detach(uls[navIdx.length].children[idx]);
      }
    };
    MenuBase2.prototype.unWireEvents = function(targetSelctor) {
      if (targetSelctor === void 0) {
        targetSelctor = this.target;
      }
      var wrapper = this.getWrapper();
      if (targetSelctor) {
        var target = void 0;
        var touchModule = void 0;
        var targetElems = selectAll(targetSelctor);
        for (var i = 0, len = targetElems.length; i < len; i++) {
          target = targetElems[i];
          if (this.isMenu) {
            EventHandler.remove(target, "click", this.menuHeaderClickHandler);
          } else {
            if (Browser.isIos) {
              touchModule = getInstance(target, Touch);
              if (touchModule) {
                touchModule.destroy();
              }
            } else {
              EventHandler.remove(target, "contextmenu", this.cmenuHandler);
            }
          }
        }
        if (!this.isMenu) {
          EventHandler.remove(this.targetElement, "scroll", this.scrollHandler);
          for (var _i = 0, _a = getScrollableParent(this.targetElement); _i < _a.length; _i++) {
            var parent_2 = _a[_i];
            EventHandler.remove(parent_2, "scroll", this.scrollHandler);
          }
        }
      }
      if (!Browser.isDevice) {
        EventHandler.remove(this.isMenu ? document : wrapper, "mouseover", this.delegateMoverHandler);
        EventHandler.remove(document, "mousedown", this.delegateMouseDownHandler);
      }
      EventHandler.remove(document, "click", this.delegateClickHandler);
      this.unWireKeyboardEvent(wrapper);
      this.rippleFn();
    };
    MenuBase2.prototype.unWireKeyboardEvent = function(element2) {
      var keyboardModule = getInstance(element2, KeyboardEvents);
      if (keyboardModule) {
        keyboardModule.destroy();
      }
    };
    MenuBase2.prototype.toggleAnimation = function(ul, isMenuOpen) {
      var _this = this;
      if (isMenuOpen === void 0) {
        isMenuOpen = true;
      }
      var pUlHeight;
      var pElement;
      if (this.animationSettings.effect === "None" || !isMenuOpen) {
        this.end(ul, isMenuOpen);
      } else {
        this.animation.animate(ul, {
          name: this.animationSettings.effect,
          duration: this.animationSettings.duration,
          timingFunction: this.animationSettings.easing,
          begin: function(options) {
            if (_this.hamburgerMode) {
              pElement = options.element.parentElement;
              options.element.style.position = "absolute";
              pUlHeight = pElement.offsetHeight;
              options.element.style.maxHeight = options.element.offsetHeight + "px";
              pElement.style.maxHeight = "";
            } else {
              options.element.style.display = "block";
              options.element.style.maxHeight = options.element.getBoundingClientRect().height + "px";
            }
          },
          progress: function(options) {
            if (_this.hamburgerMode) {
              pElement.style.minHeight = pUlHeight + options.element.offsetHeight + "px";
            }
          },
          end: function(options) {
            if (_this.hamburgerMode) {
              options.element.style.position = "";
              options.element.style.maxHeight = "";
              pElement.style.minHeight = "";
              options.element.style.top = "0px";
              options.element.children[0].focus();
              _this.triggerOpen(options.element.children[0]);
            } else {
              _this.end(options.element, isMenuOpen);
            }
          }
        });
      }
    };
    MenuBase2.prototype.triggerOpen = function(ul) {
      var item = this.navIdx.length ? this.getItem(this.navIdx) : null;
      var eventArgs = {
        element: ul,
        parentItem: item,
        items: item ? item.items : this.items
      };
      this.trigger("onOpen", eventArgs);
      if (!this.isMenu) {
        EventHandler.add(ul, "keydown", this.keyHandler, this);
      }
    };
    MenuBase2.prototype.end = function(ul, isMenuOpen) {
      if (isMenuOpen) {
        if (this.isMenu || !Browser.isDevice) {
          ul.style.display = "block";
        }
        ul.style.maxHeight = "";
        this.triggerOpen(ul);
        if (ul.querySelector("." + FOCUSED)) {
          ul.querySelector("." + FOCUSED).focus();
        } else {
          var ele = this.getWrapper().children[this.getIdx(this.getWrapper(), ul) - 1];
          if (this.currentTarget) {
            if (!(this.currentTarget.classList.contains("e-numerictextbox") || this.currentTarget.classList.contains("e-textbox") || this.currentTarget.tagName === "INPUT")) {
              if (ele) {
                ele.querySelector("." + SELECTED2).focus();
              } else {
                this.element.focus();
              }
            }
          } else {
            if (ele) {
              ele.querySelector("." + SELECTED2).focus();
            } else {
              this.element.focus();
            }
          }
        }
      } else {
        if (ul === this.element) {
          var fli = this.getLIByClass(this.element, FOCUSED);
          if (fli) {
            fli.classList.remove(FOCUSED);
          }
          var sli = this.getLIByClass(this.element, SELECTED2);
          if (sli) {
            sli.classList.remove(SELECTED2);
          }
          ul.style.display = "none";
        } else {
          detach(ul);
        }
      }
    };
    MenuBase2.prototype.getPersistData = function() {
      return "";
    };
    MenuBase2.prototype.getWrapper = function() {
      return closest(this.element, ".e-" + this.getModuleName() + "-wrapper");
    };
    MenuBase2.prototype.getIndex = function(data, isUniqueId, items, nIndex, isCallBack, level) {
      if (items === void 0) {
        items = this.items;
      }
      if (nIndex === void 0) {
        nIndex = [];
      }
      if (isCallBack === void 0) {
        isCallBack = false;
      }
      if (level === void 0) {
        level = 0;
      }
      var item;
      level = isCallBack ? level + 1 : 0;
      for (var i = 0, len = items.length; i < len; i++) {
        item = items[i];
        if ((isUniqueId ? item[this.getField("itemId", level)] : item[this.getField("text", level)]) === data) {
          nIndex.push(i);
          break;
        } else if (item[this.getField("children", level)] && item[this.getField("children", level)].length) {
          nIndex = this.getIndex(data, isUniqueId, item[this.getField("children", level)], nIndex, true, level);
          if (nIndex[nIndex.length - 1] === -1) {
            if (i !== len - 1) {
              nIndex.pop();
            }
          } else {
            nIndex.unshift(i);
            break;
          }
        } else {
          if (i === len - 1) {
            nIndex.push(-1);
          }
        }
      }
      return !isCallBack && nIndex[0] === -1 ? [] : nIndex;
    };
    MenuBase2.prototype.enableItems = function(items, enable, isUniqueId) {
      if (enable === void 0) {
        enable = true;
      }
      var ul;
      var idx;
      var navIdx;
      var disabled = DISABLED7;
      var skipItem;
      for (var i = 0; i < items.length; i++) {
        navIdx = this.getIndex(items[i], isUniqueId);
        if (this.navIdx.length) {
          if (navIdx.length !== 1) {
            skipItem = false;
            for (var i_1 = 0, len = navIdx.length - 1; i_1 < len; i_1++) {
              if (navIdx[i_1] !== this.navIdx[i_1]) {
                skipItem = true;
                break;
              }
            }
            if (skipItem) {
              continue;
            }
          }
        } else {
          if (navIdx.length !== 1) {
            continue;
          }
        }
        idx = navIdx.pop();
        ul = this.getUlByNavIdx(navIdx.length);
        if (ul && !isNullOrUndefined(idx)) {
          if (enable) {
            if (this.isMenu) {
              ul.children[idx].classList.remove(disabled);
              ul.children[idx].removeAttribute("aria-disabled");
            } else {
              if (Browser.isDevice && !ul.classList.contains("e-contextmenu")) {
                ul.children[idx + 1].classList.remove(disabled);
              } else {
                ul.children[idx].classList.remove(disabled);
              }
            }
          } else {
            if (this.isMenu) {
              ul.children[idx].classList.add(disabled);
              ul.children[idx].setAttribute("aria-disabled", "true");
            } else {
              if (Browser.isDevice && !ul.classList.contains("e-contextmenu")) {
                ul.children[idx + 1].classList.add(disabled);
              } else {
                ul.children[idx].classList.add(disabled);
              }
            }
          }
        }
      }
    };
    MenuBase2.prototype.showItems = function(items, isUniqueId) {
      this.showHideItems(items, false, isUniqueId);
    };
    MenuBase2.prototype.hideItems = function(items, isUniqueId) {
      this.showHideItems(items, true, isUniqueId);
    };
    MenuBase2.prototype.showHideItems = function(items, ishide, isUniqueId) {
      var ul;
      var index;
      var navIdx;
      var item;
      for (var i = 0; i < items.length; i++) {
        navIdx = this.getIndex(items[i], isUniqueId);
        index = navIdx.pop();
        ul = this.getUlByNavIdx(navIdx.length);
        item = this.getItems(navIdx);
        if (ul) {
          var validUl = isUniqueId ? ul.children[index].id : item[index].text.toString();
          if (ishide && validUl === items[i]) {
            ul.children[index].classList.add(HIDE);
          } else if (!ishide && validUl === items[i]) {
            ul.children[index].classList.remove(HIDE);
          }
        }
      }
    };
    MenuBase2.prototype.removeItems = function(items, isUniqueId) {
      var idx;
      var navIdx;
      var iitems;
      for (var i = 0; i < items.length; i++) {
        navIdx = this.getIndex(items[i], isUniqueId);
        idx = navIdx.pop();
        iitems = this.getItems(navIdx);
        if (!isNullOrUndefined(idx)) {
          this.removeItem(iitems, navIdx, idx);
        }
      }
    };
    MenuBase2.prototype.insertAfter = function(items, text, isUniqueId) {
      this.insertItems(items, text, isUniqueId);
    };
    MenuBase2.prototype.insertBefore = function(items, text, isUniqueId) {
      this.insertItems(items, text, isUniqueId, false);
    };
    MenuBase2.prototype.insertItems = function(items, text, isUniqueId, isAfter) {
      if (isAfter === void 0) {
        isAfter = true;
      }
      var li;
      var idx;
      var navIdx;
      var iitems;
      var menuitem;
      for (var i = 0; i < items.length; i++) {
        navIdx = this.getIndex(text, isUniqueId);
        idx = navIdx.pop();
        iitems = this.getItems(navIdx);
        menuitem = new MenuItem(iitems[0], "items", items[i], true);
        iitems.splice(isAfter ? idx + 1 : idx, 0, menuitem);
        var uls = this.isMenu ? [this.getWrapper()].concat(this.getPopups()) : [].slice.call(this.getWrapper().children);
        if (!isNullOrUndefined(idx) && navIdx.length < uls.length) {
          idx = isAfter ? idx + 1 : idx;
          li = this.createItems(iitems).children[idx];
          var ul = this.isMenu ? select(".e-menu-parent", uls[navIdx.length]) : uls[navIdx.length];
          ul.insertBefore(li, ul.children[idx]);
        }
      }
    };
    MenuBase2.prototype.removeAttributes = function() {
      var _this = this;
      ["top", "left", "display", "z-index"].forEach(function(key) {
        _this.element.style.removeProperty(key);
      });
      ["role", "tabindex", "class", "style"].forEach(function(key) {
        if (key === "class" && _this.element.classList.contains("e-menu-parent")) {
          _this.element.classList.remove("e-menu-parent");
        }
        if (["class", "style"].indexOf(key) === -1 || !_this.element.getAttribute(key)) {
          _this.element.removeAttribute(key);
        }
        if (_this.isMenu && key === "class" && _this.element.classList.contains("e-vertical")) {
          _this.element.classList.remove("e-vertical");
        }
      });
    };
    MenuBase2.prototype.destroy = function() {
      var wrapper = this.getWrapper();
      if (wrapper) {
        this.unWireEvents();
        if (!this.isMenu) {
          this.clonedElement.style.display = "";
          if (this.clonedElement.tagName === "EJS-CONTEXTMENU") {
            addClass([this.clonedElement], ["e-control", "e-lib", "e-" + this.getModuleName()]);
            this.element = this.clonedElement;
          } else {
            if (this.refreshing && this.clonedElement.childElementCount && this.clonedElement.children[0].tagName === "LI") {
              this.setProperties({ "items": [] }, true);
            }
            if (document.getElementById(this.clonedElement.id)) {
              var refEle = this.clonedElement.nextElementSibling;
              if (refEle && refEle !== wrapper) {
                this.clonedElement.parentElement.insertBefore(this.element, refEle);
              } else {
                this.clonedElement.parentElement.appendChild(this.element);
              }
              if (isBlazor() && !this.isMenu) {
                this.element = this.removeChildElement(this.element);
              } else {
                this.element.innerHTML = "";
              }
              append([].slice.call(this.clonedElement.children), this.element);
              detach(this.clonedElement);
              this.removeAttributes();
            }
          }
          this.clonedElement = null;
        } else {
          this.closeMenu();
          if (isBlazor() && !this.isMenu) {
            this.element = this.removeChildElement(this.element);
          } else {
            this.element.innerHTML = "";
          }
          this.removeAttributes();
          wrapper.parentNode.insertBefore(this.element, wrapper);
          this.clonedElement = null;
        }
        if (this.isMenu && this.clonedElement) {
          detach(this.element);
          wrapper.style.display = "";
          wrapper.classList.remove("e-" + this.getModuleName() + "-wrapper");
          wrapper.removeAttribute("data-ripple");
        } else {
          detach(wrapper);
        }
        _super.prototype.destroy.call(this);
        if (this.template) {
          this.clearTemplate(["template"]);
        }
      }
      this.rippleFn = null;
    };
    __decorate32([
      Event()
    ], MenuBase2.prototype, "beforeItemRender", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "beforeOpen", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "onOpen", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "beforeClose", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "onClose", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "select", void 0);
    __decorate32([
      Event()
    ], MenuBase2.prototype, "created", void 0);
    __decorate32([
      Property("")
    ], MenuBase2.prototype, "cssClass", void 0);
    __decorate32([
      Property(0)
    ], MenuBase2.prototype, "hoverDelay", void 0);
    __decorate32([
      Property(false)
    ], MenuBase2.prototype, "showItemOnClick", void 0);
    __decorate32([
      Property("")
    ], MenuBase2.prototype, "target", void 0);
    __decorate32([
      Property("")
    ], MenuBase2.prototype, "filter", void 0);
    __decorate32([
      Property(null)
    ], MenuBase2.prototype, "template", void 0);
    __decorate32([
      Property(false)
    ], MenuBase2.prototype, "enableScrolling", void 0);
    __decorate32([
      Property(true)
    ], MenuBase2.prototype, "enableHtmlSanitizer", void 0);
    __decorate32([
      Complex({ itemId: "id", text: "text", parentId: "parentId", iconCss: "iconCss", url: "url", separator: "separator", children: "items" }, FieldSettings2)
    ], MenuBase2.prototype, "fields", void 0);
    __decorate32([
      Collection([], MenuItem)
    ], MenuBase2.prototype, "items", void 0);
    __decorate32([
      Complex({ duration: 400, easing: "ease", effect: "SlideDown" }, MenuAnimationSettings)
    ], MenuBase2.prototype, "animationSettings", void 0);
    MenuBase2 = __decorate32([
      NotifyPropertyChanges
    ], MenuBase2);
    return MenuBase2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/toolbar/toolbar.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_VERTICAL = "e-vertical";
var CLS_ITEMS = "e-toolbar-items";
var CLS_ITEM = "e-toolbar-item";
var CLS_RTL3 = "e-rtl";
var CLS_SEPARATOR = "e-separator";
var CLS_POPUPICON = "e-popup-up-icon";
var CLS_POPUPDOWN = "e-popup-down-icon";
var CLS_POPUPOPEN = "e-popup-open";
var CLS_TEMPLATE = "e-template";
var CLS_DISABLE3 = "e-overlay";
var CLS_POPUPTEXT = "e-toolbar-text";
var CLS_TBARTEXT = "e-popup-text";
var CLS_TBAROVERFLOW = "e-overflow-show";
var CLS_POPOVERFLOW = "e-overflow-hide";
var CLS_TBARBTN = "e-tbar-btn";
var CLS_TBARNAV = "e-hor-nav";
var CLS_TBARSCRLNAV = "e-scroll-nav";
var CLS_TBARRIGHT = "e-toolbar-right";
var CLS_TBARLEFT = "e-toolbar-left";
var CLS_TBARCENTER = "e-toolbar-center";
var CLS_TBARPOS = "e-tbar-pos";
var CLS_HSCROLLCNT = "e-hscroll-content";
var CLS_VSCROLLCNT = "e-vscroll-content";
var CLS_HSCROLLBAR2 = "e-hscroll-bar";
var CLS_POPUPNAV = "e-hor-nav";
var CLS_POPUPCLASS = "e-toolbar-pop";
var CLS_POPUP = "e-toolbar-popup";
var CLS_TBARBTNTEXT = "e-tbar-btn-text";
var CLS_TBARNAVACT = "e-nav-active";
var CLS_TBARIGNORE = "e-ignore";
var CLS_POPPRI = "e-popup-alone";
var CLS_HIDDEN = "e-hidden";
var CLS_MULTIROW = "e-toolbar-multirow";
var CLS_MULTIROWPOS = "e-multirow-pos";
var CLS_MULTIROW_SEPARATOR = "e-multirow-separator";
var CLS_EXTENDABLE_SEPARATOR = "e-extended-separator";
var CLS_EXTEANDABLE_TOOLBAR = "e-extended-toolbar";
var CLS_EXTENDABLECLASS = "e-toolbar-extended";
var CLS_EXTENDPOPUP = "e-expended-nav";
var CLS_EXTENDEDPOPOPEN = "e-tbar-extended";
var Item2 = (
  /** @class */
  function(_super) {
    __extends34(Item3, _super);
    function Item3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate33([
      Property("")
    ], Item3.prototype, "id", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "text", void 0);
    __decorate33([
      Property("auto")
    ], Item3.prototype, "width", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "cssClass", void 0);
    __decorate33([
      Property(false)
    ], Item3.prototype, "showAlwaysInPopup", void 0);
    __decorate33([
      Property(false)
    ], Item3.prototype, "disabled", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "prefixIcon", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "suffixIcon", void 0);
    __decorate33([
      Property(true)
    ], Item3.prototype, "visible", void 0);
    __decorate33([
      Property("None")
    ], Item3.prototype, "overflow", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "template", void 0);
    __decorate33([
      Property("Button")
    ], Item3.prototype, "type", void 0);
    __decorate33([
      Property("Both")
    ], Item3.prototype, "showTextOn", void 0);
    __decorate33([
      Property(null)
    ], Item3.prototype, "htmlAttributes", void 0);
    __decorate33([
      Property("")
    ], Item3.prototype, "tooltipText", void 0);
    __decorate33([
      Property("Left")
    ], Item3.prototype, "align", void 0);
    __decorate33([
      Event()
    ], Item3.prototype, "click", void 0);
    __decorate33([
      Property(-1)
    ], Item3.prototype, "tabIndex", void 0);
    return Item3;
  }(ChildProperty)
);
var Toolbar = (
  /** @class */
  function(_super) {
    __extends34(Toolbar2, _super);
    function Toolbar2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.resizeContext = _this.resize.bind(_this);
      _this.orientationChangeContext = _this.orientationChange.bind(_this);
      _this.keyConfigs = {
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        moveDown: "downarrow",
        popupOpen: "enter",
        popupClose: "escape",
        tab: "tab",
        home: "home",
        end: "end"
      };
      return _this;
    }
    Toolbar2.prototype.destroy = function() {
      var _this = this;
      if (this.isReact || this.isAngular) {
        this.clearTemplate();
      }
      var btnItems = this.element.querySelectorAll(".e-control.e-btn");
      [].slice.call(btnItems).forEach(function(el) {
        if (!isNullOrUndefined(el) && !isNullOrUndefined(el.ej2_instances) && !isNullOrUndefined(el.ej2_instances[0]) && !el.ej2_instances[0].isDestroyed) {
          el.ej2_instances[0].destroy();
        }
      });
      this.unwireEvents();
      this.tempId.forEach(function(ele) {
        if (!isNullOrUndefined(_this.element.querySelector(ele))) {
          document.body.appendChild(_this.element.querySelector(ele)).style.display = "none";
        }
      });
      this.destroyItems();
      while (this.element.lastElementChild) {
        this.element.removeChild(this.element.lastElementChild);
      }
      if (this.trgtEle) {
        this.element.appendChild(this.ctrlTem);
        this.trgtEle = null;
        this.ctrlTem = null;
      }
      if (this.popObj) {
        this.popObj.destroy();
        detach(this.popObj.element);
      }
      if (this.activeEle) {
        this.activeEle = null;
      }
      this.popObj = null;
      this.tbarAlign = null;
      this.tbarItemsCol = [];
      this.remove(this.element, "e-toolpop");
      if (this.cssClass) {
        removeClass([this.element], this.cssClass.split(" "));
      }
      this.element.removeAttribute("style");
      ["aria-disabled", "aria-orientation", "role"].forEach(function(attrb) {
        return _this.element.removeAttribute(attrb);
      });
      _super.prototype.destroy.call(this);
    };
    Toolbar2.prototype.preRender = function() {
      var eventArgs = { enableCollision: this.enableCollision, scrollStep: this.scrollStep };
      this.trigger("beforeCreate", eventArgs);
      this.enableCollision = eventArgs.enableCollision;
      this.scrollStep = eventArgs.scrollStep;
      this.scrollModule = null;
      this.popObj = null;
      this.tempId = [];
      this.tbarItemsCol = this.items;
      this.isVertical = this.element.classList.contains(CLS_VERTICAL) ? true : false;
      this.isExtendedOpen = false;
      this.popupPriCount = 0;
      if (this.enableRtl) {
        this.add(this.element, CLS_RTL3);
      }
    };
    Toolbar2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.clickHandler, this);
      window.addEventListener("resize", this.resizeContext);
      window.addEventListener("orientationchange", this.orientationChangeContext);
      if (this.allowKeyboard) {
        this.wireKeyboardEvent();
      }
    };
    Toolbar2.prototype.wireKeyboardEvent = function() {
      this.keyModule = new KeyboardEvents(this.element, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs
      });
      EventHandler.add(this.element, "keydown", this.docKeyDown, this);
      this.updateTabIndex("0");
    };
    Toolbar2.prototype.updateTabIndex = function(tabIndex) {
      var ele = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE3 + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      if (!isNullOrUndefined(ele) && !isNullOrUndefined(ele.firstElementChild)) {
        var dataTabIndex = ele.firstElementChild.getAttribute("data-tabindex");
        if (dataTabIndex && dataTabIndex === "-1" && ele.firstElementChild.tagName !== "INPUT") {
          ele.firstElementChild.setAttribute("tabindex", tabIndex);
        }
      }
    };
    Toolbar2.prototype.unwireKeyboardEvent = function() {
      if (this.keyModule) {
        EventHandler.remove(this.element, "keydown", this.docKeyDown);
        this.keyModule.destroy();
        this.keyModule = null;
      }
    };
    Toolbar2.prototype.docKeyDown = function(e) {
      if (e.target.tagName === "INPUT") {
        return;
      }
      var popCheck = !isNullOrUndefined(this.popObj) && isVisible(this.popObj.element) && this.overflowMode !== "Extended";
      if (e.keyCode === 9 && e.target.classList.contains("e-hor-nav") === true && popCheck) {
        this.popObj.hide({ name: "FadeOut", duration: 100 });
      }
      var keyCheck = e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 35 || e.keyCode === 36;
      if (keyCheck) {
        e.preventDefault();
      }
    };
    Toolbar2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "click", this.clickHandler);
      this.destroyScroll();
      this.unwireKeyboardEvent();
      window.removeEventListener("resize", this.resizeContext);
      window.removeEventListener("orientationchange", this.orientationChangeContext);
      document.removeEventListener("scroll", this.clickEvent);
      document.removeEventListener("click", this.scrollEvent);
      this.scrollEvent = null;
      this.clickEvent = null;
    };
    Toolbar2.prototype.clearProperty = function() {
      this.tbarEle = [];
      this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
    };
    Toolbar2.prototype.docEvent = function(e) {
      var popEle = closest(e.target, ".e-popup");
      if (this.popObj && isVisible(this.popObj.element) && !popEle && this.overflowMode === "Popup") {
        this.popObj.hide({ name: "FadeOut", duration: 100 });
      }
    };
    Toolbar2.prototype.destroyScroll = function() {
      if (this.scrollModule) {
        if (this.tbarAlign) {
          this.add(this.scrollModule.element, CLS_TBARPOS);
        }
        this.scrollModule.destroy();
        this.scrollModule = null;
      }
    };
    Toolbar2.prototype.destroyItems = function() {
      if (this.element) {
        [].slice.call(this.element.querySelectorAll("." + CLS_ITEM)).forEach(function(el) {
          detach(el);
        });
      }
      if (this.tbarAlign) {
        var tbarItems = this.element.querySelector("." + CLS_ITEMS);
        [].slice.call(tbarItems.children).forEach(function(el) {
          detach(el);
        });
        this.tbarAlign = false;
        this.remove(tbarItems, CLS_TBARPOS);
      }
      this.clearProperty();
    };
    Toolbar2.prototype.destroyMode = function() {
      if (this.scrollModule) {
        this.remove(this.scrollModule.element, CLS_RTL3);
        this.destroyScroll();
      }
      this.remove(this.element, CLS_EXTENDEDPOPOPEN);
      this.remove(this.element, CLS_EXTEANDABLE_TOOLBAR);
      var tempEle = this.element.querySelector(".e-toolbar-multirow");
      if (tempEle) {
        this.remove(tempEle, CLS_MULTIROW);
      }
      if (this.popObj) {
        this.popupRefresh(this.popObj.element, true);
      }
    };
    Toolbar2.prototype.add = function(ele, val) {
      ele.classList.add(val);
    };
    Toolbar2.prototype.remove = function(ele, val) {
      ele.classList.remove(val);
    };
    Toolbar2.prototype.elementFocus = function(ele) {
      var fChild = ele.firstElementChild;
      if (fChild) {
        fChild.focus();
        this.activeEleSwitch(ele);
      } else {
        ele.focus();
      }
    };
    Toolbar2.prototype.clstElement = function(tbrNavChk, trgt) {
      var clst;
      if (tbrNavChk && this.popObj && isVisible(this.popObj.element)) {
        clst = this.popObj.element.querySelector("." + CLS_ITEM);
      } else if (this.element === trgt || tbrNavChk) {
        clst = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE3 + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      } else {
        clst = closest(trgt, "." + CLS_ITEM);
      }
      return clst;
    };
    Toolbar2.prototype.keyHandling = function(clst, e, trgt, navChk, scrollChk) {
      var popObj = this.popObj;
      var rootEle = this.element;
      var popAnimate = { name: "FadeOut", duration: 100 };
      var value = e.action === "moveUp" ? "previous" : "next";
      var ele;
      var nodes;
      switch (e.action) {
        case "moveRight":
          if (this.isVertical) {
            return;
          }
          if (rootEle === trgt) {
            this.elementFocus(clst);
          } else if (!navChk) {
            this.eleFocus(clst, "next");
          }
          break;
        case "moveLeft":
          if (this.isVertical) {
            return;
          }
          if (!navChk) {
            this.eleFocus(clst, "previous");
          }
          break;
        case "home":
        case "end":
          if (clst) {
            var popupCheck = closest(clst, ".e-popup");
            var extendedPopup = this.element.querySelector("." + CLS_EXTENDABLECLASS);
            if (this.overflowMode === "Extended" && extendedPopup && extendedPopup.classList.contains("e-popup-open")) {
              popupCheck = e.action === "end" ? extendedPopup : null;
            }
            if (popupCheck) {
              if (isVisible(this.popObj.element)) {
                nodes = [].slice.call(popupCheck.children);
                if (e.action === "home") {
                  ele = this.focusFirstVisibleEle(nodes);
                } else {
                  ele = this.focusLastVisibleEle(nodes);
                }
              }
            } else {
              nodes = this.element.querySelectorAll("." + CLS_ITEMS + " ." + CLS_ITEM + ":not(." + CLS_SEPARATOR + ")");
              if (e.action === "home") {
                ele = this.focusFirstVisibleEle(nodes);
              } else {
                ele = this.focusLastVisibleEle(nodes);
              }
            }
            if (ele) {
              this.elementFocus(ele);
            }
          }
          break;
        case "moveUp":
        case "moveDown":
          if (!this.isVertical) {
            if (popObj && closest(trgt, ".e-popup")) {
              var popEle = popObj.element;
              var popFrstEle = popEle.firstElementChild;
              if (value === "previous" && popFrstEle === clst) {
                popEle.lastElementChild.firstChild.focus();
              } else if (value === "next" && popEle.lastElementChild === clst) {
                popFrstEle.firstChild.focus();
              } else {
                this.eleFocus(clst, value);
              }
            } else if (e.action === "moveDown" && popObj && isVisible(popObj.element)) {
              this.elementFocus(clst);
            }
          } else {
            if (e.action === "moveUp") {
              this.eleFocus(clst, "previous");
            } else {
              this.eleFocus(clst, "next");
            }
          }
          break;
        case "tab":
          if (!scrollChk && !navChk) {
            var ele_1 = clst.firstElementChild;
            if (rootEle === trgt) {
              if (this.activeEle) {
                this.activeEle.focus();
              } else {
                this.activeEleRemove(ele_1);
                ele_1.focus();
              }
            }
          }
          break;
        case "popupClose":
          if (popObj && this.overflowMode !== "Extended") {
            popObj.hide(popAnimate);
          }
          break;
        case "popupOpen":
          if (!navChk) {
            return;
          }
          if (popObj && !isVisible(popObj.element)) {
            popObj.element.style.top = rootEle.offsetHeight + "px";
            popObj.show({ name: "FadeIn", duration: 100 });
          } else {
            popObj.hide(popAnimate);
          }
          break;
      }
    };
    Toolbar2.prototype.keyActionHandler = function(e) {
      var trgt = e.target;
      if (trgt.tagName === "INPUT" || trgt.tagName === "TEXTAREA" || this.element.classList.contains(CLS_DISABLE3)) {
        return;
      }
      e.preventDefault();
      var tbrNavChk = trgt.classList.contains(CLS_TBARNAV);
      var tbarScrollChk = trgt.classList.contains(CLS_TBARSCRLNAV);
      var clst = this.clstElement(tbrNavChk, trgt);
      if (clst || tbarScrollChk) {
        this.keyHandling(clst, e, trgt, tbrNavChk, tbarScrollChk);
      }
    };
    Toolbar2.prototype.disable = function(value) {
      var rootEle = this.element;
      if (value) {
        rootEle.classList.add(CLS_DISABLE3);
      } else {
        rootEle.classList.remove(CLS_DISABLE3);
      }
      if (this.activeEle) {
        this.activeEle.setAttribute("tabindex", this.activeEle.getAttribute("data-tabindex"));
      }
      if (this.scrollModule) {
        this.scrollModule.disable(value);
      }
      if (this.popObj) {
        if (isVisible(this.popObj.element) && this.overflowMode !== "Extended") {
          this.popObj.hide();
        }
        rootEle.querySelector("#" + rootEle.id + "_nav").setAttribute("tabindex", !value ? "0" : "-1");
      }
    };
    Toolbar2.prototype.eleContains = function(el) {
      return el.classList.contains(CLS_SEPARATOR) || el.classList.contains(CLS_DISABLE3) || el.getAttribute("disabled") || el.classList.contains(CLS_HIDDEN) || !isVisible(el) || !el.classList.contains(CLS_ITEM);
    };
    Toolbar2.prototype.focusFirstVisibleEle = function(nodes) {
      var element2;
      var index = 0;
      while (index < nodes.length) {
        var ele = nodes[parseInt(index.toString(), 10)];
        if (!ele.classList.contains(CLS_HIDDEN) && !ele.classList.contains(CLS_DISABLE3)) {
          return ele;
        }
        index++;
      }
      return element2;
    };
    Toolbar2.prototype.focusLastVisibleEle = function(nodes) {
      var element2;
      var index = nodes.length - 1;
      while (index >= 0) {
        var ele = nodes[parseInt(index.toString(), 10)];
        if (!ele.classList.contains(CLS_HIDDEN) && !ele.classList.contains(CLS_DISABLE3)) {
          return ele;
        }
        index--;
      }
      return element2;
    };
    Toolbar2.prototype.eleFocus = function(closest2, pos) {
      var sib = Object(closest2)[pos + "ElementSibling"];
      if (sib) {
        var skipEle = this.eleContains(sib);
        if (skipEle) {
          this.eleFocus(sib, pos);
          return;
        }
        this.elementFocus(sib);
      } else if (this.tbarAlign) {
        var elem = Object(closest2.parentElement)[pos + "ElementSibling"];
        if (!isNullOrUndefined(elem) && elem.children.length === 0) {
          elem = Object(elem)[pos + "ElementSibling"];
        }
        if (!isNullOrUndefined(elem) && elem.children.length > 0) {
          if (pos === "next") {
            var el = elem.querySelector("." + CLS_ITEM);
            if (this.eleContains(el)) {
              this.eleFocus(el, pos);
            } else {
              el.firstElementChild.focus();
              this.activeEleSwitch(el);
            }
          } else {
            var el = elem.lastElementChild;
            if (this.eleContains(el)) {
              this.eleFocus(el, pos);
            } else {
              this.elementFocus(el);
            }
          }
        }
      } else if (!isNullOrUndefined(closest2)) {
        var tbrItems = this.element.querySelectorAll("." + CLS_ITEMS + " ." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_DISABLE3 + "):not(." + CLS_HIDDEN + ")");
        if (pos === "next" && tbrItems) {
          this.elementFocus(tbrItems[0]);
        } else if (pos === "previous" && tbrItems) {
          this.elementFocus(tbrItems[tbrItems.length - 1]);
        }
      }
    };
    Toolbar2.prototype.clickHandler = function(e) {
      var _this = this;
      var trgt = e.target;
      var ele = this.element;
      var isPopupElement = !isNullOrUndefined(closest(trgt, "." + CLS_POPUPCLASS));
      var clsList = trgt.classList;
      var popupNav = closest(trgt, "." + CLS_TBARNAV);
      if (!popupNav) {
        popupNav = trgt;
      }
      if (!ele.children[0].classList.contains("e-hscroll") && !ele.children[0].classList.contains("e-vscroll") && clsList.contains(CLS_TBARNAV)) {
        clsList = trgt.querySelector(".e-icons").classList;
      }
      if (clsList.contains(CLS_POPUPICON) || clsList.contains(CLS_POPUPDOWN)) {
        this.popupClickHandler(ele, popupNav, CLS_RTL3);
      }
      var itemObj;
      var clst = closest(e.target, "." + CLS_ITEM);
      if ((isNullOrUndefined(clst) || clst.classList.contains(CLS_DISABLE3)) && !popupNav.classList.contains(CLS_TBARNAV)) {
        return;
      }
      if (clst) {
        var tempItem = this.items[this.tbarEle.indexOf(clst)];
        itemObj = tempItem;
      }
      var eventArgs = { originalEvent: e, item: itemObj };
      var isClickBinded = itemObj && !isNullOrUndefined(itemObj.click) && typeof itemObj.click == "object" ? !isNullOrUndefined(itemObj.click.observers) && itemObj.click.observers.length > 0 : !isNullOrUndefined(itemObj) && !isNullOrUndefined(itemObj.click);
      if (isClickBinded) {
        this.trigger("items[" + this.tbarEle.indexOf(clst) + "].click", eventArgs);
      }
      if (!eventArgs.cancel) {
        this.trigger("clicked", eventArgs, function(clickedArgs) {
          if (!isNullOrUndefined(_this.popObj) && isPopupElement && !clickedArgs.cancel && _this.overflowMode === "Popup" && clickedArgs.item && clickedArgs.item.type !== "Input") {
            _this.popObj.hide({ name: "FadeOut", duration: 100 });
          }
        });
      }
    };
    Toolbar2.prototype.popupClickHandler = function(ele, popupNav, CLS_RTL8) {
      var popObj = this.popObj;
      if (isVisible(popObj.element)) {
        popupNav.classList.remove(CLS_TBARNAVACT);
        popObj.hide({ name: "FadeOut", duration: 100 });
      } else {
        if (ele.classList.contains(CLS_RTL8)) {
          popObj.enableRtl = true;
          popObj.position = { X: "left", Y: "top" };
        }
        if (popObj.offsetX === 0 && !ele.classList.contains(CLS_RTL8)) {
          popObj.enableRtl = false;
          popObj.position = { X: "right", Y: "top" };
        }
        if (this.overflowMode === "Extended") {
          popObj.element.style.minHeight = "0px";
          popObj.width = this.getToolbarPopupWidth(this.element);
        }
        popObj.dataBind();
        popObj.refreshPosition();
        popObj.element.style.top = this.getElementOffsetY() + "px";
        popupNav.classList.add(CLS_TBARNAVACT);
        popObj.show({ name: "FadeIn", duration: 100 });
      }
    };
    Toolbar2.prototype.getToolbarPopupWidth = function(ele) {
      var eleStyles = window.getComputedStyle(ele);
      return parseFloat(eleStyles.width) + parseFloat(eleStyles.borderRightWidth) * 2;
    };
    Toolbar2.prototype.render = function() {
      var _this = this;
      this.initialize();
      this.renderControl();
      this.wireEvents();
      this.clickEvent = this.docEvent.bind(this);
      this.scrollEvent = this.docEvent.bind(this);
      this.renderComplete();
      if (this.isReact && this.portals && this.portals.length > 0) {
        this.renderReactTemplates(function() {
          _this.refreshOverflow();
        });
      }
    };
    Toolbar2.prototype.initialize = function() {
      var width = formatUnit(this.width);
      var height = formatUnit(this.height);
      if (Browser.info.name !== "msie" || this.height !== "auto" || this.overflowMode === "MultiRow") {
        setStyleAttribute(this.element, { "height": height });
      }
      setStyleAttribute(this.element, { "width": width });
      var ariaAttr = {
        "role": "toolbar",
        "aria-disabled": "false",
        "aria-orientation": !this.isVertical ? "horizontal" : "vertical"
      };
      attributes(this.element, ariaAttr);
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
      }
    };
    Toolbar2.prototype.renderControl = function() {
      var ele = this.element;
      this.trgtEle = ele.children.length > 0 ? ele.querySelector("div") : null;
      this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
      this.renderItems();
      this.renderLayout();
    };
    Toolbar2.prototype.renderLayout = function() {
      this.renderOverflowMode();
      if (this.tbarAlign) {
        this.itemPositioning();
      }
      if (this.popObj && this.popObj.element.childElementCount > 1 && this.checkPopupRefresh(this.element, this.popObj.element)) {
        this.popupRefresh(this.popObj.element, false);
      }
      this.separator();
    };
    Toolbar2.prototype.itemsAlign = function(items, itemEleDom) {
      var innerItem;
      var innerPos;
      if (!this.tbarEle) {
        this.tbarEle = [];
      }
      for (var i = 0; i < items.length; i++) {
        innerItem = this.renderSubComponent(items[parseInt(i.toString(), 10)], i);
        if (this.tbarEle.indexOf(innerItem) === -1) {
          this.tbarEle.push(innerItem);
        }
        if (!this.tbarAlign) {
          this.tbarItemAlign(items[parseInt(i.toString(), 10)], itemEleDom, i);
        }
        innerPos = itemEleDom.querySelector(".e-toolbar-" + items[parseInt(i.toString(), 10)].align.toLowerCase());
        if (innerPos) {
          if (!(items[parseInt(i.toString(), 10)].showAlwaysInPopup && items[parseInt(i.toString(), 10)].overflow !== "Show")) {
            this.tbarAlgEle[(items[parseInt(i.toString(), 10)].align + "s").toLowerCase()].push(innerItem);
          }
          innerPos.appendChild(innerItem);
        } else {
          itemEleDom.appendChild(innerItem);
        }
      }
      if (this.isReact) {
        var portals = "portals";
        this.notify("render-react-toolbar-template", this["" + portals]);
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.changeOrientation = function() {
      var ele = this.element;
      if (this.isVertical) {
        ele.classList.remove(CLS_VERTICAL);
        this.isVertical = false;
        if (this.height === "auto" || this.height === "100%") {
          ele.style.height = this.height;
        }
        ele.setAttribute("aria-orientation", "horizontal");
      } else {
        ele.classList.add(CLS_VERTICAL);
        this.isVertical = true;
        ele.setAttribute("aria-orientation", "vertical");
        setStyleAttribute(this.element, { "height": formatUnit(this.height), "width": formatUnit(this.width) });
      }
      this.destroyMode();
      this.refreshOverflow();
    };
    Toolbar2.prototype.initScroll = function(element2, innerItems) {
      if (!this.scrollModule && this.checkOverflow(element2, innerItems[0])) {
        if (this.tbarAlign) {
          this.element.querySelector("." + CLS_ITEMS + " ." + CLS_TBARCENTER).removeAttribute("style");
        }
        if (this.isVertical) {
          this.scrollModule = new VScroll({ scrollStep: this.scrollStep, enableRtl: this.enableRtl }, innerItems[0]);
        } else {
          this.scrollModule = new HScroll({ scrollStep: this.scrollStep, enableRtl: this.enableRtl }, innerItems[0]);
        }
        if (this.cssClass) {
          addClass([innerItems[0]], this.cssClass.split(" "));
        }
        var scrollEle = this.scrollModule.element.querySelector("." + CLS_HSCROLLBAR2 + ", .e-vscroll-bar");
        if (scrollEle) {
          scrollEle.removeAttribute("tabindex");
        }
        this.remove(this.scrollModule.element, CLS_TBARPOS);
        setStyleAttribute(this.element, { overflow: "hidden" });
      }
    };
    Toolbar2.prototype.itemWidthCal = function(items) {
      var _this = this;
      var width = 0;
      var style;
      [].slice.call(selectAll("." + CLS_ITEM, items)).forEach(function(el) {
        if (isVisible(el)) {
          style = window.getComputedStyle(el);
          width += _this.isVertical ? el.offsetHeight : el.offsetWidth;
          width += parseFloat(_this.isVertical ? style.marginTop : style.marginRight);
          width += parseFloat(_this.isVertical ? style.marginBottom : style.marginLeft);
        }
      });
      return width;
    };
    Toolbar2.prototype.getScrollCntEle = function(innerItem) {
      var trgClass = this.isVertical ? ".e-vscroll-content" : ".e-hscroll-content";
      return innerItem.querySelector(trgClass);
    };
    Toolbar2.prototype.checkOverflow = function(element2, innerItem) {
      if (isNullOrUndefined(element2) || isNullOrUndefined(innerItem) || !isVisible(element2)) {
        return false;
      }
      var eleWidth = this.isVertical ? element2.offsetHeight : element2.offsetWidth;
      var itemWidth = this.isVertical ? innerItem.offsetHeight : innerItem.offsetWidth;
      if (this.tbarAlign || this.scrollModule || eleWidth === itemWidth) {
        itemWidth = this.itemWidthCal(this.scrollModule ? this.getScrollCntEle(innerItem) : innerItem);
      }
      var popNav = element2.querySelector("." + CLS_TBARNAV);
      var scrollNav = element2.querySelector("." + CLS_TBARSCRLNAV);
      var navEleWidth = 0;
      if (popNav) {
        navEleWidth = this.isVertical ? popNav.offsetHeight : popNav.offsetWidth;
      } else if (scrollNav) {
        navEleWidth = this.isVertical ? scrollNav.offsetHeight * 2 : scrollNav.offsetWidth * 2;
      }
      if (itemWidth > eleWidth - navEleWidth) {
        return true;
      } else {
        return false;
      }
    };
    Toolbar2.prototype.refreshOverflow = function() {
      this.resize();
    };
    Toolbar2.prototype.toolbarAlign = function(innerItems) {
      if (this.tbarAlign) {
        this.add(innerItems, CLS_TBARPOS);
        this.itemPositioning();
      }
    };
    Toolbar2.prototype.renderOverflowMode = function() {
      var ele = this.element;
      var innerItems = ele.querySelector("." + CLS_ITEMS);
      var priorityCheck = this.popupPriCount > 0;
      if (ele && ele.children.length > 0) {
        this.offsetWid = ele.offsetWidth;
        this.remove(this.element, "e-toolpop");
        if (Browser.info.name === "msie" && this.height === "auto") {
          ele.style.height = "";
        }
        switch (this.overflowMode) {
          case "Scrollable":
            if (isNullOrUndefined(this.scrollModule)) {
              this.initScroll(ele, [].slice.call(ele.getElementsByClassName(CLS_ITEMS)));
            }
            break;
          case "Popup":
            this.add(this.element, "e-toolpop");
            if (this.tbarAlign) {
              this.removePositioning();
            }
            if (this.checkOverflow(ele, innerItems) || priorityCheck) {
              this.setOverflowAttributes(ele);
            }
            this.toolbarAlign(innerItems);
            break;
          case "MultiRow":
            this.add(innerItems, CLS_MULTIROW);
            if (this.checkOverflow(ele, innerItems) && this.tbarAlign) {
              this.removePositioning();
              this.add(innerItems, CLS_MULTIROWPOS);
            }
            if (ele.style.overflow === "hidden") {
              ele.style.overflow = "";
            }
            if (Browser.info.name === "msie" || ele.style.height !== "auto") {
              ele.style.height = "auto";
            }
            break;
          case "Extended":
            this.add(this.element, CLS_EXTEANDABLE_TOOLBAR);
            if (this.checkOverflow(ele, innerItems) || priorityCheck) {
              if (this.tbarAlign) {
                this.removePositioning();
              }
              this.setOverflowAttributes(ele);
            }
            this.toolbarAlign(innerItems);
        }
      }
    };
    Toolbar2.prototype.setOverflowAttributes = function(ele) {
      this.createPopupEle(ele, [].slice.call(selectAll("." + CLS_ITEMS + " ." + CLS_ITEM, ele)));
      var ariaAttr = {
        "tabindex": "0",
        "role": "button",
        "aria-haspopup": "true",
        "aria-label": "overflow"
      };
      attributes(this.element.querySelector("." + CLS_TBARNAV), ariaAttr);
    };
    Toolbar2.prototype.separator = function() {
      var element2 = this.element;
      var eleItem = [].slice.call(element2.querySelectorAll("." + CLS_SEPARATOR));
      var multiVar = element2.querySelector("." + CLS_MULTIROW_SEPARATOR);
      var extendVar = element2.querySelector("." + CLS_EXTENDABLE_SEPARATOR);
      var eleInlineItem = this.overflowMode === "MultiRow" ? multiVar : extendVar;
      if (eleInlineItem !== null) {
        if (this.overflowMode === "MultiRow") {
          eleInlineItem.classList.remove(CLS_MULTIROW_SEPARATOR);
        } else if (this.overflowMode === "Extended") {
          eleInlineItem.classList.remove(CLS_EXTENDABLE_SEPARATOR);
        }
      }
      for (var i = 0; i <= eleItem.length - 1; i++) {
        if (eleItem[parseInt(i.toString(), 10)].offsetLeft < 30 && eleItem[parseInt(i.toString(), 10)].offsetLeft !== 0) {
          if (this.overflowMode === "MultiRow") {
            eleItem[parseInt(i.toString(), 10)].classList.add(CLS_MULTIROW_SEPARATOR);
          } else if (this.overflowMode === "Extended") {
            eleItem[parseInt(i.toString(), 10)].classList.add(CLS_EXTENDABLE_SEPARATOR);
          }
        }
      }
    };
    Toolbar2.prototype.createPopupEle = function(ele, innerEle) {
      var innerNav = ele.querySelector("." + CLS_TBARNAV);
      var vertical = this.isVertical;
      if (!innerNav) {
        this.createPopupIcon(ele);
      }
      innerNav = ele.querySelector("." + CLS_TBARNAV);
      var innerNavDom = vertical ? innerNav.offsetHeight : innerNav.offsetWidth;
      var eleWidth = (vertical ? ele.offsetHeight : ele.offsetWidth) - innerNavDom;
      this.element.classList.remove("e-rtl");
      setStyleAttribute(this.element, { direction: "initial" });
      this.checkPriority(ele, innerEle, eleWidth, true);
      if (this.enableRtl) {
        this.element.classList.add("e-rtl");
      }
      this.element.style.removeProperty("direction");
      this.createPopup();
    };
    Toolbar2.prototype.pushingPoppedEle = function(tbarObj, popupPri, ele, eleHeight, sepHeight) {
      var element2 = tbarObj.element;
      var poppedEle = [].slice.call(selectAll("." + CLS_POPUP, element2.querySelector("." + CLS_ITEMS)));
      var nodes = selectAll("." + CLS_TBAROVERFLOW, ele);
      var nodeIndex = 0;
      var nodePri = 0;
      poppedEle.forEach(function(el, index) {
        nodes = selectAll("." + CLS_TBAROVERFLOW, ele);
        if (el.classList.contains(CLS_TBAROVERFLOW) && nodes.length > 0) {
          if (tbarObj.tbResize && nodes.length > index) {
            ele.insertBefore(el, nodes[parseInt(index.toString(), 10)]);
            ++nodePri;
          } else {
            ele.insertBefore(el, ele.children[nodes.length]);
            ++nodePri;
          }
        } else if (el.classList.contains(CLS_TBAROVERFLOW)) {
          ele.insertBefore(el, ele.firstChild);
          ++nodePri;
        } else if (tbarObj.tbResize && el.classList.contains(CLS_POPOVERFLOW) && ele.children.length > 0 && nodes.length === 0) {
          ele.insertBefore(el, ele.firstChild);
          ++nodePri;
        } else if (el.classList.contains(CLS_POPOVERFLOW)) {
          popupPri.push(el);
        } else if (tbarObj.tbResize) {
          ele.insertBefore(el, ele.childNodes[nodeIndex + nodePri]);
          ++nodeIndex;
        } else {
          ele.appendChild(el);
        }
        if (el.classList.contains(CLS_SEPARATOR)) {
          setStyleAttribute(el, { display: "", height: sepHeight + "px" });
        } else {
          setStyleAttribute(el, { display: "", height: eleHeight + "px" });
        }
      });
      popupPri.forEach(function(el) {
        ele.appendChild(el);
      });
      var tbarEle = selectAll("." + CLS_ITEM, element2.querySelector("." + CLS_ITEMS));
      for (var i = tbarEle.length - 1; i >= 0; i--) {
        var tbarElement = tbarEle[parseInt(i.toString(), 10)];
        if (tbarElement.classList.contains(CLS_SEPARATOR) && this.overflowMode !== "Extended") {
          setStyleAttribute(tbarElement, { display: "none" });
        } else {
          break;
        }
      }
    };
    Toolbar2.prototype.createPopup = function() {
      var element2 = this.element;
      var sepHeight;
      var sepItem;
      if (this.overflowMode === "Extended") {
        sepItem = element2.querySelector("." + CLS_SEPARATOR);
        sepHeight = element2.style.height === "auto" || element2.style.height === "" ? null : sepItem && sepItem.offsetHeight;
      }
      var eleItem = element2.querySelector("." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_POPUP + ")");
      var eleHeight = element2.style.height === "auto" || element2.style.height === "" ? null : eleItem && eleItem.offsetHeight;
      var ele;
      var popupPri = [];
      if (select("#" + element2.id + "_popup." + CLS_POPUPCLASS, element2)) {
        ele = select("#" + element2.id + "_popup." + CLS_POPUPCLASS, element2);
      } else {
        var extendEle = this.createElement("div", {
          id: element2.id + "_popup",
          className: CLS_POPUPCLASS + " " + CLS_EXTENDABLECLASS
        });
        var popupEle = this.createElement("div", { id: element2.id + "_popup", className: CLS_POPUPCLASS });
        ele = this.overflowMode === "Extended" ? extendEle : popupEle;
      }
      this.pushingPoppedEle(this, popupPri, ele, eleHeight, sepHeight);
      this.popupInit(element2, ele);
    };
    Toolbar2.prototype.getElementOffsetY = function() {
      return this.overflowMode === "Extended" && window.getComputedStyle(this.element).getPropertyValue("box-sizing") === "border-box" ? this.element.clientHeight : this.element.offsetHeight;
    };
    Toolbar2.prototype.popupInit = function(element2, ele) {
      if (!this.popObj) {
        element2.appendChild(ele);
        if (this.cssClass) {
          addClass([ele], this.cssClass.split(" "));
        }
        setStyleAttribute(this.element, { overflow: "" });
        var popup = new Popup(null, {
          relateTo: this.element,
          offsetY: this.isVertical ? 0 : this.getElementOffsetY(),
          enableRtl: this.enableRtl,
          open: this.popupOpen.bind(this),
          close: this.popupClose.bind(this),
          collision: { Y: this.enableCollision ? "flip" : "none" },
          position: this.enableRtl ? { X: "left", Y: "top" } : { X: "right", Y: "top" }
        });
        if (this.overflowMode === "Extended") {
          popup.width = this.getToolbarPopupWidth(this.element);
          popup.offsetX = 0;
        }
        popup.appendTo(ele);
        document.addEventListener("scroll", this.clickEvent);
        document.addEventListener("click", this.scrollEvent);
        if (this.overflowMode !== "Extended") {
          popup.element.style.maxHeight = popup.element.offsetHeight + "px";
        }
        if (this.isVertical) {
          popup.element.style.visibility = "hidden";
        }
        if (this.isExtendedOpen) {
          var popupNav = this.element.querySelector("." + CLS_TBARNAV);
          popupNav.classList.add(CLS_TBARNAVACT);
          classList(popupNav.firstElementChild, [CLS_POPUPICON], [CLS_POPUPDOWN]);
          this.element.querySelector("." + CLS_EXTENDABLECLASS).classList.add(CLS_POPUPOPEN);
        } else {
          popup.hide();
        }
        this.popObj = popup;
      } else if (this.overflowMode !== "Extended") {
        var popupEle = this.popObj.element;
        setStyleAttribute(popupEle, { maxHeight: "", display: "block" });
        setStyleAttribute(popupEle, { maxHeight: popupEle.offsetHeight + "px", display: "" });
      }
    };
    Toolbar2.prototype.tbarPopupHandler = function(isOpen) {
      if (this.overflowMode === "Extended") {
        if (isOpen) {
          this.add(this.element, CLS_EXTENDEDPOPOPEN);
        } else {
          this.remove(this.element, CLS_EXTENDEDPOPOPEN);
        }
      }
    };
    Toolbar2.prototype.popupOpen = function(e) {
      var popObj = this.popObj;
      if (!this.isVertical) {
        popObj.offsetY = this.getElementOffsetY();
        popObj.dataBind();
      }
      var popupEle = this.popObj.element;
      var toolEle = this.popObj.element.parentElement;
      var popupNav = toolEle.querySelector("." + CLS_TBARNAV);
      popupNav.setAttribute("aria-expanded", "true");
      if (this.overflowMode === "Extended") {
        popObj.element.style.minHeight = "";
      } else {
        setStyleAttribute(popObj.element, { height: "auto", maxHeight: "" });
        popObj.element.style.maxHeight = popObj.element.offsetHeight + "px";
      }
      var popupElePos = popupEle.offsetTop + popupEle.offsetHeight + calculatePosition(toolEle).top;
      var popIcon = popupNav.firstElementChild;
      popupNav.classList.add(CLS_TBARNAVACT);
      classList(popIcon, [CLS_POPUPICON], [CLS_POPUPDOWN]);
      this.tbarPopupHandler(true);
      var scrollVal = isNullOrUndefined(window.scrollY) ? 0 : window.scrollY;
      if (!this.isVertical && window.innerHeight + scrollVal < popupElePos && this.element.offsetTop < popupEle.offsetHeight) {
        var overflowHeight = popupEle.offsetHeight - (popupElePos - window.innerHeight - scrollVal + 5);
        popObj.height = overflowHeight + "px";
        for (var i = 0; i <= popupEle.childElementCount; i++) {
          var ele = popupEle.children[parseInt(i.toString(), 10)];
          if (ele.offsetTop + ele.offsetHeight > overflowHeight) {
            overflowHeight = ele.offsetTop;
            break;
          }
        }
        if (this.overflowMode !== "Extended") {
          setStyleAttribute(popObj.element, { maxHeight: overflowHeight + "px" });
        }
      } else if (this.isVertical && this.overflowMode !== "Extended") {
        var tbEleData = this.element.getBoundingClientRect();
        setStyleAttribute(popObj.element, { maxHeight: tbEleData.top + this.element.offsetHeight + "px", bottom: 0, visibility: "" });
      }
      if (popObj) {
        var popupOffset = popupEle.getBoundingClientRect();
        if (popupOffset.right > document.documentElement.clientWidth && popupOffset.width > toolEle.getBoundingClientRect().width) {
          popObj.collision = { Y: "none" };
          popObj.dataBind();
        }
        popObj.refreshPosition();
      }
    };
    Toolbar2.prototype.popupClose = function(e) {
      var element2 = this.element;
      var popupNav = element2.querySelector("." + CLS_TBARNAV);
      popupNav.setAttribute("aria-expanded", "false");
      var popIcon = popupNav.firstElementChild;
      popupNav.classList.remove(CLS_TBARNAVACT);
      classList(popIcon, [CLS_POPUPDOWN], [CLS_POPUPICON]);
      this.tbarPopupHandler(false);
    };
    Toolbar2.prototype.checkPriority = function(ele, inEle, eleWidth, pre) {
      var popPriority = this.popupPriCount > 0;
      var len = inEle.length;
      var eleWid = eleWidth;
      var eleOffset;
      var checkoffset;
      var sepCheck = 0;
      var itemCount = 0;
      var itemPopCount = 0;
      var checkClass = function(ele2, val) {
        var rVal = false;
        val.forEach(function(cls) {
          if (ele2.classList.contains(cls)) {
            rVal = true;
          }
        });
        return rVal;
      };
      for (var i = len - 1; i >= 0; i--) {
        var mrgn = void 0;
        var compuStyle = window.getComputedStyle(inEle[parseInt(i.toString(), 10)]);
        if (this.isVertical) {
          mrgn = parseFloat(compuStyle.marginTop);
          mrgn += parseFloat(compuStyle.marginBottom);
        } else {
          mrgn = parseFloat(compuStyle.marginRight);
          mrgn += parseFloat(compuStyle.marginLeft);
        }
        var fstEleCheck = inEle[parseInt(i.toString(), 10)] === this.tbarEle[0];
        if (fstEleCheck) {
          this.tbarEleMrgn = mrgn;
        }
        eleOffset = this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth;
        var eleWid_1 = fstEleCheck ? eleOffset + mrgn : eleOffset;
        if (checkClass(inEle[parseInt(i.toString(), 10)], [CLS_POPPRI]) && popPriority) {
          inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
          if (this.isVertical) {
            setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minHeight: eleWid_1 + "px" });
          } else {
            setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minWidth: eleWid_1 + "px" });
          }
          itemPopCount++;
        }
        if (this.isVertical) {
          checkoffset = inEle[parseInt(i.toString(), 10)].offsetTop + inEle[parseInt(i.toString(), 10)].offsetHeight + mrgn > eleWidth;
        } else {
          checkoffset = inEle[parseInt(i.toString(), 10)].offsetLeft + inEle[parseInt(i.toString(), 10)].offsetWidth + mrgn > eleWidth;
        }
        if (checkoffset) {
          if (inEle[parseInt(i.toString(), 10)].classList.contains(CLS_SEPARATOR)) {
            if (this.overflowMode === "Extended") {
              var sepEle = inEle[parseInt(i.toString(), 10)];
              if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
                itemPopCount++;
              }
              itemCount++;
            } else if (this.overflowMode === "Popup") {
              if (sepCheck > 0 && itemCount === itemPopCount) {
                var sepEle = inEle[i + itemCount + (sepCheck - 1)];
                if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                  setStyleAttribute(sepEle, { display: "none" });
                }
              }
              sepCheck++;
              itemCount = 0;
              itemPopCount = 0;
            }
          } else {
            itemCount++;
          }
          if (inEle[parseInt(i.toString(), 10)].classList.contains(CLS_TBAROVERFLOW) && pre) {
            eleWidth -= (this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth) + mrgn;
          } else if (!checkClass(inEle[parseInt(i.toString(), 10)], [CLS_SEPARATOR, CLS_TBARIGNORE])) {
            inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
            if (this.isVertical) {
              setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minHeight: eleWid_1 + "px" });
            } else {
              setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minWidth: eleWid_1 + "px" });
            }
            itemPopCount++;
          } else {
            eleWidth -= (this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth) + mrgn;
          }
        }
      }
      if (pre) {
        var popedEle = selectAll("." + CLS_ITEM + ":not(." + CLS_POPUP + ")", this.element);
        this.checkPriority(ele, popedEle, eleWid, false);
      }
    };
    Toolbar2.prototype.createPopupIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var className = "e-" + element2.id.concat("_nav " + CLS_POPUPNAV);
      className = this.overflowMode === "Extended" ? className + " " + CLS_EXTENDPOPUP : className;
      var nav = this.createElement("div", { id, className });
      if (Browser.info.name === "msie" || Browser.info.name === "edge") {
        nav.classList.add("e-ie-align");
      }
      var navItem = this.createElement("div", { className: CLS_POPUPDOWN + " e-icons" });
      nav.appendChild(navItem);
      nav.setAttribute("tabindex", "0");
      nav.setAttribute("role", "button");
      element2.appendChild(nav);
    };
    Toolbar2.prototype.tbarPriRef = function(inEle, indx, sepPri, el, des, elWid, wid, ig, eleStyles) {
      var ignoreCount = ig;
      var popEle = this.popObj.element;
      var query = "." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_TBAROVERFLOW + ")";
      var priEleCnt = selectAll("." + CLS_POPUP + ":not(." + CLS_TBAROVERFLOW + ")", popEle).length;
      var checkClass = function(ele, val) {
        return ele.classList.contains(val);
      };
      if (selectAll(query, inEle).length === 0) {
        var eleSep = inEle.children[indx - (indx - sepPri) - 1];
        var ignoreCheck = !isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_TBARIGNORE);
        if (!isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_SEPARATOR) && !isVisible(eleSep) || ignoreCheck) {
          eleSep.style.display = "unset";
          var eleSepWidth = eleSep.offsetWidth + parseFloat(window.getComputedStyle(eleSep).marginRight) * 2;
          var prevSep = eleSep.previousElementSibling;
          if (elWid + eleSepWidth < wid || des) {
            inEle.insertBefore(el, inEle.children[indx + ignoreCount - (indx - sepPri)]);
            if (!isNullOrUndefined(prevSep)) {
              prevSep.style.display = "";
            }
          } else {
            setStyleAttribute(el, eleStyles);
            if (prevSep.classList.contains(CLS_SEPARATOR)) {
              prevSep.style.display = "none";
            }
          }
          eleSep.style.display = "";
        } else {
          inEle.insertBefore(el, inEle.children[indx + ignoreCount - (indx - sepPri)]);
        }
      } else {
        inEle.insertBefore(el, inEle.children[indx + ignoreCount - priEleCnt]);
      }
    };
    Toolbar2.prototype.popupRefresh = function(popupEle, destroy3) {
      var _this = this;
      var ele = this.element;
      var isVer = this.isVertical;
      var innerEle = ele.querySelector("." + CLS_ITEMS);
      var popNav = ele.querySelector("." + CLS_TBARNAV);
      if (isNullOrUndefined(popNav)) {
        return;
      }
      innerEle.removeAttribute("style");
      popupEle.style.display = "block";
      var dimension;
      if (isVer) {
        dimension = ele.offsetHeight - (popNav.offsetHeight + innerEle.offsetHeight);
      } else {
        dimension = ele.offsetWidth - (popNav.offsetWidth + innerEle.offsetWidth);
      }
      var popupEleWidth = 0;
      [].slice.call(popupEle.children).forEach(function(el) {
        popupEleWidth += _this.popupEleWidth(el);
        setStyleAttribute(el, { "position": "" });
      });
      if (dimension + (isVer ? popNav.offsetHeight : popNav.offsetWidth) > popupEleWidth && this.popupPriCount === 0) {
        destroy3 = true;
      }
      this.popupEleRefresh(dimension, popupEle, destroy3);
      popupEle.style.display = "";
      if (popupEle.children.length === 0 && popNav && this.popObj) {
        detach(popNav);
        popNav = null;
        this.popObj.destroy();
        detach(this.popObj.element);
        this.popObj = null;
      }
    };
    Toolbar2.prototype.ignoreEleFetch = function(index, innerEle) {
      var ignoreEle = [].slice.call(innerEle.querySelectorAll("." + CLS_TBARIGNORE));
      var ignoreInx = [];
      var count = 0;
      if (ignoreEle.length > 0) {
        ignoreEle.forEach(function(ele) {
          ignoreInx.push([].slice.call(innerEle.children).indexOf(ele));
        });
      } else {
        return 0;
      }
      ignoreInx.forEach(function(val) {
        if (val <= index) {
          count++;
        }
      });
      return count;
    };
    Toolbar2.prototype.checkPopupRefresh = function(root, popEle) {
      popEle.style.display = "block";
      var elWid = this.popupEleWidth(popEle.firstElementChild);
      popEle.firstElementChild.style.removeProperty("Position");
      var tbarWidth = root.offsetWidth - root.querySelector("." + CLS_TBARNAV).offsetWidth;
      var tbarItemsWid = root.querySelector("." + CLS_ITEMS).offsetWidth;
      popEle.style.removeProperty("display");
      if (tbarWidth > elWid + tbarItemsWid) {
        return true;
      }
      return false;
    };
    Toolbar2.prototype.popupEleWidth = function(el) {
      el.style.position = "absolute";
      var elWidth = this.isVertical ? el.offsetHeight : el.offsetWidth;
      var btnText = el.querySelector("." + CLS_TBARBTNTEXT);
      if (el.classList.contains("e-tbtn-align") || el.classList.contains(CLS_TBARTEXT)) {
        var btn = el.children[0];
        if (!isNullOrUndefined(btnText) && el.classList.contains(CLS_TBARTEXT)) {
          btnText.style.display = "none";
        } else if (!isNullOrUndefined(btnText) && el.classList.contains(CLS_POPUPTEXT)) {
          btnText.style.display = "block";
        }
        btn.style.minWidth = "0%";
        elWidth = parseFloat(!this.isVertical ? el.style.minWidth : el.style.minHeight);
        btn.style.minWidth = "";
        btn.style.minHeight = "";
        if (!isNullOrUndefined(btnText)) {
          btnText.style.display = "";
        }
      }
      return elWidth;
    };
    Toolbar2.prototype.popupEleRefresh = function(width, popupEle, destroy3) {
      var popPriority = this.popupPriCount > 0;
      var eleSplice = this.tbarEle;
      var priEleCnt;
      var index;
      var innerEle = this.element.querySelector("." + CLS_ITEMS);
      var ignoreCount = 0;
      var _loop_1 = function(el2) {
        if (el2.classList.contains(CLS_POPPRI) && popPriority && !destroy3) {
          return "continue";
        }
        var elWidth = this_1.popupEleWidth(el2);
        if (el2 === this_1.tbarEle[0]) {
          elWidth += this_1.tbarEleMrgn;
        }
        el2.style.position = "";
        if (elWidth < width || destroy3) {
          var inlineStyles = {
            minWidth: el2.style.minWidth,
            height: el2.style.height,
            minHeight: el2.style.minHeight
          };
          setStyleAttribute(el2, { minWidth: "", height: "", minHeight: "" });
          if (!el2.classList.contains(CLS_POPOVERFLOW)) {
            el2.classList.remove(CLS_POPUP);
          }
          index = this_1.tbarEle.indexOf(el2);
          if (this_1.tbarAlign) {
            var pos = this_1.items[parseInt(index.toString(), 10)].align;
            index = this_1.tbarAlgEle[(pos + "s").toLowerCase()].indexOf(el2);
            eleSplice = this_1.tbarAlgEle[(pos + "s").toLowerCase()];
            innerEle = this_1.element.querySelector("." + CLS_ITEMS + " .e-toolbar-" + pos.toLowerCase());
          }
          var sepBeforePri_1 = 0;
          if (this_1.overflowMode !== "Extended") {
            eleSplice.slice(0, index).forEach(function(el3) {
              if (el3.classList.contains(CLS_TBAROVERFLOW) || el3.classList.contains(CLS_SEPARATOR)) {
                if (el3.classList.contains(CLS_SEPARATOR)) {
                  el3.style.display = "";
                  width -= el3.offsetWidth;
                }
                sepBeforePri_1++;
              }
            });
          }
          ignoreCount = this_1.ignoreEleFetch(index, innerEle);
          if (el2.classList.contains(CLS_TBAROVERFLOW)) {
            this_1.tbarPriRef(innerEle, index, sepBeforePri_1, el2, destroy3, elWidth, width, ignoreCount, inlineStyles);
            width -= el2.offsetWidth;
          } else if (index === 0) {
            innerEle.insertBefore(el2, innerEle.firstChild);
            width -= el2.offsetWidth;
          } else {
            priEleCnt = selectAll("." + CLS_TBAROVERFLOW, this_1.popObj.element).length;
            innerEle.insertBefore(el2, innerEle.children[index + ignoreCount - priEleCnt]);
            width -= el2.offsetWidth;
          }
          el2.style.height = "";
        } else {
          return "break";
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = [].slice.call(popupEle.children); _i < _a.length; _i++) {
        var el = _a[_i];
        var state_1 = _loop_1(el);
        if (state_1 === "break")
          break;
      }
      var checkOverflow = this.checkOverflow(this.element, this.element.getElementsByClassName(CLS_ITEMS)[0]);
      if (checkOverflow && !destroy3) {
        this.renderOverflowMode();
      }
    };
    Toolbar2.prototype.removePositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      if (isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
        return;
      }
      this.remove(item, CLS_TBARPOS);
      var innerItem = [].slice.call(item.childNodes);
      innerItem[1].removeAttribute("style");
      innerItem[2].removeAttribute("style");
    };
    Toolbar2.prototype.refreshPositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      this.add(item, CLS_TBARPOS);
      this.itemPositioning();
    };
    Toolbar2.prototype.itemPositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      var margin;
      if (isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
        return;
      }
      var popupNav = this.element.querySelector("." + CLS_TBARNAV);
      var innerItem;
      if (this.scrollModule) {
        var trgClass = this.isVertical ? CLS_VSCROLLCNT : CLS_HSCROLLCNT;
        innerItem = [].slice.call(item.querySelector("." + trgClass).children);
      } else {
        innerItem = [].slice.call(item.childNodes);
      }
      if (this.isVertical) {
        margin = innerItem[0].offsetHeight + innerItem[2].offsetHeight;
      } else {
        margin = innerItem[0].offsetWidth + innerItem[2].offsetWidth;
      }
      var tbarWid = this.isVertical ? this.element.offsetHeight : this.element.offsetWidth;
      if (popupNav) {
        tbarWid -= this.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth;
        var popWid = (this.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth) + "px";
        innerItem[2].removeAttribute("style");
        if (this.isVertical) {
          if (this.enableRtl) {
            innerItem[2].style.top = popWid;
          } else {
            innerItem[2].style.bottom = popWid;
          }
        } else {
          if (this.enableRtl) {
            innerItem[2].style.left = popWid;
          } else {
            innerItem[2].style.right = popWid;
          }
        }
      }
      if (tbarWid <= margin) {
        return;
      }
      var value = (tbarWid - margin - (!this.isVertical ? innerItem[1].offsetWidth : innerItem[1].offsetHeight)) / 2;
      innerItem[1].removeAttribute("style");
      var mrgn = (!this.isVertical ? innerItem[0].offsetWidth : innerItem[0].offsetHeight) + value + "px";
      if (this.isVertical) {
        if (this.enableRtl) {
          innerItem[1].style.marginBottom = mrgn;
        } else {
          innerItem[1].style.marginTop = mrgn;
        }
      } else {
        if (this.enableRtl) {
          innerItem[1].style.marginRight = mrgn;
        } else {
          innerItem[1].style.marginLeft = mrgn;
        }
      }
    };
    Toolbar2.prototype.tbarItemAlign = function(item, itemEle, pos) {
      var _this = this;
      if (item.showAlwaysInPopup && item.overflow !== "Show") {
        return;
      }
      var alignDiv = [];
      alignDiv.push(this.createElement("div", { className: CLS_TBARLEFT }));
      alignDiv.push(this.createElement("div", { className: CLS_TBARCENTER }));
      alignDiv.push(this.createElement("div", { className: CLS_TBARRIGHT }));
      if (pos === 0 && item.align !== "Left") {
        alignDiv.forEach(function(ele) {
          itemEle.appendChild(ele);
        });
        this.tbarAlign = true;
        this.add(itemEle, CLS_TBARPOS);
      } else if (item.align !== "Left") {
        var alignEle = itemEle.childNodes;
        var leftAlign_1 = alignDiv[0];
        [].slice.call(alignEle).forEach(function(el) {
          _this.tbarAlgEle.lefts.push(el);
          leftAlign_1.appendChild(el);
        });
        itemEle.appendChild(leftAlign_1);
        itemEle.appendChild(alignDiv[1]);
        itemEle.appendChild(alignDiv[2]);
        this.tbarAlign = true;
        this.add(itemEle, CLS_TBARPOS);
      }
    };
    Toolbar2.prototype.ctrlTemplate = function() {
      var _this = this;
      this.ctrlTem = this.trgtEle.cloneNode(true);
      this.add(this.trgtEle, CLS_ITEMS);
      this.tbarEle = [];
      var innerEle = [].slice.call(this.trgtEle.children);
      innerEle.forEach(function(ele) {
        if (ele.tagName === "DIV") {
          _this.tbarEle.push(ele);
          if (!isNullOrUndefined(ele.firstElementChild)) {
            ele.firstElementChild.setAttribute("aria-disabled", "false");
          }
          _this.add(ele, CLS_ITEM);
        }
      });
    };
    Toolbar2.prototype.renderItems = function() {
      var ele = this.element;
      var items = this.items;
      if (this.trgtEle != null) {
        this.ctrlTemplate();
      } else if (ele && items.length > 0) {
        var itemEleDom = void 0;
        if (ele && ele.children.length > 0) {
          itemEleDom = ele.querySelector("." + CLS_ITEMS);
        }
        if (!itemEleDom) {
          itemEleDom = this.createElement("div", { className: CLS_ITEMS });
        }
        this.itemsAlign(items, itemEleDom);
        ele.appendChild(itemEleDom);
      }
    };
    Toolbar2.prototype.setAttr = function(attr, element2) {
      var key = Object.keys(attr);
      var keyVal;
      for (var i = 0; i < key.length; i++) {
        keyVal = key[parseInt(i.toString(), 10)];
        if (keyVal === "class") {
          this.add(element2, attr["" + keyVal]);
        } else {
          element2.setAttribute(keyVal, attr["" + keyVal]);
        }
      }
    };
    Toolbar2.prototype.enableItems = function(items, isEnable) {
      var elements = items;
      var len = elements.length;
      var ele;
      if (isNullOrUndefined(isEnable)) {
        isEnable = true;
      }
      var enable = function(isEnable2, ele2) {
        if (isEnable2) {
          ele2.classList.remove(CLS_DISABLE3);
          if (!isNullOrUndefined(ele2.firstElementChild)) {
            ele2.firstElementChild.setAttribute("aria-disabled", "false");
          }
        } else {
          ele2.classList.add(CLS_DISABLE3);
          if (!isNullOrUndefined(ele2.firstElementChild)) {
            ele2.firstElementChild.setAttribute("aria-disabled", "true");
          }
        }
      };
      if (!isNullOrUndefined(len) && len >= 1) {
        for (var a = 0, element2 = [].slice.call(elements); a < len; a++) {
          var itemElement = element2[parseInt(a.toString(), 10)];
          if (typeof itemElement === "number") {
            ele = this.getElementByIndex(itemElement);
            if (isNullOrUndefined(ele)) {
              return;
            } else {
              elements[parseInt(a.toString(), 10)] = ele;
            }
          } else {
            ele = itemElement;
          }
          enable(isEnable, ele);
        }
        if (isEnable) {
          removeClass(elements, CLS_DISABLE3);
        } else {
          addClass(elements, CLS_DISABLE3);
        }
      } else {
        if (typeof elements === "number") {
          ele = this.getElementByIndex(elements);
          if (isNullOrUndefined(ele)) {
            return;
          }
        } else {
          ele = items;
        }
        enable(isEnable, ele);
      }
    };
    Toolbar2.prototype.getElementByIndex = function(index) {
      if (this.tbarEle[parseInt(index.toString(), 10)]) {
        return this.tbarEle[parseInt(index.toString(), 10)];
      }
      return null;
    };
    Toolbar2.prototype.addItems = function(items, index) {
      var innerItems;
      this.extendedOpen();
      var itemsDiv = this.element.querySelector("." + CLS_ITEMS);
      if (isNullOrUndefined(itemsDiv)) {
        this.itemsRerender(items);
        return;
      }
      var innerEle;
      var itemAgn = "Left";
      if (isNullOrUndefined(index)) {
        index = 0;
      }
      items.forEach(function(e) {
        if (!isNullOrUndefined(e.align) && e.align !== "Left" && itemAgn === "Left") {
          itemAgn = e.align;
        }
      });
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var item = items_1[_i];
        if (isNullOrUndefined(item.type)) {
          item.type = "Button";
        }
        innerItems = selectAll("." + CLS_ITEM, this.element);
        item.align = itemAgn;
        innerEle = this.renderSubComponent(item, index);
        if (this.tbarEle.length >= index && innerItems.length >= 0) {
          if (isNullOrUndefined(this.scrollModule)) {
            this.destroyMode();
          }
          var algIndex = item.align[0] === "L" ? 0 : item.align[0] === "C" ? 1 : 2;
          var ele = void 0;
          if (!this.tbarAlign && itemAgn !== "Left") {
            this.tbarItemAlign(item, itemsDiv, 1);
            this.tbarAlign = true;
            ele = closest(innerItems[0], "." + CLS_ITEMS).children[parseInt(algIndex.toString(), 10)];
            ele.appendChild(innerEle);
            this.tbarAlgEle[(item.align + "s").toLowerCase()].push(innerEle);
            this.refreshPositioning();
          } else if (this.tbarAlign) {
            ele = closest(innerItems[0], "." + CLS_ITEMS).children[parseInt(algIndex.toString(), 10)];
            ele.insertBefore(innerEle, ele.children[parseInt(index.toString(), 10)]);
            this.tbarAlgEle[(item.align + "s").toLowerCase()].splice(index, 0, innerEle);
            this.refreshPositioning();
          } else if (innerItems.length === 0) {
            innerItems = selectAll("." + CLS_ITEMS, this.element);
            innerItems[0].appendChild(innerEle);
          } else {
            innerItems[0].parentNode.insertBefore(innerEle, innerItems[parseInt(index.toString(), 10)]);
          }
          this.items.splice(index, 0, item);
          if (item.template) {
            this.tbarEle.splice(this.tbarEle.length - 1, 1);
          }
          this.tbarEle.splice(index, 0, innerEle);
          index++;
          this.offsetWid = itemsDiv.offsetWidth;
        }
      }
      itemsDiv.style.width = "";
      this.renderOverflowMode();
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.removeItems = function(args) {
      var elements = args;
      var index;
      var innerItems = [].slice.call(selectAll("." + CLS_ITEM, this.element));
      if (typeof elements === "number") {
        index = parseInt(args.toString(), 10);
        this.removeItemByIndex(index, innerItems);
      } else {
        if (elements && elements.length > 1) {
          for (var _i = 0, _a = [].slice.call(elements); _i < _a.length; _i++) {
            var ele = _a[_i];
            index = this.tbarEle.indexOf(ele);
            this.removeItemByIndex(index, innerItems);
            innerItems = selectAll("." + CLS_ITEM, this.element);
          }
        } else {
          var ele = elements && elements.length && elements.length === 1 ? elements[0] : args;
          index = innerItems.indexOf(ele);
          this.removeItemByIndex(index, innerItems);
        }
      }
      this.resize();
    };
    Toolbar2.prototype.removeItemByIndex = function(index, innerItems) {
      if (this.tbarEle[parseInt(index.toString(), 10)] && innerItems[parseInt(index.toString(), 10)]) {
        var eleIdx = this.tbarEle.indexOf(innerItems[parseInt(index.toString(), 10)]);
        if (this.tbarAlign) {
          var indexAgn = this.tbarAlgEle[(this.items[parseInt(eleIdx.toString(), 10)].align + "s").toLowerCase()].indexOf(this.tbarEle[parseInt(eleIdx.toString(), 10)]);
          this.tbarAlgEle[(this.items[parseInt(eleIdx.toString(), 10)].align + "s").toLowerCase()].splice(parseInt(indexAgn.toString(), 10), 1);
        }
        if (this.isReact) {
          this.clearToolbarTemplate(innerItems[parseInt(index.toString(), 10)]);
        }
        var btnItem = innerItems[parseInt(index.toString(), 10)].querySelector(".e-control.e-btn");
        if (!isNullOrUndefined(btnItem) && !isNullOrUndefined(btnItem.ej2_instances[0]) && !btnItem.ej2_instances[0].isDestroyed) {
          btnItem.ej2_instances[0].destroy();
        }
        detach(innerItems[parseInt(index.toString(), 10)]);
        this.items.splice(eleIdx, 1);
        this.tbarEle.splice(eleIdx, 1);
      }
    };
    Toolbar2.prototype.templateRender = function(templateProp, innerEle, item, index) {
      var itemType = item.type;
      var eleObj = templateProp;
      var isComponent;
      if (typeof templateProp === "object") {
        isComponent = typeof eleObj.appendTo === "function";
      }
      if (typeof templateProp === "string" || !isComponent) {
        var templateFn = void 0;
        var val = templateProp;
        var regEx = new RegExp(/<(?=.*? .*?\/ ?>|br|hr|input|!--|wbr)[a-z]+.*?>|<([a-z]+).*?<\/\1>/i);
        val = typeof templateProp === "string" ? templateProp.trim() : templateProp;
        try {
          if (typeof templateProp === "object" && !isNullOrUndefined(templateProp.tagName)) {
            innerEle.appendChild(templateProp);
          } else if (typeof templateProp === "string" && regEx.test(val)) {
            innerEle.innerHTML = val;
          } else if (document.querySelectorAll(val).length) {
            var ele = document.querySelector(val);
            var tempStr = ele.outerHTML.trim();
            innerEle.appendChild(ele);
            ele.style.display = "";
            if (!isNullOrUndefined(tempStr)) {
              this.tempId.push(val);
            }
          } else {
            templateFn = compile(val);
          }
        } catch (e) {
          templateFn = compile(val);
        }
        var tempArray = void 0;
        if (!isNullOrUndefined(templateFn)) {
          var toolbarTemplateID = this.element.id + index + "_template";
          tempArray = templateFn({}, this, "template", toolbarTemplateID, this.isStringTemplate, void 0, void 0, this.root);
        }
        if (!isNullOrUndefined(tempArray) && tempArray.length > 0) {
          [].slice.call(tempArray).forEach(function(ele2) {
            if (!isNullOrUndefined(ele2.tagName)) {
              ele2.style.display = "";
            }
            innerEle.appendChild(ele2);
          });
        }
      } else if (itemType === "Input") {
        var ele = this.createElement("input");
        if (item.id) {
          ele.id = item.id;
        } else {
          ele.id = getUniqueID("tbr-ipt");
        }
        innerEle.appendChild(ele);
        eleObj.appendTo(ele);
      }
      this.add(innerEle, CLS_TEMPLATE);
      var firstChild = innerEle.firstElementChild;
      if (!isNullOrUndefined(firstChild)) {
        firstChild.setAttribute("tabindex", isNullOrUndefined(firstChild.getAttribute("tabIndex")) ? "-1" : this.getDataTabindex(firstChild));
        firstChild.setAttribute("data-tabindex", isNullOrUndefined(firstChild.getAttribute("tabIndex")) ? "-1" : this.getDataTabindex(firstChild));
      }
      this.tbarEle.push(innerEle);
    };
    Toolbar2.prototype.buttonRendering = function(item, innerEle) {
      var dom = this.createElement("button", { className: CLS_TBARBTN });
      dom.setAttribute("type", "button");
      var textStr = item.text;
      var iconCss;
      var iconPos;
      if (item.id) {
        dom.id = item.id;
      } else {
        dom.id = getUniqueID("e-tbr-btn");
      }
      var btnTxt = this.createElement("span", { className: "e-tbar-btn-text" });
      if (textStr) {
        btnTxt.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(textStr) : textStr;
        dom.appendChild(btnTxt);
        dom.classList.add("e-tbtn-txt");
      } else {
        this.add(innerEle, "e-tbtn-align");
      }
      if (item.prefixIcon || item.suffixIcon) {
        if (item.prefixIcon && item.suffixIcon || item.prefixIcon) {
          iconCss = item.prefixIcon + " e-icons";
          iconPos = "Left";
        } else {
          iconCss = item.suffixIcon + " e-icons";
          iconPos = "Right";
        }
      }
      var btnObj = new Button({ iconCss, iconPosition: iconPos });
      btnObj.createElement = this.createElement;
      btnObj.appendTo(dom);
      if (item.width) {
        setStyleAttribute(dom, { "width": formatUnit(item.width) });
      }
      return dom;
    };
    Toolbar2.prototype.renderSubComponent = function(item, index) {
      var dom;
      var innerEle = this.createElement("div", { className: CLS_ITEM });
      var tempDom = this.createElement("div", {
        innerHTML: this.enableHtmlSanitizer && !isNullOrUndefined(item.tooltipText) ? SanitizeHtmlHelper.sanitize(item.tooltipText) : item.tooltipText
      });
      if (!this.tbarEle) {
        this.tbarEle = [];
      }
      if (item.htmlAttributes) {
        this.setAttr(item.htmlAttributes, innerEle);
      }
      if (item.tooltipText) {
        innerEle.setAttribute("title", tempDom.textContent);
      }
      if (item.cssClass) {
        innerEle.className = innerEle.className + " " + item.cssClass;
      }
      if (item.template) {
        this.templateRender(item.template, innerEle, item, index);
      } else {
        switch (item.type) {
          case "Button":
            dom = this.buttonRendering(item, innerEle);
            dom.setAttribute("tabindex", isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString());
            dom.setAttribute("data-tabindex", isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString());
            dom.setAttribute("aria-label", item.text || item.tooltipText);
            dom.setAttribute("aria-disabled", "false");
            innerEle.appendChild(dom);
            innerEle.addEventListener("click", this.itemClick.bind(this));
            break;
          case "Separator":
            this.add(innerEle, CLS_SEPARATOR);
            break;
        }
      }
      if (item.showTextOn) {
        var sTxt = item.showTextOn;
        if (sTxt === "Toolbar") {
          this.add(innerEle, CLS_POPUPTEXT);
          this.add(innerEle, "e-tbtn-align");
        } else if (sTxt === "Overflow") {
          this.add(innerEle, CLS_TBARTEXT);
        }
      }
      if (item.overflow) {
        var overflow = item.overflow;
        if (overflow === "Show") {
          this.add(innerEle, CLS_TBAROVERFLOW);
        } else if (overflow === "Hide") {
          if (!innerEle.classList.contains(CLS_SEPARATOR)) {
            this.add(innerEle, CLS_POPOVERFLOW);
          }
        }
      }
      if (item.overflow !== "Show" && item.showAlwaysInPopup && !innerEle.classList.contains(CLS_SEPARATOR)) {
        this.add(innerEle, CLS_POPPRI);
        this.popupPriCount++;
      }
      if (item.disabled) {
        this.add(innerEle, CLS_DISABLE3);
      }
      if (item.visible === false) {
        this.add(innerEle, CLS_HIDDEN);
      }
      return innerEle;
    };
    Toolbar2.prototype.getDataTabindex = function(ele) {
      return isNullOrUndefined(ele.getAttribute("data-tabindex")) ? "-1" : ele.getAttribute("data-tabindex");
    };
    Toolbar2.prototype.itemClick = function(e) {
      this.activeEleSwitch(e.currentTarget);
    };
    Toolbar2.prototype.activeEleSwitch = function(ele) {
      this.activeEleRemove(ele.firstElementChild);
      this.activeEle.focus();
    };
    Toolbar2.prototype.activeEleRemove = function(curEle) {
      var previousEle = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE3 + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      if (!isNullOrUndefined(this.activeEle)) {
        this.activeEle.setAttribute("tabindex", this.getDataTabindex(this.activeEle));
        if (previousEle) {
          previousEle.removeAttribute("tabindex");
        }
        previousEle = this.activeEle;
      }
      this.activeEle = curEle;
      if (this.getDataTabindex(this.activeEle) === "-1") {
        if (isNullOrUndefined(this.trgtEle) && !curEle.parentElement.classList.contains(CLS_TEMPLATE)) {
          if (!isNullOrUndefined(this.element.querySelector(".e-hor-nav")) && this.element.querySelector(".e-hor-nav").classList.contains("e-nav-active")) {
            this.updateTabIndex("0");
            var tabindexValue = this.getDataTabindex(previousEle) === "-1" ? "0" : this.getDataTabindex(previousEle);
            previousEle.setAttribute("tabindex", tabindexValue);
          } else {
            this.updateTabIndex("-1");
          }
          curEle.removeAttribute("tabindex");
        } else {
          var tabIndex = parseInt(this.getDataTabindex(this.activeEle), 10) + 1;
          this.activeEle.setAttribute("tabindex", tabIndex.toString());
        }
      }
    };
    Toolbar2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Toolbar2.prototype.getModuleName = function() {
      return "toolbar";
    };
    Toolbar2.prototype.itemsRerender = function(newProp) {
      this.items = this.tbarItemsCol;
      if (this.isReact || this.isAngular) {
        this.clearTemplate();
      }
      this.destroyMode();
      this.destroyItems();
      this.items = newProp;
      this.tbarItemsCol = this.items;
      this.renderItems();
      this.renderOverflowMode();
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.resize = function() {
      var ele = this.element;
      this.tbResize = true;
      if (this.tbarAlign) {
        this.itemPositioning();
      }
      if (this.popObj && this.overflowMode === "Popup") {
        this.popObj.hide();
      }
      var checkOverflow = this.checkOverflow(ele, ele.getElementsByClassName(CLS_ITEMS)[0]);
      if (!checkOverflow) {
        this.destroyScroll();
        var multirowele = ele.querySelector("." + CLS_ITEMS);
        if (!isNullOrUndefined(multirowele)) {
          this.remove(multirowele, CLS_MULTIROWPOS);
          if (this.tbarAlign) {
            this.add(multirowele, CLS_TBARPOS);
          }
        }
      }
      if (checkOverflow && this.scrollModule && this.offsetWid === ele.offsetWidth) {
        return;
      }
      if (this.offsetWid > ele.offsetWidth || checkOverflow) {
        this.renderOverflowMode();
      }
      if (this.popObj) {
        if (this.overflowMode === "Extended") {
          this.popObj.width = this.getToolbarPopupWidth(this.element);
        }
        if (this.tbarAlign) {
          this.removePositioning();
        }
        this.popupRefresh(this.popObj.element, false);
        if (this.tbarAlign) {
          this.refreshPositioning();
        }
      }
      if (this.element.querySelector("." + CLS_HSCROLLBAR2)) {
        this.scrollStep = this.element.querySelector("." + CLS_HSCROLLBAR2).offsetWidth;
      }
      this.offsetWid = ele.offsetWidth;
      this.tbResize = false;
      this.separator();
    };
    Toolbar2.prototype.orientationChange = function() {
      var _this = this;
      setTimeout(function() {
        _this.resize();
      }, 500);
    };
    Toolbar2.prototype.extendedOpen = function() {
      var sib = this.element.querySelector("." + CLS_EXTENDABLECLASS);
      if (this.overflowMode === "Extended" && sib) {
        this.isExtendedOpen = sib.classList.contains(CLS_POPUPOPEN);
      }
    };
    Toolbar2.prototype.updateHideEleTabIndex = function(ele, isHidden, isElement, eleIndex, innerItems) {
      if (isElement) {
        eleIndex = innerItems.indexOf(ele);
      }
      var nextEle = innerItems[++eleIndex];
      while (nextEle) {
        var skipEle = this.eleContains(nextEle);
        if (!skipEle) {
          var dataTabIndex = nextEle.firstElementChild.getAttribute("data-tabindex");
          if (isHidden && dataTabIndex === "-1") {
            nextEle.firstElementChild.setAttribute("tabindex", "0");
          } else if (dataTabIndex !== nextEle.firstElementChild.getAttribute("tabindex")) {
            nextEle.firstElementChild.setAttribute("tabindex", dataTabIndex);
          }
          break;
        }
        nextEle = innerItems[++eleIndex];
      }
    };
    Toolbar2.prototype.clearToolbarTemplate = function(templateEle) {
      if (this.registeredTemplate && this.registeredTemplate["template"]) {
        var registeredTemplates = this.registeredTemplate;
        for (var index = 0; index < registeredTemplates["template"].length; index++) {
          var registeredItem = registeredTemplates["template"][parseInt(index.toString(), 10)].rootNodes[0];
          var closestItem = closest(registeredItem, "." + CLS_ITEM);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate(["template"], [registeredTemplates["template"][parseInt(index.toString(), 10)]]);
            break;
          }
        }
      } else if (this.portals && this.portals.length > 0) {
        var portals = this.portals;
        for (var index = 0; index < portals.length; index++) {
          var portalItem = portals[parseInt(index.toString(), 10)];
          var closestItem = closest(portalItem.containerInfo, "." + CLS_ITEM);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate(["template"], index);
            break;
          }
        }
      }
    };
    Toolbar2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var tEle = this.element;
      this.extendedOpen();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "items":
            if (!(newProp.items instanceof Array && oldProp.items instanceof Array)) {
              var changedProb = Object.keys(newProp.items);
              for (var i = 0; i < changedProb.length; i++) {
                var index = parseInt(Object.keys(newProp.items)[parseInt(i.toString(), 10)], 10);
                var property = Object.keys(newProp.items[parseInt(index.toString(), 10)])[0];
                var newProperty = Object(newProp.items[parseInt(index.toString(), 10)])["" + property];
                if (this.tbarAlign || property === "align") {
                  this.refresh();
                  this.trigger("created");
                  break;
                }
                var popupPriCheck = property === "showAlwaysInPopup" && !newProperty;
                var booleanCheck = property === "overflow" && this.popupPriCount !== 0;
                if (popupPriCheck || this.items[parseInt(index.toString(), 10)].showAlwaysInPopup && booleanCheck) {
                  --this.popupPriCount;
                }
                if (isNullOrUndefined(this.scrollModule)) {
                  this.destroyMode();
                }
                var itemCol = [].slice.call(selectAll("." + CLS_ITEMS + " ." + CLS_ITEM, tEle));
                if (this.isReact && this.items[parseInt(index.toString(), 10)].template) {
                  this.clearToolbarTemplate(itemCol[parseInt(index.toString(), 10)]);
                }
                detach(itemCol[parseInt(index.toString(), 10)]);
                this.tbarEle.splice(index, 1);
                this.addItems([this.items[parseInt(index.toString(), 10)]], index);
                this.items.splice(index, 1);
                if (this.items[parseInt(index.toString(), 10)].template) {
                  this.tbarEle.splice(this.items.length, 1);
                }
              }
            } else {
              this.itemsRerender(newProp.items);
            }
            break;
          case "width":
            setStyleAttribute(tEle, { "width": formatUnit(newProp.width) });
            this.refreshOverflow();
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            break;
          case "overflowMode":
            this.destroyMode();
            this.renderOverflowMode();
            if (this.enableRtl) {
              this.add(tEle, CLS_RTL3);
            }
            this.refreshOverflow();
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.add(tEle, CLS_RTL3);
            } else {
              this.remove(tEle, CLS_RTL3);
            }
            if (!isNullOrUndefined(this.scrollModule)) {
              if (newProp.enableRtl) {
                this.add(this.scrollModule.element, CLS_RTL3);
              } else {
                this.remove(this.scrollModule.element, CLS_RTL3);
              }
            }
            if (!isNullOrUndefined(this.popObj)) {
              if (newProp.enableRtl) {
                this.add(this.popObj.element, CLS_RTL3);
              } else {
                this.remove(this.popObj.element, CLS_RTL3);
              }
            }
            if (this.tbarAlign) {
              this.itemPositioning();
            }
            break;
          case "scrollStep":
            if (this.scrollModule) {
              this.scrollModule.scrollStep = this.scrollStep;
            }
            break;
          case "enableCollision":
            if (this.popObj) {
              this.popObj.collision = { Y: this.enableCollision ? "flip" : "none" };
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.split(" "));
            }
            break;
          case "allowKeyboard":
            this.unwireKeyboardEvent();
            if (newProp.allowKeyboard) {
              this.wireKeyboardEvent();
            }
            break;
        }
      }
    };
    Toolbar2.prototype.hideItem = function(index, value) {
      var isElement = typeof index === "object" ? true : false;
      var eleIndex = index;
      var ele;
      if (!isElement && isNullOrUndefined(eleIndex)) {
        return;
      }
      var innerItems = [].slice.call(selectAll("." + CLS_ITEM, this.element));
      if (isElement) {
        ele = index;
      } else if (this.tbarEle[parseInt(eleIndex.toString(), 10)]) {
        var innerItems_1 = [].slice.call(selectAll("." + CLS_ITEM, this.element));
        ele = innerItems_1[parseInt(eleIndex.toString(), 10)];
      }
      if (ele) {
        if (value) {
          ele.classList.add(CLS_HIDDEN);
          if (!ele.classList.contains(CLS_SEPARATOR)) {
            if (isNullOrUndefined(ele.firstElementChild.getAttribute("tabindex")) || ele.firstElementChild.getAttribute("tabindex") !== "-1") {
              this.updateHideEleTabIndex(ele, value, isElement, eleIndex, innerItems);
            }
          }
        } else {
          ele.classList.remove(CLS_HIDDEN);
          if (!ele.classList.contains(CLS_SEPARATOR)) {
            this.updateHideEleTabIndex(ele, value, isElement, eleIndex, innerItems);
          }
        }
        this.refreshOverflow();
      }
    };
    __decorate33([
      Collection([], Item2)
    ], Toolbar2.prototype, "items", void 0);
    __decorate33([
      Property("auto")
    ], Toolbar2.prototype, "width", void 0);
    __decorate33([
      Property("auto")
    ], Toolbar2.prototype, "height", void 0);
    __decorate33([
      Property("")
    ], Toolbar2.prototype, "cssClass", void 0);
    __decorate33([
      Property("Scrollable")
    ], Toolbar2.prototype, "overflowMode", void 0);
    __decorate33([
      Property()
    ], Toolbar2.prototype, "scrollStep", void 0);
    __decorate33([
      Property(true)
    ], Toolbar2.prototype, "enableCollision", void 0);
    __decorate33([
      Property(true)
    ], Toolbar2.prototype, "enableHtmlSanitizer", void 0);
    __decorate33([
      Property(true)
    ], Toolbar2.prototype, "allowKeyboard", void 0);
    __decorate33([
      Event()
    ], Toolbar2.prototype, "clicked", void 0);
    __decorate33([
      Event()
    ], Toolbar2.prototype, "created", void 0);
    __decorate33([
      Event()
    ], Toolbar2.prototype, "destroyed", void 0);
    __decorate33([
      Event()
    ], Toolbar2.prototype, "beforeCreate", void 0);
    Toolbar2 = __decorate33([
      NotifyPropertyChanges
    ], Toolbar2);
    return Toolbar2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/accordion/accordion.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ACRDN_ROOT = "e-acrdn-root";
var CLS_ROOT3 = "e-accordion";
var CLS_ITEM2 = "e-acrdn-item";
var CLS_ITEMFOCUS = "e-item-focus";
var CLS_ITEMHIDE = "e-hide";
var CLS_HEADER = "e-acrdn-header";
var CLS_HEADERICN = "e-acrdn-header-icon";
var CLS_HEADERCTN = "e-acrdn-header-content";
var CLS_CONTENT = "e-acrdn-panel";
var CLS_CTENT = "e-acrdn-content";
var CLS_TOOGLEICN = "e-toggle-icon";
var CLS_COLLAPSEICN = "e-tgl-collapse-icon e-icons";
var CLS_EXPANDICN = "e-expand-icon";
var CLS_RTL4 = "e-rtl";
var CLS_CTNHIDE = "e-content-hide";
var CLS_SLCT = "e-select";
var CLS_SLCTED = "e-selected";
var CLS_ACTIVE = "e-active";
var CLS_ANIMATE = "e-animate";
var CLS_DISABLE4 = "e-overlay";
var CLS_TOGANIMATE = "e-toggle-animation";
var CLS_NEST = "e-nested";
var CLS_EXPANDSTATE = "e-expand-state";
var CLS_CONTAINER = "e-accordion-container";
var AccordionActionSettings = (
  /** @class */
  function(_super) {
    __extends35(AccordionActionSettings2, _super);
    function AccordionActionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate34([
      Property("SlideDown")
    ], AccordionActionSettings2.prototype, "effect", void 0);
    __decorate34([
      Property(400)
    ], AccordionActionSettings2.prototype, "duration", void 0);
    __decorate34([
      Property("linear")
    ], AccordionActionSettings2.prototype, "easing", void 0);
    return AccordionActionSettings2;
  }(ChildProperty)
);
var AccordionAnimationSettings = (
  /** @class */
  function(_super) {
    __extends35(AccordionAnimationSettings2, _super);
    function AccordionAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate34([
      Complex({ effect: "SlideUp", duration: 400, easing: "linear" }, AccordionActionSettings)
    ], AccordionAnimationSettings2.prototype, "collapse", void 0);
    __decorate34([
      Complex({ effect: "SlideDown", duration: 400, easing: "linear" }, AccordionActionSettings)
    ], AccordionAnimationSettings2.prototype, "expand", void 0);
    return AccordionAnimationSettings2;
  }(ChildProperty)
);
var AccordionItem = (
  /** @class */
  function(_super) {
    __extends35(AccordionItem2, _super);
    function AccordionItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate34([
      Property(null)
    ], AccordionItem2.prototype, "content", void 0);
    __decorate34([
      Property(null)
    ], AccordionItem2.prototype, "header", void 0);
    __decorate34([
      Property(null)
    ], AccordionItem2.prototype, "cssClass", void 0);
    __decorate34([
      Property(null)
    ], AccordionItem2.prototype, "iconCss", void 0);
    __decorate34([
      Property(false)
    ], AccordionItem2.prototype, "expanded", void 0);
    __decorate34([
      Property(true)
    ], AccordionItem2.prototype, "visible", void 0);
    __decorate34([
      Property(false)
    ], AccordionItem2.prototype, "disabled", void 0);
    __decorate34([
      Property()
    ], AccordionItem2.prototype, "id", void 0);
    return AccordionItem2;
  }(ChildProperty)
);
var Accordion = (
  /** @class */
  function(_super) {
    __extends35(Accordion2, _super);
    function Accordion2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.keyConfigs = {
        moveUp: "uparrow",
        moveDown: "downarrow",
        enter: "enter",
        space: "space",
        home: "home",
        end: "end"
      };
      return _this;
    }
    Accordion2.prototype.destroy = function() {
      if (this.isReact || this.isAngular || this.isVue) {
        this.clearTemplate();
      }
      var ele = this.element;
      _super.prototype.destroy.call(this);
      this.unWireEvents();
      this.isDestroy = true;
      this.restoreContent(null);
      [].slice.call(ele.children).forEach(function(el) {
        ele.removeChild(el);
      });
      if (this.trgtEle) {
        this.trgtEle = null;
        while (this.ctrlTem.firstElementChild) {
          ele.appendChild(this.ctrlTem.firstElementChild);
        }
        this.ctrlTem = null;
      }
      ele.classList.remove(CLS_ACRDN_ROOT);
      ele.removeAttribute("style");
      this.element.removeAttribute("data-ripple");
      if (!this.isNested && isRippleEnabled) {
        this.removeRippleEffect();
      }
    };
    Accordion2.prototype.preRender = function() {
      var nested = closest(this.element, "." + CLS_CONTENT);
      this.isNested = false;
      this.templateEle = [];
      if (!this.isDestroy) {
        this.isDestroy = false;
      }
      if (nested && nested.firstElementChild && nested.firstElementChild.firstElementChild) {
        if (nested.firstElementChild.firstElementChild.classList.contains(CLS_ROOT3)) {
          nested.classList.add(CLS_NEST);
          this.isNested = true;
        }
      } else {
        this.element.classList.add(CLS_ACRDN_ROOT);
      }
      if (this.enableRtl) {
        this.add(this.element, CLS_RTL4);
      }
    };
    Accordion2.prototype.add = function(ele, val) {
      ele.classList.add(val);
    };
    Accordion2.prototype.remove = function(ele, val) {
      ele.classList.remove(val);
    };
    Accordion2.prototype.render = function() {
      this.initializeHeaderTemplate();
      this.initializeItemTemplate();
      this.initialize();
      this.renderControl();
      this.wireEvents();
      this.renderComplete();
    };
    Accordion2.prototype.initialize = function() {
      var width = formatUnit(this.width);
      var height = formatUnit(this.height);
      setStyleAttribute(this.element, { "width": width, "height": height });
      if (isNullOrUndefined(this.initExpand)) {
        this.initExpand = [];
      }
      if (!isNullOrUndefined(this.expandedIndices) && this.expandedIndices.length > 0) {
        this.initExpand = this.expandedIndices;
      }
    };
    Accordion2.prototype.renderControl = function() {
      this.trgtEle = this.element.children.length > 0 ? select("div", this.element) : null;
      this.renderItems();
      this.initItemExpand();
    };
    Accordion2.prototype.wireFocusEvents = function() {
      var acrdItem = [].slice.call(this.element.querySelectorAll("." + CLS_ITEM2));
      for (var _i = 0, acrdItem_1 = acrdItem; _i < acrdItem_1.length; _i++) {
        var item = acrdItem_1[_i];
        var headerEle = item.querySelector("." + CLS_HEADER);
        if (item.childElementCount > 0 && headerEle) {
          EventHandler.clearEvents(headerEle);
          EventHandler.add(headerEle, "focus", this.focusIn, this);
          EventHandler.add(headerEle, "blur", this.focusOut, this);
        }
      }
    };
    Accordion2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "click", this.clickHandler);
      if (!isNullOrUndefined(this.keyModule)) {
        this.keyModule.destroy();
      }
    };
    Accordion2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.clickHandler, this);
      if (!this.isNested && !this.isDestroy) {
        this.removeRippleEffect = rippleEffect(this.element, { selector: "." + CLS_HEADER });
      }
      if (!this.isNested) {
        this.keyModule = new KeyboardEvents(this.element, {
          keyAction: this.keyActionHandler.bind(this),
          keyConfigs: this.keyConfigs,
          eventName: "keydown"
        });
      }
    };
    Accordion2.prototype.templateParser = function(template) {
      if (template) {
        try {
          if (typeof template !== "function" && document.querySelectorAll(template).length) {
            return compile(document.querySelector(template).innerHTML.trim());
          } else {
            return compile(template);
          }
        } catch (error) {
          return compile(template);
        }
      }
      return void 0;
    };
    Accordion2.prototype.initializeHeaderTemplate = function() {
      if (this.headerTemplate) {
        this.headerTemplateFn = this.templateParser(this.headerTemplate);
      }
    };
    Accordion2.prototype.initializeItemTemplate = function() {
      if (this.itemTemplate) {
        this.itemTemplateFn = this.templateParser(this.itemTemplate);
      }
    };
    Accordion2.prototype.getHeaderTemplate = function() {
      return this.headerTemplateFn;
    };
    Accordion2.prototype.getItemTemplate = function() {
      return this.itemTemplateFn;
    };
    Accordion2.prototype.focusIn = function(e) {
      e.target.parentElement.classList.add(CLS_ITEMFOCUS);
    };
    Accordion2.prototype.focusOut = function(e) {
      e.target.parentElement.classList.remove(CLS_ITEMFOCUS);
    };
    Accordion2.prototype.ctrlTemplate = function() {
      this.ctrlTem = this.element.cloneNode(true);
      var innerEles;
      var rootEle = select("." + CLS_CONTAINER, this.element);
      if (rootEle) {
        innerEles = rootEle.children;
      } else {
        innerEles = this.element.children;
      }
      var items = [];
      [].slice.call(innerEles).forEach(function(el) {
        items.push({
          header: el.childElementCount > 0 && el.children[0] ? el.children[0] : "",
          content: el.childElementCount > 1 && el.children[1] ? el.children[1] : ""
        });
        el.parentNode.removeChild(el);
      });
      if (rootEle) {
        this.element.removeChild(rootEle);
      }
      this.setProperties({ items }, true);
    };
    Accordion2.prototype.toggleIconGenerate = function() {
      var tglIcon = this.createElement("div", { className: CLS_TOOGLEICN });
      var hdrColIcon = this.createElement("span", { className: CLS_COLLAPSEICN });
      tglIcon.appendChild(hdrColIcon);
      return tglIcon;
    };
    Accordion2.prototype.initItemExpand = function() {
      var len = this.initExpand.length;
      if (len === 0) {
        return;
      }
      if (this.expandMode === "Single") {
        this.expandItem(true, this.initExpand[len - 1]);
      } else {
        for (var i = 0; i < len; i++) {
          this.expandItem(true, this.initExpand[parseInt(i.toString(), 10)]);
        }
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.renderItems = function() {
      var _this = this;
      var ele = this.element;
      var innerItem;
      var innerDataSourceItem;
      if (!isNullOrUndefined(this.trgtEle)) {
        this.ctrlTemplate();
      }
      if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0) {
        this.dataSource.forEach(function(item, index) {
          innerDataSourceItem = _this.renderInnerItem(item, index);
          ele.appendChild(innerDataSourceItem);
          if (innerDataSourceItem.childElementCount > 0) {
            EventHandler.add(innerDataSourceItem.querySelector("." + CLS_HEADER), "focus", _this.focusIn, _this);
            EventHandler.add(innerDataSourceItem.querySelector("." + CLS_HEADER), "blur", _this.focusOut, _this);
          }
        });
      } else {
        var items = this.items;
        if (ele && items.length > 0) {
          items.forEach(function(item, index) {
            innerItem = _this.renderInnerItem(item, index);
            ele.appendChild(innerItem);
            if (innerItem.childElementCount > 0) {
              EventHandler.add(innerItem.querySelector("." + CLS_HEADER), "focus", _this.focusIn, _this);
              EventHandler.add(innerItem.querySelector("." + CLS_HEADER), "blur", _this.focusOut, _this);
            }
          });
        }
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.clickHandler = function(e) {
      var trgt = e.target;
      var items = this.getItems();
      var eventArgs = {};
      var tglIcon;
      var acrdEle = closest(trgt, "." + CLS_ROOT3);
      if (acrdEle !== this.element) {
        return;
      }
      trgt.classList.add("e-target");
      var acrdnItem = closest(trgt, "." + CLS_ITEM2);
      var acrdnHdr = closest(trgt, "." + CLS_HEADER);
      var acrdnCtn = closest(trgt, "." + CLS_CONTENT);
      if (acrdnItem && (isNullOrUndefined(acrdnHdr) || isNullOrUndefined(acrdnCtn))) {
        acrdnHdr = acrdnItem.children[0];
        acrdnCtn = acrdnItem.children[1];
      }
      if (acrdnHdr) {
        tglIcon = select("." + CLS_TOOGLEICN, acrdnHdr);
      }
      var acrdnCtnItem;
      if (acrdnHdr) {
        acrdnCtnItem = closest(acrdnHdr, "." + CLS_ITEM2);
      } else if (acrdnCtn) {
        acrdnCtnItem = closest(acrdnCtn, "." + CLS_ITEM2);
      }
      var index = this.getIndexByItem(acrdnItem);
      if (acrdnCtnItem) {
        eventArgs.item = items[this.getIndexByItem(acrdnCtnItem)];
      }
      eventArgs.originalEvent = e;
      var ctnCheck = !isNullOrUndefined(tglIcon) && acrdnItem.childElementCount <= 1;
      if (ctnCheck && (isNullOrUndefined(acrdnCtn) || !isNullOrUndefined(select("." + CLS_HEADER + " ." + CLS_TOOGLEICN, acrdnCtnItem)))) {
        acrdnItem.appendChild(this.contentRendering(index));
        this.ariaAttrUpdate(acrdnItem);
        this.afterContentRender(trgt, eventArgs, acrdnItem, acrdnHdr, acrdnCtn, acrdnCtnItem);
      } else {
        this.afterContentRender(trgt, eventArgs, acrdnItem, acrdnHdr, acrdnCtn, acrdnCtnItem);
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.afterContentRender = function(trgt, eventArgs, acrdnItem, acrdnHdr, acrdnCtn, acrdnCtnItem) {
      var _this = this;
      var acrdActive = [];
      this.trigger("clicked", eventArgs);
      var cntclkCheck = acrdnCtn && !isNullOrUndefined(select(".e-target", acrdnCtn));
      var inlineAcrdnSel = "." + CLS_CONTENT + " ." + CLS_ROOT3;
      var inlineEleAcrdn = acrdnCtn && !isNullOrUndefined(select("." + CLS_ROOT3, acrdnCtn)) && isNullOrUndefined(closest(trgt, inlineAcrdnSel));
      var nestContCheck = acrdnCtn && isNullOrUndefined(select("." + CLS_ROOT3, acrdnCtn)) || !(closest(trgt, "." + CLS_ROOT3) === this.element);
      cntclkCheck = cntclkCheck && (inlineEleAcrdn || nestContCheck);
      trgt.classList.remove("e-target");
      if (trgt.classList.contains(CLS_CONTENT) || trgt.classList.contains(CLS_CTENT) || cntclkCheck) {
        return;
      }
      var acrdcontainer = this.element.querySelector("." + CLS_CONTAINER);
      var acrdnchild = acrdcontainer ? acrdcontainer.children : this.element.children;
      [].slice.call(acrdnchild).forEach(function(el2) {
        if (el2.classList.contains(CLS_ACTIVE)) {
          acrdActive.push(el2);
        }
      });
      var acrdAniEle = [].slice.call(this.element.querySelectorAll("." + CLS_ITEM2 + " [" + CLS_ANIMATE + "]"));
      if (acrdAniEle.length > 0) {
        for (var _i = 0, acrdAniEle_1 = acrdAniEle; _i < acrdAniEle_1.length; _i++) {
          var el = acrdAniEle_1[_i];
          acrdActive.push(el.parentElement);
        }
      }
      var sameContentCheck = acrdActive.indexOf(acrdnCtnItem) !== -1 && acrdnCtn.getAttribute("e-animate") === "true";
      var sameHeader = false;
      if (!isNullOrUndefined(acrdnItem) && !isNullOrUndefined(acrdnHdr)) {
        var acrdnCtn_1 = select("." + CLS_CONTENT, acrdnItem);
        var acrdnRoot = closest(acrdnItem, "." + CLS_ACRDN_ROOT);
        var expandState = acrdnRoot.querySelector("." + CLS_EXPANDSTATE);
        if (isNullOrUndefined(acrdnCtn_1)) {
          return;
        }
        sameHeader = expandState === acrdnItem;
        if (isVisible(acrdnCtn_1) && (!sameContentCheck || acrdnCtnItem.classList.contains(CLS_SLCTED))) {
          this.collapse(acrdnCtn_1);
        } else {
          if (acrdActive.length > 0 && this.expandMode === "Single" && !sameContentCheck) {
            acrdActive.forEach(function(el2) {
              _this.collapse(select("." + CLS_CONTENT, el2));
              el2.classList.remove(CLS_EXPANDSTATE);
            });
          }
          this.expand(acrdnCtn_1);
        }
        if (!isNullOrUndefined(expandState) && !sameHeader) {
          expandState.classList.remove(CLS_EXPANDSTATE);
        }
      }
    };
    Accordion2.prototype.eleMoveFocus = function(action, root, trgt) {
      var clst;
      var clstItem = closest(trgt, "." + CLS_ITEM2);
      if (trgt === root) {
        clst = (action === "moveUp" ? trgt.lastElementChild : trgt).querySelector("." + CLS_HEADER);
      } else if (trgt.classList.contains(CLS_HEADER)) {
        clstItem = action === "moveUp" ? clstItem.previousElementSibling : clstItem.nextElementSibling;
        if (clstItem) {
          clst = select("." + CLS_HEADER, clstItem);
        }
      }
      if (clst) {
        clst.focus();
      }
    };
    Accordion2.prototype.keyActionHandler = function(e) {
      var trgt = e.target;
      var header = closest(e.target, CLS_HEADER);
      if (isNullOrUndefined(header) && !trgt.classList.contains(CLS_ROOT3) && !trgt.classList.contains(CLS_HEADER)) {
        return;
      }
      var clst;
      var root = this.element;
      var content;
      switch (e.action) {
        case "moveUp":
          this.eleMoveFocus(e.action, root, trgt);
          break;
        case "moveDown":
          this.eleMoveFocus(e.action, root, trgt);
          break;
        case "space":
        case "enter":
          content = trgt.nextElementSibling;
          if (!isNullOrUndefined(content) && content.classList.contains(CLS_CONTENT)) {
            if (content.getAttribute("e-animate") !== "true") {
              trgt.click();
            }
          } else {
            trgt.click();
          }
          e.preventDefault();
          break;
        case "home":
        case "end":
          clst = e.action === "home" ? root.firstElementChild.children[0] : root.lastElementChild.children[0];
          clst.focus();
          e.preventDefault();
          break;
      }
    };
    Accordion2.prototype.headerEleGenerate = function() {
      var header = this.createElement("div", { className: CLS_HEADER, id: getUniqueID("acrdn_header") });
      var ariaAttr = {
        "tabindex": "0",
        "role": "button",
        "aria-disabled": "false",
        "aria-expanded": "false"
      };
      attributes(header, ariaAttr);
      return header;
    };
    Accordion2.prototype.renderInnerItem = function(item, index) {
      var innerEle = this.createElement("div", {
        className: CLS_ITEM2,
        id: item.id || getUniqueID("acrdn_item")
      });
      if (this.headerTemplate) {
        var ctnEle = this.headerEleGenerate();
        var hdrEle = this.createElement("div", { className: CLS_HEADERCTN });
        ctnEle.appendChild(hdrEle);
        append(this.getHeaderTemplate()(item, this, "headerTemplate", this.element.id + "_headerTemplate", false), hdrEle);
        innerEle.appendChild(ctnEle);
        ctnEle.appendChild(this.toggleIconGenerate());
        this.add(innerEle, CLS_SLCT);
        return innerEle;
      }
      if (item.header && this.angularnativeCondiCheck(item, "header")) {
        var header = item.header;
        if (this.enableHtmlSanitizer && typeof item.header === "string") {
          header = SanitizeHtmlHelper.sanitize(item.header);
        }
        var ctnEle = this.headerEleGenerate();
        var hdrEle = this.createElement("div", { className: CLS_HEADERCTN });
        ctnEle.appendChild(hdrEle);
        ctnEle.appendChild(this.fetchElement(hdrEle, header, index));
        innerEle.appendChild(ctnEle);
      }
      var hdr = select("." + CLS_HEADER, innerEle);
      if (item.expanded && !isNullOrUndefined(index) && !this.enablePersistence) {
        if (this.initExpand.indexOf(index) === -1) {
          this.initExpand.push(index);
        }
      }
      if (item.cssClass) {
        addClass([innerEle], item.cssClass.split(" "));
      }
      if (item.disabled) {
        addClass([innerEle], CLS_DISABLE4);
      }
      if (item.visible === false) {
        addClass([innerEle], CLS_ITEMHIDE);
      }
      if (item.iconCss) {
        var hdrIcnEle = this.createElement("div", { className: CLS_HEADERICN });
        var icon = this.createElement("span", { className: item.iconCss + " e-icons" });
        hdrIcnEle.appendChild(icon);
        if (isNullOrUndefined(hdr)) {
          hdr = this.headerEleGenerate();
          hdr.appendChild(hdrIcnEle);
          innerEle.appendChild(hdr);
        } else {
          hdr.insertBefore(hdrIcnEle, hdr.childNodes[0]);
        }
      }
      if (item.content && this.angularnativeCondiCheck(item, "content")) {
        var hdrIcon = this.toggleIconGenerate();
        if (isNullOrUndefined(hdr)) {
          hdr = this.headerEleGenerate();
          innerEle.appendChild(hdr);
        }
        hdr.appendChild(hdrIcon);
        this.add(innerEle, CLS_SLCT);
      }
      return innerEle;
    };
    Accordion2.prototype.angularnativeCondiCheck = function(item, prop) {
      var property = prop === "content" ? item.content : item.header;
      var content = property;
      if (this.isAngular && !isNullOrUndefined(content.elementRef)) {
        var data = content.elementRef.nativeElement.data;
        if (isNullOrUndefined(data) || data === "" || data.indexOf("bindings=") === -1) {
          return true;
        }
        var parseddata = JSON.parse(content.elementRef.nativeElement.data.replace("bindings=", ""));
        if (!isNullOrUndefined(parseddata) && parseddata["ng-reflect-ng-if"] === "false") {
          return false;
        } else {
          return true;
        }
      } else {
        return true;
      }
    };
    Accordion2.prototype.fetchElement = function(ele, value, index) {
      var templateFn;
      var temString;
      try {
        if (document.querySelectorAll(value).length && value !== "Button") {
          var eleVal = document.querySelector(value);
          temString = eleVal.outerHTML.trim();
          ele.appendChild(eleVal);
          eleVal.style.display = "";
        } else {
          templateFn = compile(value);
        }
      } catch (e) {
        if (typeof value === "string") {
          ele.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(value) : value;
        } else if (value instanceof HTMLElement) {
          ele.appendChild(value);
          if (this.trgtEle) {
            ele.firstElementChild.style.display = "";
          }
        } else {
          templateFn = compile(value);
        }
      }
      var tempArray;
      if (!isNullOrUndefined(templateFn)) {
        if (this.isReact) {
          this.renderReactTemplates();
        }
        var templateProps = void 0;
        var templateName = void 0;
        if (ele.classList.contains(CLS_HEADERCTN)) {
          templateProps = this.element.id + index + "_header";
          templateName = "header";
        } else if (ele.classList.contains(CLS_CTENT)) {
          templateProps = this.element.id + index + "_content";
          templateName = "content";
        }
        tempArray = templateFn({}, this, templateName, templateProps, this.isStringTemplate);
      }
      if (!isNullOrUndefined(tempArray) && tempArray.length > 0 && !(isNullOrUndefined(tempArray[0].tagName) && tempArray.length === 1)) {
        [].slice.call(tempArray).forEach(function(el) {
          if (!isNullOrUndefined(el.tagName)) {
            el.style.display = "";
          }
          ele.appendChild(el);
        });
      } else if (ele.childElementCount === 0) {
        ele.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(value) : value;
      }
      if (!isNullOrUndefined(temString)) {
        if (this.templateEle.indexOf(value) === -1) {
          this.templateEle.push(value);
        }
      }
      return ele;
    };
    Accordion2.prototype.ariaAttrUpdate = function(itemEle) {
      var header = select("." + CLS_HEADER, itemEle);
      var content = select("." + CLS_CONTENT, itemEle);
      header.setAttribute("aria-controls", content.id);
      content.setAttribute("aria-labelledby", header.id);
      content.setAttribute("role", "region");
    };
    Accordion2.prototype.contentRendering = function(index) {
      var itemcnt = this.createElement("div", { className: CLS_CONTENT + " " + CLS_CTNHIDE, id: getUniqueID("acrdn_panel") });
      attributes(itemcnt, { "aria-hidden": "true" });
      var ctn = this.createElement("div", { className: CLS_CTENT });
      if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0) {
        if (this.isReact) {
          this.renderReactTemplates();
        }
        append(this.getItemTemplate()(this.dataSource[parseInt(index.toString(), 10)], this, "itemTemplate", this.element.id + "_itemTemplate", false), ctn);
        itemcnt.appendChild(ctn);
      } else {
        var content = this.items[parseInt(index.toString(), 10)].content;
        if (this.enableHtmlSanitizer && typeof content === "string") {
          content = SanitizeHtmlHelper.sanitize(content);
        }
        itemcnt.appendChild(this.fetchElement(ctn, content, index));
      }
      return itemcnt;
    };
    Accordion2.prototype.expand = function(trgt) {
      var _this = this;
      var items = this.getItems();
      var trgtItemEle = closest(trgt, "." + CLS_ITEM2);
      if (isNullOrUndefined(trgt) || isVisible(trgt) && trgt.getAttribute("e-animate") !== "true" || trgtItemEle.classList.contains(CLS_DISABLE4)) {
        return;
      }
      var acrdnRoot = closest(trgtItemEle, "." + CLS_ACRDN_ROOT);
      var expandState = acrdnRoot.querySelector("." + CLS_EXPANDSTATE);
      var animation = {
        name: this.animation.expand.effect,
        duration: this.animation.expand.duration,
        timingFunction: this.animation.expand.easing
      };
      var icon = select("." + CLS_TOOGLEICN, trgtItemEle).firstElementChild;
      var eventArgs = {
        element: trgtItemEle,
        item: items[this.getIndexByItem(trgtItemEle)],
        index: this.getIndexByItem(trgtItemEle),
        content: trgtItemEle.querySelector("." + CLS_CONTENT),
        isExpanded: true
      };
      this.trigger("expanding", eventArgs, function(expandArgs) {
        if (!expandArgs.cancel) {
          icon.classList.add(CLS_TOGANIMATE);
          _this.expandedItemsPush(trgtItemEle);
          if (!isNullOrUndefined(expandState)) {
            expandState.classList.remove(CLS_EXPANDSTATE);
          }
          trgtItemEle.classList.add(CLS_EXPANDSTATE);
          if (animation.name === "None" && animationMode !== "Enable" || animationMode === "Disable") {
            _this.expandProgress("begin", icon, trgt, trgtItemEle, expandArgs);
            _this.expandProgress("end", icon, trgt, trgtItemEle, expandArgs);
          } else {
            _this.expandAnimation(animation.name, icon, trgt, trgtItemEle, animation, expandArgs);
          }
        }
      });
    };
    Accordion2.prototype.expandAnimation = function(ef, icn, trgt, trgtItemEle, animate, args) {
      var _this = this;
      if (ef === "None" && animationMode === "Enable") {
        ef = "SlideDown";
        animate.name = "SlideDown";
      }
      var height;
      this.lastActiveItemId = trgtItemEle.id;
      if (ef === "SlideDown") {
        animate.begin = function() {
          _this.expandProgress("begin", icn, trgt, trgtItemEle, args);
          trgt.style.position = "absolute";
          height = trgtItemEle.offsetHeight;
          trgt.style.maxHeight = trgt.offsetHeight + "px";
          trgtItemEle.style.maxHeight = "";
        };
        animate.progress = function() {
          trgtItemEle.style.minHeight = height + trgt.offsetHeight + "px";
        };
        animate.end = function() {
          setStyleAttribute(trgt, { "position": "", "maxHeight": "" });
          trgtItemEle.style.minHeight = "";
          _this.expandProgress("end", icn, trgt, trgtItemEle, args);
        };
      } else {
        animate.begin = function() {
          _this.expandProgress("begin", icn, trgt, trgtItemEle, args);
        };
        animate.end = function() {
          _this.expandProgress("end", icn, trgt, trgtItemEle, args);
        };
      }
      new Animation(animate).animate(trgt);
    };
    Accordion2.prototype.expandProgress = function(progress, icon, trgt, trgtItemEle, eventArgs) {
      this.remove(trgt, CLS_CTNHIDE);
      this.add(trgtItemEle, CLS_SLCTED);
      this.add(icon, CLS_EXPANDICN);
      if (progress === "end") {
        this.add(trgtItemEle, CLS_ACTIVE);
        trgt.setAttribute("aria-hidden", "false");
        attributes(trgt.previousElementSibling, { "aria-expanded": "true" });
        icon.classList.remove(CLS_TOGANIMATE);
        this.trigger("expanded", eventArgs);
      }
    };
    Accordion2.prototype.expandedItemsPush = function(item) {
      var index = this.getIndexByItem(item);
      if (this.expandedIndices.indexOf(index) === -1) {
        var temp = [].slice.call(this.expandedIndices);
        temp.push(index);
        this.setProperties({ expandedIndices: temp }, true);
      }
    };
    Accordion2.prototype.getIndexByItem = function(item) {
      var itemEle = this.getItemElements();
      return [].slice.call(itemEle).indexOf(item);
    };
    Accordion2.prototype.getItemElements = function() {
      var itemEle = [];
      var itemCollection = this.element.children;
      [].slice.call(itemCollection).forEach(function(el) {
        if (el.classList.contains(CLS_ITEM2)) {
          itemEle.push(el);
        }
      });
      return itemEle;
    };
    Accordion2.prototype.expandedItemsPop = function(item) {
      var index = this.getIndexByItem(item);
      var temp = [].slice.call(this.expandedIndices);
      temp.splice(temp.indexOf(index), 1);
      this.setProperties({ expandedIndices: temp }, true);
    };
    Accordion2.prototype.collapse = function(trgt) {
      var _this = this;
      var items = this.getItems();
      var trgtItemEle = closest(trgt, "." + CLS_ITEM2);
      if (isNullOrUndefined(trgt) || !isVisible(trgt) || trgtItemEle.classList.contains(CLS_DISABLE4)) {
        return;
      }
      var animation = {
        name: this.animation.collapse.effect,
        duration: this.animation.collapse.duration,
        timingFunction: this.animation.collapse.easing
      };
      var icon = select("." + CLS_TOOGLEICN, trgtItemEle).firstElementChild;
      var eventArgs = {
        element: trgtItemEle,
        item: items[this.getIndexByItem(trgtItemEle)],
        index: this.getIndexByItem(trgtItemEle),
        content: trgtItemEle.querySelector("." + CLS_CONTENT),
        isExpanded: false
      };
      this.trigger("expanding", eventArgs, function(expandArgs) {
        if (!expandArgs.cancel) {
          _this.expandedItemsPop(trgtItemEle);
          trgtItemEle.classList.remove(CLS_EXPANDSTATE);
          icon.classList.add(CLS_TOGANIMATE);
          if (animation.name === "None" && animationMode !== "Enable" || animationMode === "Disable") {
            _this.collapseProgress("begin", icon, trgt, trgtItemEle, expandArgs);
            _this.collapseProgress("end", icon, trgt, trgtItemEle, expandArgs);
          } else {
            _this.collapseAnimation(animation.name, trgt, trgtItemEle, icon, animation, expandArgs);
          }
        }
      });
    };
    Accordion2.prototype.collapseAnimation = function(ef, trgt, trgtItEl, icn, animate, args) {
      var _this = this;
      if (ef === "None" && animationMode === "Enable") {
        ef = "SlideUp";
        animate.name = "SlideUp";
      }
      var height;
      var trgtHeight;
      var itemHeight;
      var remain;
      this.lastActiveItemId = trgtItEl.id;
      if (ef === "SlideUp") {
        animate.begin = function() {
          itemHeight = trgtItEl.offsetHeight;
          trgtItEl.style.minHeight = itemHeight + "px";
          trgt.style.position = "absolute";
          height = trgtItEl.offsetHeight;
          trgtHeight = trgt.offsetHeight;
          trgt.style.maxHeight = trgtHeight + "px";
          _this.collapseProgress("begin", icn, trgt, trgtItEl, args);
        };
        animate.progress = function() {
          remain = height - (trgtHeight - trgt.offsetHeight);
          if (remain < itemHeight) {
            trgtItEl.style.minHeight = remain + "px";
          }
        };
        animate.end = function() {
          trgt.style.display = "none";
          _this.collapseProgress("end", icn, trgt, trgtItEl, args);
          trgtItEl.style.minHeight = "";
          setStyleAttribute(trgt, { "position": "", "maxHeight": "", "display": "" });
        };
      } else {
        animate.begin = function() {
          _this.collapseProgress("begin", icn, trgt, trgtItEl, args);
        };
        animate.end = function() {
          _this.collapseProgress("end", icn, trgt, trgtItEl, args);
        };
      }
      new Animation(animate).animate(trgt);
    };
    Accordion2.prototype.collapseProgress = function(progress, icon, trgt, trgtItemEle, eventArgs) {
      this.remove(icon, CLS_EXPANDICN);
      this.remove(trgtItemEle, CLS_SLCTED);
      if (progress === "end") {
        this.add(trgt, CLS_CTNHIDE);
        icon.classList.remove(CLS_TOGANIMATE);
        this.remove(trgtItemEle, CLS_ACTIVE);
        trgt.setAttribute("aria-hidden", "true");
        attributes(trgt.previousElementSibling, { "aria-expanded": "false" });
        this.trigger("expanded", eventArgs);
      }
    };
    Accordion2.prototype.getModuleName = function() {
      return "accordion";
    };
    Accordion2.prototype.getItems = function() {
      var items;
      if (this.itemTemplate && this.headerTemplate) {
        items = this.dataSource;
      } else {
        items = this.items;
      }
      return items;
    };
    Accordion2.prototype.addItem = function(item, index) {
      var _this = this;
      var ele = this.element;
      var itemEle = this.getItemElements();
      var items = this.getItems();
      if (isNullOrUndefined(index)) {
        index = items.length;
      }
      if (ele.childElementCount >= index) {
        var addItems = item instanceof Array ? item : [item];
        addItems.forEach(function(addItem, i) {
          var itemIndex = index + i;
          items.splice(itemIndex, 0, addItem);
          var innerItemEle = _this.renderInnerItem(addItem, itemIndex);
          if (ele.childElementCount === itemIndex) {
            ele.appendChild(innerItemEle);
          } else {
            ele.insertBefore(innerItemEle, itemEle[parseInt(itemIndex.toString(), 10)]);
          }
          EventHandler.add(innerItemEle.querySelector("." + CLS_HEADER), "focus", _this.focusIn, _this);
          EventHandler.add(innerItemEle.querySelector("." + CLS_HEADER), "blur", _this.focusOut, _this);
          _this.expandedIndices = [];
          _this.expandedItemRefresh();
          if (addItem && addItem.expanded) {
            _this.expandItem(true, itemIndex);
          }
        });
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.expandedItemRefresh = function() {
      var _this = this;
      var itemEle = this.getItemElements();
      [].slice.call(itemEle).forEach(function(el) {
        if (el.classList.contains(CLS_SLCTED)) {
          _this.expandedItemsPush(el);
        }
      });
    };
    Accordion2.prototype.removeItem = function(index) {
      if (this.isReact || this.isAngular) {
        var item = selectAll("." + CLS_ITEM2, this.element)[parseInt(index.toString(), 10)];
        var header = select("." + CLS_HEADERCTN, item);
        var content = select("." + CLS_CTENT, item);
        this.clearAccordionTemplate(header, this.dataSource.length > 0 ? "headerTemplate" : "header", CLS_HEADERCTN);
        this.clearAccordionTemplate(content, this.dataSource.length > 0 ? "itemTemplate" : "content", CLS_CTENT);
      }
      var itemEle = this.getItemElements();
      var ele = itemEle[parseInt(index.toString(), 10)];
      var items = this.getItems();
      if (isNullOrUndefined(ele)) {
        return;
      }
      this.restoreContent(index);
      detach(ele);
      items.splice(index, 1);
      this.expandedIndices = [];
      this.expandedItemRefresh();
    };
    Accordion2.prototype.select = function(index) {
      var itemEle = this.getItemElements();
      var ele = itemEle[parseInt(index.toString(), 10)];
      if (isNullOrUndefined(ele) || isNullOrUndefined(select("." + CLS_HEADER, ele))) {
        return;
      }
      ele.children[0].focus();
    };
    Accordion2.prototype.hideItem = function(index, isHidden) {
      var itemEle = this.getItemElements();
      var ele = itemEle[parseInt(index.toString(), 10)];
      if (isNullOrUndefined(ele)) {
        return;
      }
      if (isNullOrUndefined(isHidden)) {
        isHidden = true;
      }
      if (isHidden) {
        this.add(ele, CLS_ITEMHIDE);
      } else {
        this.remove(ele, CLS_ITEMHIDE);
      }
    };
    Accordion2.prototype.enableItem = function(index, isEnable) {
      var itemEle = this.getItemElements();
      var ele = itemEle[parseInt(index.toString(), 10)];
      if (isNullOrUndefined(ele)) {
        return;
      }
      var eleHeader = ele.firstElementChild;
      if (isEnable) {
        this.remove(ele, CLS_DISABLE4);
        attributes(eleHeader, { "tabindex": "0", "aria-disabled": "false" });
        eleHeader.focus();
      } else {
        if (ele.classList.contains(CLS_ACTIVE)) {
          this.expandItem(false, index);
          this.eleMoveFocus("movedown", this.element, eleHeader);
        }
        this.add(ele, CLS_DISABLE4);
        eleHeader.setAttribute("aria-disabled", "true");
        eleHeader.removeAttribute("tabindex");
      }
    };
    Accordion2.prototype.expandItem = function(isExpand, index) {
      var _this = this;
      var itemEle = this.getItemElements();
      if (isNullOrUndefined(index)) {
        if (this.expandMode === "Single" && isExpand) {
          var ele = itemEle[itemEle.length - 1];
          this.itemExpand(isExpand, ele, this.getIndexByItem(ele));
        } else {
          var item = select("#" + this.lastActiveItemId, this.element);
          [].slice.call(itemEle).forEach(function(el) {
            _this.itemExpand(isExpand, el, _this.getIndexByItem(el));
            el.classList.remove(CLS_EXPANDSTATE);
          });
          var expandedItem = select("." + CLS_EXPANDSTATE, this.element);
          if (expandedItem) {
            expandedItem.classList.remove(CLS_EXPANDSTATE);
          }
          if (item) {
            item.classList.add(CLS_EXPANDSTATE);
          }
        }
      } else {
        var ele = itemEle[parseInt(index.toString(), 10)];
        if (isNullOrUndefined(ele) || !ele.classList.contains(CLS_SLCT) || ele.classList.contains(CLS_ACTIVE) && isExpand) {
          return;
        } else {
          if (this.expandMode === "Single") {
            this.expandItem(false);
          }
          this.itemExpand(isExpand, ele, index);
        }
      }
    };
    Accordion2.prototype.itemExpand = function(isExpand, ele, index) {
      var ctn = ele.children[1];
      if (ele.classList.contains(CLS_DISABLE4)) {
        return;
      }
      if (isNullOrUndefined(ctn) && isExpand) {
        ctn = this.contentRendering(index);
        ele.appendChild(ctn);
        this.ariaAttrUpdate(ele);
        this.expand(ctn);
      } else if (!isNullOrUndefined(ctn)) {
        if (isExpand) {
          this.expand(ctn);
        } else {
          this.collapse(ctn);
        }
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.destroyItems = function() {
      this.restoreContent(null);
      if (this.isReact || this.isAngular || this.isVue) {
        this.clearTemplate();
      }
      [].slice.call(this.element.querySelectorAll("." + CLS_ITEM2)).forEach(function(el) {
        detach(el);
      });
    };
    Accordion2.prototype.restoreContent = function(index) {
      var ctnElePos;
      if (isNullOrUndefined(index)) {
        ctnElePos = this.element;
      } else {
        ctnElePos = this.element.querySelectorAll("." + CLS_ITEM2)[parseInt(index.toString(), 10)];
      }
      this.templateEle.forEach(function(eleStr) {
        if (!isNullOrUndefined(ctnElePos.querySelector(eleStr))) {
          document.body.appendChild(ctnElePos.querySelector(eleStr)).style.display = "none";
        }
      });
    };
    Accordion2.prototype.updateItem = function(item, index) {
      if (!isNullOrUndefined(item)) {
        var items = this.getItems();
        var itemObj = items[parseInt(index.toString(), 10)];
        items.splice(index, 1);
        this.restoreContent(index);
        var header = select("." + CLS_HEADERCTN, item);
        var content = select("." + CLS_CTENT, item);
        if (this.isReact || this.isAngular) {
          this.clearAccordionTemplate(header, "header", CLS_HEADERCTN);
          this.clearAccordionTemplate(content, "content", CLS_CTENT);
        }
        detach(item);
        this.addItem(itemObj, index);
      }
    };
    Accordion2.prototype.setTemplate = function(template, toElement, index) {
      this.fetchElement(toElement, template, index);
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Accordion2.prototype.clearAccordionTemplate = function(templateEle, templateName, className) {
      if (this.registeredTemplate && this.registeredTemplate["" + templateName]) {
        var registeredTemplates = this.registeredTemplate;
        for (var index = 0; index < registeredTemplates["" + templateName].length; index++) {
          var registeredItem = registeredTemplates["" + templateName][parseInt(index.toString(), 10)].rootNodes[0];
          var closestItem = closest(registeredItem, "." + className);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle || isNullOrUndefined(registeredItem.parentNode)) {
            this.clearTemplate([templateName], [registeredTemplates["" + templateName][parseInt(index.toString(), 10)]]);
            break;
          }
        }
      } else if (this.portals && this.portals.length > 0) {
        var portals = this.portals;
        for (var index = 0; index < portals.length; index++) {
          var portalItem = portals[parseInt(index.toString(), 10)];
          var closestItem = closest(portalItem.containerInfo, "." + className);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate([templateName], index);
            break;
          }
        }
      }
    };
    Accordion2.prototype.getPersistData = function() {
      var keyEntity = ["expandedIndices"];
      return this.addOnPersist(keyEntity);
    };
    Accordion2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var acrdn = this.element;
      var isRefresh = false;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "items":
            if (!(newProp.items instanceof Array && oldProp.items instanceof Array)) {
              var changedProp = Object.keys(newProp.items);
              for (var j = 0; j < changedProp.length; j++) {
                var index = parseInt(Object.keys(newProp.items)[parseInt(j.toString(), 10)], 10);
                var property = Object.keys(newProp.items[parseInt(index.toString(), 10)]);
                for (var k = 0; k < property.length; k++) {
                  var item = selectAll("." + CLS_ITEM2, this.element)[parseInt(index.toString(), 10)];
                  var oldVal = Object(oldProp.items[parseInt(index.toString(), 10)])["" + property[parseInt(k.toString(), 10)]];
                  var newVal = Object(newProp.items[parseInt(index.toString(), 10)])["" + property[parseInt(k.toString(), 10)]];
                  var temp = property[parseInt(k.toString(), 10)];
                  var content = select("." + CLS_CTENT, item);
                  if (temp === "header" || temp === "iconCss" || temp === "expanded" || temp === "content" && oldVal === "") {
                    this.updateItem(item, index);
                  }
                  if (property[parseInt(k.toString(), 10)] === "cssClass" && !isNullOrUndefined(item)) {
                    if (oldVal) {
                      removeClass([item], oldVal.split(" "));
                    }
                    if (newVal) {
                      addClass([item], newVal.split(" "));
                    }
                  }
                  if (property[parseInt(k.toString(), 10)] === "visible" && !isNullOrUndefined(item)) {
                    if (Object(newProp.items[parseInt(index.toString(), 10)])["" + property[parseInt(k.toString(), 10)]] === false) {
                      item.classList.add(CLS_ITEMHIDE);
                    } else {
                      item.classList.remove(CLS_ITEMHIDE);
                    }
                  }
                  if (property[parseInt(k.toString(), 10)] === "disabled" && !isNullOrUndefined(item)) {
                    this.enableItem(index, !newVal);
                  }
                  if (property.indexOf("header") < 0 && property[parseInt(k.toString(), 10)] === "content" && !isNullOrUndefined(item) && item.children.length === 2) {
                    if (typeof newVal === "function") {
                      if (this.isAngular || this.isReact) {
                        this.clearAccordionTemplate(content, property[parseInt(k.toString(), 10)], CLS_CTENT);
                      }
                      var activeContent = item.querySelector("." + CLS_CTENT);
                      activeContent.innerHTML = "";
                      this.setTemplate(newVal, activeContent, index);
                    } else {
                      if (item.classList.contains(CLS_SLCTED)) {
                        this.expandItem(false, index);
                      }
                      detach(item.querySelector("." + CLS_CONTENT));
                    }
                  }
                }
              }
            } else {
              isRefresh = true;
            }
            break;
          case "dataSource":
          case "expandedIndices":
            if (this.expandedIndices === null) {
              this.expandedIndices = [];
            }
            isRefresh = true;
            break;
          case "headerTemplate":
            this.initializeHeaderTemplate();
            isRefresh = true;
            break;
          case "itemTemplate":
            this.initializeItemTemplate();
            isRefresh = true;
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.add(acrdn, CLS_RTL4);
            } else {
              this.remove(acrdn, CLS_RTL4);
            }
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            break;
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(newProp.width) });
            break;
          case "expandMode":
            if (newProp.expandMode === "Single" && !isNullOrUndefined(this.expandedIndices) && this.expandedIndices.length > 1) {
              this.expandItem(false);
            }
            break;
        }
      }
      if (isRefresh) {
        this.initExpand = [];
        if (!isNullOrUndefined(this.expandedIndices) && this.expandedIndices.length > 0) {
          this.initExpand = this.expandedIndices;
        }
        this.destroyItems();
        this.renderItems();
        this.initItemExpand();
      }
    };
    __decorate34([
      Collection([], AccordionItem)
    ], Accordion2.prototype, "items", void 0);
    __decorate34([
      Property([])
    ], Accordion2.prototype, "dataSource", void 0);
    __decorate34([
      Property()
    ], Accordion2.prototype, "itemTemplate", void 0);
    __decorate34([
      Property()
    ], Accordion2.prototype, "headerTemplate", void 0);
    __decorate34([
      Property("100%")
    ], Accordion2.prototype, "width", void 0);
    __decorate34([
      Property("auto")
    ], Accordion2.prototype, "height", void 0);
    __decorate34([
      Property([])
    ], Accordion2.prototype, "expandedIndices", void 0);
    __decorate34([
      Property("Multiple")
    ], Accordion2.prototype, "expandMode", void 0);
    __decorate34([
      Property(true)
    ], Accordion2.prototype, "enableHtmlSanitizer", void 0);
    __decorate34([
      Complex({}, AccordionAnimationSettings)
    ], Accordion2.prototype, "animation", void 0);
    __decorate34([
      Event()
    ], Accordion2.prototype, "clicked", void 0);
    __decorate34([
      Event()
    ], Accordion2.prototype, "expanding", void 0);
    __decorate34([
      Event()
    ], Accordion2.prototype, "expanded", void 0);
    __decorate34([
      Event()
    ], Accordion2.prototype, "created", void 0);
    __decorate34([
      Event()
    ], Accordion2.prototype, "destroyed", void 0);
    Accordion2 = __decorate34([
      NotifyPropertyChanges
    ], Accordion2);
    return Accordion2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/context-menu/context-menu.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ContextMenu = (
  /** @class */
  function(_super) {
    __extends36(ContextMenu2, _super);
    function ContextMenu2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    ContextMenu2.prototype.preRender = function() {
      this.isMenu = false;
      this.element.id = this.element.id || getUniqueID("ej2-contextmenu");
      _super.prototype.preRender.call(this);
    };
    ContextMenu2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      attributes(this.element, { "role": "menubar", "tabindex": "0" });
      this.element.style.zIndex = getZindexPartial(this.element).toString();
    };
    ContextMenu2.prototype.open = function(top, left, target) {
      _super.prototype.openMenu.call(this, null, null, top, left, null, target);
    };
    ContextMenu2.prototype.close = function() {
      _super.prototype.closeMenu.call(this);
    };
    ContextMenu2.prototype.onPropertyChanged = function(newProp, oldProp) {
      _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "filter":
            this.close();
            this.filter = newProp.filter;
            break;
          case "target":
            this.unWireEvents(oldProp.target);
            this.wireEvents();
            break;
        }
      }
    };
    ContextMenu2.prototype.getModuleName = function() {
      return "contextmenu";
    };
    __decorate35([
      Property("")
    ], ContextMenu2.prototype, "target", void 0);
    __decorate35([
      Property("")
    ], ContextMenu2.prototype, "filter", void 0);
    __decorate35([
      Collection([], MenuItem)
    ], ContextMenu2.prototype, "items", void 0);
    ContextMenu2 = __decorate35([
      NotifyPropertyChanges
    ], ContextMenu2);
    return ContextMenu2;
  }(MenuBase)
);

// node_modules/@syncfusion/ej2-navigations/src/menu/menu.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var VMENU = "e-vertical";
var SCROLLABLE = "e-scrollable";
var HAMBURGER = "e-hamburger";
var Menu = (
  /** @class */
  function(_super) {
    __extends37(Menu2, _super);
    function Menu2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.tempItems = [];
      return _this;
    }
    Menu2.prototype.getModuleName = function() {
      return "menu";
    };
    Menu2.prototype.preRender = function() {
      this.isMenu = true;
      this.element.id = this.element.id || getUniqueID("ej2-menu");
      if (this.template) {
        try {
          if (typeof this.template !== "function" && document.querySelectorAll(this.template).length) {
            this.template = document.querySelector(this.template).innerHTML.trim();
            this.clearChanges();
          }
        } catch (e) {
        }
        this.updateMenuItems(this.items);
      } else {
        this.updateMenuItems(this.items);
      }
      _super.prototype.preRender.call(this);
    };
    Menu2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      attributes(this.element, { "role": "menubar", "tabindex": "0" });
      if (this.orientation === "Vertical") {
        this.element.classList.add(VMENU);
        if (this.hamburgerMode && !this.target) {
          this.element.previousElementSibling.classList.add(VMENU);
        }
        this.element.setAttribute("aria-orientation", "vertical");
      } else {
        if (Browser.isDevice && !this.enableScrolling) {
          this.element.parentElement.classList.add(SCROLLABLE);
        }
      }
      if (this.hamburgerMode) {
        this.element.parentElement.classList.add(HAMBURGER);
        if (this.orientation === "Horizontal") {
          this.element.classList.add("e-hide-menu");
        }
      }
    };
    Menu2.prototype.updateMenuItems = function(items) {
      this.tempItems = items;
      this.items = [];
      this.tempItems.map(this.createMenuItems, this);
      this.setProperties({ items: this.items }, true);
      this.tempItems = [];
    };
    Menu2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "orientation":
            if (newProp.orientation === "Vertical") {
              this.element.classList.add(VMENU);
              if (this.hamburgerMode) {
                if (!this.target) {
                  this.element.previousElementSibling.classList.add(VMENU);
                }
                this.element.classList.remove("e-hide-menu");
              }
              this.element.setAttribute("aria-orientation", "vertical");
            } else {
              this.element.classList.remove(VMENU);
              if (this.hamburgerMode) {
                if (!this.target) {
                  this.element.previousElementSibling.classList.remove(VMENU);
                }
                this.element.classList.add("e-hide-menu");
              }
              this.element.removeAttribute("aria-orientation");
            }
            break;
          case "items":
            if (!Object.keys(oldProp.items).length) {
              this.updateMenuItems(newProp.items);
            }
            break;
          case "hamburgerMode":
            if (!this.element.previousElementSibling) {
              _super.prototype.createHeaderContainer.call(this);
            }
            if (newProp.hamburgerMode) {
              this.element.parentElement.classList.add(HAMBURGER);
              [].slice.call(this.element.getElementsByClassName("e-blankicon")).forEach(function(li) {
                li.style[_this.enableRtl ? "paddingRight" : "paddingLeft"] = "";
              });
            } else {
              this.element.parentElement.classList.remove(HAMBURGER);
              if (this.orientation === "Vertical") {
                this.setBlankIconStyle(this.element);
              }
            }
            if (this.orientation === "Vertical") {
              if (!this.target) {
                this.element.previousElementSibling.classList.add(VMENU);
              }
              this.element.classList.remove("e-hide-menu");
            } else {
              if (this.target) {
                this.element.previousElementSibling.classList.add(VMENU);
              } else {
                this.element.previousElementSibling.classList.remove(VMENU);
              }
              this.element.classList[newProp.hamburgerMode ? "add" : "remove"]("e-hide-menu");
            }
            break;
          case "title":
            if (this.hamburgerMode && this.element.previousElementSibling) {
              newProp.title = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(newProp.title) : newProp.title;
              this.element.previousElementSibling.querySelector(".e-menu-title").innerHTML = newProp.title;
            }
            break;
          case "target":
            if (this.hamburgerMode) {
              this.unWireEvents(oldProp.target);
              this.wireEvents();
              if (this.orientation === "Horizontal") {
                if (!newProp.target) {
                  if (!this.element.previousElementSibling) {
                    _super.prototype.createHeaderContainer.call(this);
                  }
                  this.element.previousElementSibling.classList.remove(VMENU);
                } else {
                  this.element.previousElementSibling.classList.add(VMENU);
                }
                this.element.classList.add("e-hide-menu");
              }
            }
            break;
        }
      }
      _super.prototype.onPropertyChanged.call(this, newProp, oldProp);
    };
    Menu2.prototype.createMenuItems = function(item) {
      var idx;
      var i;
      var items = this.items;
      var pIdField = this.getField("parentId");
      if (item["" + pIdField]) {
        idx = this.getIndex(item["" + pIdField].toString(), true);
        for (i = 0; i < idx.length; i++) {
          if (!items[idx[i]].items) {
            items[idx[i]].items = [];
          }
          items = items[idx[i]].items;
        }
        items.push(item);
      } else {
        this.items.push(item);
      }
    };
    Menu2.prototype.open = function() {
      _super.prototype.openHamburgerMenu.call(this);
    };
    Menu2.prototype.close = function() {
      _super.prototype.closeHamburgerMenu.call(this);
    };
    __decorate36([
      Property("Horizontal")
    ], Menu2.prototype, "orientation", void 0);
    __decorate36([
      Property("")
    ], Menu2.prototype, "target", void 0);
    __decorate36([
      Property(null)
    ], Menu2.prototype, "template", void 0);
    __decorate36([
      Property(false)
    ], Menu2.prototype, "enableScrolling", void 0);
    __decorate36([
      Property(false)
    ], Menu2.prototype, "hamburgerMode", void 0);
    __decorate36([
      Property("Menu")
    ], Menu2.prototype, "title", void 0);
    __decorate36([
      Property(true)
    ], Menu2.prototype, "enableHtmlSanitizer", void 0);
    __decorate36([
      Complex({ itemId: "id", text: "text", parentId: "parentId", iconCss: "iconCss", url: "url", separator: "separator", children: "items" }, FieldSettings2)
    ], Menu2.prototype, "fields", void 0);
    Menu2 = __decorate36([
      NotifyPropertyChanges
    ], Menu2);
    return Menu2;
  }(MenuBase)
);

// node_modules/@syncfusion/ej2-navigations/src/tab/tab.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_TAB = "e-tab";
var CLS_HEADER2 = "e-tab-header";
var CLS_BLA_TEM = "blazor-template";
var CLS_CONTENT2 = "e-content";
var CLS_NEST2 = "e-nested";
var CLS_ITEMS2 = "e-items";
var CLS_ITEM3 = "e-item";
var CLS_TEMPLATE2 = "e-template";
var CLS_RTL5 = "e-rtl";
var CLS_ACTIVE2 = "e-active";
var CLS_DISABLE5 = "e-disable";
var CLS_HIDDEN2 = "e-hidden";
var CLS_FOCUS = "e-focused";
var CLS_ICONS = "e-icons";
var CLS_ICON = "e-icon";
var CLS_ICON_TAB = "e-icon-tab";
var CLS_ICON_CLOSE = "e-close-icon";
var CLS_CLOSE_SHOW = "e-close-show";
var CLS_TEXT = "e-tab-text";
var CLS_INDICATOR = "e-indicator";
var CLS_WRAP = "e-tab-wrap";
var CLS_TEXT_WRAP = "e-text-wrap";
var CLS_TAB_ICON = "e-tab-icon";
var CLS_TB_ITEMS = "e-toolbar-items";
var CLS_TB_ITEM = "e-toolbar-item";
var CLS_TB_POP = "e-toolbar-pop";
var CLS_TB_POPUP = "e-toolbar-popup";
var CLS_HOR_NAV = "e-hor-nav";
var CLS_POPUP_OPEN = "e-popup-open";
var CLS_POPUP_CLOSE = "e-popup-close";
var CLS_PROGRESS = "e-progress";
var CLS_IGNORE = "e-ignore";
var CLS_OVERLAY3 = "e-overlay";
var CLS_HSCRCNT = "e-hscroll-content";
var CLS_VSCRCNT = "e-vscroll-content";
var CLS_VTAB = "e-vertical-tab";
var CLS_VERTICAL2 = "e-vertical";
var CLS_VLEFT = "e-vertical-left";
var CLS_VRIGHT = "e-vertical-right";
var CLS_HBOTTOM = "e-horizontal-bottom";
var CLS_FILL = "e-fill-mode";
var TABITEMPREFIX = "tabitem_";
var CLS_REORDER_ACTIVE_ITEM = "e-reorder-active-item";
var TabActionSettings = (
  /** @class */
  function(_super) {
    __extends38(TabActionSettings2, _super);
    function TabActionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate37([
      Property("SlideLeftIn")
    ], TabActionSettings2.prototype, "effect", void 0);
    __decorate37([
      Property(600)
    ], TabActionSettings2.prototype, "duration", void 0);
    __decorate37([
      Property("ease")
    ], TabActionSettings2.prototype, "easing", void 0);
    return TabActionSettings2;
  }(ChildProperty)
);
var TabAnimationSettings = (
  /** @class */
  function(_super) {
    __extends38(TabAnimationSettings2, _super);
    function TabAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate37([
      Complex({ effect: "SlideLeftIn", duration: 600, easing: "ease" }, TabActionSettings)
    ], TabAnimationSettings2.prototype, "previous", void 0);
    __decorate37([
      Complex({ effect: "SlideRightIn", duration: 600, easing: "ease" }, TabActionSettings)
    ], TabAnimationSettings2.prototype, "next", void 0);
    return TabAnimationSettings2;
  }(ChildProperty)
);
var Header = (
  /** @class */
  function(_super) {
    __extends38(Header2, _super);
    function Header2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate37([
      Property("")
    ], Header2.prototype, "text", void 0);
    __decorate37([
      Property("")
    ], Header2.prototype, "iconCss", void 0);
    __decorate37([
      Property("left")
    ], Header2.prototype, "iconPosition", void 0);
    return Header2;
  }(ChildProperty)
);
var TabItem = (
  /** @class */
  function(_super) {
    __extends38(TabItem2, _super);
    function TabItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate37([
      Complex({}, Header)
    ], TabItem2.prototype, "header", void 0);
    __decorate37([
      Property(null)
    ], TabItem2.prototype, "headerTemplate", void 0);
    __decorate37([
      Property("")
    ], TabItem2.prototype, "content", void 0);
    __decorate37([
      Property("")
    ], TabItem2.prototype, "cssClass", void 0);
    __decorate37([
      Property(false)
    ], TabItem2.prototype, "disabled", void 0);
    __decorate37([
      Property(true)
    ], TabItem2.prototype, "visible", void 0);
    __decorate37([
      Property()
    ], TabItem2.prototype, "id", void 0);
    __decorate37([
      Property(-1)
    ], TabItem2.prototype, "tabIndex", void 0);
    return TabItem2;
  }(ChildProperty)
);
var Tab = (
  /** @class */
  function(_super) {
    __extends38(Tab2, _super);
    function Tab2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.show = {};
      _this.hide = {};
      _this.maxHeight = 0;
      _this.title = "Close";
      _this.isInteracted = false;
      _this.lastIndex = 0;
      _this.isAdd = false;
      _this.isIconAlone = false;
      _this.draggableItems = [];
      _this.resizeContext = _this.refreshActiveTabBorder.bind(_this);
      _this.keyConfigs = {
        tab: "tab",
        home: "home",
        end: "end",
        enter: "enter",
        space: "space",
        delete: "delete",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        moveDown: "downarrow"
      };
      return _this;
    }
    Tab2.prototype.destroy = function() {
      if (this.isReact || this.isAngular) {
        this.clearTemplate();
      }
      if (!isNullOrUndefined(this.tbObj)) {
        this.tbObj.destroy();
        this.tbObj = null;
      }
      this.unWireEvents();
      this.element.removeAttribute("aria-disabled");
      this.expTemplateContent();
      if (!this.isTemplate) {
        while (this.element.firstElementChild) {
          remove(this.element.firstElementChild);
        }
      } else {
        var cntEle = select("." + CLS_TAB + " > ." + CLS_CONTENT2, this.element);
        this.element.classList.remove(CLS_TEMPLATE2);
        if (!isNullOrUndefined(cntEle)) {
          cntEle.innerHTML = this.cnt;
        }
      }
      if (this.btnCls) {
        this.btnCls = null;
      }
      this.hdrEle = null;
      this.cntEle = null;
      this.tbItems = null;
      this.tbItem = null;
      this.tbPop = null;
      this.prevItem = null;
      this.popEle = null;
      this.bdrLine = null;
      this.content = null;
      this.dragItem = null;
      this.cloneElement = null;
      this.draggingItems = [];
      if (this.draggableItems && this.draggableItems.length > 0) {
        for (var i = 0; i < this.draggableItems.length; i++) {
          this.draggableItems[i].destroy();
          this.draggableItems[i] = null;
        }
        this.draggableItems = [];
      }
      _super.prototype.destroy.call(this);
      this.trigger("destroyed");
    };
    Tab2.prototype.refresh = function() {
      if (this.isReact) {
        this.clearTemplate();
      }
      _super.prototype.refresh.call(this);
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Tab2.prototype.preRender = function() {
      var nested = closest(this.element, "." + CLS_CONTENT2);
      this.prevIndex = 0;
      this.isNested = false;
      this.isPopup = false;
      this.initRender = true;
      this.isSwiped = false;
      this.itemIndexArray = [];
      this.templateEle = [];
      if (this.allowDragAndDrop) {
        this.dragArea = !isNullOrUndefined(this.dragArea) ? this.dragArea : "#" + this.element.id + " " + ("." + CLS_HEADER2);
      }
      if (!isNullOrUndefined(nested)) {
        nested.parentElement.classList.add(CLS_NEST2);
        this.isNested = true;
      }
      var name = Browser.info.name;
      var css = name === "msie" ? "e-ie" : name === "edge" ? "e-edge" : name === "safari" ? "e-safari" : "";
      setStyleAttribute(this.element, { "width": formatUnit(this.width), "height": formatUnit(this.height) });
      this.setCssClass(this.element, this.cssClass, true);
      attributes(this.element, { "aria-disabled": "false" });
      this.setCssClass(this.element, css, true);
      this.updatePopAnimationConfig();
    };
    Tab2.prototype.render = function() {
      var _this = this;
      this.btnCls = this.createElement("span", { className: CLS_ICONS + " " + CLS_ICON_CLOSE, attrs: { title: this.title } });
      this.tabId = this.element.id.length > 0 ? "-" + this.element.id : getRandomId();
      this.renderContainer();
      this.wireEvents();
      this.initRender = false;
      if (this.isReact && this.portals && this.portals.length > 0) {
        this.renderReactTemplates(function() {
          if (!isNullOrUndefined(_this.tbObj)) {
            _this.tbObj.refreshOverflow();
          }
          _this.refreshActiveBorder();
        });
      }
    };
    Tab2.prototype.renderContainer = function() {
      var ele = this.element;
      this.items.forEach(function(item, index) {
        if (isNullOrUndefined(item.id) && !isNullOrUndefined(item.setProperties)) {
          item.setProperties({ id: TABITEMPREFIX + index.toString() }, true);
        }
      });
      if (this.items.length > 0 && ele.children.length === 0) {
        ele.appendChild(this.createElement("div", { className: CLS_CONTENT2 }));
        this.setOrientation(this.headerPlacement, this.createElement("div", { className: CLS_HEADER2 }));
        this.isTemplate = false;
      } else if (this.element.children.length > 0) {
        this.isTemplate = true;
        ele.classList.add(CLS_TEMPLATE2);
        var header = ele.querySelector("." + CLS_HEADER2);
        if (header && this.headerPlacement === "Bottom") {
          this.setOrientation(this.headerPlacement, header);
        }
      }
      if (!isNullOrUndefined(select("." + CLS_HEADER2, this.element)) && !isNullOrUndefined(select("." + CLS_CONTENT2, this.element))) {
        this.renderHeader();
        this.tbItems = select("." + CLS_HEADER2 + " ." + CLS_TB_ITEMS, this.element);
        if (!isNullOrUndefined(this.tbItems)) {
          rippleEffect(this.tbItems, { selector: ".e-tab-wrap" });
        }
        this.renderContent();
        if (selectAll("." + CLS_TB_ITEM, this.element).length > 0) {
          this.tbItems = select("." + CLS_HEADER2 + " ." + CLS_TB_ITEMS, this.element);
          this.bdrLine = this.createElement("div", { className: CLS_INDICATOR + " " + CLS_HIDDEN2 + " " + CLS_IGNORE });
          var scrCnt = select("." + this.scrCntClass, this.tbItems);
          if (!isNullOrUndefined(scrCnt)) {
            scrCnt.insertBefore(this.bdrLine, scrCnt.firstChild);
          } else {
            this.tbItems.insertBefore(this.bdrLine, this.tbItems.firstChild);
          }
          this.setContentHeight(true);
          this.select(this.selectedItem);
        }
        this.setRTL(this.enableRtl);
      }
    };
    Tab2.prototype.renderHeader = function() {
      var _this = this;
      var hdrPlace = this.headerPlacement;
      var tabItems = [];
      this.hdrEle = this.getTabHeader();
      this.addVerticalClass();
      if (!this.isTemplate) {
        tabItems = this.parseObject(this.items, 0);
      } else {
        if (this.element.children.length > 1 && this.element.children[1].classList.contains(CLS_HEADER2)) {
          this.setProperties({ headerPlacement: "Bottom" }, true);
        }
        var count = this.hdrEle.children.length;
        var hdrItems = [];
        for (var i = 0; i < count; i++) {
          hdrItems.push(this.hdrEle.children.item(i));
        }
        if (count > 0) {
          var tabItems_1 = this.createElement("div", { className: CLS_ITEMS2 });
          this.hdrEle.appendChild(tabItems_1);
          hdrItems.forEach(function(item, index) {
            _this.lastIndex = index;
            var attr = {
              className: CLS_ITEM3,
              id: CLS_ITEM3 + _this.tabId + "_" + index
            };
            var txt = _this.createElement("span", {
              className: CLS_TEXT,
              attrs: { "role": "presentation" }
            }).outerHTML;
            var cont = _this.createElement("div", {
              className: CLS_TEXT_WRAP,
              innerHTML: txt + _this.btnCls.outerHTML
            }).outerHTML;
            var wrap = _this.createElement("div", {
              className: CLS_WRAP,
              innerHTML: cont,
              attrs: { role: "tab", tabIndex: "-1", "aria-selected": "false", "aria-controls": CLS_CONTENT2 + _this.tabId + "_" + index, "aria-disabled": "false" }
            });
            wrap.querySelector("." + CLS_TEXT).appendChild(item);
            tabItems_1.appendChild(_this.createElement("div", attr));
            selectAll("." + CLS_ITEM3, tabItems_1)[index].appendChild(wrap);
          });
        }
      }
      this.tbObj = new Toolbar({
        width: hdrPlace === "Left" || hdrPlace === "Right" ? "auto" : "100%",
        height: hdrPlace === "Left" || hdrPlace === "Right" ? "100%" : "auto",
        overflowMode: this.overflowMode,
        items: tabItems.length !== 0 ? tabItems : [],
        clicked: this.clickHandler.bind(this),
        scrollStep: this.scrollStep,
        enableHtmlSanitizer: this.enableHtmlSanitizer,
        cssClass: this.cssClass
      });
      this.tbObj.isStringTemplate = true;
      this.tbObj.createElement = this.createElement;
      this.tbObj.appendTo(this.hdrEle);
      attributes(this.hdrEle, { role: "tablist" });
      if (!isNullOrUndefined(this.element.getAttribute("aria-label"))) {
        this.hdrEle.setAttribute("aria-label", this.element.getAttribute("aria-label"));
        this.element.removeAttribute("aria-label");
      } else if (!isNullOrUndefined(this.element.getAttribute("aria-labelledby"))) {
        this.hdrEle.setAttribute("aria-labelledby", this.element.getAttribute("aria-labelledby"));
        this.element.removeAttribute("aria-labelledby");
      }
      this.setCloseButton(this.showCloseButton);
      var toolbarHeader = this.tbObj.element.querySelector("." + CLS_TB_ITEMS);
      if (!isNullOrUndefined(toolbarHeader)) {
        if (isNullOrUndefined(toolbarHeader.id) || toolbarHeader.id === "") {
          toolbarHeader.id = this.element.id + "_tab_header_items";
        }
      }
    };
    Tab2.prototype.renderContent = function() {
      this.cntEle = select("." + CLS_CONTENT2, this.element);
      var hdrItem = selectAll("." + CLS_TB_ITEM, this.element);
      if (this.isTemplate) {
        this.cnt = this.cntEle.children.length > 0 ? this.cntEle.innerHTML : "";
        var contents = this.cntEle.children;
        for (var i = 0; i < hdrItem.length; i++) {
          if (contents.length - 1 >= i) {
            addClass([contents.item(i)], CLS_ITEM3);
            attributes(contents.item(i), { "role": "tabpanel", "aria-labelledby": CLS_ITEM3 + this.tabId + "_" + i });
            contents.item(i).id = CLS_CONTENT2 + this.tabId + "_" + i;
          }
        }
      }
    };
    Tab2.prototype.reRenderItems = function() {
      this.renderContainer();
      if (!isNullOrUndefined(this.cntEle)) {
        this.touchModule = new Touch(this.cntEle, { swipe: this.swipeHandler.bind(this) });
      }
    };
    Tab2.prototype.parseObject = function(items, index) {
      var _this = this;
      var tbItems = Array.prototype.slice.call(selectAll(".e-tab-header ." + CLS_TB_ITEM, this.element));
      var maxId = this.lastIndex;
      if (!this.isReplace && tbItems.length > 0) {
        var idList_1 = [];
        tbItems.forEach(function(item) {
          idList_1.push(_this.getIndexFromEle(item.id));
        });
        maxId = Math.max.apply(Math, idList_1);
      }
      var tItems = [];
      var txtWrapEle;
      var spliceArray = [];
      var i = 0;
      items.forEach(function(item, i2) {
        var pos = isNullOrUndefined(item.header) || isNullOrUndefined(item.header.iconPosition) ? "" : item.header.iconPosition;
        var css = isNullOrUndefined(item.header) || isNullOrUndefined(item.header.iconCss) ? "" : item.header.iconCss;
        if (isNullOrUndefined(item.headerTemplate) && (isNullOrUndefined(item.header) || isNullOrUndefined(item.header.text) || item.header.text.length === 0 && css === "")) {
          spliceArray.push(i2);
          return;
        }
        var txt = item.headerTemplate || item.header.text;
        if (typeof txt === "string" && _this.enableHtmlSanitizer) {
          txt = SanitizeHtmlHelper.sanitize(txt);
        }
        var itemIndex;
        if (_this.isReplace && !isNullOrUndefined(_this.tbId) && _this.tbId !== "") {
          itemIndex = parseInt(_this.tbId.substring(_this.tbId.lastIndexOf("_") + 1), 10);
          _this.tbId = "";
        } else {
          itemIndex = index + i2;
        }
        _this.lastIndex = tbItems.length === 0 ? i2 : _this.isReplace ? itemIndex : maxId + 1 + i2;
        var disabled = item.disabled ? " " + CLS_DISABLE5 + " " + CLS_OVERLAY3 : "";
        var hidden = item.visible === false ? " " + CLS_HIDDEN2 : "";
        txtWrapEle = _this.createElement("div", { className: CLS_TEXT, attrs: { "role": "presentation" } });
        var tHtml = txt instanceof Object ? txt.outerHTML : txt;
        var txtEmpty = !isNullOrUndefined(tHtml) && tHtml !== "";
        if (!isNullOrUndefined(txt.tagName)) {
          txtWrapEle.appendChild(txt);
        } else {
          _this.headerTextCompile(txtWrapEle, txt, i2);
        }
        var tEle;
        var icon = _this.createElement("span", {
          className: CLS_ICONS + " " + CLS_TAB_ICON + " " + CLS_ICON + "-" + pos + " " + css
        });
        var tCont = _this.createElement("div", { className: CLS_TEXT_WRAP });
        tCont.appendChild(txtWrapEle);
        if (txt !== "" && txt !== void 0 && css !== "") {
          if (pos === "left" || pos === "top") {
            tCont.insertBefore(icon, tCont.firstElementChild);
          } else {
            tCont.appendChild(icon);
          }
          tEle = txtWrapEle;
          _this.isIconAlone = false;
        } else {
          tEle = css === "" ? txtWrapEle : icon;
          if (tEle === icon) {
            detach(txtWrapEle);
            tCont.appendChild(icon);
            _this.isIconAlone = true;
          }
        }
        var tabIndex = isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString();
        var wrapAttrs = item.disabled ? { role: "tab", "aria-disabled": "true" } : { tabIndex, "data-tabindex": tabIndex, role: "tab", "aria-selected": "false", "aria-disabled": "false" };
        tCont.appendChild(_this.btnCls.cloneNode(true));
        var wrap = _this.createElement("div", { className: CLS_WRAP, attrs: wrapAttrs });
        wrap.appendChild(tCont);
        if (_this.itemIndexArray instanceof Array) {
          _this.itemIndexArray.splice(index + i2, 0, CLS_ITEM3 + _this.tabId + "_" + _this.lastIndex);
        }
        var attrObj = {
          id: CLS_ITEM3 + _this.tabId + "_" + _this.lastIndex,
          "data-id": item.id
        };
        var tItem = { htmlAttributes: attrObj, template: wrap };
        tItem.cssClass = (item.cssClass !== void 0 ? item.cssClass : " ") + " " + disabled + " " + hidden + " " + (css !== "" ? "e-i" + pos : "") + " " + (!txtEmpty ? CLS_ICON : "");
        if (pos === "top" || pos === "bottom") {
          _this.element.classList.add("e-vertical-icon");
        }
        tItems.push(tItem);
        i2++;
      });
      if (!this.isAdd) {
        spliceArray.forEach(function(spliceItemIndex) {
          _this.items.splice(spliceItemIndex, 1);
        });
      }
      if (this.isIconAlone) {
        this.element.classList.add(CLS_ICON_TAB);
      } else {
        this.element.classList.remove(CLS_ICON_TAB);
      }
      return tItems;
    };
    Tab2.prototype.removeActiveClass = function() {
      var tabHeader = this.getTabHeader();
      if (tabHeader) {
        var tabItems = selectAll("." + CLS_TB_ITEM + "." + CLS_ACTIVE2, tabHeader);
        [].slice.call(tabItems).forEach(function(node) {
          return node.classList.remove(CLS_ACTIVE2);
        });
        [].slice.call(tabItems).forEach(function(node) {
          return node.firstElementChild.setAttribute("aria-selected", "false");
        });
      }
    };
    Tab2.prototype.checkPopupOverflow = function(ele) {
      this.tbPop = select("." + CLS_TB_POP, this.element);
      var popIcon = select(".e-hor-nav", this.element);
      var tbrItems = select("." + CLS_TB_ITEMS, this.element);
      var lastChild = tbrItems.lastChild;
      var isOverflow = false;
      if (!this.isVertical() && (this.enableRtl && popIcon.offsetLeft + popIcon.offsetWidth > tbrItems.offsetLeft || !this.enableRtl && popIcon.offsetLeft < tbrItems.offsetWidth)) {
        isOverflow = true;
      } else if (this.isVertical() && popIcon.offsetTop < lastChild.offsetTop + lastChild.offsetHeight) {
        isOverflow = true;
      }
      if (isOverflow) {
        ele.classList.add(CLS_TB_POPUP);
        this.tbPop.insertBefore(ele, selectAll("." + CLS_TB_POPUP, this.tbPop)[0]);
      }
      return true;
    };
    Tab2.prototype.popupHandler = function(target) {
      var ripEle = target.querySelector(".e-ripple-element");
      if (!isNullOrUndefined(ripEle)) {
        ripEle.outerHTML = "";
        target.querySelector("." + CLS_WRAP).classList.remove("e-ripple");
      }
      this.tbItem = selectAll("." + CLS_TB_ITEMS + " ." + CLS_TB_ITEM, this.hdrEle);
      var lastChild = this.tbItem[this.tbItem.length - 1];
      if (this.tbItem.length !== 0) {
        target.classList.remove(CLS_TB_POPUP);
        target.removeAttribute("style");
        this.tbItems.appendChild(target);
        this.actEleId = target.id;
        if (this.checkPopupOverflow(lastChild)) {
          var prevEle = this.tbItems.lastChild.previousElementSibling;
          this.checkPopupOverflow(prevEle);
        }
        this.isPopup = true;
      }
      return selectAll("." + CLS_TB_ITEM, this.tbItems).length - 1;
    };
    Tab2.prototype.setCloseButton = function(val) {
      var trg = select("." + CLS_HEADER2, this.element);
      if (val === true) {
        trg.classList.add(CLS_CLOSE_SHOW);
      } else {
        trg.classList.remove(CLS_CLOSE_SHOW);
      }
      this.tbObj.refreshOverflow();
      this.refreshActiveTabBorder();
    };
    Tab2.prototype.prevCtnAnimation = function(prev, current) {
      var animation;
      var checkRTL = this.enableRtl || this.element.classList.contains(CLS_RTL5);
      if (this.isPopup || prev <= current) {
        if (this.animation.previous.effect === "SlideLeftIn") {
          animation = {
            name: "SlideLeftOut",
            duration: this.animation.previous.duration,
            timingFunction: this.animation.previous.easing
          };
        } else {
          animation = null;
        }
      } else {
        if (this.animation.next.effect === "SlideRightIn") {
          animation = {
            name: "SlideRightOut",
            duration: this.animation.next.duration,
            timingFunction: this.animation.next.easing
          };
        } else {
          animation = null;
        }
      }
      return animation;
    };
    Tab2.prototype.triggerPrevAnimation = function(oldCnt, prevIndex) {
      var _this = this;
      var animateObj = this.prevCtnAnimation(prevIndex, this.selectedItem);
      if (!isNullOrUndefined(animateObj)) {
        animateObj.begin = function() {
          setStyleAttribute(oldCnt, { "position": "absolute" });
          oldCnt.classList.add(CLS_PROGRESS);
          oldCnt.classList.add("e-view");
        };
        animateObj.end = function() {
          oldCnt.style.display = "none";
          oldCnt.classList.remove(CLS_ACTIVE2);
          oldCnt.classList.remove(CLS_PROGRESS);
          oldCnt.classList.remove("e-view");
          setStyleAttribute(oldCnt, { "display": "", "position": "" });
          if (oldCnt.childNodes.length === 0 && !_this.isTemplate) {
            detach(oldCnt);
          }
        };
        new Animation(animateObj).animate(oldCnt);
      } else {
        oldCnt.classList.remove(CLS_ACTIVE2);
      }
    };
    Tab2.prototype.triggerAnimation = function(id, value) {
      var _this = this;
      var prevIndex = this.prevIndex;
      var oldCnt;
      var itemCollection = [].slice.call(this.element.querySelector("." + CLS_CONTENT2).children);
      itemCollection.forEach(function(item) {
        if (item.id === _this.prevActiveEle) {
          oldCnt = item;
        }
      });
      var prevEle = this.tbItem[prevIndex];
      var newCnt = this.getTrgContent(this.cntEle, this.extIndex(id));
      if (isNullOrUndefined(oldCnt) && !isNullOrUndefined(prevEle)) {
        var idNo = this.extIndex(prevEle.id);
        oldCnt = this.getTrgContent(this.cntEle, idNo);
      }
      if (!isNullOrUndefined(newCnt)) {
        this.prevActiveEle = newCnt.id;
      }
      var isPrevent = isNullOrUndefined(this.animation) || isNullOrUndefined(this.animation.next.effect) || isNullOrUndefined(this.animation.previous.effect) || this.animation.previous.effect === "None" || this.animation.next.effect === "None";
      if (this.initRender || value === false || isPrevent) {
        if (oldCnt && oldCnt !== newCnt) {
          oldCnt.classList.remove(CLS_ACTIVE2);
        }
        return;
      }
      var cnt = select("." + CLS_CONTENT2, this.element);
      var animateObj;
      if (this.prevIndex > this.selectedItem && !this.isPopup) {
        var openEff = this.animation.previous.effect;
        animateObj = {
          name: openEff === "None" ? "" : openEff !== "SlideLeftIn" ? openEff : "SlideLeftIn",
          duration: this.animation.previous.duration === 0 && animationMode === "Enable" ? 600 : this.animation.previous.duration,
          timingFunction: this.animation.previous.easing
        };
      } else if (this.isPopup || this.prevIndex < this.selectedItem || this.prevIndex === this.selectedItem) {
        var clsEff = this.animation.next.effect;
        animateObj = {
          name: clsEff === "None" ? "" : clsEff !== "SlideRightIn" ? clsEff : "SlideRightIn",
          duration: this.animation.next.duration === 0 && animationMode === "Enable" ? 600 : this.animation.next.duration,
          timingFunction: this.animation.next.easing
        };
      }
      animateObj.progress = function() {
        cnt.classList.add(CLS_PROGRESS);
        _this.setActiveBorder();
      };
      animateObj.end = function() {
        cnt.classList.remove(CLS_PROGRESS);
        newCnt.classList.add(CLS_ACTIVE2);
      };
      if (!this.initRender && !isNullOrUndefined(oldCnt)) {
        this.triggerPrevAnimation(oldCnt, prevIndex);
      }
      this.isPopup = false;
      if (animateObj.name === "") {
        newCnt.classList.add(CLS_ACTIVE2);
      } else {
        new Animation(animateObj).animate(newCnt);
      }
    };
    Tab2.prototype.keyPressed = function(trg) {
      var trgParent = closest(trg, "." + CLS_HEADER2 + " ." + CLS_TB_ITEM);
      var trgIndex = this.getEleIndex(trgParent);
      if (!isNullOrUndefined(this.popEle) && trg.classList.contains("e-hor-nav")) {
        this.popEle.classList.contains(CLS_POPUP_OPEN) ? this.popObj.hide(this.hide) : this.popObj.show(this.show);
      } else if (trg.classList.contains("e-scroll-nav")) {
        trg.click();
      } else {
        if (!isNullOrUndefined(trgParent) && trgParent.classList.contains(CLS_ACTIVE2) === false) {
          this.selectTab(trgIndex, null, true);
          if (!isNullOrUndefined(this.popEle)) {
            this.popObj.hide(this.hide);
          }
        }
      }
    };
    Tab2.prototype.getTabHeader = function() {
      if (isNullOrUndefined(this.element)) {
        return void 0;
      }
      var headers = [].slice.call(this.element.children).filter(function(e) {
        return e.classList.contains(CLS_HEADER2);
      });
      if (headers.length > 0) {
        return headers[0];
      } else {
        var wrap = [].slice.call(this.element.children).filter(function(e) {
          return !e.classList.contains(CLS_BLA_TEM);
        })[0];
        if (!wrap) {
          return void 0;
        }
        return [].slice.call(wrap.children).filter(function(e) {
          return e.classList.contains(CLS_HEADER2);
        })[0];
      }
    };
    Tab2.prototype.getEleIndex = function(item) {
      return Array.prototype.indexOf.call(selectAll("." + CLS_TB_ITEM, this.getTabHeader()), item);
    };
    Tab2.prototype.extIndex = function(id) {
      return id.replace(CLS_ITEM3 + this.tabId + "_", "");
    };
    Tab2.prototype.expTemplateContent = function() {
      var _this = this;
      this.templateEle.forEach(function(eleStr) {
        if (!isNullOrUndefined(_this.element.querySelector(eleStr))) {
          document.body.appendChild(_this.element.querySelector(eleStr)).style.display = "none";
        }
      });
    };
    Tab2.prototype.templateCompile = function(ele, cnt, index) {
      var tempEle = this.createElement("div");
      this.compileElement(tempEle, cnt, "content", index);
      if (tempEle.childNodes.length !== 0) {
        ele.appendChild(tempEle);
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Tab2.prototype.compileElement = function(ele, val, prop, index) {
      var templateFn;
      if (typeof val === "string") {
        val = val.trim();
        if (this.isVue) {
          templateFn = compile(this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(val) : val);
        } else {
          ele.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(val) : val;
        }
      } else {
        templateFn = compile(val);
      }
      var templateFUN;
      if (!isNullOrUndefined(templateFn)) {
        templateFUN = templateFn({}, this, prop);
      }
      if (!isNullOrUndefined(templateFn) && templateFUN.length > 0) {
        [].slice.call(templateFUN).forEach(function(el) {
          ele.appendChild(el);
        });
      }
    };
    Tab2.prototype.headerTextCompile = function(element2, text, index) {
      this.compileElement(element2, text, "headerTemplate", index);
    };
    Tab2.prototype.getContent = function(ele, cnt, callType, index) {
      var eleStr;
      cnt = isNullOrUndefined(cnt) ? "" : cnt;
      if (typeof cnt === "string" || isNullOrUndefined(cnt.innerHTML)) {
        if (typeof cnt === "string" && this.enableHtmlSanitizer) {
          cnt = SanitizeHtmlHelper.sanitize(cnt);
        }
        if (cnt[0] === "." || cnt[0] === "#") {
          if (document.querySelectorAll(cnt).length) {
            var eleVal = document.querySelector(cnt);
            eleStr = eleVal.outerHTML.trim();
            if (callType === "clone") {
              ele.appendChild(eleVal.cloneNode(true));
            } else {
              ele.appendChild(eleVal);
              eleVal.style.display = "";
            }
          } else {
            this.templateCompile(ele, cnt, index);
          }
        } else {
          this.templateCompile(ele, cnt, index);
        }
      } else {
        ele.appendChild(cnt);
      }
      if (!isNullOrUndefined(eleStr)) {
        if (this.templateEle.indexOf(cnt.toString()) === -1) {
          this.templateEle.push(cnt.toString());
        }
      }
    };
    Tab2.prototype.getTrgContent = function(cntEle, no) {
      var ele;
      if (this.element.classList.contains(CLS_NEST2)) {
        ele = select("." + CLS_NEST2 + "> ." + CLS_CONTENT2 + " > #" + CLS_CONTENT2 + this.tabId + "_" + no, this.element);
      } else {
        ele = this.findEle(cntEle.children, CLS_CONTENT2 + this.tabId + "_" + no);
      }
      return ele;
    };
    Tab2.prototype.findEle = function(items, key) {
      var ele;
      for (var i = 0; i < items.length; i++) {
        if (items[i].id === key) {
          ele = items[i];
          break;
        }
      }
      return ele;
    };
    Tab2.prototype.isVertical = function() {
      var isVertical = this.headerPlacement === "Left" || this.headerPlacement === "Right" ? true : false;
      this.scrCntClass = isVertical ? CLS_VSCRCNT : CLS_HSCRCNT;
      return isVertical;
    };
    Tab2.prototype.addVerticalClass = function() {
      if (this.isVertical()) {
        var tbPos = this.headerPlacement === "Left" ? CLS_VLEFT : CLS_VRIGHT;
        addClass([this.hdrEle], [CLS_VERTICAL2, tbPos]);
        if (!this.element.classList.contains(CLS_NEST2)) {
          addClass([this.element], [CLS_VTAB, tbPos]);
        } else {
          addClass([this.hdrEle], [CLS_VTAB, tbPos]);
        }
      }
      if (this.headerPlacement === "Bottom") {
        addClass([this.hdrEle], [CLS_HBOTTOM]);
      }
    };
    Tab2.prototype.updatePopAnimationConfig = function() {
      this.show = { name: this.isVertical() ? "FadeIn" : "SlideDown", duration: 100 };
      this.hide = { name: this.isVertical() ? "FadeOut" : "SlideUp", duration: 100 };
    };
    Tab2.prototype.changeOrientation = function(place) {
      this.setOrientation(place, this.hdrEle);
      var activeTab = this.hdrEle.querySelector("." + CLS_ACTIVE2);
      var isVertical = this.hdrEle.classList.contains(CLS_VERTICAL2) ? true : false;
      removeClass([this.element], [CLS_VTAB]);
      removeClass([this.hdrEle], [CLS_VERTICAL2, CLS_VLEFT, CLS_VRIGHT]);
      if (isVertical !== this.isVertical()) {
        this.changeToolbarOrientation();
        if (!isNullOrUndefined(activeTab) && activeTab.classList.contains(CLS_TB_POPUP)) {
          this.popupHandler(activeTab);
        }
      }
      this.addVerticalClass();
      this.setActiveBorder();
      this.focusItem();
    };
    Tab2.prototype.focusItem = function() {
      var curActItem = select(" #" + CLS_ITEM3 + this.tabId + "_" + this.selectedItem, this.hdrEle);
      if (!isNullOrUndefined(curActItem)) {
        curActItem.firstElementChild.focus();
      }
    };
    Tab2.prototype.changeToolbarOrientation = function() {
      this.tbObj.setProperties({ height: this.isVertical() ? "100%" : "auto", width: this.isVertical() ? "auto" : "100%" }, true);
      this.tbObj.changeOrientation();
      this.updatePopAnimationConfig();
    };
    Tab2.prototype.setOrientation = function(place, ele) {
      var headerPos = Array.prototype.indexOf.call(this.element.children, ele);
      var contentPos = Array.prototype.indexOf.call(this.element.children, this.element.querySelector("." + CLS_CONTENT2));
      if (place === "Bottom" && contentPos > headerPos) {
        this.element.appendChild(ele);
      } else {
        removeClass([ele], [CLS_HBOTTOM]);
        this.element.insertBefore(ele, select("." + CLS_CONTENT2, this.element));
      }
    };
    Tab2.prototype.setCssClass = function(ele, cls, val) {
      if (cls === "" || isNullOrUndefined(cls)) {
        return;
      }
      var list = cls.split(" ");
      for (var i = 0; i < list.length; i++) {
        if (val) {
          ele.classList.add(list[i]);
        } else {
          ele.classList.remove(list[i]);
        }
      }
    };
    Tab2.prototype.setContentHeight = function(val) {
      if (this.element.classList.contains(CLS_FILL)) {
        removeClass([this.element], [CLS_FILL]);
      }
      if (isNullOrUndefined(this.cntEle)) {
        return;
      }
      var hdrEle = this.getTabHeader();
      if (this.heightAdjustMode === "None") {
        if (this.height === "auto") {
          return;
        } else {
          if (!this.isVertical()) {
            setStyleAttribute(this.cntEle, { "height": this.element.clientHeight - hdrEle.offsetHeight + "px" });
          }
        }
      } else if (this.heightAdjustMode === "Fill") {
        addClass([this.element], [CLS_FILL]);
        setStyleAttribute(this.element, { "height": "100%" });
        this.cntEle.style.height = "calc(100% - " + this.hdrEle.offsetHeight + "px)";
      } else if (this.heightAdjustMode === "Auto") {
        if (this.isTemplate === true) {
          var cnt = selectAll("." + CLS_CONTENT2 + " > ." + CLS_ITEM3, this.element);
          for (var i = 0; i < cnt.length; i++) {
            cnt[i].setAttribute("style", "display:block; visibility: visible");
            this.maxHeight = Math.max(this.maxHeight, this.getHeight(cnt[i]));
            cnt[i].style.removeProperty("display");
            cnt[i].style.removeProperty("visibility");
          }
        } else {
          this.cntEle = select("." + CLS_CONTENT2, this.element);
          if (val === true) {
            this.cntEle.appendChild(this.createElement("div", {
              id: CLS_CONTENT2 + this.tabId + "_0",
              className: CLS_ITEM3 + " " + CLS_ACTIVE2,
              attrs: { "role": "tabpanel", "aria-labelledby": CLS_ITEM3 + this.tabId + "_0" }
            }));
          }
          var ele = this.cntEle.children.item(0);
          for (var i = 0; i < this.items.length; i++) {
            this.getContent(ele, this.items[i].content, "clone", i);
            this.maxHeight = Math.max(this.maxHeight, this.getHeight(ele));
            while (ele.firstChild) {
              ele.removeChild(ele.firstChild);
            }
          }
          if (this.isReact || this.isAngular || this.isVue) {
            this.clearTemplate(["content"]);
          }
          this.templateEle = [];
          this.getContent(ele, this.items[0].content, "render", 0);
          if (this.prevIndex !== this.selectedItem) {
            ele.classList.remove(CLS_ACTIVE2);
          }
        }
        setStyleAttribute(this.cntEle, { "height": this.maxHeight + "px" });
      } else {
        setStyleAttribute(this.cntEle, { "height": "auto" });
      }
    };
    Tab2.prototype.getHeight = function(ele) {
      var cs = window.getComputedStyle(ele);
      return ele.offsetHeight + parseFloat(cs.getPropertyValue("padding-top")) + parseFloat(cs.getPropertyValue("padding-bottom")) + parseFloat(cs.getPropertyValue("margin-top")) + parseFloat(cs.getPropertyValue("margin-bottom"));
    };
    Tab2.prototype.setActiveBorder = function() {
      var trgHdrEle = this.getTabHeader();
      var trg = select("." + CLS_TB_ITEM + "." + CLS_ACTIVE2, trgHdrEle);
      if (isNullOrUndefined(trg)) {
        return;
      }
      if (!this.reorderActiveTab) {
        if (trg.classList.contains(CLS_TB_POPUP) && !this.bdrLine.classList.contains(CLS_HIDDEN2)) {
          this.bdrLine.classList.add(CLS_HIDDEN2);
        }
        if (trgHdrEle && !trgHdrEle.classList.contains(CLS_REORDER_ACTIVE_ITEM)) {
          trgHdrEle.classList.add(CLS_REORDER_ACTIVE_ITEM);
        }
      } else if (trgHdrEle) {
        trgHdrEle.classList.remove(CLS_REORDER_ACTIVE_ITEM);
      }
      var root = closest(trg, "." + CLS_TAB);
      if (this.element !== root) {
        return;
      }
      this.tbItems = select("." + CLS_TB_ITEMS, trgHdrEle);
      var bar = select("." + CLS_INDICATOR, trgHdrEle);
      var scrollCnt = select("." + CLS_TB_ITEMS + " ." + this.scrCntClass, trgHdrEle);
      if (this.isVertical()) {
        setStyleAttribute(bar, { "left": "", "right": "" });
        var tbHeight = isNullOrUndefined(scrollCnt) ? this.tbItems.offsetHeight : scrollCnt.offsetHeight;
        if (tbHeight !== 0) {
          setStyleAttribute(bar, { "top": trg.offsetTop + "px", "height": trg.offsetHeight + "px" });
        } else {
          setStyleAttribute(bar, { "top": 0, "height": 0 });
        }
      } else {
        if (this.overflowMode === "MultiRow") {
          var top_1 = this.headerPlacement === "Bottom" ? trg.offsetTop : trg.offsetHeight + trg.offsetTop;
          setStyleAttribute(bar, { "top": top_1 + "px", "height": "" });
        } else {
          setStyleAttribute(bar, { "top": "", "height": "" });
        }
        var tbWidth = isNullOrUndefined(scrollCnt) ? this.tbItems.offsetWidth : scrollCnt.offsetWidth;
        if (tbWidth !== 0) {
          setStyleAttribute(bar, { "left": trg.offsetLeft + "px", "right": tbWidth - (trg.offsetLeft + trg.offsetWidth) + "px" });
        } else {
          setStyleAttribute(bar, { "left": "auto", "right": "auto" });
        }
      }
      if (!isNullOrUndefined(this.bdrLine) && !trg.classList.contains(CLS_TB_POPUP)) {
        this.bdrLine.classList.remove(CLS_HIDDEN2);
      }
    };
    Tab2.prototype.setActive = function(value, skipDataBind, isInteracted) {
      if (skipDataBind === void 0) {
        skipDataBind = false;
      }
      if (isInteracted === void 0) {
        isInteracted = false;
      }
      this.tbItem = selectAll("." + CLS_TB_ITEM, this.getTabHeader());
      var trg = this.tbItem[value];
      if (value < 0 || isNaN(value) || this.tbItem.length === 0 || !isNullOrUndefined(trg) && trg.classList.contains(CLS_DISABLE5)) {
        return;
      }
      if (value >= 0 && !skipDataBind) {
        this.allowServerDataBinding = false;
        this.setProperties({ selectedItem: value }, true);
        this.allowServerDataBinding = true;
        if (!this.initRender) {
          this.serverDataBind();
        }
      }
      if (trg.classList.contains(CLS_ACTIVE2)) {
        this.setActiveBorder();
        return;
      }
      if (!this.isTemplate) {
        attributes(trg.firstElementChild, { "aria-controls": CLS_CONTENT2 + this.tabId + "_" + value });
      }
      var id = trg.id;
      this.removeActiveClass();
      trg.classList.add(CLS_ACTIVE2);
      trg.firstElementChild.setAttribute("aria-selected", "true");
      var no = Number(this.extIndex(id));
      if (isNullOrUndefined(this.prevActiveEle)) {
        this.prevActiveEle = CLS_CONTENT2 + this.tabId + "_" + no;
      }
      if (this.isTemplate) {
        if (select("." + CLS_CONTENT2, this.element).children.length > 0) {
          var trg_1 = this.findEle(select("." + CLS_CONTENT2, this.element).children, CLS_CONTENT2 + this.tabId + "_" + no);
          if (!isNullOrUndefined(trg_1)) {
            trg_1.classList.add(CLS_ACTIVE2);
          }
          this.triggerAnimation(id, this.enableAnimation);
        }
      } else {
        this.cntEle = select("." + CLS_TAB + " > ." + CLS_CONTENT2, this.element);
        var item = this.getTrgContent(this.cntEle, this.extIndex(id));
        if (isNullOrUndefined(item)) {
          this.cntEle.appendChild(this.createElement("div", {
            id: CLS_CONTENT2 + this.tabId + "_" + this.extIndex(id),
            className: CLS_ITEM3 + " " + CLS_ACTIVE2,
            attrs: { role: "tabpanel", "aria-labelledby": CLS_ITEM3 + this.tabId + "_" + this.extIndex(id) }
          }));
          var eleTrg = this.getTrgContent(this.cntEle, this.extIndex(id));
          var itemIndex = Array.prototype.indexOf.call(this.itemIndexArray, id);
          this.getContent(eleTrg, this.items[itemIndex].content, "render", itemIndex);
        } else {
          item.classList.add(CLS_ACTIVE2);
        }
        this.triggerAnimation(id, this.enableAnimation);
      }
      this.setActiveBorder();
      this.refreshItemVisibility(trg);
      if (!this.initRender && !skipDataBind) {
        var eventArg = {
          previousItem: this.prevItem,
          previousIndex: this.prevIndex,
          selectedItem: trg,
          selectedIndex: value,
          selectedContent: select("#" + CLS_CONTENT2 + this.tabId + "_" + this.selectingID, this.content),
          isSwiped: this.isSwiped,
          isInteracted,
          preventFocus: false
        };
        this.trigger("selected", eventArg, function(selectEventArgs) {
          if (!selectEventArgs.preventFocus) {
            trg.firstElementChild.focus();
          }
        });
      }
    };
    Tab2.prototype.setItems = function(items) {
      this.isReplace = true;
      this.tbItems = select("." + CLS_TB_ITEMS, this.getTabHeader());
      this.tbObj.items = this.parseObject(items, 0);
      this.tbObj.dataBind();
      this.isReplace = false;
    };
    Tab2.prototype.setRTL = function(value) {
      this.tbObj.enableRtl = value;
      this.tbObj.dataBind();
      this.setCssClass(this.element, CLS_RTL5, value);
      this.refreshActiveBorder();
    };
    Tab2.prototype.refreshActiveBorder = function() {
      if (!isNullOrUndefined(this.bdrLine)) {
        this.bdrLine.classList.add(CLS_HIDDEN2);
      }
      this.setActiveBorder();
    };
    Tab2.prototype.showPopup = function(config) {
      var tbPop = select(".e-popup.e-toolbar-pop", this.hdrEle);
      if (tbPop && tbPop.classList.contains("e-popup-close")) {
        var tbPopObj = tbPop && tbPop.ej2_instances[0];
        tbPopObj.position.X = this.headerPlacement === "Left" || this.element.classList.contains(CLS_RTL5) ? "left" : "right";
        tbPopObj.dataBind();
        tbPopObj.show(config);
      }
    };
    Tab2.prototype.bindDraggable = function() {
      var _this = this;
      if (this.allowDragAndDrop) {
        var tabHeader = this.element.querySelector("." + CLS_HEADER2);
        if (tabHeader) {
          var items = Array.prototype.slice.call(tabHeader.querySelectorAll("." + CLS_TB_ITEM));
          items.forEach(function(element2) {
            _this.initializeDrag(element2);
          });
        }
      }
    };
    Tab2.prototype.wireEvents = function() {
      this.bindDraggable();
      window.addEventListener("resize", this.resizeContext);
      EventHandler.add(this.element, "mouseover", this.hoverHandler, this);
      EventHandler.add(this.element, "keydown", this.spaceKeyDown, this);
      if (!isNullOrUndefined(this.cntEle)) {
        this.touchModule = new Touch(this.cntEle, { swipe: this.swipeHandler.bind(this) });
      }
      this.keyModule = new KeyboardEvents(this.element, { keyAction: this.keyHandler.bind(this), keyConfigs: this.keyConfigs });
      this.tabKeyModule = new KeyboardEvents(this.element, {
        keyAction: this.keyHandler.bind(this),
        keyConfigs: { openPopup: "shift+f10", tab: "tab", shiftTab: "shift+tab" },
        eventName: "keydown"
      });
    };
    Tab2.prototype.unWireEvents = function() {
      if (!isNullOrUndefined(this.keyModule)) {
        this.keyModule.destroy();
      }
      if (!isNullOrUndefined(this.tabKeyModule)) {
        this.tabKeyModule.destroy();
      }
      if (!isNullOrUndefined(this.cntEle) && !isNullOrUndefined(this.touchModule)) {
        this.touchModule.destroy();
        this.touchModule = null;
      }
      window.removeEventListener("resize", this.resizeContext);
      EventHandler.remove(this.element, "mouseover", this.hoverHandler);
      EventHandler.remove(this.element, "keydown", this.spaceKeyDown);
      this.element.classList.remove(CLS_RTL5);
      this.element.classList.remove(CLS_FOCUS);
    };
    Tab2.prototype.clickHandler = function(args) {
      this.element.classList.remove(CLS_FOCUS);
      var trg = args.originalEvent.target;
      var trgParent = closest(trg, "." + CLS_TB_ITEM);
      var trgIndex = this.getEleIndex(trgParent);
      if (trg.classList.contains(CLS_ICON_CLOSE)) {
        this.removeTab(trgIndex);
      } else if (this.isVertical() && closest(trg, "." + CLS_HOR_NAV)) {
        this.showPopup(this.show);
      } else {
        this.isPopup = false;
        if (!isNullOrUndefined(trgParent) && trgIndex !== this.selectedItem) {
          this.selectTab(trgIndex, args.originalEvent, true);
        }
      }
    };
    Tab2.prototype.swipeHandler = function(e) {
      if (e.velocity < 3 && isNullOrUndefined(e.originalEvent.changedTouches)) {
        return;
      }
      if (this.isNested) {
        this.element.setAttribute("data-swipe", "true");
      }
      var nestedTab = this.element.querySelector('[data-swipe="true"]');
      if (nestedTab) {
        nestedTab.removeAttribute("data-swipe");
        return;
      }
      this.isSwiped = true;
      if (e.swipeDirection === "Right" && this.selectedItem !== 0) {
        for (var k = this.selectedItem - 1; k >= 0; k--) {
          if (!this.tbItem[k].classList.contains(CLS_HIDDEN2)) {
            this.selectTab(k, null, true);
            break;
          }
        }
      } else if (e.swipeDirection === "Left" && this.selectedItem !== selectAll("." + CLS_TB_ITEM, this.element).length - 1) {
        for (var i = this.selectedItem + 1; i < this.tbItem.length; i++) {
          if (!this.tbItem[i].classList.contains(CLS_HIDDEN2)) {
            this.selectTab(i, null, true);
            break;
          }
        }
      }
      this.isSwiped = false;
    };
    Tab2.prototype.spaceKeyDown = function(e) {
      if (e.keyCode === 32 && e.which === 32 || e.keyCode === 35 && e.which === 35) {
        var clstHead = closest(e.target, "." + CLS_HEADER2);
        if (!isNullOrUndefined(clstHead)) {
          e.preventDefault();
        }
      }
    };
    Tab2.prototype.keyHandler = function(e) {
      if (this.element.classList.contains(CLS_DISABLE5)) {
        return;
      }
      this.element.classList.add(CLS_FOCUS);
      var trg = e.target;
      var tabHeader = this.getTabHeader();
      var actEle = select("." + CLS_ACTIVE2, tabHeader);
      this.popEle = select("." + CLS_TB_POP, tabHeader);
      if (!isNullOrUndefined(this.popEle)) {
        this.popObj = this.popEle.ej2_instances[0];
      }
      var item = closest(document.activeElement, "." + CLS_TB_ITEM);
      var trgParent = closest(trg, "." + CLS_TB_ITEM);
      switch (e.action) {
        case "space":
        case "enter":
          if (trg.parentElement.classList.contains(CLS_DISABLE5)) {
            return;
          }
          if (e.action === "enter" && trg.classList.contains("e-hor-nav")) {
            this.showPopup(this.show);
            break;
          }
          this.keyPressed(trg);
          break;
        case "tab":
        case "shiftTab":
          if (trg.classList.contains(CLS_WRAP) && closest(trg, "." + CLS_TB_ITEM).classList.contains(CLS_ACTIVE2) === false) {
            trg.setAttribute("tabindex", trg.getAttribute("data-tabindex"));
          }
          if (this.popObj && isVisible(this.popObj.element)) {
            this.popObj.hide(this.hide);
          }
          if (!isNullOrUndefined(actEle) && actEle.children.item(0).getAttribute("tabindex") === "-1") {
            actEle.children.item(0).setAttribute("tabindex", "0");
          }
          break;
        case "moveLeft":
        case "moveRight":
          if (!isNullOrUndefined(item)) {
            this.refreshItemVisibility(item);
          }
          break;
        case "openPopup":
          e.preventDefault();
          if (!isNullOrUndefined(this.popEle) && this.popEle.classList.contains(CLS_POPUP_CLOSE)) {
            this.popObj.show(this.show);
          }
          break;
        case "delete":
          if (this.showCloseButton === true && !isNullOrUndefined(trgParent)) {
            var nxtSib = trgParent.nextSibling;
            if (!isNullOrUndefined(nxtSib) && nxtSib.classList.contains(CLS_TB_ITEM)) {
              nxtSib.firstElementChild.focus();
            }
            this.removeTab(this.getEleIndex(trgParent));
          }
          this.setActiveBorder();
          break;
      }
    };
    Tab2.prototype.refreshItemVisibility = function(target) {
      var scrCnt = select("." + this.scrCntClass, this.tbItems);
      if (!this.isVertical() && !isNullOrUndefined(scrCnt)) {
        var scrBar = select(".e-hscroll-bar", this.tbItems);
        var scrStart = scrBar.scrollLeft;
        var scrEnd = scrStart + scrBar.offsetWidth;
        var eleStart = target.offsetLeft;
        var eleWidth = target.offsetWidth;
        var eleEnd = target.offsetLeft + target.offsetWidth;
        if (scrStart < eleStart && scrEnd < eleEnd) {
          var eleViewRange = scrEnd - eleStart;
          scrBar.scrollLeft = scrStart + (eleWidth - eleViewRange);
        } else {
          if (scrStart > eleStart && scrEnd > eleEnd) {
            var eleViewRange = eleEnd - scrStart;
            scrBar.scrollLeft = scrStart - (eleWidth - eleViewRange);
          }
        }
      } else {
        return;
      }
    };
    Tab2.prototype.getIndexFromEle = function(id) {
      return parseInt(id.substring(id.lastIndexOf("_") + 1), 10);
    };
    Tab2.prototype.hoverHandler = function(e) {
      var trg = e.target;
      if (!isNullOrUndefined(trg.classList) && trg.classList.contains(CLS_ICON_CLOSE)) {
        trg.setAttribute("title", new L10n("tab", { closeButtonTitle: this.title }, this.locale).getConstant("closeButtonTitle"));
      }
    };
    Tab2.prototype.evalOnPropertyChangeItems = function(newProp, oldProp) {
      var _this = this;
      if (!(newProp.items instanceof Array && oldProp.items instanceof Array)) {
        var changedProp = Object.keys(newProp.items);
        for (var i = 0; i < changedProp.length; i++) {
          var index = parseInt(Object.keys(newProp.items)[i], 10);
          var properties = Object.keys(newProp.items[index]);
          for (var j = 0; j < properties.length; j++) {
            var oldVal = Object(oldProp.items[index])[properties[j]];
            var newVal = Object(newProp.items[index])[properties[j]];
            var hdr = this.element.querySelectorAll("." + CLS_TB_ITEM)[index];
            var itemIndex = void 0;
            if (hdr && !isNullOrUndefined(hdr.id) && hdr.id !== "") {
              itemIndex = this.getIndexFromEle(hdr.id);
            } else {
              itemIndex = index;
            }
            var hdrItem = select("." + CLS_TB_ITEMS + " #" + CLS_ITEM3 + this.tabId + "_" + itemIndex, this.element);
            var cntItem = select("." + CLS_CONTENT2 + " #" + CLS_CONTENT2 + this.tabId + "_" + itemIndex, this.element);
            if (properties[j] === "header" || properties[j] === "headerTemplate") {
              var icon = isNullOrUndefined(this.items[index].header) || isNullOrUndefined(this.items[index].header.iconCss) ? "" : this.items[index].header.iconCss;
              var textVal = this.items[index].headerTemplate || this.items[index].header.text;
              if (properties[j] === "headerTemplate") {
                this.clearTabTemplate(hdrItem, properties[j], CLS_TB_ITEM);
              }
              if (textVal === "" && icon === "") {
                this.removeTab(index);
              } else {
                this.tbId = hdr.id;
                var arr = [];
                arr.push(this.items[index]);
                this.items.splice(index, 1);
                this.itemIndexArray.splice(index, 1);
                this.tbObj.items.splice(index, 1);
                var isHiddenEle = hdrItem.classList.contains(CLS_HIDDEN2);
                detach(hdrItem);
                this.isReplace = true;
                this.addTab(arr, index);
                if (isHiddenEle) {
                  this.hideTab(index);
                }
                this.isReplace = false;
              }
            }
            if (properties[j] === "content" && !isNullOrUndefined(cntItem)) {
              var strVal = typeof newVal === "string" || isNullOrUndefined(newVal.innerHTML);
              if (strVal && (newVal[0] === "." || newVal[0] === "#") && newVal.length) {
                var eleVal = document.querySelector(newVal);
                cntItem.appendChild(eleVal);
                eleVal.style.display = "";
              } else if (newVal === "" && oldVal[0] === "#") {
                document.body.appendChild(this.element.querySelector(oldVal)).style.display = "none";
                cntItem.innerHTML = newVal;
              } else if (this.isAngular || this.isReact) {
                this.clearTabTemplate(cntItem, properties[j], CLS_ITEM3);
                cntItem.innerHTML = "";
                this.templateCompile(cntItem, newVal, index);
              } else if (typeof newVal !== "function") {
                cntItem.innerHTML = newVal;
              }
            }
            if (properties[j] === "cssClass") {
              if (!isNullOrUndefined(hdrItem)) {
                hdrItem.classList.remove(oldVal);
                hdrItem.classList.add(newVal);
              }
              if (!isNullOrUndefined(cntItem)) {
                cntItem.classList.remove(oldVal);
                cntItem.classList.add(newVal);
              }
            }
            if (properties[j] === "disabled") {
              this.enableTab(index, newVal === true ? false : true);
            }
            if (properties[j] === "visible") {
              this.hideTab(index, newVal === true ? false : true);
            }
          }
        }
        if (this.isReact && this.portals && this.portals.length > 0) {
          this.renderReactTemplates(function() {
            _this.refreshActiveTabBorder();
          });
        }
      } else {
        this.lastIndex = 0;
        if (isNullOrUndefined(this.tbObj)) {
          this.reRenderItems();
        } else {
          if (this.isReact || this.isAngular) {
            this.clearTemplate();
          }
          this.setItems(newProp.items);
          if (this.templateEle.length > 0) {
            this.expTemplateContent();
          }
          this.templateEle = [];
          var selectElement = select("." + CLS_TAB + " > ." + CLS_CONTENT2, this.element);
          while (selectElement.firstElementChild) {
            detach(selectElement.firstElementChild);
          }
          this.select(this.selectedItem);
          this.draggableItems = [];
          this.bindDraggable();
        }
      }
    };
    Tab2.prototype.clearTabTemplate = function(templateEle, templateName, className) {
      if (!this.clearTemplates) {
        return;
      }
      if (this.registeredTemplate && this.registeredTemplate[templateName]) {
        var registeredTemplates = this.registeredTemplate;
        for (var index = 0; index < registeredTemplates[templateName].length; index++) {
          var registeredItem = registeredTemplates[templateName][index].rootNodes[0];
          var closestItem = closest(registeredItem, "." + className);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate([templateName], [registeredTemplates[templateName][index]]);
            break;
          }
        }
      } else if (this.portals && this.portals.length > 0) {
        var portals = this.portals;
        for (var index = 0; index < portals.length; index++) {
          var portalItem = portals[index];
          var closestItem = closest(portalItem.containerInfo, "." + className);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate([templateName], index);
            break;
          }
        }
      }
    };
    Tab2.prototype.initializeDrag = function(target) {
      var _this = this;
      var dragObj = new Draggable(target, {
        dragArea: this.dragArea,
        dragTarget: "." + CLS_TB_ITEM,
        clone: true,
        helper: this.helper.bind(this),
        dragStart: this.itemDragStart.bind(this),
        drag: function(e) {
          var dragIndex = _this.getEleIndex(_this.dragItem);
          var dropIndex;
          var dropItem;
          var dragArgs = {
            draggedItem: _this.dragItem,
            event: e.event,
            target: e.target,
            droppedItem: e.target.closest("." + CLS_TB_ITEM),
            clonedElement: _this.cloneElement,
            index: dragIndex
          };
          if (!isNullOrUndefined(e.target.closest("." + CLS_TAB)) && !e.target.closest("." + CLS_TAB).isEqualNode(_this.element) && _this.dragArea !== "." + CLS_HEADER2) {
            _this.trigger("dragging", dragArgs);
          } else {
            if (!e.target.closest(_this.dragArea) && _this.overflowMode !== "Popup") {
              document.body.style.cursor = "not-allowed";
              addClass([_this.cloneElement], CLS_HIDDEN2);
              if (_this.dragItem.classList.contains(CLS_HIDDEN2)) {
                removeClass([_this.dragItem], CLS_HIDDEN2);
              }
              _this.dragItem.querySelector("." + CLS_WRAP).style.visibility = "visible";
            } else {
              document.body.style.cursor = "";
              _this.dragItem.querySelector("." + CLS_WRAP).style.visibility = "hidden";
              if (_this.cloneElement.classList.contains(CLS_HIDDEN2)) {
                removeClass([_this.cloneElement], CLS_HIDDEN2);
              }
            }
            if (_this.overflowMode === "Scrollable" && !isNullOrUndefined(_this.element.querySelector(".e-hscroll"))) {
              var scrollRightNavEle = _this.element.querySelector(".e-scroll-right-nav");
              var scrollLeftNavEle = _this.element.querySelector(".e-scroll-left-nav");
              var hscrollBar = _this.element.querySelector(".e-hscroll-bar");
              if (!isNullOrUndefined(scrollRightNavEle) && Math.abs(scrollRightNavEle.offsetWidth / 2 + scrollRightNavEle.offsetLeft) > _this.cloneElement.offsetLeft + _this.cloneElement.offsetWidth) {
                hscrollBar.scrollLeft -= 10;
              }
              if (!isNullOrUndefined(scrollLeftNavEle) && Math.abs(scrollLeftNavEle.offsetLeft + scrollLeftNavEle.offsetWidth - _this.cloneElement.offsetLeft) > scrollLeftNavEle.offsetWidth / 2) {
                hscrollBar.scrollLeft += 10;
              }
            }
            _this.cloneElement.style.pointerEvents = "none";
            dropItem = closest(e.target, "." + CLS_TB_ITEM + ".e-draggable");
            var scrollContentWidth = 0;
            if (_this.overflowMode === "Scrollable" && !isNullOrUndefined(_this.element.querySelector(".e-hscroll"))) {
              scrollContentWidth = _this.element.querySelector(".e-hscroll-content").offsetWidth;
            }
            if (dropItem != null && !dropItem.isSameNode(_this.dragItem) && dropItem.closest("." + CLS_TAB).isSameNode(_this.dragItem.closest("." + CLS_TAB))) {
              dropIndex = _this.getEleIndex(dropItem);
              if (dropIndex < dragIndex && Math.abs(dropItem.offsetLeft + dropItem.offsetWidth - _this.cloneElement.offsetLeft) > dropItem.offsetWidth / 2) {
                _this.dragAction(dropItem, dragIndex, dropIndex);
              }
              if (dropIndex > dragIndex && Math.abs(dropItem.offsetWidth / 2) + dropItem.offsetLeft - scrollContentWidth < _this.cloneElement.offsetLeft + _this.cloneElement.offsetWidth) {
                _this.dragAction(dropItem, dragIndex, dropIndex);
              }
            }
            _this.droppedIndex = _this.getEleIndex(_this.dragItem);
            _this.trigger("dragging", dragArgs);
          }
        },
        dragStop: this.itemDragStop.bind(this)
      });
      this.draggableItems.push(dragObj);
    };
    Tab2.prototype.helper = function(e) {
      this.cloneElement = this.createElement("div");
      if (e.element) {
        this.cloneElement = e.element.cloneNode(true);
        addClass([this.cloneElement], "e-tab-clone-element");
        if (this.element.querySelector("." + CLS_HEADER2).classList.contains(CLS_CLOSE_SHOW)) {
          addClass([this.cloneElement], CLS_CLOSE_SHOW);
        }
        removeClass([this.cloneElement.querySelector("." + CLS_WRAP)], "e-ripple");
        if (!isNullOrUndefined(this.cloneElement.querySelector(".e-ripple-element"))) {
          remove(this.cloneElement.querySelector(".e-ripple-element"));
        }
        document.body.appendChild(this.cloneElement);
      }
      return this.cloneElement;
    };
    Tab2.prototype.itemDragStart = function(e) {
      var _this = this;
      this.draggingItems = this.items.map(function(x) {
        return x;
      });
      this.dragItem = e.element;
      var dragArgs = {
        draggedItem: e.element,
        event: e.event,
        target: e.target,
        droppedItem: null,
        index: this.getEleIndex(this.dragItem),
        clonedElement: this.cloneElement,
        cancel: false
      };
      this.trigger("onDragStart", dragArgs, function(tabItemDragArgs) {
        if (tabItemDragArgs.cancel) {
          var dragObj = e.element.ej2_instances[0];
          if (!isNullOrUndefined(dragObj)) {
            dragObj.intDestroy(e.event);
          }
          detach(_this.cloneElement);
        } else {
          _this.removeActiveClass();
          addClass([_this.tbItems.querySelector("." + CLS_INDICATOR)], CLS_HIDDEN2);
          _this.dragItem.querySelector("." + CLS_WRAP).style.visibility = "hidden";
        }
      });
    };
    Tab2.prototype.dragAction = function(dropItem, dragsIndex, dropIndex) {
      if (this.items.length > 0) {
        var item = this.draggingItems[dragsIndex];
        this.draggingItems.splice(dragsIndex, 1);
        this.draggingItems.splice(dropIndex, 0, item);
      }
      if (this.overflowMode === "MultiRow") {
        dropItem.parentNode.insertBefore(this.dragItem, dropItem.nextElementSibling);
      }
      if (dragsIndex > dropIndex) {
        if (!this.dragItem.parentElement.isSameNode(dropItem.parentElement)) {
          if (this.overflowMode === "Extended") {
            if (dropItem.isSameNode(dropItem.parentElement.lastChild)) {
              var popupContainer = this.dragItem.parentNode;
              dropItem.parentNode.insertBefore(this.dragItem, dropItem);
              popupContainer.insertBefore(dropItem.parentElement.lastChild, popupContainer.childNodes[0]);
            } else {
              this.dragItem.parentNode.insertBefore(dropItem.parentElement.lastChild, this.dragItem.parentElement.childNodes[0]);
              dropItem.parentNode.insertBefore(this.dragItem, dropItem);
            }
          } else {
            var lastEle = dropItem.parentElement.lastChild;
            if (dropItem.isSameNode(lastEle)) {
              var popupContainer = this.dragItem.parentNode;
              dropItem.parentNode.insertBefore(this.dragItem, dropItem);
              popupContainer.insertBefore(lastEle, popupContainer.childNodes[0]);
            } else {
              this.dragItem.parentNode.insertBefore(dropItem.parentElement.lastChild, this.dragItem.parentElement.childNodes[0]);
              dropItem.parentNode.insertBefore(this.dragItem, dropItem);
            }
          }
        } else {
          this.dragItem.parentNode.insertBefore(this.dragItem, dropItem);
        }
      }
      if (dragsIndex < dropIndex) {
        if (!this.dragItem.parentElement.isSameNode(dropItem.parentElement)) {
          if (this.overflowMode === "Extended") {
            this.dragItem.parentElement.appendChild(dropItem.parentElement.firstElementChild);
            dropItem.parentNode.insertBefore(this.dragItem, dropItem.nextSibling);
          } else {
            this.dragItem.parentNode.insertBefore(dropItem.parentElement.lastChild, this.dragItem.parentElement.childNodes[0]);
            dropItem.parentNode.insertBefore(this.dragItem, dropItem);
          }
        } else {
          this.dragItem.parentNode.insertBefore(this.dragItem, dropItem.nextElementSibling);
        }
      }
    };
    Tab2.prototype.itemDragStop = function(e) {
      var _this = this;
      detach(this.cloneElement);
      this.cloneElement = null;
      this.dragItem.querySelector("." + CLS_WRAP).style.visibility = "visible";
      document.body.style.cursor = "";
      var dragStopArgs = {
        draggedItem: this.dragItem,
        event: e.event,
        target: e.target,
        droppedItem: this.tbItem[this.droppedIndex],
        clonedElement: null,
        index: this.droppedIndex,
        cancel: false
      };
      this.trigger("dragged", dragStopArgs, function(tabItemDropArgs) {
        if (tabItemDropArgs.cancel) {
          _this.refresh();
        } else {
          if (_this.items.length > 0 && _this.draggingItems.length > 0) {
            _this.items = _this.draggingItems;
            _this.selectedItem = _this.droppedIndex;
            _this.refresh();
          } else {
            _this.dragItem.querySelector("." + CLS_WRAP).style.visibility = "";
            removeClass([_this.tbItems.querySelector("." + CLS_INDICATOR)], CLS_HIDDEN2);
            _this.selectTab(_this.droppedIndex, null, true);
          }
        }
      });
      this.dragItem = null;
    };
    Tab2.prototype.enableTab = function(index, value) {
      var tbItems = selectAll("." + CLS_TB_ITEM, this.element)[index];
      if (isNullOrUndefined(tbItems)) {
        return;
      }
      if (value === true) {
        tbItems.classList.remove(CLS_DISABLE5, CLS_OVERLAY3);
        tbItems.firstElementChild.setAttribute("tabindex", tbItems.firstElementChild.getAttribute("data-tabindex"));
      } else {
        tbItems.classList.add(CLS_DISABLE5, CLS_OVERLAY3);
        tbItems.firstElementChild.removeAttribute("tabindex");
        if (tbItems.classList.contains(CLS_ACTIVE2)) {
          this.select(index + 1);
        }
      }
      if (!isNullOrUndefined(this.items[index])) {
        this.items[index].disabled = !value;
        this.dataBind();
      }
      tbItems.firstElementChild.setAttribute("aria-disabled", value === true ? "false" : "true");
    };
    Tab2.prototype.addTab = function(items, index) {
      var _this = this;
      var addArgs = { addedItems: items, cancel: false };
      if (!this.isReplace) {
        this.trigger("adding", addArgs, function(tabAddingArgs) {
          if (!tabAddingArgs.cancel) {
            _this.addingTabContent(items, index);
          }
        });
      } else {
        this.addingTabContent(items, index);
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Tab2.prototype.addingTabContent = function(items, index) {
      var _this = this;
      var lastEleIndex = 0;
      this.hdrEle = select("." + CLS_HEADER2, this.element);
      if (isNullOrUndefined(this.hdrEle)) {
        this.items = items;
        this.reRenderItems();
        this.bindDraggable();
      } else {
        var itemsCount = selectAll(".e-tab-header ." + CLS_TB_ITEM, this.element).length;
        if (itemsCount !== 0) {
          lastEleIndex = this.lastIndex + 1;
        }
        if (isNullOrUndefined(index)) {
          index = itemsCount - 1;
        }
        if (itemsCount < index || index < 0 || isNaN(index)) {
          return;
        }
        if (itemsCount === 0 && !isNullOrUndefined(this.hdrEle)) {
          this.hdrEle.style.display = "";
        }
        if (!isNullOrUndefined(this.bdrLine)) {
          this.bdrLine.classList.add(CLS_HIDDEN2);
        }
        this.tbItems = select("." + CLS_TB_ITEMS, this.getTabHeader());
        this.isAdd = true;
        var tabItems_2 = this.parseObject(items, index);
        this.isAdd = false;
        var i_1 = 0;
        var textValue_1;
        items.forEach(function(item, place) {
          textValue_1 = item.headerTemplate || item.header.text;
          if (!(isNullOrUndefined(item.headerTemplate || item.header) || isNullOrUndefined(textValue_1) || textValue_1.length === 0 && !isNullOrUndefined(item.header) && isNullOrUndefined(item.header.iconCss))) {
            if (tabItems_2[place]) {
              if (isNullOrUndefined(item.id)) {
                item.id = CLS_ITEM3 + _this.tabId + "_" + TABITEMPREFIX + (lastEleIndex + place).toString();
              }
              tabItems_2[place].htmlAttributes["data-id"] = item.id;
            }
            _this.items.splice(index + i_1, 0, item);
            i_1++;
          }
          if (_this.isTemplate && !isNullOrUndefined(item.header) && !isNullOrUndefined(item.header.text)) {
            var no = lastEleIndex + place;
            var ele = _this.createElement("div", {
              id: CLS_CONTENT2 + _this.tabId + "_" + no,
              className: CLS_ITEM3,
              attrs: { role: "tabpanel", "aria-labelledby": CLS_ITEM3 + "_" + no }
            });
            _this.cntEle.insertBefore(ele, _this.cntEle.children[index + place]);
            var eleTrg = _this.getTrgContent(_this.cntEle, no.toString());
            _this.getContent(eleTrg, item.content, "render", index);
          }
        });
        this.tbObj.addItems(tabItems_2, index);
        if (!this.isReplace) {
          this.trigger("added", { addedItems: items });
        }
        if (this.selectedItem === index) {
          this.select(index);
        } else {
          this.setActiveBorder();
          this.tbItem = selectAll("." + CLS_TB_ITEM, this.getTabHeader());
        }
        this.bindDraggable();
      }
    };
    Tab2.prototype.removeTab = function(index) {
      var _this = this;
      var trg = selectAll("." + CLS_TB_ITEM, this.element)[index];
      if (isNullOrUndefined(trg)) {
        return;
      }
      var removeArgs = { removedItem: trg, removedIndex: index, cancel: false };
      this.trigger("removing", removeArgs, function(tabRemovingArgs) {
        if (!tabRemovingArgs.cancel) {
          var header = select("#" + CLS_ITEM3 + _this.tabId + "_" + _this.extIndex(trg.id), select("." + CLS_TB_ITEMS, _this.element));
          if (!isNullOrUndefined(header)) {
            _this.clearTabTemplate(header, "headerTemplate", CLS_TB_ITEM);
          }
          _this.tbObj.removeItems(index);
          if (_this.allowDragAndDrop && index !== Array.prototype.indexOf.call(_this.itemIndexArray, trg.id)) {
            index = Array.prototype.indexOf.call(_this.itemIndexArray, trg.id);
          }
          var targetEleIndex = _this.itemIndexArray.indexOf(trg.id);
          _this.items.splice(targetEleIndex, 1);
          _this.itemIndexArray.splice(targetEleIndex, 1);
          _this.refreshActiveBorder();
          var cntTrg = select("#" + CLS_CONTENT2 + _this.tabId + "_" + _this.extIndex(trg.id), select("." + CLS_CONTENT2, _this.element));
          if (!isNullOrUndefined(cntTrg)) {
            _this.clearTabTemplate(cntTrg, "content", CLS_ITEM3);
            detach(cntTrg);
          }
          _this.trigger("removed", tabRemovingArgs);
          if (_this.draggableItems && _this.draggableItems.length > 0) {
            _this.draggableItems[index].destroy();
            _this.draggableItems[index] = null;
            _this.draggableItems.splice(index, 1);
          }
          if (trg.classList.contains(CLS_ACTIVE2)) {
            index = index > selectAll("." + CLS_TB_ITEM + ":not(." + CLS_TB_POPUP + ")", _this.element).length - 1 ? index - 1 : index;
            _this.enableAnimation = false;
            _this.selectedItem = index;
            _this.select(index);
          } else if (index !== _this.selectedItem) {
            if (index < _this.selectedItem) {
              index = _this.itemIndexArray.indexOf(_this.tbItem[_this.selectedItem].id);
              _this.setProperties({ selectedItem: index > -1 ? index : _this.selectedItem }, true);
              _this.prevIndex = _this.selectedItem;
            }
            _this.tbItem = selectAll("." + CLS_TB_ITEM, _this.getTabHeader());
          }
          if (selectAll("." + CLS_TB_ITEM, _this.element).length === 0) {
            _this.hdrEle.style.display = "none";
          }
          _this.enableAnimation = true;
        }
      });
    };
    Tab2.prototype.hideTab = function(index, value) {
      var items;
      var item = selectAll("." + CLS_TB_ITEM, this.element)[index];
      if (isNullOrUndefined(item)) {
        return;
      }
      if (isNullOrUndefined(value)) {
        value = true;
      }
      this.bdrLine.classList.add(CLS_HIDDEN2);
      if (value === true) {
        item.classList.add(CLS_HIDDEN2);
        items = selectAll("." + CLS_TB_ITEM + ":not(." + CLS_HIDDEN2 + ")", this.tbItems);
        if (items.length !== 0 && item.classList.contains(CLS_ACTIVE2)) {
          if (index !== 0) {
            for (var i = index - 1; i >= 0; i--) {
              if (!this.tbItem[i].classList.contains(CLS_HIDDEN2)) {
                this.select(i);
                break;
              } else if (i === 0) {
                for (var k = index + 1; k < this.tbItem.length; k++) {
                  if (!this.tbItem[k].classList.contains(CLS_HIDDEN2)) {
                    this.select(k);
                    break;
                  }
                }
              }
            }
          } else {
            for (var k = index + 1; k < this.tbItem.length; k++) {
              if (!this.tbItem[k].classList.contains(CLS_HIDDEN2)) {
                this.select(k);
                break;
              }
            }
          }
        } else if (items.length === 0) {
          this.element.classList.add(CLS_HIDDEN2);
        }
      } else {
        this.element.classList.remove(CLS_HIDDEN2);
        items = selectAll("." + CLS_TB_ITEM + ":not(." + CLS_HIDDEN2 + ")", this.tbItems);
        item.classList.remove(CLS_HIDDEN2);
        if (items.length === 0) {
          this.select(index);
        }
      }
      this.setActiveBorder();
      if (!isNullOrUndefined(item.firstElementChild)) {
        item.firstElementChild.setAttribute("aria-hidden", "" + value);
      }
      if (this.overflowMode === "Popup" && this.tbObj) {
        this.tbObj.refreshOverflow();
      }
    };
    Tab2.prototype.selectTab = function(args, event, isInteracted) {
      if (event === void 0) {
        event = null;
      }
      if (isInteracted === void 0) {
        isInteracted = false;
      }
      this.isInteracted = isInteracted;
      this.select(args, event);
    };
    Tab2.prototype.select = function(args, event) {
      var _this = this;
      var tabHeader = this.getTabHeader();
      this.tbItems = select("." + CLS_TB_ITEMS, tabHeader);
      this.tbItem = selectAll("." + CLS_TB_ITEM, tabHeader);
      this.content = select("." + CLS_CONTENT2, this.element);
      this.prevItem = this.tbItem[this.prevIndex];
      if (isNullOrUndefined(this.selectedItem) || this.selectedItem < 0 || this.tbItem.length <= this.selectedItem || isNaN(this.selectedItem)) {
        this.selectedItem = 0;
      } else {
        this.selectedID = this.extIndex(this.tbItem[this.selectedItem].id);
      }
      var trg = this.tbItem[args];
      if (isNullOrUndefined(trg)) {
        this.selectedID = "0";
      } else {
        this.selectingID = this.extIndex(trg.id);
      }
      if (!isNullOrUndefined(this.prevItem) && !this.prevItem.classList.contains(CLS_DISABLE5)) {
        this.prevItem.children.item(0).setAttribute("tabindex", this.prevItem.firstElementChild.getAttribute("tabindex"));
      }
      var eventArg = {
        event,
        previousItem: this.prevItem,
        previousIndex: this.prevIndex,
        selectedItem: this.tbItem[this.selectedItem],
        selectedIndex: this.selectedItem,
        selectedContent: !isNullOrUndefined(this.content) ? select("#" + CLS_CONTENT2 + this.tabId + "_" + this.selectedID, this.content) : null,
        selectingItem: trg,
        selectingIndex: args,
        selectingContent: !isNullOrUndefined(this.content) ? select("#" + CLS_CONTENT2 + this.tabId + "_" + this.selectingID, this.content) : null,
        isSwiped: this.isSwiped,
        isInteracted: this.isInteracted,
        cancel: false
      };
      if (!this.initRender) {
        this.trigger("selecting", eventArg, function(selectArgs) {
          if (!selectArgs.cancel) {
            _this.selectingContent(args, _this.isInteracted);
          }
        });
      } else {
        this.selectingContent(args, this.isInteracted);
      }
      this.isInteracted = false;
    };
    Tab2.prototype.selectingContent = function(args, isInteracted) {
      if (typeof args === "number") {
        if (!isNullOrUndefined(this.tbItem[args]) && (this.tbItem[args].classList.contains(CLS_DISABLE5) || this.tbItem[args].classList.contains(CLS_HIDDEN2))) {
          for (var i = args + 1; i < this.items.length; i++) {
            if (this.items[i].disabled === false && this.items[i].visible === true) {
              args = i;
              break;
            } else {
              args = 0;
            }
          }
        }
        if (this.tbItem.length > args && args >= 0 && !isNaN(args)) {
          this.prevIndex = this.selectedItem;
          this.prevItem = this.tbItem[this.prevIndex];
          if (this.tbItem[args].classList.contains(CLS_TB_POPUP) && this.reorderActiveTab) {
            this.setActive(this.popupHandler(this.tbItem[args]), null, isInteracted);
            if (!isNullOrUndefined(this.items) && this.items.length > 0 && this.allowDragAndDrop) {
              this.tbItem = selectAll("." + CLS_TB_ITEMS + " ." + CLS_TB_ITEM, this.hdrEle);
              var item = this.items[args];
              this.items.splice(args, 1);
              this.items.splice(this.tbItem.length - 1, 0, item);
              var itemId = this.itemIndexArray[args];
              this.itemIndexArray.splice(args, 1);
              this.itemIndexArray.splice(this.tbItem.length - 1, 0, itemId);
            }
          } else {
            this.setActive(args, null, isInteracted);
          }
        } else {
          this.setActive(0, null, isInteracted);
        }
      } else if (args instanceof HTMLElement) {
        this.setActive(this.getEleIndex(args), null, isInteracted);
      }
    };
    Tab2.prototype.getItemIndex = function(tabItemId) {
      var tabIndex;
      for (var i = 0; i < this.tbItem.length; i++) {
        var value = this.tbItem[i].getAttribute("data-id");
        if (tabItemId === value) {
          tabIndex = i;
          break;
        }
      }
      return tabIndex;
    };
    Tab2.prototype.disable = function(value) {
      this.setCssClass(this.element, CLS_DISABLE5, value);
      this.element.setAttribute("aria-disabled", "" + value);
    };
    Tab2.prototype.getPersistData = function() {
      return this.addOnPersist(["selectedItem", "actEleId"]);
    };
    Tab2.prototype.getModuleName = function() {
      return "tab";
    };
    Tab2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      var sortedKeys = Object.keys(newProp).sort(function(a, b) {
        if (a === "items")
          return -1;
        if (b === "items")
          return 1;
        return 0;
      });
      for (var _i = 0, sortedKeys_1 = sortedKeys; _i < sortedKeys_1.length; _i++) {
        var prop = sortedKeys_1[_i];
        switch (prop) {
          case "width":
            setStyleAttribute(this.element, { width: formatUnit(newProp.width) });
            break;
          case "height":
            setStyleAttribute(this.element, { height: formatUnit(newProp.height) });
            this.setContentHeight(false);
            break;
          case "cssClass":
            var headerEle = this.element.querySelector("." + CLS_HEADER2);
            if (oldProp.cssClass !== "" && !isNullOrUndefined(oldProp.cssClass)) {
              this.setCssClass(this.element, oldProp.cssClass, false);
              this.setCssClass(this.element, newProp.cssClass, true);
              if (!isNullOrUndefined(headerEle)) {
                this.setCssClass(headerEle, oldProp.cssClass, false);
                this.setCssClass(headerEle, newProp.cssClass, true);
              }
            } else {
              this.setCssClass(this.element, newProp.cssClass, true);
              if (!isNullOrUndefined(headerEle)) {
                this.setCssClass(headerEle, newProp.cssClass, true);
              }
            }
            break;
          case "items":
            this.evalOnPropertyChangeItems(newProp, oldProp);
            break;
          case "showCloseButton":
            this.setCloseButton(newProp.showCloseButton);
            break;
          case "reorderActiveTab":
            this.refreshActiveTabBorder();
            break;
          case "selectedItem":
            this.selectedItem = oldProp.selectedItem;
            this.select(newProp.selectedItem);
            break;
          case "headerPlacement":
            this.changeOrientation(newProp.headerPlacement);
            break;
          case "enableRtl":
            this.setRTL(newProp.enableRtl);
            break;
          case "overflowMode":
            this.tbObj.overflowMode = newProp.overflowMode;
            this.tbObj.dataBind();
            this.refreshActiveTabBorder();
            break;
          case "heightAdjustMode":
            this.setContentHeight(false);
            this.select(this.selectedItem);
            break;
          case "scrollStep":
            if (this.tbObj) {
              this.tbObj.scrollStep = this.scrollStep;
            }
            break;
          case "allowDragAndDrop":
            this.bindDraggable();
            break;
          case "dragArea":
            if (this.allowDragAndDrop) {
              this.draggableItems.forEach(function(item) {
                item.dragArea = _this.dragArea;
              });
              this.refresh();
            }
            break;
        }
      }
    };
    Tab2.prototype.refreshActiveTab = function() {
      if (this.isReact && this.isTemplate) {
        this.clearTemplate();
      }
      if (!this.isTemplate) {
        if (this.element.querySelector("." + CLS_TB_ITEM + "." + CLS_ACTIVE2)) {
          detach(this.element.querySelector("." + CLS_TB_ITEM + "." + CLS_ACTIVE2).children[0]);
          detach(this.element.querySelector("." + CLS_CONTENT2).querySelector("." + CLS_ACTIVE2).children[0]);
          var item = this.items[this.selectedItem];
          var pos = isNullOrUndefined(item.header) || isNullOrUndefined(item.header.iconPosition) ? "" : item.header.iconPosition;
          var css = isNullOrUndefined(item.header) || isNullOrUndefined(item.header.iconCss) ? "" : item.header.iconCss;
          var text = item.headerTemplate || item.header.text;
          var txtWrap = this.createElement("div", { className: CLS_TEXT, attrs: { "role": "presentation" } });
          if (!isNullOrUndefined(text.tagName)) {
            txtWrap.appendChild(text);
          } else {
            this.headerTextCompile(txtWrap, text, this.selectedItem);
          }
          var tEle = void 0;
          var icon = this.createElement("span", {
            className: CLS_ICONS + " " + CLS_TAB_ICON + " " + CLS_ICON + "-" + pos + " " + css
          });
          var tConts = this.createElement("div", { className: CLS_TEXT_WRAP });
          tConts.appendChild(txtWrap);
          if (text !== "" && text !== void 0 && css !== "") {
            if (pos === "left" || pos === "top") {
              tConts.insertBefore(icon, tConts.firstElementChild);
            } else {
              tConts.appendChild(icon);
            }
            tEle = txtWrap;
            this.isIconAlone = false;
          } else {
            tEle = css === "" ? txtWrap : icon;
            if (tEle === icon) {
              detach(txtWrap);
              tConts.appendChild(icon);
              this.isIconAlone = true;
            }
          }
          var tabIndex = isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString();
          var wrapAtt = item.disabled ? {} : { tabIndex, "data-tabindex": tabIndex, role: "tab", "aria-selected": "true", "aria-disabled": "false" };
          tConts.appendChild(this.btnCls.cloneNode(true));
          var wraper = this.createElement("div", { className: CLS_WRAP, attrs: wrapAtt });
          wraper.appendChild(tConts);
          if (pos === "top" || pos === "bottom") {
            this.element.classList.add("e-vertical-icon");
          }
          this.element.querySelector("." + CLS_TB_ITEM + "." + CLS_ACTIVE2).appendChild(wraper);
          var crElem = this.createElement("div");
          var cnt = item.content;
          var eleStr = void 0;
          if (typeof cnt === "string" || isNullOrUndefined(cnt.innerHTML)) {
            if (typeof cnt === "string" && this.enableHtmlSanitizer) {
              cnt = SanitizeHtmlHelper.sanitize(cnt);
            }
            if (cnt[0] === "." || cnt[0] === "#") {
              if (document.querySelectorAll(cnt).length) {
                var eleVal = document.querySelector(cnt);
                eleStr = eleVal.outerHTML.trim();
                crElem.appendChild(eleVal);
                eleVal.style.display = "";
              } else {
                this.compileElement(crElem, cnt, "content", this.selectedItem);
              }
            } else {
              this.compileElement(crElem, cnt, "content", this.selectedItem);
            }
          } else {
            crElem.appendChild(cnt);
          }
          if (!isNullOrUndefined(eleStr)) {
            if (this.templateEle.indexOf(cnt.toString()) === -1) {
              this.templateEle.push(cnt.toString());
            }
          }
          this.element.querySelector("." + CLS_ITEM3 + "." + CLS_ACTIVE2).appendChild(crElem);
        }
      } else {
        var tabItems = this.element.querySelector("." + CLS_TB_ITEMS);
        var element2 = this.element.querySelector("." + CLS_TB_ITEM + "." + CLS_ACTIVE2);
        var index = this.getIndexFromEle(element2.id);
        var header = element2.innerText;
        var detachContent = this.element.querySelector("." + CLS_CONTENT2).querySelector("." + CLS_ACTIVE2).children[0];
        var mainContents = detachContent.innerHTML;
        detach(element2);
        detach(detachContent);
        var attr = {
          className: CLS_TB_ITEM + " " + CLS_TEMPLATE2 + " " + CLS_ACTIVE2,
          id: CLS_ITEM3 + this.tabId + "_" + index
        };
        var txtString = this.createElement("span", {
          className: CLS_TEXT,
          innerHTML: header,
          attrs: { "role": "presentation" }
        }).outerHTML;
        var conte = this.createElement("div", {
          className: CLS_TEXT_WRAP,
          innerHTML: txtString + this.btnCls.outerHTML
        }).outerHTML;
        var tabIndex = element2.firstElementChild.getAttribute("data-tabindex");
        var wrap = this.createElement("div", {
          className: CLS_WRAP,
          innerHTML: conte,
          attrs: { tabIndex, "data-tabindex": tabIndex, role: "tab", "aria-controls": CLS_CONTENT2 + this.tabId + "_" + index, "aria-selected": "true", "aria-disabled": "false" }
        });
        tabItems.insertBefore(this.createElement("div", attr), tabItems.children[index + 1]);
        this.element.querySelector("." + CLS_TB_ITEM + "." + CLS_ACTIVE2).appendChild(wrap);
        var crElem = this.createElement("div", { innerHTML: mainContents });
        this.element.querySelector("." + CLS_CONTENT2).querySelector("." + CLS_ACTIVE2).appendChild(crElem);
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Tab2.prototype.refreshActiveTabBorder = function() {
      var activeEle = select("." + CLS_TB_ITEM + "." + CLS_TB_POPUP + "." + CLS_ACTIVE2, this.element);
      if (!isNullOrUndefined(activeEle) && this.reorderActiveTab) {
        this.select(this.getEleIndex(activeEle));
      }
      this.refreshActiveBorder();
    };
    __decorate37([
      Collection([], TabItem)
    ], Tab2.prototype, "items", void 0);
    __decorate37([
      Property("100%")
    ], Tab2.prototype, "width", void 0);
    __decorate37([
      Property("auto")
    ], Tab2.prototype, "height", void 0);
    __decorate37([
      Property("")
    ], Tab2.prototype, "cssClass", void 0);
    __decorate37([
      Property(0)
    ], Tab2.prototype, "selectedItem", void 0);
    __decorate37([
      Property("Top")
    ], Tab2.prototype, "headerPlacement", void 0);
    __decorate37([
      Property("Content")
    ], Tab2.prototype, "heightAdjustMode", void 0);
    __decorate37([
      Property("Scrollable")
    ], Tab2.prototype, "overflowMode", void 0);
    __decorate37([
      Property("Dynamic")
    ], Tab2.prototype, "loadOn", void 0);
    __decorate37([
      Property(false)
    ], Tab2.prototype, "enablePersistence", void 0);
    __decorate37([
      Property(true)
    ], Tab2.prototype, "enableHtmlSanitizer", void 0);
    __decorate37([
      Property(false)
    ], Tab2.prototype, "showCloseButton", void 0);
    __decorate37([
      Property(true)
    ], Tab2.prototype, "reorderActiveTab", void 0);
    __decorate37([
      Property()
    ], Tab2.prototype, "scrollStep", void 0);
    __decorate37([
      Property()
    ], Tab2.prototype, "dragArea", void 0);
    __decorate37([
      Property(false)
    ], Tab2.prototype, "allowDragAndDrop", void 0);
    __decorate37([
      Property(true)
    ], Tab2.prototype, "clearTemplates", void 0);
    __decorate37([
      Complex({}, TabAnimationSettings)
    ], Tab2.prototype, "animation", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "created", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "adding", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "added", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "selecting", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "selected", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "removing", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "removed", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "onDragStart", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "dragging", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "dragged", void 0);
    __decorate37([
      Event()
    ], Tab2.prototype, "destroyed", void 0);
    Tab2 = __decorate37([
      NotifyPropertyChanges
    ], Tab2);
    return Tab2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/treeview/treeview.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ROOT5 = "e-treeview";
var CONTROL3 = "e-control";
var COLLAPSIBLE = "e-icon-collapsible";
var EXPANDABLE = "e-icon-expandable";
var LISTITEM = "e-list-item";
var LISTTEXT = "e-list-text";
var LISTWRAP = "e-text-wrap";
var IELISTWRAP = "e-ie-wrap";
var PARENTITEM = "e-list-parent";
var HOVER = "e-hover";
var ACTIVE2 = "e-active";
var LOAD = "e-icons-spinner";
var PROCESS = "e-process";
var ICON3 = "e-icons";
var TEXTWRAP = "e-text-content";
var INPUT2 = "e-input";
var INPUTGROUP2 = "e-input-group";
var TREEINPUT = "e-tree-input";
var EDITING = "e-editing";
var RTL12 = "e-rtl";
var INTERACTION = "e-interaction";
var DRAGITEM = "e-drag-item";
var DROPPABLE = "e-droppable";
var DRAGGING = "e-dragging";
var SIBLING = "e-sibling";
var DROPIN = "e-drop-in";
var DROPNEXT = "e-drop-next";
var DROPOUT = "e-drop-out";
var NODROP = "e-no-drop";
var FULLROWWRAP = "e-fullrow-wrap";
var FULLROW = "e-fullrow";
var SELECTED3 = "e-selected";
var EXPANDED = "e-expanded";
var NODECOLLAPSED = "e-node-collapsed";
var DISABLE = "e-disable";
var DROPCOUNT = "e-drop-count";
var CHECK2 = "e-check";
var INDETERMINATE2 = "e-stop";
var CHECKBOXWRAP = "e-treeview-checkbox";
var CHECKBOXFRAME = "e-frame";
var CHECKBOXRIPPLE = "e-ripple-container";
var RIPPLE4 = "e-ripple";
var RIPPLEELMENT = "e-ripple-element";
var FOCUS = "e-node-focus";
var IMAGE = "e-list-img";
var BIGGER = "e-bigger";
var SMALL = "e-small";
var CHILD = "e-has-child";
var ITEM_ANIMATION_ACTIVE = "e-animation-active";
var DISABLED8 = "e-disabled";
var PREVENTSELECT = "e-prevent";
var treeAriaAttr = {
  treeRole: "group",
  itemRole: "treeitem",
  listRole: "group",
  itemText: "",
  wrapperRole: ""
};
var FieldsSettings = (
  /** @class */
  function(_super) {
    __extends39(FieldsSettings2, _super);
    function FieldsSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate38([
      Property("child")
    ], FieldsSettings2.prototype, "child", void 0);
    __decorate38([
      Property([])
    ], FieldsSettings2.prototype, "dataSource", void 0);
    __decorate38([
      Property("expanded")
    ], FieldsSettings2.prototype, "expanded", void 0);
    __decorate38([
      Property("hasChildren")
    ], FieldsSettings2.prototype, "hasChildren", void 0);
    __decorate38([
      Property("htmlAttributes")
    ], FieldsSettings2.prototype, "htmlAttributes", void 0);
    __decorate38([
      Property("iconCss")
    ], FieldsSettings2.prototype, "iconCss", void 0);
    __decorate38([
      Property("id")
    ], FieldsSettings2.prototype, "id", void 0);
    __decorate38([
      Property("imageUrl")
    ], FieldsSettings2.prototype, "imageUrl", void 0);
    __decorate38([
      Property("isChecked")
    ], FieldsSettings2.prototype, "isChecked", void 0);
    __decorate38([
      Property("parentID")
    ], FieldsSettings2.prototype, "parentID", void 0);
    __decorate38([
      Property(null)
    ], FieldsSettings2.prototype, "query", void 0);
    __decorate38([
      Property("selectable")
    ], FieldsSettings2.prototype, "selectable", void 0);
    __decorate38([
      Property("selected")
    ], FieldsSettings2.prototype, "selected", void 0);
    __decorate38([
      Property(null)
    ], FieldsSettings2.prototype, "tableName", void 0);
    __decorate38([
      Property("text")
    ], FieldsSettings2.prototype, "text", void 0);
    __decorate38([
      Property("tooltip")
    ], FieldsSettings2.prototype, "tooltip", void 0);
    __decorate38([
      Property("navigateUrl")
    ], FieldsSettings2.prototype, "navigateUrl", void 0);
    return FieldsSettings2;
  }(ChildProperty)
);
var ActionSettings = (
  /** @class */
  function(_super) {
    __extends39(ActionSettings2, _super);
    function ActionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate38([
      Property("SlideDown")
    ], ActionSettings2.prototype, "effect", void 0);
    __decorate38([
      Property(400)
    ], ActionSettings2.prototype, "duration", void 0);
    __decorate38([
      Property("linear")
    ], ActionSettings2.prototype, "easing", void 0);
    return ActionSettings2;
  }(ChildProperty)
);
var NodeAnimationSettings = (
  /** @class */
  function(_super) {
    __extends39(NodeAnimationSettings2, _super);
    function NodeAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate38([
      Complex({ effect: "SlideUp", duration: 400, easing: "linear" }, ActionSettings)
    ], NodeAnimationSettings2.prototype, "collapse", void 0);
    __decorate38([
      Complex({ effect: "SlideDown", duration: 400, easing: "linear" }, ActionSettings)
    ], NodeAnimationSettings2.prototype, "expand", void 0);
    return NodeAnimationSettings2;
  }(ChildProperty)
);
var TreeView = (
  /** @class */
  function(_super) {
    __extends39(TreeView2, _super);
    function TreeView2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isRefreshed = false;
      _this.preventExpand = false;
      _this.checkedElement = [];
      _this.disableNode = [];
      _this.validArr = [];
      _this.validNodes = [];
      _this.expandChildren = [];
      _this.isFieldChange = false;
      _this.changeDataSource = false;
      _this.hasTemplate = false;
      _this.isFirstRender = false;
      _this.isNodeDropped = false;
      _this.isInteracted = false;
      _this.isRightClick = false;
      _this.mouseDownStatus = false;
      _this.isDropIn = false;
      _this.OldCheckedData = [];
      return _this;
    }
    TreeView_1 = TreeView2;
    TreeView2.prototype.getModuleName = function() {
      return "treeview";
    };
    TreeView2.prototype.preRender = function() {
      var _this = this;
      this.checkActionNodes = [];
      this.parentNodeCheck = [];
      this.dragStartAction = false;
      this.isAnimate = false;
      this.keyConfigs = {
        escape: "escape",
        end: "end",
        enter: "enter",
        f2: "f2",
        home: "home",
        moveDown: "downarrow",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        ctrlDown: "ctrl+downarrow",
        ctrlUp: "ctrl+uparrow",
        ctrlEnter: "ctrl+enter",
        ctrlHome: "ctrl+home",
        ctrlEnd: "ctrl+end",
        ctrlA: "ctrl+A",
        shiftDown: "shift+downarrow",
        shiftUp: "shift+uparrow",
        shiftEnter: "shift+enter",
        shiftHome: "shift+home",
        shiftEnd: "shift+end",
        csDown: "ctrl+shift+downarrow",
        csUp: "ctrl+shift+uparrow",
        csEnter: "ctrl+shift+enter",
        csHome: "ctrl+shift+home",
        csEnd: "ctrl+shift+end",
        space: "space",
        shiftSpace: "shift+space",
        ctrlSpace: "ctrl+space"
      };
      this.listBaseOption = {
        expandCollapse: true,
        showIcon: true,
        expandIconClass: EXPANDABLE,
        ariaAttributes: treeAriaAttr,
        expandIconPosition: "Left",
        itemCreated: function(e) {
          _this.beforeNodeCreate(e);
        },
        enableHtmlSanitizer: this.enableHtmlSanitizer,
        itemNavigable: this.fullRowNavigable
      };
      this.updateListProp(this.fields);
      this.aniObj = new Animation({});
      this.treeList = [];
      this.isLoaded = false;
      this.isInitalExpand = false;
      this.expandChildren = [];
      this.index = 0;
      this.setTouchClass();
      this.DDTTreeData = JSON.parse(JSON.stringify(this.fields.dataSource));
      if (isNullOrUndefined(this.selectedNodes)) {
        this.setProperties({ selectedNodes: [] }, true);
      }
      if (isNullOrUndefined(this.checkedNodes)) {
        this.setProperties({ checkedNodes: [] }, true);
      }
      if (isNullOrUndefined(this.expandedNodes)) {
        this.setProperties({ expandedNodes: [] }, true);
      } else {
        this.isInitalExpand = true;
      }
    };
    TreeView2.prototype.getPersistData = function() {
      var keyEntity = ["selectedNodes", "checkedNodes", "expandedNodes"];
      return this.addOnPersist(keyEntity);
    };
    TreeView2.prototype.render = function() {
      this.initialRender = true;
      this.initialize();
      this.setDataBinding(false);
      this.setDisabledMode();
      this.setExpandOnType();
      if (!this.disabled) {
        this.setRipple();
      }
      this.wireEditingEvents(this.allowEditing);
      this.setDragAndDrop(this.allowDragAndDrop);
      if (!this.disabled) {
        this.wireEvents();
      }
      this.initialRender = false;
      this.renderComplete();
    };
    TreeView2.prototype.initialize = function() {
      this.element.setAttribute("role", "tree");
      this.element.setAttribute("aria-activedescendant", this.element.id + "_active");
      this.setCssClass(null, this.cssClass);
      this.setEnableRtl();
      this.setFullRow(this.fullRowSelect);
      this.setTextWrap();
      this.nodeTemplateFn = this.templateComplier(this.nodeTemplate);
    };
    TreeView2.prototype.setDisabledMode = function() {
      if (this.disabled) {
        this.element.classList.add(DISABLED8);
        this.element.setAttribute("aria-disabled", "true");
      } else {
        this.element.classList.remove(DISABLED8);
        this.element.setAttribute("aria-disabled", "false");
      }
    };
    TreeView2.prototype.setEnableRtl = function() {
      (this.enableRtl ? addClass : removeClass)([this.element], RTL12);
    };
    TreeView2.prototype.setRipple = function() {
      var tempStr = "." + FULLROW + ",." + TEXTWRAP;
      var rippleModel = {
        selector: tempStr,
        ignore: "." + TEXTWRAP + " > ." + ICON3 + ",." + INPUTGROUP2 + ",." + INPUT2 + ", ." + CHECKBOXWRAP
      };
      this.rippleFn = rippleEffect(this.element, rippleModel);
      var iconModel = {
        selector: "." + TEXTWRAP + " > ." + ICON3,
        isCenterRipple: true
      };
      this.rippleIconFn = rippleEffect(this.element, iconModel);
    };
    TreeView2.prototype.setFullRow = function(isEnabled) {
      (isEnabled ? addClass : removeClass)([this.element], FULLROWWRAP);
    };
    TreeView2.prototype.setMultiSelect = function(isEnabled) {
      if (isEnabled) {
        this.element.setAttribute("aria-multiselectable", "true");
      } else {
        this.element.setAttribute("aria-multiselectable", "false");
      }
    };
    TreeView2.prototype.templateComplier = function(template) {
      if (template) {
        this.hasTemplate = true;
        this.element.classList.add(INTERACTION);
        try {
          if (typeof template !== "function" && document.querySelectorAll(template).length) {
            return compile(document.querySelector(template).innerHTML.trim());
          } else {
            return compile(template);
          }
        } catch (e) {
          return compile(template);
        }
      }
      this.element.classList.remove(INTERACTION);
      return void 0;
    };
    TreeView2.prototype.setDataBinding = function(changeDataSource) {
      var _this = this;
      this.treeList.push("false");
      if (this.fields.dataSource instanceof DataManager) {
        this.isOffline = this.fields.dataSource.dataSource.offline;
        if (this.fields.dataSource.ready) {
          this.fields.dataSource.ready.then(function(e) {
            _this.isOffline = _this.fields.dataSource.dataSource.offline;
            if (_this.fields.dataSource instanceof DataManager && _this.isOffline) {
              _this.treeList.pop();
              _this.treeData = e.result;
              _this.isNumberTypeId = _this.getType();
              _this.setRootData();
              _this.renderItems(true);
              if (_this.treeList.length === 0 && !_this.isLoaded) {
                _this.finalize();
              }
            }
          }).catch(function(e) {
            _this.trigger("actionFailure", { error: e });
          });
        } else {
          this.fields.dataSource.executeQuery(this.getQuery(this.fields)).then(function(e) {
            _this.treeList.pop();
            _this.treeData = e.result;
            _this.isNumberTypeId = _this.getType();
            _this.setRootData();
            if (changeDataSource) {
              _this.changeDataSource = true;
            }
            _this.renderItems(true);
            _this.changeDataSource = false;
            if (_this.treeList.length === 0 && !_this.isLoaded) {
              _this.finalize();
            }
          }).catch(function(e) {
            _this.trigger("actionFailure", { error: e });
          });
        }
      } else {
        this.treeList.pop();
        if (isNullOrUndefined(this.fields.dataSource)) {
          this.rootData = this.treeData = [];
        } else {
          this.treeData = JSON.parse(JSON.stringify(this.fields.dataSource));
          this.setRootData();
        }
        this.isNumberTypeId = this.getType();
        this.renderItems(false);
      }
      if (this.treeList.length === 0 && !this.isLoaded) {
        this.finalize();
      }
    };
    TreeView2.prototype.getQuery = function(mapper, value) {
      if (value === void 0) {
        value = null;
      }
      var columns = [];
      var query;
      if (!mapper.query) {
        query = new Query();
        var prop = this.getActualProperties(mapper);
        for (var _i = 0, _a = Object.keys(prop); _i < _a.length; _i++) {
          var col = _a[_i];
          if (col !== "dataSource" && col !== "tableName" && col !== "child" && !!mapper["" + col] && col !== "url" && columns.indexOf(mapper["" + col]) === -1) {
            columns.push(mapper["" + col]);
          }
        }
        query.select(columns);
        if (Object.prototype.hasOwnProperty.call(prop, "tableName")) {
          query.from(mapper.tableName);
        }
      } else {
        query = mapper.query.clone();
      }
      ListBase.addSorting(this.sortOrder, mapper.text, query);
      if (!isNullOrUndefined(value) && !isNullOrUndefined(mapper.parentID)) {
        query.where(mapper.parentID, "equal", this.isNumberTypeId ? parseFloat(value) : value);
      }
      return query;
    };
    TreeView2.prototype.getType = function() {
      return this.treeData[0] ? typeof getValue(this.fields.id, this.treeData[0]) === "number" ? true : false : false;
    };
    TreeView2.prototype.setRootData = function() {
      this.dataType = this.getDataType(this.treeData, this.fields);
      if (this.dataType === 1) {
        this.groupedData = this.getGroupedData(this.treeData, this.fields.parentID);
        var rootItems = this.getChildNodes(this.treeData, void 0, true);
        if (isNullOrUndefined(rootItems)) {
          this.rootData = [];
        } else {
          this.rootData = rootItems;
        }
      } else {
        this.rootData = this.treeData;
      }
    };
    TreeView2.prototype.isChildObject = function() {
      if (typeof this.fields.child === "object") {
        return true;
      } else {
        return false;
      }
    };
    TreeView2.prototype.renderItems = function(isSorted) {
      this.listBaseOption.ariaAttributes.level = 1;
      var sortedData = this.getSortedData(this.rootData);
      this.ulElement = ListBase.createList(this.createElement, isSorted ? this.rootData : sortedData, this.listBaseOption);
      this.element.appendChild(this.ulElement);
      var rootNodes = this.ulElement.querySelectorAll(".e-list-item");
      if (this.loadOnDemand === false) {
        var i = 0;
        while (i < rootNodes.length) {
          this.renderChildNodes(rootNodes[parseInt(i.toString(), 10)], true, null, true);
          i++;
        }
      }
      var parentEle = selectAll("." + PARENTITEM, this.element);
      if (parentEle.length === 1 && (rootNodes && rootNodes.length !== 0) || this.loadOnDemand) {
        this.finalizeNode(this.element);
      }
      this.parentNodeCheck = [];
      this.parentCheckData = [];
      this.updateCheckedStateFromDS();
      if (this.autoCheck && this.showCheckBox && !this.isLoaded) {
        this.updateParentCheckState();
      }
    };
    TreeView2.prototype.updateCheckedStateFromDS = function() {
      this.validNodes = [];
      if (this.treeData && this.showCheckBox) {
        if (this.dataType === 1) {
          var mapper = this.fields;
          var resultData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.isChecked, "equal", true, false));
          for (var i = 0; i < resultData.length; i++) {
            var resultId = resultData[parseInt(i.toString(), 10)][this.fields.id] ? resultData[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
            if (this.checkedNodes.indexOf(resultId) === -1 && !this.isLoaded) {
              this.checkedNodes.push(resultId);
            }
            if (resultData[parseInt(i.toString(), 10)][this.fields.hasChildren]) {
              var id = resultData[parseInt(i.toString(), 10)][this.fields.id];
              var childData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.parentID, "equal", id, false));
              for (var child = 0; child < childData.length; child++) {
                var childId = childData[parseInt(child.toString(), 10)][this.fields.id] ? childData[parseInt(child.toString(), 10)][this.fields.id].toString() : null;
                if (this.checkedNodes.indexOf(childId) === -1 && this.autoCheck) {
                  this.checkedNodes.push(childId);
                }
              }
            }
          }
          for (var i = 0; i < this.checkedNodes.length; i++) {
            var mapper_1 = this.fields;
            var checkState = new DataManager(this.treeData).executeLocal(new Query().where(mapper_1.id, "equal", this.checkedNodes[parseInt(i.toString(), 10)], true));
            if (checkState[0] && this.autoCheck) {
              this.getCheckedNodeDetails(mapper_1, checkState);
              this.checkIndeterminateState(checkState[0]);
            }
            if (checkState.length > 0) {
              var checkedId = checkState[0][this.fields.id] ? checkState[0][this.fields.id].toString() : null;
              if (this.checkedNodes.indexOf(checkedId) > -1 && this.validNodes.indexOf(checkedId) === -1) {
                this.validNodes.push(checkedId);
              }
            }
            var checkedData = new DataManager(this.treeData).executeLocal(new Query().where(mapper_1.parentID, "equal", this.checkedNodes[parseInt(i.toString(), 10)], true));
            for (var index = 0; index < checkedData.length; index++) {
              var checkedId = checkedData[parseInt(index.toString(), 10)][this.fields.id] ? checkedData[parseInt(index.toString(), 10)][this.fields.id].toString() : null;
              if (this.checkedNodes.indexOf(checkedId) === -1 && this.autoCheck) {
                this.checkedNodes.push(checkedId);
              }
              if (this.checkedNodes.indexOf(checkedId) > -1 && this.validNodes.indexOf(checkedId) === -1) {
                this.validNodes.push(checkedId);
              }
            }
          }
        } else if (this.dataType === 2 || this.fields.dataSource instanceof DataManager && this.isOffline) {
          for (var index = 0; index < this.treeData.length; index++) {
            var fieldId = this.treeData[parseInt(index.toString(), 10)][this.fields.id] ? this.treeData[parseInt(index.toString(), 10)][this.fields.id].toString() : "";
            if (this.treeData[parseInt(index.toString(), 10)][this.fields.isChecked] && !this.isLoaded && this.checkedNodes.indexOf(fieldId) === -1) {
              this.checkedNodes.push(fieldId);
            }
            if (this.checkedNodes.indexOf(fieldId) > -1 && this.validNodes.indexOf(fieldId) === -1) {
              this.validNodes.push(fieldId);
            }
            var childItems = getValue(this.fields.child.toString(), this.treeData[parseInt(index.toString(), 10)]);
            if (childItems) {
              this.updateChildCheckState(childItems, this.treeData[parseInt(index.toString(), 10)]);
            }
          }
          this.validNodes = this.enablePersistence ? this.checkedNodes : this.validNodes;
        }
        this.setProperties({ checkedNodes: this.validNodes }, true);
      }
    };
    TreeView2.prototype.getCheckedNodeDetails = function(mapper, checkNodes) {
      var id = checkNodes[0][this.fields.parentID] ? checkNodes[0][this.fields.parentID].toString() : null;
      var count = 0;
      var element2 = this.element.querySelector('[data-uid="' + checkNodes[0][this.fields.id] + '"]');
      var parentEle = this.element.querySelector('[data-uid="' + checkNodes[0][this.fields.parentID] + '"]');
      if (!element2 && !parentEle) {
        if (this.parentNodeCheck.indexOf(id) === -1) {
          this.parentNodeCheck.push(id);
        }
        var childNodes = this.getChildNodes(this.treeData, id);
        for (var i = 0; i < childNodes.length; i++) {
          var childId = childNodes[parseInt(i.toString(), 10)][this.fields.id] ? childNodes[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
          if (this.checkedNodes.indexOf(childId) !== -1) {
            count++;
          }
          if (count === childNodes.length && this.checkedNodes.indexOf(id) === -1) {
            this.checkedNodes.push(id);
          }
        }
        var preElement = new DataManager(this.treeData).executeLocal(new Query().where(mapper.id, "equal", id, true));
        this.getCheckedNodeDetails(mapper, preElement);
      } else if (parentEle) {
        var check = select("." + CHECK2, parentEle);
        if (!check) {
          this.changeState(parentEle, "indeterminate", null, true, true);
        }
      }
    };
    TreeView2.prototype.updateParentCheckState = function() {
      var indeterminate = selectAll("." + INDETERMINATE2, this.element);
      var childCheckedElement;
      var data = this.treeData;
      if (this.element.classList.contains("e-filtering")) {
        data = this.DDTTreeData;
      }
      for (var i = 0; i < indeterminate.length; i++) {
        var node = closest(indeterminate[parseInt(i.toString(), 10)], "." + LISTITEM);
        var nodeId = node.getAttribute("data-uid").toString();
        var OldCheckedNodes = void 0;
        if (this.element.classList.contains("e-filtering")) {
          OldCheckedNodes = new DataManager(this.OldCheckedData).executeLocal(new Query().where("parentID", "equal", nodeId, true));
        }
        if (this.dataType === 1) {
          childCheckedElement = new DataManager(data).executeLocal(new Query().where(this.fields.parentID, "equal", nodeId, true));
        } else {
          childCheckedElement = this.getChildNodes(data, nodeId);
        }
        var count = 0;
        if (childCheckedElement) {
          var _loop_1 = function(j2) {
            var childId = childCheckedElement[parseInt(j2.toString(), 10)][this_1.fields.id].toString();
            if (this_1.checkedNodes.indexOf(childId) !== -1) {
              count++;
            } else if (this_1.element.classList.contains("e-filtering") && OldCheckedNodes.findIndex(function(e) {
              return e["id"] === childId;
            }) !== -1) {
              count++;
            }
          };
          var this_1 = this;
          for (var j = 0; j < childCheckedElement.length; j++) {
            _loop_1(j);
          }
          if (count === childCheckedElement.length) {
            var nodeCheck = node.getAttribute("data-uid");
            if (this.checkedNodes.indexOf(nodeCheck) === -1) {
              this.checkedNodes.push(nodeCheck);
            }
            this.changeState(node, "check", null, true, true);
          } else if (count === 0 && this.checkedNodes.length === 0) {
            this.changeState(node, "uncheck", null, true, true);
          }
        }
      }
    };
    TreeView2.prototype.checkIndeterminateState = function(data) {
      var element2;
      if (this.dataType === 1) {
        element2 = this.element.querySelector('[data-uid="' + data[this.fields.parentID] + '"]');
      } else {
        element2 = this.element.querySelector('[data-uid="' + data[this.fields.id] + '"]');
      }
      if (element2) {
        var ariaChecked = element2.getAttribute("aria-checked");
        if (ariaChecked !== "true") {
          this.changeState(element2, "indeterminate", null, true, true);
        }
      } else if (this.dataType === 2) {
        if (this.parentNodeCheck.indexOf(data[this.fields.id].toString()) === -1) {
          this.parentNodeCheck.push(data[this.fields.id].toString());
        }
      }
    };
    TreeView2.prototype.updateChildCheckState = function(childItems, treeData) {
      var count = 0;
      var checkedParent = treeData[this.fields.id] ? treeData[this.fields.id].toString() : "";
      for (var index = 0; index < childItems.length; index++) {
        var checkedChild = childItems[parseInt(index.toString(), 10)][this.fields.id] ? childItems[parseInt(index.toString(), 10)][this.fields.id].toString() : "";
        if (childItems[parseInt(index.toString(), 10)][this.fields.isChecked] && !this.isLoaded && this.checkedNodes.indexOf(checkedChild) === -1) {
          this.checkedNodes.push(checkedChild);
        }
        if (this.checkedNodes.indexOf(checkedParent) !== -1 && this.checkedNodes.indexOf(checkedChild) === -1 && this.autoCheck) {
          this.checkedNodes.push(checkedChild);
        }
        if (this.checkedNodes.indexOf(checkedChild) !== -1 && this.autoCheck) {
          count++;
        }
        if (this.checkedNodes.indexOf(checkedChild) > -1 && this.validNodes.indexOf(checkedChild) === -1) {
          this.validNodes.push(checkedChild);
        }
        var subChildItems = getValue(this.fields.child.toString(), childItems[parseInt(index.toString(), 10)]);
        if (subChildItems && subChildItems.length) {
          if (this.parentCheckData.indexOf(treeData) === -1) {
            this.parentCheckData.push(treeData);
          }
          this.updateChildCheckState(subChildItems, childItems[parseInt(index.toString(), 10)]);
        }
        if (count === childItems.length && this.autoCheck && this.checkedNodes.indexOf(checkedParent) === -1) {
          this.checkedNodes.push(checkedParent);
        }
      }
      if (count !== 0 && this.autoCheck) {
        this.checkIndeterminateState(treeData);
        for (var len = 0; len < this.parentCheckData.length; len++) {
          if (treeData !== this.parentCheckData[parseInt(len.toString(), 10)] && this.parentCheckData[parseInt(len.toString(), 10)]) {
            this.checkIndeterminateState(this.parentCheckData[parseInt(len.toString(), 10)]);
          }
        }
      }
      this.parentCheckData = [];
    };
    TreeView2.prototype.beforeNodeCreate = function(e) {
      if (this.showCheckBox) {
        var checkboxEle = createCheckBox(this.createElement, true, { cssClass: this.touchClass });
        checkboxEle.classList.add(CHECKBOXWRAP);
        var icon = select("div." + ICON3, e.item);
        var id = e.item.getAttribute("data-uid");
        e.item.childNodes[0].insertBefore(checkboxEle, e.item.childNodes[0].childNodes[isNullOrUndefined(icon) ? 0 : 1]);
        var checkValue = getValue(e.fields.isChecked, e.curData);
        if (this.checkedNodes.indexOf(id) > -1) {
          select("." + CHECKBOXFRAME, checkboxEle).classList.add(CHECK2);
          e.item.setAttribute("aria-checked", "true");
          this.addCheck(e.item);
        } else if (!isNullOrUndefined(checkValue) && checkValue.toString() === "true") {
          select("." + CHECKBOXFRAME, checkboxEle).classList.add(CHECK2);
          e.item.setAttribute("aria-checked", "true");
          this.addCheck(e.item);
        } else {
          e.item.setAttribute("aria-checked", "false");
        }
        var frame = select("." + CHECKBOXFRAME, checkboxEle);
        EventHandler.add(frame, "mousedown", this.frameMouseHandler, this);
        EventHandler.add(frame, "mouseup", this.frameMouseHandler, this);
      }
      if (this.fullRowSelect) {
        this.createFullRow(e.item);
      }
      if (this.allowMultiSelection && !e.item.classList.contains(SELECTED3)) {
        e.item.setAttribute("aria-selected", "false");
      }
      var fields = e.fields;
      this.addActionClass(e, fields.selected, SELECTED3);
      this.addActionClass(e, fields.expanded, EXPANDED);
      e.item.setAttribute("tabindex", "-1");
      EventHandler.add(e.item, "focus", this.focusIn, this);
      if (!isNullOrUndefined(this.nodeTemplateFn)) {
        var textEle = e.item.querySelector("." + LISTTEXT);
        var dataId = e.item.getAttribute("data-uid");
        textEle.innerHTML = "";
        this.renderNodeTemplate(e.curData, textEle, dataId);
      }
      var eventArgs = {
        node: e.item,
        nodeData: e.curData,
        text: e.text
      };
      if (!this.isRefreshed) {
        this.trigger("drawNode", eventArgs);
        if (e.curData[this.fields.selectable] === false && !this.showCheckBox) {
          e.item.classList.add(PREVENTSELECT);
          e.item.firstElementChild.setAttribute("style", "cursor: not-allowed");
        }
      }
    };
    TreeView2.prototype.frameMouseHandler = function(e) {
      var rippleSpan = select("." + CHECKBOXRIPPLE, e.target.parentElement);
      rippleMouseHandler(e, rippleSpan);
    };
    TreeView2.prototype.addActionClass = function(e, action, cssClass2) {
      var data = e.curData;
      var actionValue = getValue(action, data);
      if (!isNullOrUndefined(actionValue) && actionValue.toString() !== "false") {
        e.item.classList.add(cssClass2);
      }
    };
    TreeView2.prototype.getDataType = function(ds, mapper) {
      if (this.fields.dataSource instanceof DataManager) {
        for (var i = 0; i < ds.length; i++) {
          if (this.isOffline) {
            if (typeof mapper.child === "string" && isNullOrUndefined(getValue(mapper.child, ds[parseInt(i.toString(), 10)])) && !isNullOrUndefined(getValue(mapper.parentID, ds[parseInt(i.toString(), 10)]))) {
              return 1;
            }
          } else if (typeof mapper.child === "string" && isNullOrUndefined(getValue(mapper.child, ds[parseInt(i.toString(), 10)]))) {
            return 1;
          }
        }
        return 2;
      }
      for (var i = 0, len = ds.length; i < len; i++) {
        if (typeof mapper.child === "string" && (!isNullOrUndefined(getValue(mapper.child, ds[parseInt(i.toString(), 10)])) || Object.prototype.hasOwnProperty.call(ds[parseInt(i.toString(), 10)], mapper.child))) {
          return 2;
        }
        if (this.isChildObject()) {
          return 2;
        }
        if (!isNullOrUndefined(getValue(mapper.parentID, ds[parseInt(i.toString(), 10)])) || !isNullOrUndefined(getValue(mapper.hasChildren, ds[parseInt(i.toString(), 10)]))) {
          return 1;
        }
      }
      return 1;
    };
    TreeView2.prototype.getGroupedData = function(dataSource, groupBy) {
      var cusQuery = new Query().group(groupBy);
      var ds = ListBase.getDataSource(dataSource, cusQuery);
      var grpItem = [];
      for (var j = 0; j < ds.length; j++) {
        var itemObj = ds[parseInt(j.toString(), 10)].items;
        grpItem.push(itemObj);
      }
      return grpItem;
    };
    TreeView2.prototype.getSortedData = function(list) {
      if (list && this.sortOrder !== "None") {
        list = ListBase.getDataSource(list, ListBase.addSorting(this.sortOrder, this.fields.text));
      }
      return list;
    };
    TreeView2.prototype.finalizeNode = function(element2) {
      var _this = this;
      var iNodes = selectAll("." + IMAGE, element2);
      for (var k = 0; k < iNodes.length; k++) {
        iNodes[parseInt(k.toString(), 10)].setAttribute("alt", IMAGE);
      }
      if (this.isLoaded) {
        var sNodes = selectAll("." + SELECTED3, element2);
        for (var i = 0; i < sNodes.length; i++) {
          this.selectNode(sNodes[parseInt(i.toString(), 10)], null);
          break;
        }
        removeClass(sNodes, SELECTED3);
      }
      var cNodes = selectAll("." + LISTITEM + ":not(." + EXPANDED + ")", element2);
      for (var j = 0; j < cNodes.length; j++) {
        var icon = select("div." + ICON3, cNodes[parseInt(j.toString(), 10)]);
        if (icon && icon.classList.contains(EXPANDABLE)) {
          this.disableExpandAttr(cNodes[parseInt(j.toString(), 10)]);
        }
      }
      var eNodes = selectAll("." + EXPANDED, element2);
      if (!this.loadOnDemand && this.fields.dataSource instanceof DataManager) {
        this.isInitalExpand = this.treeData.filter(function(e) {
          return e[_this.fields.expanded] === true;
        }).length > 0 ? true : this.isInitalExpand;
      }
      if (!this.isInitalExpand) {
        for (var i = 0; i < eNodes.length; i++) {
          this.renderChildNodes(eNodes[parseInt(i.toString(), 10)]);
        }
      }
      removeClass(eNodes, EXPANDED);
      this.updateList();
      if (this.isLoaded) {
        this.updateCheckedProp();
      }
    };
    TreeView2.prototype.updateCheckedProp = function() {
      if (this.showCheckBox) {
        var nodes = [].concat([], this.checkedNodes);
        this.setProperties({ checkedNodes: nodes }, true);
      }
    };
    TreeView2.prototype.ensureIndeterminate = function() {
      if (this.autoCheck) {
        var liElement = selectAll("li", this.element);
        var ulElement = void 0;
        for (var i = 0; i < liElement.length; i++) {
          if (liElement[parseInt(i.toString(), 10)].classList.contains(LISTITEM)) {
            ulElement = select("." + PARENTITEM, liElement[parseInt(i.toString(), 10)]);
            if (ulElement) {
              this.ensureParentCheckState(liElement[parseInt(i.toString(), 10)]);
            } else {
              this.ensureChildCheckState(liElement[parseInt(i.toString(), 10)]);
            }
          }
        }
      } else {
        var indeterminate = selectAll("." + INDETERMINATE2, this.element);
        for (var i = 0; i < indeterminate.length; i++) {
          indeterminate[parseInt(i.toString(), 10)].classList.remove(INDETERMINATE2);
        }
      }
    };
    TreeView2.prototype.ensureParentCheckState = function(element2) {
      if (!isNullOrUndefined(element2)) {
        if (element2.classList.contains(ROOT5)) {
          return;
        }
        var ulElement = element2;
        if (element2.classList.contains(LISTITEM)) {
          ulElement = select("." + PARENTITEM, element2);
        }
        var checkedNodes = selectAll("." + CHECK2, ulElement);
        var indeterminateNodes = selectAll("." + INDETERMINATE2, ulElement);
        var nodes = selectAll("." + LISTITEM, ulElement);
        var checkBoxEle = element2.getElementsByClassName(CHECKBOXWRAP)[0];
        var count = nodes.length;
        var checkedCount = checkedNodes.length;
        var dataUid = element2.getAttribute("data-uid");
        if (this.element.classList.contains("e-filtering")) {
          var oldCheckedNodes = new DataManager(this.OldCheckedData).executeLocal(new Query().where("parentID", "equal", dataUid, true));
          checkedCount = oldCheckedNodes.length;
          var childItems = [];
          if (this.dataType === 1) {
            childItems = new DataManager(this.DDTTreeData).executeLocal(new Query().where(this.fields.parentID, "equal", dataUid, true));
          } else {
            childItems = this.getChildNodes(this.DDTTreeData, dataUid);
          }
          count = childItems.length;
        }
        if (count === checkedCount) {
          this.changeState(checkBoxEle, "check", null, true, true);
        } else if (checkedCount > 0 || indeterminateNodes.length > 0) {
          this.changeState(checkBoxEle, "indeterminate", null, true, true);
        } else if (checkedCount === 0) {
          this.changeState(checkBoxEle, "uncheck", null, true, true);
        }
        var parentUL = closest(element2, "." + PARENTITEM);
        if (!isNullOrUndefined(parentUL)) {
          var currentParent = closest(parentUL, "." + LISTITEM);
          this.ensureParentCheckState(currentParent);
        }
      }
    };
    TreeView2.prototype.ensureChildCheckState = function(element2, e) {
      if (!isNullOrUndefined(element2)) {
        var childElement = select("." + PARENTITEM, element2);
        var checkBoxes = void 0;
        if (!isNullOrUndefined(childElement)) {
          checkBoxes = selectAll("." + CHECKBOXWRAP, childElement);
          var isChecked = element2.getElementsByClassName(CHECKBOXFRAME)[0].classList.contains(CHECK2);
          var parentCheck = element2.getElementsByClassName(CHECKBOXFRAME)[0].classList.contains(INDETERMINATE2);
          var childCheck = childElement.querySelectorAll("li");
          var checkedState = void 0;
          for (var index = 0; index < checkBoxes.length; index++) {
            var childId = childCheck[parseInt(index.toString(), 10)].getAttribute("data-uid");
            if (!isNullOrUndefined(this.currentLoadData) && !isNullOrUndefined(getValue(this.fields.isChecked, this.currentLoadData[parseInt(index.toString(), 10)]))) {
              checkedState = getValue(this.fields.isChecked, this.currentLoadData[parseInt(index.toString(), 10)]) ? "check" : "uncheck";
              if (this.ele !== -1) {
                checkedState = isChecked ? "check" : "uncheck";
              }
              if (checkedState === "uncheck" && (!isUndefined(this.parentNodeCheck) && this.autoCheck && this.parentNodeCheck.indexOf(childId) !== -1)) {
                this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(childId), 1);
                checkedState = "indeterminate";
              }
            } else {
              var isNodeChecked = checkBoxes[parseInt(index.toString(), 10)].getElementsByClassName(CHECKBOXFRAME)[0].classList.contains(CHECK2);
              if (isChecked) {
                checkedState = "check";
              } else if (isNodeChecked && !this.isLoaded) {
                checkedState = "check";
              } else if (this.checkedNodes.indexOf(childId) !== -1 && this.isLoaded && (parentCheck || isChecked)) {
                checkedState = "check";
              } else if (childCheck[parseInt(index.toString(), 10)].classList.contains(CHILD) && (!isUndefined(this.parentNodeCheck) && this.autoCheck && (isChecked || parentCheck) && this.parentNodeCheck.indexOf(childId) !== -1)) {
                checkedState = "indeterminate";
                this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(childId), 1);
              } else if (this.dataType === 1 && (!isUndefined(this.parentNodeCheck) && this.autoCheck && (isChecked || parentCheck) && this.parentNodeCheck.indexOf(childId) !== -1)) {
                checkedState = "indeterminate";
                this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(childId), 1);
              } else {
                checkedState = "uncheck";
              }
            }
            this.changeState(checkBoxes[parseInt(index.toString(), 10)], checkedState, e, true, true);
          }
        }
        if (this.autoCheck && this.isLoaded) {
          this.updateParentCheckState();
        }
      }
    };
    TreeView2.prototype.doCheckBoxAction = function(nodes, doCheck) {
      if (!isNullOrUndefined(nodes)) {
        for (var len = nodes.length - 1; len >= 0; len--) {
          var liEle = this.getElement(nodes[parseInt(len.toString(), 10)]);
          if (isNullOrUndefined(liEle)) {
            var node = nodes[len - (nodes.length - 1)] ? nodes[len - (nodes.length - 1)].toString() : nodes[parseInt(len.toString(), 10)] ? nodes[parseInt(len.toString(), 10)].toString() : null;
            if (node !== "" && doCheck && node) {
              this.setValidCheckedNode(node);
              this.dynamicCheckState(node, doCheck);
            } else if (this.checkedNodes.indexOf(node) !== -1 && node !== "" && !doCheck) {
              this.checkedNodes.splice(this.checkedNodes.indexOf(node), 1);
              var childItems = this.getChildNodes(this.treeData, node);
              if (childItems) {
                for (var i = 0; i < childItems.length; i++) {
                  var id = childItems[parseInt(i.toString(), 10)][this.fields.id] ? childItems[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
                  if (this.checkedNodes.indexOf(id) !== -1) {
                    this.checkedNodes.splice(this.checkedNodes.indexOf(id), 1);
                    var ele = this.element.querySelector('[data-uid="' + id + '"]');
                    if (ele) {
                      this.changeState(ele, "uncheck", null);
                    }
                  }
                }
                if (this.parentNodeCheck.indexOf(node) !== -1) {
                  this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(node), 1);
                }
              }
              if (node) {
                this.dynamicCheckState(node, doCheck);
              }
              this.updateField(this.treeData, this.fields, node, "isChecked", null);
            }
            continue;
          }
          var checkBox = select("." + PARENTITEM + " ." + CHECKBOXWRAP, liEle);
          this.validateCheckNode(checkBox, !doCheck, liEle, null);
        }
      } else {
        var checkBoxes = selectAll("." + CHECKBOXWRAP, this.element);
        if (this.loadOnDemand) {
          for (var index = 0; index < checkBoxes.length; index++) {
            this.updateFieldChecked(checkBoxes[parseInt(index.toString(), 10)], doCheck);
            this.changeState(checkBoxes[parseInt(index.toString(), 10)], doCheck ? "check" : "uncheck", null, null, null, doCheck);
          }
        } else {
          for (var index = 0; index < checkBoxes.length; index++) {
            this.updateFieldChecked(checkBoxes[parseInt(index.toString(), 10)], doCheck);
            this.changeState(checkBoxes[parseInt(index.toString(), 10)], doCheck ? "check" : "uncheck");
          }
        }
      }
      if (nodes) {
        for (var j = 0; j < nodes.length - 1; j++) {
          var node = nodes[parseInt(j.toString(), 10)] ? nodes[parseInt(j.toString(), 10)].toString() : "";
          if (!doCheck) {
            this.updateField(this.treeData, this.fields, node, "isChecked", null);
          }
        }
      }
      if (this.autoCheck) {
        this.updateParentCheckState();
      }
    };
    TreeView2.prototype.updateFieldChecked = function(checkbox, doCheck) {
      var currLi = closest(checkbox, "." + LISTITEM);
      var id = currLi.getAttribute("data-uid");
      var nodeDetails = this.getNodeData(currLi);
      if (nodeDetails.isChecked === "true" && !doCheck) {
        this.updateField(this.treeData, this.fields, id, "isChecked", null);
      }
    };
    TreeView2.prototype.dynamicCheckState = function(node, doCheck) {
      if (this.dataType === 1) {
        var count = 0;
        var resultId = new DataManager(this.treeData).executeLocal(new Query().where(this.fields.id, "equal", node, true));
        if (resultId[0]) {
          var id = resultId[0][this.fields.id] ? resultId[0][this.fields.id].toString() : null;
          var parent_1 = resultId[0][this.fields.parentID] ? resultId[0][this.fields.parentID].toString() : null;
          var parentElement = this.element.querySelector('[data-uid="' + parent_1 + '"]');
          var element2 = this.element.querySelector('[data-uid="' + id + '"]');
          var childNodes = this.getChildNodes(this.treeData, parent_1);
          if (childNodes) {
            for (var i = 0; i < childNodes.length; i++) {
              var childId = childNodes[parseInt(i.toString(), 10)][this.fields.id] ? childNodes[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
              if (this.checkedNodes.indexOf(childId) !== -1) {
                count++;
              }
            }
          }
          if (this.checkedNodes.indexOf(node) !== -1 && parentElement && id === node && this.autoCheck) {
            this.changeState(parentElement, "indeterminate", null);
          } else if (this.checkedNodes.indexOf(node) === -1 && element2 && id === node && !doCheck) {
            this.changeState(element2, "uncheck", null);
          } else if (this.checkedNodes.indexOf(node) !== -1 && element2 && id === node && doCheck) {
            this.changeState(element2, "check", null);
          } else if (this.checkedNodes.indexOf(node) === -1 && !element2 && parentElement && id === node && this.autoCheck && count !== 0) {
            this.changeState(parentElement, "indeterminate", null);
          } else if (this.checkedNodes.indexOf(node) === -1 && !element2 && parentElement && id === node && this.autoCheck && count === 0) {
            this.changeState(parentElement, "uncheck", null);
          } else if (!element2 && !parentElement && id === node && this.autoCheck) {
            this.updateIndeterminate(node, doCheck);
          }
        }
      } else if (this.dataType === 2 || this.fields.dataSource instanceof DataManager && this.isOffline) {
        var id = void 0;
        var parentElement = void 0;
        var check = void 0;
        for (var i = 0; i < this.treeData.length; i++) {
          id = this.treeData[parseInt(i.toString(), 10)][this.fields.id] ? this.treeData[parseInt(i.toString(), 10)][this.fields.id].toString() : "";
          parentElement = this.element.querySelector('[data-uid="' + id + '"]');
          check = parentElement ? select("." + CHECK2, parentElement) : null;
          if (this.checkedNodes.indexOf(id) === -1 && parentElement && check && !doCheck) {
            this.changeState(parentElement, "uncheck", null);
          }
          var subChild = getValue(this.fields.child.toString(), this.treeData[parseInt(i.toString(), 10)]);
          if (subChild) {
            this.updateChildIndeterminate(subChild, id, node, doCheck, id);
          }
        }
      }
    };
    TreeView2.prototype.updateIndeterminate = function(node, doCheck) {
      var indeterminateData = this.getTreeData(node);
      var count = 0;
      var parent;
      if (this.dataType === 1) {
        parent = indeterminateData[0][this.fields.parentID] ? indeterminateData[0][this.fields.parentID].toString() : null;
      }
      var childNodes = this.getChildNodes(this.treeData, parent);
      if (childNodes) {
        for (var i = 0; i < childNodes.length; i++) {
          var childId = childNodes[parseInt(i.toString(), 10)][this.fields.id] ? childNodes[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
          if (this.checkedNodes.indexOf(childId) !== -1) {
            count++;
          }
        }
      }
      var parentElement = this.element.querySelector('[data-uid="' + parent + '"]');
      if (parentElement && doCheck) {
        this.changeState(parentElement, "indeterminate", null);
      } else if (!doCheck && parentElement && this.parentNodeCheck.indexOf(parent) === -1 && count !== 0) {
        this.changeState(parentElement, "indeterminate", null);
      } else if (!doCheck && parentElement && this.parentNodeCheck.indexOf(parent) === -1 && count === 0) {
        this.changeState(parentElement, "uncheck", null);
      } else if (!parentElement) {
        if (!doCheck && this.checkedNodes.indexOf(parent) === -1 && this.parentNodeCheck.indexOf(parent) !== -1) {
          this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(parent), 1);
        } else if (doCheck && this.checkedNodes.indexOf(parent) === -1 && this.parentNodeCheck.indexOf(parent) === -1) {
          this.parentNodeCheck.push(parent);
        } else if (!doCheck && this.checkedNodes.indexOf(parent) !== -1 && this.parentNodeCheck.indexOf(parent) === -1 && count !== 0) {
          this.parentNodeCheck.push(parent);
        }
        this.updateIndeterminate(parent, doCheck);
        if (this.checkedNodes.indexOf(parent) !== -1 && !doCheck) {
          this.checkedNodes.splice(this.checkedNodes.indexOf(parent), 1);
        }
      }
    };
    TreeView2.prototype.updateChildIndeterminate = function(subChild, parent, node, doCheck, child) {
      var count = 0;
      for (var j = 0; j < subChild.length; j++) {
        var subId = subChild[parseInt(j.toString(), 10)][this.fields.id] ? subChild[parseInt(j.toString(), 10)][this.fields.id].toString() : "";
        if (this.checkedNodes.indexOf(subId) !== -1) {
          count++;
        }
        var parentElement = this.element.querySelector('[data-uid="' + parent + '"]');
        var indeterminate = parentElement ? select("." + INDETERMINATE2, parentElement) : null;
        var check = parentElement ? select("." + CHECK2, parentElement) : null;
        var element2 = this.element.querySelector('[data-uid="' + subId + '"]');
        var childElementCheck = element2 ? select("." + CHECK2, element2) : null;
        if (this.checkedNodes.indexOf(node) !== -1 && parentElement && subId === node && this.autoCheck) {
          this.changeState(parentElement, "indeterminate", null);
        } else if (this.checkedNodes.indexOf(node) === -1 && parentElement && !element2 && subId === node && !doCheck) {
          if (this.autoCheck) {
            this.changeState(parentElement, "uncheck", null);
          } else {
            if (count !== 0) {
              this.changeState(parentElement, "indeterminate", null);
            } else {
              this.changeState(parentElement, "uncheck", null);
            }
          }
        } else if (this.checkedNodes.indexOf(node) === -1 && element2 && subId === node && !doCheck) {
          this.changeState(element2, "uncheck", null);
        } else if (this.checkedNodes.indexOf(node) === -1 && indeterminate && subId === node && this.autoCheck && count === 0 && !doCheck) {
          indeterminate.classList.remove(INDETERMINATE2);
        } else if (this.checkedNodes.indexOf(node) === -1 && !element2 && check && subId === node && count === 0) {
          this.changeState(parentElement, "uncheck", null);
        } else if (this.checkedNodes.indexOf(subId) === -1 && element2 && childElementCheck && count === 0) {
          this.changeState(element2, "uncheck", null);
        } else if (!element2 && !parentElement && subId === node || this.parentNodeCheck.indexOf(parent) !== -1 && this.autoCheck) {
          var childElement = this.element.querySelector('[data-uid="' + child + '"]');
          if (doCheck && count !== 0) {
            this.changeState(childElement, "indeterminate", null);
          } else if (doCheck && count === subChild.length && this.checkedNodes.indexOf(parent) === -1) {
            this.checkedNodes.push(parent);
          } else if (!doCheck && count === 0 && this.parentNodeCheck.indexOf(parent) !== -1) {
            this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(parent));
          }
          if (this.parentNodeCheck.indexOf(parent) === -1) {
            this.parentNodeCheck.push(parent);
          }
        }
        var innerChild = getValue(this.fields.child.toString(), subChild[parseInt(j.toString(), 10)]);
        if (innerChild) {
          this.updateChildIndeterminate(innerChild, subId, node, doCheck, child);
        }
      }
    };
    TreeView2.prototype.changeState = function(wrapper, state, e, isPrevent, isAdd, doCheck) {
      var _this = this;
      var eventArgs;
      var currLi = closest(wrapper, "." + LISTITEM);
      if (wrapper === currLi) {
        wrapper = select("." + CHECKBOXWRAP, currLi);
      }
      if (!isPrevent) {
        this.checkActionNodes = [];
        eventArgs = this.getCheckEvent(currLi, state, e);
        this.trigger("nodeChecking", eventArgs, function(observedArgs) {
          if (!observedArgs.cancel) {
            _this.nodeCheckAction(wrapper, state, currLi, observedArgs, e, isPrevent, isAdd, doCheck);
          }
        });
      } else {
        this.nodeCheckAction(wrapper, state, currLi, eventArgs, e, isPrevent, isAdd, doCheck);
      }
    };
    TreeView2.prototype.nodeCheckAction = function(wrapper, state, currLi, eventArgs, e, isPrevent, isAdd, doCheck) {
      var ariaState;
      var frameSpan = wrapper.getElementsByClassName(CHECKBOXFRAME)[0];
      if (state === "check" && !frameSpan.classList.contains(CHECK2)) {
        frameSpan.classList.remove(INDETERMINATE2);
        frameSpan.classList.add(CHECK2);
        this.addCheck(currLi);
        ariaState = "true";
      } else if (state === "uncheck" && (frameSpan.classList.contains(CHECK2) || frameSpan.classList.contains(INDETERMINATE2))) {
        removeClass([frameSpan], [CHECK2, INDETERMINATE2]);
        this.removeCheck(currLi);
        ariaState = "false";
      } else if (state === "indeterminate" && this.autoCheck) {
        frameSpan.classList.remove(CHECK2);
        frameSpan.classList.add(INDETERMINATE2);
        this.removeCheck(currLi);
        ariaState = "mixed";
      }
      ariaState = state === "check" ? "true" : state === "uncheck" ? "false" : ariaState;
      if (!isNullOrUndefined(ariaState)) {
        currLi.setAttribute("aria-checked", ariaState);
      }
      if (isAdd) {
        var data = [].concat([], this.checkActionNodes);
        eventArgs = this.getCheckEvent(currLi, state, e);
        if (isUndefined(isPrevent)) {
          eventArgs.data = data;
        }
      }
      if (doCheck !== void 0) {
        this.ensureStateChange(currLi, doCheck);
      }
      if (!isPrevent) {
        if (!isNullOrUndefined(ariaState)) {
          currLi.setAttribute("aria-checked", ariaState);
          eventArgs.data[0].checked = ariaState;
          this.trigger("nodeChecked", eventArgs);
          this.checkActionNodes = [];
        }
      }
    };
    TreeView2.prototype.addCheck = function(liEle) {
      var id = liEle.getAttribute("data-uid");
      if (!isNullOrUndefined(id) && this.checkedNodes.indexOf(id) === -1) {
        this.checkedNodes.push(id);
      }
    };
    TreeView2.prototype.removeCheck = function(liEle) {
      var index = this.checkedNodes.indexOf(liEle.getAttribute("data-uid"));
      if (index > -1) {
        this.checkedNodes.splice(index, 1);
      }
    };
    TreeView2.prototype.getCheckEvent = function(currLi, action, e) {
      this.checkActionNodes.push(this.getNodeData(currLi));
      var nodeData = this.checkActionNodes;
      return { action, cancel: false, isInteracted: isNullOrUndefined(e) ? false : true, node: currLi, data: nodeData };
    };
    TreeView2.prototype.finalize = function() {
      var firstUl = select("." + PARENTITEM, this.element);
      if (!isNullOrUndefined(firstUl)) {
        firstUl.setAttribute("role", treeAriaAttr.treeRole);
        this.setMultiSelect(this.allowMultiSelection);
        var firstNode = select("." + LISTITEM, this.element);
        if (firstNode) {
          firstNode.setAttribute("tabindex", "0");
          this.updateIdAttr(null, firstNode);
        }
        if (this.allowTextWrap) {
          this.updateWrap();
        }
        this.renderReactTemplates();
        this.hasPid = this.rootData[0] ? Object.prototype.hasOwnProperty.call(this.rootData[0], this.fields.parentID) : false;
        this.doExpandAction();
      }
    };
    TreeView2.prototype.setTextWrap = function() {
      (this.allowTextWrap ? addClass : removeClass)([this.element], LISTWRAP);
      if (Browser.isIE) {
        (this.allowTextWrap ? addClass : removeClass)([this.element], IELISTWRAP);
      }
    };
    TreeView2.prototype.updateWrap = function(ulEle) {
      if (!this.fullRowSelect) {
        return;
      }
      var liEle = ulEle ? selectAll("." + LISTITEM, ulEle) : this.liList;
      var length = liEle.length;
      for (var i = 0; i < length; i++) {
        this.calculateWrap(liEle[parseInt(i.toString(), 10)]);
      }
    };
    TreeView2.prototype.calculateWrap = function(liEle) {
      var element2 = select("." + FULLROW, liEle);
      if (element2 && element2.nextElementSibling) {
        element2.style.height = this.allowTextWrap ? element2.nextElementSibling.offsetHeight + "px" : "";
      }
    };
    TreeView2.prototype.doExpandAction = function() {
      var _this = this;
      var eUids = this.expandedNodes;
      if (!this.loadOnDemand && this.fields.dataSource instanceof DataManager) {
        this.isInitalExpand = this.treeData.filter(function(e) {
          return e[_this.fields.expanded] === true;
        }).length > 0 ? true : this.isInitalExpand;
      }
      if (this.isInitalExpand && eUids.length > 0) {
        this.setProperties({ expandedNodes: [] }, true);
        if (this.fields.dataSource instanceof DataManager) {
          this.expandGivenNodes(eUids);
        } else {
          for (var i = 0; i < eUids.length; i++) {
            var eNode = select('[data-uid="' + eUids[parseInt(i.toString(), 10)] + '"]', this.element);
            if (!isNullOrUndefined(eNode)) {
              var icon = select("." + EXPANDABLE, select("." + TEXTWRAP, eNode));
              if (!isNullOrUndefined(icon)) {
                this.expandAction(eNode, icon, null);
              }
            } else {
              if (eUids[parseInt(i.toString(), 10)] && this.expandChildren.indexOf(eUids[parseInt(i.toString(), 10)]) === -1) {
                this.expandChildren.push(eUids[parseInt(i.toString(), 10)].toString());
              }
              continue;
            }
          }
          this.afterFinalized();
        }
      } else {
        this.afterFinalized();
      }
    };
    TreeView2.prototype.expandGivenNodes = function(arr) {
      var _this = this;
      this.expandCallback(arr[this.index], function() {
        _this.index++;
        if (_this.index < arr.length) {
          _this.expandGivenNodes(arr);
        } else {
          _this.afterFinalized();
        }
      });
      if (this.index > 0) {
        this.index = 0;
      }
    };
    TreeView2.prototype.expandCallback = function(eUid, callback) {
      var eNode = select('[data-uid="' + eUid + '"]', this.element);
      if (!isNullOrUndefined(eNode)) {
        var icon = select("." + EXPANDABLE, select("." + TEXTWRAP, eNode));
        if (!isNullOrUndefined(icon)) {
          this.expandAction(eNode, icon, null, false, callback);
        }
        callback();
      } else {
        callback();
      }
    };
    TreeView2.prototype.afterFinalized = function() {
      this.doSelectionAction();
      this.updateCheckedProp();
      this.isAnimate = true;
      this.isInitalExpand = false;
      if ((!this.isLoaded || this.isFieldChange) && !this.isNodeDropped) {
        var eventArgs = { data: this.treeData };
        this.trigger("dataBound", eventArgs);
      }
      this.isLoaded = true;
      this.isNodeDropped = false;
    };
    TreeView2.prototype.doSelectionAction = function() {
      var sNodes = selectAll("." + SELECTED3, this.element);
      var sUids = this.selectedNodes;
      if (sUids.length > 0) {
        this.setProperties({ selectedNodes: [] }, true);
        for (var i = 0; i < sUids.length; i++) {
          var sNode = select('[data-uid="' + sUids[parseInt(i.toString(), 10)] + '"]', this.element);
          if (sNode && !sNode.classList.contains("e-active")) {
            this.selectNode(sNode, null, true);
          } else {
            this.selectedNodes.push(sUids[parseInt(i.toString(), 10)]);
          }
          if (!this.allowMultiSelection) {
            break;
          }
        }
      } else {
        this.selectGivenNodes(sNodes);
      }
      removeClass(sNodes, SELECTED3);
    };
    TreeView2.prototype.selectGivenNodes = function(sNodes) {
      for (var i = 0; i < sNodes.length; i++) {
        if (!sNodes[parseInt(i.toString(), 10)].classList.contains("e-disable")) {
          this.selectNode(sNodes[parseInt(i.toString(), 10)], null, true);
        }
        if (!this.allowMultiSelection) {
          break;
        }
      }
    };
    TreeView2.prototype.clickHandler = function(event) {
      var target = Browser.isDevice && event.originalEvent.changedTouches && !Browser.isIos ? document.elementFromPoint(event.originalEvent.changedTouches[0].clientX, event.originalEvent.changedTouches[0].clientY) : event.originalEvent.target;
      EventHandler.remove(this.element, "contextmenu", this.preventContextMenu);
      if (!target || this.dragStartAction) {
        return;
      } else {
        var classList2 = target.classList;
        var li = closest(target, "." + LISTITEM);
        if (!li || li.classList.contains(PREVENTSELECT) && !(classList2.contains(EXPANDABLE) || classList2.contains(COLLAPSIBLE))) {
          return;
        } else if (event.originalEvent.which !== 3) {
          var rippleElement = select("." + RIPPLEELMENT, li);
          var rippleIcons = select("." + ICON3, li);
          this.removeHover();
          this.setFocusElement(li);
          if (this.showCheckBox && !li.classList.contains("e-disable")) {
            var checkWrapper = closest(target, "." + CHECKBOXWRAP);
            if (!isNullOrUndefined(checkWrapper)) {
              var checkElement = select("." + CHECKBOXFRAME, checkWrapper);
              this.validateCheckNode(checkWrapper, checkElement.classList.contains(CHECK2), li, event.originalEvent);
              this.triggerClickEvent(event.originalEvent, li);
              return;
            }
          }
          if (classList2.contains(EXPANDABLE)) {
            this.expandAction(li, target, event);
          } else if (classList2.contains(COLLAPSIBLE)) {
            this.collapseNode(li, target, event);
          } else if (rippleElement && rippleIcons) {
            if (rippleIcons.classList.contains(RIPPLE4) && rippleIcons.classList.contains(EXPANDABLE)) {
              this.expandAction(li, rippleIcons, event);
            } else if (rippleIcons.classList.contains(RIPPLE4) && rippleIcons.classList.contains(COLLAPSIBLE)) {
              this.collapseNode(li, rippleIcons, event);
            } else if (!classList2.contains(PARENTITEM) && !classList2.contains(LISTITEM)) {
              this.toggleSelect(li, event.originalEvent, false);
            }
          } else {
            if (!classList2.contains(PARENTITEM) && !classList2.contains(LISTITEM)) {
              this.toggleSelect(li, event.originalEvent, false);
            }
          }
        }
        if (event.originalEvent.which === 3) {
          this.isRightClick = true;
        }
        this.triggerClickEvent(event.originalEvent, li);
      }
    };
    TreeView2.prototype.nodeCheckedEvent = function(wrapper, isCheck, e) {
      var eventArgs = this.getCheckEvent(wrapper, isCheck ? "uncheck" : "check", e);
      eventArgs.data = eventArgs.data.splice(0, eventArgs.data.length - 1);
      this.trigger("nodeChecked", eventArgs);
    };
    TreeView2.prototype.updateOldCheckedData = function(data) {
      var dataManager = new DataManager(data);
      var childItems = dataManager.executeLocal(new Query().where("isChecked", "equal", "true", true));
      var uncheckedItems = dataManager.executeLocal(new Query().where("isChecked", "equal", "false", true));
      if (uncheckedItems.length > 0) {
        var index = this.OldCheckedData.findIndex(function(e) {
          return e["id"] === uncheckedItems[0]["id"];
        });
        if (index !== -1) {
          this.OldCheckedData.splice(index, 1);
          return;
        }
      }
      if (childItems.length > 0) {
        var index = this.OldCheckedData.findIndex(function(e) {
          return e["id"] === childItems[0]["id"];
        });
        if (index === -1) {
          this.OldCheckedData.push(childItems[0]);
          return;
        }
      }
    };
    TreeView2.prototype.triggerClickEvent = function(e, li) {
      var eventArgs = {
        event: e,
        node: li
      };
      this.trigger("nodeClicked", eventArgs);
    };
    TreeView2.prototype.expandNode = function(currLi, icon, loaded) {
      var _this = this;
      this.renderReactTemplates();
      if (icon.classList.contains(LOAD)) {
        this.hideSpinner(icon);
      }
      if (!this.initialRender) {
        icon.classList.add("interaction");
      }
      if (loaded !== true || loaded === true && currLi.classList.contains("e-expanded")) {
        if (this.preventExpand !== true) {
          removeClass([icon], EXPANDABLE);
          addClass([icon], COLLAPSIBLE);
          var start_1 = 0;
          var end_1 = 0;
          var ul_1 = select("." + PARENTITEM, currLi);
          var liEle_1 = currLi;
          this.setHeight(liEle_1, ul_1);
          var activeElement_1 = select("." + LISTITEM + "." + ACTIVE2, currLi);
          if (this.isAnimate && !this.isRefreshed) {
            this.aniObj.animate(ul_1, {
              name: this.animation.expand.effect,
              duration: this.animation.expand.duration === 0 && animationMode === "Enable" ? 400 : this.animation.expand.duration,
              timingFunction: this.animation.expand.easing,
              begin: function() {
                liEle_1.style.overflow = "hidden";
                if (!isNullOrUndefined(activeElement_1) && activeElement_1 instanceof HTMLElement) {
                  activeElement_1.classList.add(ITEM_ANIMATION_ACTIVE);
                }
                start_1 = liEle_1.offsetHeight;
                end_1 = select("." + TEXTWRAP, currLi).offsetHeight;
              },
              progress: function(args) {
                args.element.style.display = "block";
                _this.animateHeight(args, start_1, end_1);
              },
              end: function(args) {
                args.element.style.display = "block";
                if (!isNullOrUndefined(activeElement_1) && activeElement_1 instanceof HTMLElement) {
                  activeElement_1.classList.remove(ITEM_ANIMATION_ACTIVE);
                }
                _this.expandedNode(liEle_1, ul_1, icon);
              }
            });
          } else {
            this.expandedNode(liEle_1, ul_1, icon);
          }
        }
      } else {
        var ul = select("." + PARENTITEM, currLi);
        ul.style.display = "none";
        if (this.fields.dataSource instanceof DataManager === true) {
          this.preventExpand = false;
        }
      }
      if (this.initialRender) {
        icon.classList.add("interaction");
      }
    };
    TreeView2.prototype.expandedNode = function(currLi, ul, icon) {
      ul.style.display = "block";
      currLi.style.display = "block";
      currLi.style.overflow = "";
      currLi.style.height = "";
      removeClass([icon], PROCESS);
      this.addExpand(currLi);
      if (this.allowTextWrap && this.isLoaded && this.isFirstRender) {
        this.updateWrap(currLi);
        this.isFirstRender = false;
      }
      if (this.isLoaded && this.expandArgs && !this.isRefreshed) {
        this.expandArgs = this.getExpandEvent(currLi, null);
        this.expandArgs.isInteracted = this.isInteracted;
        this.trigger("nodeExpanded", this.expandArgs);
      }
    };
    TreeView2.prototype.addExpand = function(liEle) {
      liEle.setAttribute("aria-expanded", "true");
      removeClass([liEle], NODECOLLAPSED);
      var id = liEle.getAttribute("data-uid");
      if (!isNullOrUndefined(id) && this.expandedNodes.indexOf(id) === -1) {
        this.expandedNodes.push(id);
      }
    };
    TreeView2.prototype.collapseNode = function(currLi, icon, e) {
      var _this = this;
      if (icon.classList.contains(PROCESS)) {
        return;
      } else {
        addClass([icon], PROCESS);
      }
      var colArgs;
      if (this.isLoaded) {
        colArgs = this.getExpandEvent(currLi, e);
        this.isInteracted = colArgs.isInteracted;
        this.trigger("nodeCollapsing", colArgs, function(observedArgs) {
          if (observedArgs.cancel) {
            removeClass([icon], PROCESS);
          } else {
            _this.nodeCollapseAction(currLi, icon, observedArgs);
          }
        });
      } else {
        this.nodeCollapseAction(currLi, icon, colArgs);
      }
    };
    TreeView2.prototype.nodeCollapseAction = function(currLi, icon, colArgs) {
      var _this = this;
      removeClass([icon], COLLAPSIBLE);
      addClass([icon], EXPANDABLE);
      var start = 0;
      var end = 0;
      var ul = select("." + PARENTITEM, currLi);
      var liEle = currLi;
      var activeElement = select("." + LISTITEM + "." + ACTIVE2, currLi);
      if (this.isAnimate) {
        this.aniObj.animate(ul, {
          name: this.animation.collapse.effect,
          duration: this.animation.collapse.duration === 0 && animationMode === "Enable" ? 400 : this.animation.collapse.duration,
          timingFunction: this.animation.collapse.easing,
          begin: function() {
            liEle.style.overflow = "hidden";
            if (!isNullOrUndefined(activeElement) && activeElement instanceof HTMLElement) {
              activeElement.classList.add(ITEM_ANIMATION_ACTIVE);
            }
            start = select("." + TEXTWRAP, currLi).offsetHeight;
            end = liEle.offsetHeight;
          },
          progress: function(args) {
            _this.animateHeight(args, start, end);
          },
          end: function(args) {
            args.element.style.display = "none";
            if (!isNullOrUndefined(activeElement) && activeElement instanceof HTMLElement) {
              activeElement.classList.remove(ITEM_ANIMATION_ACTIVE);
            }
            _this.collapsedNode(liEle, ul, icon, colArgs);
          }
        });
      } else {
        this.collapsedNode(liEle, ul, icon, colArgs);
      }
    };
    TreeView2.prototype.collapsedNode = function(liEle, ul, icon, colArgs) {
      ul.style.display = "none";
      liEle.style.overflow = "";
      liEle.style.height = "";
      removeClass([icon], PROCESS);
      this.removeExpand(liEle);
      if (this.isLoaded) {
        colArgs = this.getExpandEvent(liEle, null);
        colArgs.isInteracted = this.isInteracted;
        this.trigger("nodeCollapsed", colArgs);
      }
    };
    TreeView2.prototype.removeExpand = function(liEle, toRemove) {
      if (toRemove) {
        liEle.removeAttribute("aria-expanded");
      } else {
        this.disableExpandAttr(liEle);
      }
      var index = this.expandedNodes.indexOf(liEle.getAttribute("data-uid"));
      if (index > -1) {
        this.expandedNodes.splice(index, 1);
      }
    };
    TreeView2.prototype.disableExpandAttr = function(liEle) {
      liEle.setAttribute("aria-expanded", "false");
      addClass([liEle], NODECOLLAPSED);
    };
    TreeView2.prototype.setHeight = function(currLi, ul) {
      ul.style.display = "block";
      ul.style.visibility = "hidden";
      currLi.style.height = currLi.offsetHeight + "px";
      ul.style.display = "none";
      ul.style.visibility = "";
    };
    TreeView2.prototype.animateHeight = function(args, start, end) {
      var remaining = (args.duration - args.timeStamp) / args.duration;
      var currentHeight = (end - start) * remaining + start;
      args.element.parentElement.style.height = currentHeight + "px";
    };
    TreeView2.prototype.renderChildNodes = function(parentLi, expandChild, callback, loaded) {
      var _this = this;
      var eicon = select("div." + ICON3, parentLi);
      if (isNullOrUndefined(eicon)) {
        return;
      }
      this.showSpinner(eicon);
      var childItems;
      if (this.fields.dataSource instanceof DataManager) {
        var level = this.parents(parentLi, "." + PARENTITEM).length;
        var mapper_2 = this.getChildFields(this.fields, level, 1);
        if (isNullOrUndefined(mapper_2) || isNullOrUndefined(mapper_2.dataSource)) {
          detach(eicon);
          this.removeExpand(parentLi, true);
          return;
        }
        this.treeList.push("false");
        if (this.fields.dataSource instanceof DataManager && this.isOffline) {
          this.treeList.pop();
          childItems = this.getChildNodes(this.treeData, parentLi.getAttribute("data-uid"));
          this.loadChild(childItems, mapper_2, eicon, parentLi, expandChild, callback, loaded);
        } else {
          mapper_2.dataSource.executeQuery(this.getQuery(mapper_2, parentLi.getAttribute("data-uid"))).then(function(e) {
            _this.treeList.pop();
            childItems = e.result;
            if (_this.dataType === 1) {
              _this.dataType = 2;
            }
            _this.loadChild(childItems, mapper_2, eicon, parentLi, expandChild, callback, loaded);
          }).catch(function(e) {
            _this.trigger("actionFailure", { error: e });
          });
        }
      } else {
        childItems = this.getChildNodes(this.treeData, parentLi.getAttribute("data-uid"), false, parseFloat(parentLi.getAttribute("aria-level")) + 1);
        this.currentLoadData = this.getSortedData(childItems);
        if (isNullOrUndefined(childItems) || childItems.length === 0) {
          detach(eicon);
          if (eicon.classList.contains(LOAD)) {
            this.hideSpinner(eicon);
          }
          this.removeExpand(parentLi, true);
          return;
        } else {
          this.listBaseOption.ariaAttributes.level = parseFloat(parentLi.getAttribute("aria-level")) + 1;
          parentLi.appendChild(ListBase.createList(this.createElement, this.currentLoadData, this.listBaseOption));
          this.expandNode(parentLi, eicon, loaded);
          this.setSelectionForChildNodes(childItems);
          this.ensureCheckNode(parentLi);
          this.finalizeNode(parentLi);
          this.disableTreeNodes(childItems);
          this.renderSubChild(parentLi, expandChild, loaded);
        }
      }
    };
    TreeView2.prototype.loadChild = function(childItems, mapper, eicon, parentLi, expandChild, callback, loaded) {
      this.currentLoadData = childItems;
      if (isNullOrUndefined(childItems) || childItems.length === 0) {
        detach(eicon);
        this.removeExpand(parentLi, true);
      } else {
        this.updateListProp(mapper);
        if (this.fields.dataSource instanceof DataManager && !this.isOffline) {
          var id = parentLi.getAttribute("data-uid");
          var nodeData = this.getNodeObject(id);
          setValue("child", childItems, nodeData);
        }
        this.listBaseOption.ariaAttributes.level = parseFloat(parentLi.getAttribute("aria-level")) + 1;
        parentLi.appendChild(ListBase.createList(this.createElement, childItems, this.listBaseOption));
        this.expandNode(parentLi, eicon, loaded);
        this.setSelectionForChildNodes(childItems);
        this.ensureCheckNode(parentLi);
        this.finalizeNode(parentLi);
        this.disableTreeNodes(childItems);
        this.renderSubChild(parentLi, expandChild, loaded);
      }
      if (callback) {
        callback();
      }
      if (expandChild) {
        this.expandedNodes.push(parentLi.getAttribute("data-uid"));
      }
      if (this.treeList.length === 0 && !this.isLoaded) {
        this.finalize();
      }
    };
    TreeView2.prototype.disableTreeNodes = function(childItems) {
      var i = 0;
      while (i < childItems.length) {
        var id = childItems[parseInt(i.toString(), 10)][this.fields.id] ? childItems[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
        if (this.disableNode !== void 0 && this.disableNode.indexOf(id) !== -1) {
          this.doDisableAction([id]);
        }
        i++;
      }
    };
    TreeView2.prototype.setSelectionForChildNodes = function(nodes) {
      var i;
      for (i = 0; i < nodes.length; i++) {
        var id = nodes[parseInt(i.toString(), 10)][this.fields.id] ? nodes[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
        if (this.selectedNodes !== void 0 && this.selectedNodes.indexOf(id) !== -1) {
          this.doSelectionAction();
        }
      }
    };
    TreeView2.prototype.ensureCheckNode = function(element2) {
      if (this.showCheckBox) {
        this.ele = this.checkedElement ? this.checkedElement.indexOf(element2.getAttribute("data-uid")) : null;
        if (this.autoCheck) {
          this.ensureChildCheckState(element2);
          this.ensureParentCheckState(element2);
        }
      }
      this.currentLoadData = null;
    };
    TreeView2.prototype.getFields = function(mapper, nodeLevel, dataLevel) {
      if (nodeLevel === dataLevel) {
        return mapper;
      } else {
        return this.getFields(this.getChildMapper(mapper), nodeLevel, dataLevel + 1);
      }
    };
    TreeView2.prototype.getChildFields = function(mapper, nodeLevel, dataLevel) {
      if (nodeLevel === dataLevel) {
        return this.getChildMapper(mapper);
      } else {
        return this.getChildFields(this.getChildMapper(mapper), nodeLevel, dataLevel + 1);
      }
    };
    TreeView2.prototype.getChildMapper = function(mapper) {
      return typeof mapper.child === "string" || isNullOrUndefined(mapper.child) ? mapper : mapper.child;
    };
    TreeView2.prototype.getChildNodes = function(obj, parentId, isRoot, level) {
      var _this = this;
      if (isRoot === void 0) {
        isRoot = false;
      }
      var childNodes;
      if (isNullOrUndefined(obj)) {
        return childNodes;
      } else if (this.dataType === 1) {
        return this.getChildGroup(this.groupedData, parentId, isRoot);
      } else {
        if (typeof this.fields.child === "string") {
          var index = obj.findIndex(function(data) {
            return getValue(_this.fields.id, data) && getValue(_this.fields.id, data).toString() === parentId;
          });
          if (index !== -1) {
            return getValue(this.fields.child, obj[parseInt(index.toString(), 10)]);
          }
          if (index === -1) {
            for (var i = 0, objlen = obj.length; i < objlen; i++) {
              var tempArray = getValue(this.fields.child, obj[parseInt(i.toString(), 10)]);
              var childIndex = !isNullOrUndefined(tempArray) ? tempArray.findIndex(function(data) {
                return getValue(_this.fields.id, data) && getValue(_this.fields.id, data).toString() === parentId;
              }) : -1;
              if (childIndex !== -1) {
                return getValue(this.fields.child, tempArray[parseInt(childIndex.toString(), 10)]);
              } else if (!isNullOrUndefined(tempArray)) {
                childNodes = this.getChildNodes(tempArray, parentId);
                if (childNodes !== void 0) {
                  break;
                }
              }
            }
          }
        } else if (this.isChildObject()) {
          var tempField = !isNullOrUndefined(level) ? this.fields : this.fields.child;
          var i = 1;
          while (i < level) {
            if (!isNullOrUndefined(tempField.child)) {
              tempField = tempField.child;
            } else {
              break;
            }
            i++;
          }
          this.updateListProp(tempField);
          var index = obj.findIndex(function(data) {
            return getValue(_this.fields.id, data) && getValue(_this.fields.id, data).toString() === parentId;
          });
          if (index !== -1) {
            return getValue("child", obj[parseInt(index.toString(), 10)]);
          }
          if (index === -1) {
            for (var i_1 = 0, objlen = obj.length; i_1 < objlen; i_1++) {
              var tempArray = getValue("child", obj[parseInt(i_1.toString(), 10)]);
              var childIndex = !isNullOrUndefined(tempArray) ? tempArray.findIndex(function(data) {
                return getValue(_this.fields.child.id, data) && getValue(_this.fields.child.id, data).toString() === parentId;
              }) : -1;
              if (childIndex !== -1) {
                return getValue("child", tempArray[parseInt(childIndex.toString(), 10)]);
              } else if (!isNullOrUndefined(tempArray)) {
                childNodes = this.getChildNodes(tempArray, parentId, false, level);
                if (childNodes !== void 0) {
                  break;
                }
              }
            }
          }
        }
      }
      return childNodes;
    };
    TreeView2.prototype.getChildGroup = function(data, parentId, isRoot) {
      var childNodes;
      if (isNullOrUndefined(data)) {
        return childNodes;
      }
      for (var i = 0, objlen = data.length; i < objlen; i++) {
        if (!isNullOrUndefined(data[parseInt(i.toString(), 10)][0]) && !isNullOrUndefined(getValue(this.fields.parentID, data[parseInt(i.toString(), 10)][0]))) {
          if (getValue(this.fields.parentID, data[parseInt(i.toString(), 10)][0]).toString() === parentId) {
            return data[parseInt(i.toString(), 10)];
          }
        } else if (isRoot) {
          return data[parseInt(i.toString(), 10)];
        } else {
          return [];
        }
      }
      return childNodes;
    };
    TreeView2.prototype.renderSubChild = function(element2, expandChild, loaded) {
      if (expandChild) {
        var cIcons = selectAll("." + EXPANDABLE, element2);
        for (var i = 0, len = cIcons.length; i < len; i++) {
          var icon = cIcons[parseInt(i.toString(), 10)];
          if (element2.querySelector(".e-icons") !== cIcons[parseInt(i.toString(), 10)]) {
            var curLi = closest(icon, "." + LISTITEM);
            this.expandArgs = this.getExpandEvent(curLi, null);
            if (loaded !== true) {
              this.trigger("nodeExpanding", this.expandArgs);
            }
            this.renderChildNodes(curLi, expandChild, null, loaded);
          }
        }
      }
    };
    TreeView2.prototype.toggleSelect = function(li, e, multiSelect) {
      if (!li.classList.contains("e-disable")) {
        if (this.allowMultiSelection && (e && e.ctrlKey || multiSelect) && this.isActive(li)) {
          this.unselectNode(li, e);
        } else {
          this.selectNode(li, e, multiSelect);
        }
      }
    };
    TreeView2.prototype.isActive = function(li) {
      return li.classList.contains(ACTIVE2) ? true : false;
    };
    TreeView2.prototype.selectNode = function(li, e, multiSelect) {
      var _this = this;
      if (isNullOrUndefined(li) || !this.allowMultiSelection && this.isActive(li) && !isNullOrUndefined(e)) {
        this.setFocusElement(li);
        return;
      }
      var eventArgs;
      if (this.isLoaded) {
        eventArgs = this.getSelectEvent(li, "select", e);
        this.trigger("nodeSelecting", eventArgs, function(observedArgs) {
          if (!observedArgs.cancel && !observedArgs.node.classList.contains(PREVENTSELECT)) {
            _this.nodeSelectAction(li, e, observedArgs, multiSelect);
          }
        });
      } else {
        this.nodeSelectAction(li, e, eventArgs, multiSelect);
      }
    };
    TreeView2.prototype.nodeSelectAction = function(li, e, eventArgs, multiSelect) {
      if (!this.allowMultiSelection || !multiSelect && (!e || e && !(e.ctrlKey || e.metaKey))) {
        this.removeSelectAll();
      }
      if (this.allowMultiSelection && e && e.shiftKey) {
        if (!this.startNode) {
          this.startNode = li;
        }
        var startIndex = this.liList.indexOf(this.startNode);
        var endIndex = this.liList.indexOf(li);
        if (startIndex > endIndex) {
          var temp = startIndex;
          startIndex = endIndex;
          endIndex = temp;
        }
        for (var i = startIndex; i <= endIndex; i++) {
          var currNode = this.liList[parseInt(i.toString(), 10)];
          if (isVisible(currNode) && !currNode.classList.contains("e-disable")) {
            this.addSelect(currNode);
          }
        }
      } else {
        this.startNode = li;
        this.addSelect(li);
      }
      if (this.isLoaded) {
        eventArgs.nodeData = this.getNodeData(li);
        this.trigger("nodeSelected", eventArgs);
        this.isRightClick = false;
      }
      this.isRightClick = false;
    };
    TreeView2.prototype.unselectNode = function(li, e) {
      var _this = this;
      var eventArgs;
      if (this.isLoaded) {
        eventArgs = this.getSelectEvent(li, "un-select", e);
        this.trigger("nodeSelecting", eventArgs, function(observedArgs) {
          if (!observedArgs.cancel) {
            _this.nodeUnselectAction(li, observedArgs);
          }
        });
      } else {
        this.nodeUnselectAction(li, eventArgs);
      }
    };
    TreeView2.prototype.nodeUnselectAction = function(li, eventArgs) {
      this.removeSelect(li);
      this.setFocusElement(li);
      if (this.isLoaded) {
        eventArgs.nodeData = this.getNodeData(li);
        this.trigger("nodeSelected", eventArgs);
      }
    };
    TreeView2.prototype.setFocusElement = function(li) {
      if (!isNullOrUndefined(li)) {
        var focusedNode = this.getFocusedNode();
        if (focusedNode) {
          removeClass([focusedNode], FOCUS);
          focusedNode.setAttribute("tabindex", "-1");
        }
        addClass([li], FOCUS);
        li.setAttribute("tabindex", "0");
        EventHandler.add(li, "blur", this.focusOut, this);
        this.updateIdAttr(focusedNode, li);
      }
    };
    TreeView2.prototype.addSelect = function(liEle) {
      liEle.setAttribute("aria-selected", "true");
      addClass([liEle], ACTIVE2);
      var id = liEle.getAttribute("data-uid");
      if (!isNullOrUndefined(id) && this.selectedNodes.indexOf(id) === -1) {
        this.selectedNodes.push(id);
      }
    };
    TreeView2.prototype.removeSelect = function(liEle) {
      if (this.allowMultiSelection) {
        liEle.setAttribute("aria-selected", "false");
      } else {
        liEle.removeAttribute("aria-selected");
      }
      removeClass([liEle], ACTIVE2);
      var index = this.selectedNodes.indexOf(liEle.getAttribute("data-uid"));
      if (index > -1) {
        this.selectedNodes.splice(index, 1);
      }
    };
    TreeView2.prototype.removeSelectAll = function() {
      var selectedLI = this.element.querySelectorAll("." + ACTIVE2);
      for (var _i = 0, selectedLI_1 = selectedLI; _i < selectedLI_1.length; _i++) {
        var ele = selectedLI_1[_i];
        if (this.allowMultiSelection) {
          ele.setAttribute("aria-selected", "false");
        } else {
          ele.removeAttribute("aria-selected");
        }
      }
      removeClass(selectedLI, ACTIVE2);
      this.setProperties({ selectedNodes: [] }, true);
    };
    TreeView2.prototype.getSelectEvent = function(currLi, action, e) {
      var nodeData = this.getNodeData(currLi);
      return { action, cancel: false, isInteracted: isNullOrUndefined(e) ? false : true, node: currLi, nodeData };
    };
    TreeView2.prototype.setExpandOnType = function() {
      this.expandOnType = this.expandOn === "Auto" ? Browser.isDevice ? "Click" : "DblClick" : this.expandOn;
    };
    TreeView2.prototype.expandHandler = function(e) {
      var target = Browser.isDevice && e.originalEvent.changedTouches && !Browser.isIos ? document.elementFromPoint(e.originalEvent.changedTouches[0].clientX, e.originalEvent.changedTouches[0].clientY) : e.originalEvent.target;
      if (!target || target.classList.contains(INPUT2) || target.classList.contains(ROOT5) || target.classList.contains(PARENTITEM) || target.classList.contains(LISTITEM) || target.classList.contains(ICON3) || this.showCheckBox && closest(target, "." + CHECKBOXWRAP)) {
        return;
      } else {
        this.expandCollapseAction(closest(target, "." + LISTITEM), e);
      }
    };
    TreeView2.prototype.expandCollapseAction = function(currLi, e) {
      var icon = select("div." + ICON3, currLi);
      if (!icon || icon.classList.contains(PROCESS)) {
        return;
      } else {
        var classList2 = icon.classList;
        if (classList2.contains(EXPANDABLE)) {
          this.expandAction(currLi, icon, e);
        } else if (classList2.contains(COLLAPSIBLE)) {
          this.collapseNode(currLi, icon, e);
        }
      }
    };
    TreeView2.prototype.expandAction = function(currLi, icon, e, expandChild, callback) {
      var _this = this;
      if (icon.classList.contains(PROCESS)) {
        return;
      } else {
        addClass([icon], PROCESS);
      }
      if (this.isLoaded && !this.isRefreshed) {
        this.expandArgs = this.getExpandEvent(currLi, e);
        this.isInteracted = this.expandArgs.isInteracted;
        this.trigger("nodeExpanding", this.expandArgs, function(observedArgs) {
          if (observedArgs.cancel) {
            removeClass([icon], PROCESS);
          } else {
            _this.nodeExpandAction(currLi, icon, expandChild, callback);
          }
        });
      } else {
        this.nodeExpandAction(currLi, icon, expandChild, callback);
      }
    };
    TreeView2.prototype.nodeExpandAction = function(currLi, icon, expandChild, callback) {
      var ul = select("." + PARENTITEM, currLi);
      if (ul && ul.nodeName === "UL") {
        this.expandNode(currLi, icon);
      } else {
        this.isFirstRender = true;
        this.renderChildNodes(currLi, expandChild, callback);
        var liEles = selectAll("." + LISTITEM, currLi);
        for (var i = 0; i < liEles.length; i++) {
          var id = this.getId(liEles[parseInt(i.toString(), 10)]);
          if (this.expandChildren.indexOf(id) !== -1 && this.expandChildren !== void 0) {
            var icon_1 = select("." + EXPANDABLE, select("." + TEXTWRAP, liEles[parseInt(i.toString(), 10)]));
            if (!isNullOrUndefined(icon_1)) {
              this.expandAction(liEles[parseInt(i.toString(), 10)], icon_1, null);
            }
            this.expandChildren.splice(this.expandChildren.indexOf(id), 1);
          }
        }
      }
    };
    TreeView2.prototype.keyActionHandler = function(e) {
      var _this = this;
      var target = e.target;
      var focusedNode = this.getFocusedNode();
      if (target && target.classList.contains(INPUT2)) {
        var inpEle = target;
        if (e.action === "enter") {
          inpEle.blur();
        } else if (e.action === "escape") {
          inpEle.value = this.oldText;
          inpEle.blur();
        }
        return;
      }
      e.preventDefault();
      var eventArgs = {
        cancel: false,
        event: e,
        node: focusedNode
      };
      this.trigger("keyPress", eventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          switch (e.action) {
            case "space":
              if (_this.showCheckBox) {
                _this.checkNode(e);
              } else {
                _this.toggleSelect(focusedNode, e);
              }
              break;
            case "moveRight":
              _this.openNode(_this.enableRtl ? false : true, e);
              break;
            case "moveLeft":
              _this.openNode(_this.enableRtl ? true : false, e);
              break;
            case "shiftDown":
              _this.shiftKeySelect(true, e);
              break;
            case "moveDown":
            case "ctrlDown":
            case "csDown":
              _this.navigateNode(true);
              break;
            case "shiftUp":
              _this.shiftKeySelect(false, e);
              break;
            case "moveUp":
            case "ctrlUp":
            case "csUp":
              _this.navigateNode(false);
              break;
            case "home":
            case "shiftHome":
            case "ctrlHome":
            case "csHome":
              _this.navigateRootNode(true);
              break;
            case "end":
            case "shiftEnd":
            case "ctrlEnd":
            case "csEnd":
              _this.navigateRootNode(false);
              break;
            case "enter":
            case "ctrlEnter":
            case "shiftEnter":
            case "csEnter":
            case "shiftSpace":
            case "ctrlSpace":
              _this.toggleSelect(focusedNode, e);
              break;
            case "f2":
              if (_this.allowEditing && !focusedNode.classList.contains("e-disable")) {
                _this.createTextbox(focusedNode);
              }
              break;
            case "ctrlA":
              if (_this.allowMultiSelection) {
                var sNodes = selectAll("." + LISTITEM + ":not(." + ACTIVE2 + ")", _this.element);
                _this.selectGivenNodes(sNodes);
              }
              break;
          }
        }
      });
    };
    TreeView2.prototype.navigateToFocus = function(isUp) {
      var focusNode = this.getFocusedNode().querySelector("." + TEXTWRAP);
      var pos = focusNode.getBoundingClientRect();
      var parent = this.getScrollParent(this.element);
      if (!isNullOrUndefined(parent)) {
        var parentPos = parent.getBoundingClientRect();
        if (pos.bottom > parentPos.bottom) {
          parent.scrollTop += pos.bottom - parentPos.bottom;
        } else if (pos.top < parentPos.top) {
          parent.scrollTop -= parentPos.top - pos.top;
        }
      }
      var isVisible2 = this.isVisibleInViewport(focusNode);
      if (!isVisible2) {
        focusNode.scrollIntoView(isUp);
      }
    };
    TreeView2.prototype.isVisibleInViewport = function(txtWrap) {
      var pos = txtWrap.getBoundingClientRect();
      return pos.top >= 0 && pos.left >= 0 && pos.bottom <= (window.innerHeight || document.documentElement.clientHeight) && pos.right <= (window.innerWidth || document.documentElement.clientWidth);
    };
    TreeView2.prototype.getScrollParent = function(node) {
      if (isNullOrUndefined(node)) {
        return null;
      }
      return node.scrollHeight > node.clientHeight ? node : this.getScrollParent(node.parentElement);
    };
    TreeView2.prototype.shiftKeySelect = function(isTowards, e) {
      if (this.allowMultiSelection) {
        var focusedNode = this.getFocusedNode();
        var nextNode = isTowards ? this.getNextNode(focusedNode) : this.getPrevNode(focusedNode);
        this.removeHover();
        this.setFocusElement(nextNode);
        this.toggleSelect(nextNode, e, false);
        this.navigateToFocus(!isTowards);
      } else {
        this.navigateNode(isTowards);
      }
    };
    TreeView2.prototype.checkNode = function(e) {
      var focusedNode = this.getFocusedNode();
      var checkWrap = select("." + CHECKBOXWRAP, focusedNode);
      var isChecked = select(" ." + CHECKBOXFRAME, checkWrap).classList.contains(CHECK2);
      if (!focusedNode.classList.contains("e-disable")) {
        if (focusedNode.getElementsByClassName("e-checkbox-disabled").length === 0) {
          this.validateCheckNode(checkWrap, isChecked, focusedNode, e);
        }
      }
    };
    TreeView2.prototype.validateCheckNode = function(checkWrap, isCheck, li, e) {
      var _this = this;
      var currLi = closest(checkWrap, "." + LISTITEM);
      this.checkActionNodes = [];
      var ariaState = !isCheck ? "true" : "false";
      if (!isNullOrUndefined(ariaState)) {
        currLi.setAttribute("aria-checked", ariaState);
      }
      var eventArgs = this.getCheckEvent(currLi, isCheck ? "uncheck" : "check", e);
      this.trigger("nodeChecking", eventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          _this.nodeCheckingAction(checkWrap, isCheck, li, observedArgs, e);
        }
      });
    };
    TreeView2.prototype.nodeCheckingAction = function(checkWrap, isCheck, li, eventArgs, e) {
      if (this.checkedElement.indexOf(li.getAttribute("data-uid")) === -1) {
        this.checkedElement.push(li.getAttribute("data-uid"));
        if (this.autoCheck) {
          var child = this.getChildNodes(this.treeData, li.getAttribute("data-uid"));
          if (child !== null) {
            this.allCheckNode(child, this.checkedElement, null, null, false);
          } else {
            child = null;
          }
        }
      }
      this.changeState(checkWrap, isCheck ? "uncheck" : "check", e, true);
      if (this.autoCheck) {
        this.ensureChildCheckState(li);
        this.updateOldCheckedData([this.getNodeData(li)]);
        this.ensureParentCheckState(closest(closest(li, "." + PARENTITEM), "." + LISTITEM));
        var doCheck = void 0;
        if (eventArgs.action === "check") {
          doCheck = true;
        } else if (eventArgs.action === "uncheck") {
          doCheck = false;
        }
        this.ensureStateChange(li, doCheck);
      }
      this.nodeCheckedEvent(checkWrap, isCheck, e);
    };
    TreeView2.prototype.ensureStateChange = function(li, doCheck) {
      var childElement = select("." + PARENTITEM, li);
      var parentIndex = li.getAttribute("data-uid");
      var mapper = this.fields;
      if (this.dataType === 1 && this.autoCheck) {
        var resultData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.parentID, "equal", parentIndex, true));
        for (var i = 0; i < resultData.length; i++) {
          var resultId = resultData[parseInt(i.toString(), 10)][this.fields.id] ? resultData[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
          var isCheck = resultData[parseInt(i.toString(), 10)][this.fields.isChecked] ? resultData[parseInt(i.toString(), 10)][this.fields.isChecked].toString() : null;
          if (this.checkedNodes.indexOf(parentIndex) !== -1 && this.checkedNodes.indexOf(resultId) === -1) {
            this.checkedNodes.push(resultId);
            var childItems = this.getChildNodes(this.treeData, resultId);
            this.getChildItems(childItems, doCheck);
            if (this.parentNodeCheck.indexOf(resultId) !== -1) {
              this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(resultId), 1);
            }
          } else if (this.checkedNodes.indexOf(parentIndex) === -1 && childElement === null && this.checkedNodes.indexOf(resultId) !== -1) {
            this.checkedNodes.splice(this.checkedNodes.indexOf(resultId), 1);
            if (isCheck === "true") {
              this.updateField(this.treeData, this.fields, resultId, "isChecked", null);
            }
            if (this.checkedNodes.indexOf(parentIndex) === -1 && childElement === null || this.parentNodeCheck.indexOf(resultId) !== -1) {
              var childNodes = this.getChildNodes(this.treeData, resultId);
              this.getChildItems(childNodes, doCheck);
              if (this.parentNodeCheck.indexOf(resultId) !== -1) {
                this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(resultId), 1);
              }
            }
          } else {
            var childItems = this.getChildNodes(this.treeData, resultId);
            this.getChildItems(childItems, doCheck);
          }
        }
      } else if (this.dataType === 1 && !this.autoCheck) {
        if (!doCheck) {
          var checkedData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.isChecked, "equal", true, false));
          for (var i = 0; i < checkedData.length; i++) {
            var id = checkedData[parseInt(i.toString(), 10)][this.fields.id] ? checkedData[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
            if (this.checkedNodes.indexOf(id) !== -1) {
              this.checkedNodes.splice(this.checkedNodes.indexOf(id), 1);
            }
            this.updateField(this.treeData, this.fields, id, "isChecked", null);
          }
          this.checkedNodes = [];
        } else {
          for (var i = 0; i < this.treeData.length; i++) {
            var checkedId = this.treeData[parseInt(i.toString(), 10)][this.fields.id] ? this.treeData[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
            if (this.checkedNodes.indexOf(checkedId) === -1) {
              this.checkedNodes.push(checkedId);
            }
          }
        }
      } else {
        var childItems = this.getChildNodes(this.treeData, parentIndex);
        if (childItems) {
          this.childStateChange(childItems, parentIndex, childElement, doCheck);
        }
      }
    };
    TreeView2.prototype.getChildItems = function(childItems, doCheck) {
      for (var i = 0; i < childItems.length; i++) {
        var childId = childItems[parseInt(i.toString(), 10)][this.fields.id] ? childItems[parseInt(i.toString(), 10)][this.fields.id].toString() : null;
        var childIsCheck = childItems[parseInt(i.toString(), 10)][this.fields.isChecked] ? childItems[parseInt(i.toString(), 10)][this.fields.isChecked].toString() : null;
        if (this.checkedNodes.indexOf(childId) !== -1 && !doCheck) {
          this.checkedNodes.splice(this.checkedNodes.indexOf(childId), 1);
        }
        if (this.checkedNodes.indexOf(childId) === -1 && doCheck) {
          this.checkedNodes.push(childId);
        }
        if (childIsCheck === "true" && !doCheck) {
          this.updateField(this.treeData, this.fields, childId, "isChecked", null);
        }
        var subChildItems = this.getChildNodes(this.treeData, childId);
        if (subChildItems.length > 0) {
          this.getChildItems(subChildItems, doCheck);
        }
      }
    };
    TreeView2.prototype.childStateChange = function(childItems, parent, childElement, doCheck) {
      for (var i = 0; i < childItems.length; i++) {
        var checkedChild = childItems[parseInt(i.toString(), 10)][this.fields.id] ? childItems[parseInt(i.toString(), 10)][this.fields.id].toString() : "";
        var isCheck = childItems[parseInt(i.toString(), 10)][this.fields.isChecked] ? childItems[parseInt(i.toString(), 10)][this.fields.isChecked].toString() : null;
        if (this.autoCheck) {
          if (this.checkedNodes.indexOf(parent) !== -1 && this.checkedNodes.indexOf(checkedChild) === -1) {
            this.checkedNodes.push(checkedChild);
            if (this.parentNodeCheck.indexOf(checkedChild) !== -1) {
              this.parentNodeCheck.splice(this.parentNodeCheck.indexOf(checkedChild), 1);
            }
          } else if (this.checkedNodes.indexOf(parent) === -1 && this.checkedNodes.indexOf(checkedChild) !== -1 && !doCheck) {
            this.checkedNodes.splice(this.checkedNodes.indexOf(checkedChild), 1);
            if (isCheck === "true") {
              this.updateField(this.treeData, this.fields, checkedChild, "isChecked", null);
            }
          }
        } else if (!this.autoCheck) {
          if (!doCheck) {
            if (this.checkedNodes.indexOf(checkedChild) !== -1) {
              this.checkedNodes.splice(this.checkedNodes.indexOf(checkedChild), 1);
            }
            this.updateField(this.treeData, this.fields, checkedChild, "isChecked", null);
            this.checkedNodes = [];
          } else {
            if (this.checkedNodes.indexOf(checkedChild) === -1) {
              this.checkedNodes.push(checkedChild);
            }
          }
        }
        var subChild = this.getChildNodes([childItems[parseInt(i.toString(), 10)]], checkedChild);
        if (subChild) {
          this.childStateChange(subChild, parent, childElement, doCheck);
        }
      }
    };
    TreeView2.prototype.allCheckNode = function(child, newCheck, checked, childCheck, validateCheck) {
      if (child) {
        for (var length_1 = 0; length_1 < child.length; length_1++) {
          var childId = getValue(this.fields.id, child[parseInt(length_1.toString(), 10)]);
          var check = this.element.querySelector('[data-uid="' + childId + '"]');
          if (validateCheck !== false && this.checkedElement.indexOf(childId.toString()) === -1) {
            if (check === null && !isNullOrUndefined(child[parseInt(length_1.toString(), 10)][this.fields.isChecked]) && newCheck.indexOf(childId.toString()) === -1 || childCheck === 0 || checked === 2) {
              if (child[parseInt(length_1.toString(), 10)][this.fields.isChecked] !== false || checked === 2) {
                newCheck.push(childId.toString());
              } else {
                childCheck = null;
              }
              childCheck = child[parseInt(length_1.toString(), 10)][this.fields.isChecked] !== false || checked === 2 ? 0 : null;
            }
          }
          if (newCheck.indexOf(childId.toString()) === -1 && isNullOrUndefined(checked)) {
            newCheck.push(childId.toString());
          }
          var hierChildId = getValue(this.fields.child.toString(), child[parseInt(length_1.toString(), 10)]);
          if (getValue(this.fields.hasChildren, child[parseInt(length_1.toString(), 10)]) === true || hierChildId) {
            var id = getValue(this.fields.id, child[parseInt(length_1.toString(), 10)]);
            var childId_1 = void 0;
            if (this.dataType === 1) {
              childId_1 = this.getChildNodes(this.treeData, id.toString());
            } else {
              childId_1 = hierChildId;
            }
            if (childId_1) {
              if (isNullOrUndefined(validateCheck)) {
                this.allCheckNode(childId_1, newCheck, checked, childCheck);
              } else {
                this.allCheckNode(childId_1, newCheck, checked, childCheck, validateCheck);
              }
              childCheck = null;
            }
          }
          childCheck = null;
        }
      }
    };
    TreeView2.prototype.openNode = function(toBeOpened, e) {
      var focusedNode = this.getFocusedNode();
      var icon = select("div." + ICON3, focusedNode);
      if (toBeOpened) {
        if (!icon) {
          return;
        } else if (icon.classList.contains(EXPANDABLE)) {
          this.expandAction(focusedNode, icon, e);
        } else {
          this.focusNextNode(focusedNode, true);
        }
      } else {
        if (icon && icon.classList.contains(COLLAPSIBLE)) {
          this.collapseNode(focusedNode, icon, e);
        } else {
          var parentLi = closest(closest(focusedNode, "." + PARENTITEM), "." + LISTITEM);
          if (!parentLi) {
            return;
          } else {
            if (!parentLi.classList.contains("e-disable")) {
              this.setFocus(focusedNode, parentLi);
              this.navigateToFocus(true);
            }
          }
        }
      }
    };
    TreeView2.prototype.navigateNode = function(isTowards) {
      var focusedNode = this.getFocusedNode();
      this.focusNextNode(focusedNode, isTowards);
    };
    TreeView2.prototype.navigateRootNode = function(isBackwards) {
      var focusedNode = this.getFocusedNode();
      var rootNode = isBackwards ? this.getRootNode() : this.getEndNode();
      if (!rootNode.classList.contains("e-disable")) {
        this.setFocus(focusedNode, rootNode);
        this.navigateToFocus(isBackwards);
      }
    };
    TreeView2.prototype.getFocusedNode = function() {
      var selectedItem;
      var fNode = select("." + LISTITEM + '[tabindex="0"]', this.element);
      if (isNullOrUndefined(fNode)) {
        selectedItem = select("." + LISTITEM, this.element);
      }
      return isNullOrUndefined(fNode) ? isNullOrUndefined(selectedItem) ? this.element.firstElementChild : selectedItem : fNode;
    };
    TreeView2.prototype.focusNextNode = function(li, isTowards) {
      var nextNode = isTowards ? this.getNextNode(li) : this.getPrevNode(li);
      this.setFocus(li, nextNode);
      this.navigateToFocus(!isTowards);
      if (nextNode.classList.contains("e-disable") || nextNode.classList.contains("e-prevent")) {
        var lastChild = nextNode.lastChild;
        if (nextNode.previousSibling == null && nextNode.classList.contains("e-level-1")) {
          this.focusNextNode(nextNode, true);
        } else if (nextNode.nextSibling == null && nextNode.classList.contains("e-node-collapsed")) {
          this.focusNextNode(nextNode, false);
        } else if (nextNode.nextSibling == null && lastChild.classList.contains(TEXTWRAP)) {
          this.focusNextNode(nextNode, false);
        } else {
          this.focusNextNode(nextNode, isTowards);
        }
      }
    };
    TreeView2.prototype.getNextNode = function(li) {
      var index = this.liList.indexOf(li);
      var nextNode;
      do {
        index++;
        nextNode = this.liList[parseInt(index.toString(), 10)];
        if (isNullOrUndefined(nextNode)) {
          return li;
        }
      } while (!isVisible(nextNode));
      return nextNode;
    };
    TreeView2.prototype.getPrevNode = function(li) {
      var index = this.liList.indexOf(li);
      var prevNode;
      do {
        index--;
        prevNode = this.liList[parseInt(index.toString(), 10)];
        if (isNullOrUndefined(prevNode)) {
          return li;
        }
      } while (!isVisible(prevNode));
      return prevNode;
    };
    TreeView2.prototype.getRootNode = function() {
      var index = 0;
      var rootNode;
      do {
        rootNode = this.liList[parseInt(index.toString(), 10)];
        index++;
      } while (!isVisible(rootNode));
      return rootNode;
    };
    TreeView2.prototype.getEndNode = function() {
      var index = this.liList.length - 1;
      var endNode;
      do {
        endNode = this.liList[parseInt(index.toString(), 10)];
        index--;
      } while (!isVisible(endNode));
      return endNode;
    };
    TreeView2.prototype.setFocus = function(preNode, nextNode) {
      removeClass([preNode], FOCUS);
      preNode.setAttribute("tabindex", "-1");
      if (!nextNode.classList.contains("e-disable") && !nextNode.classList.contains(PREVENTSELECT)) {
        addClass([nextNode], FOCUS);
        nextNode.setAttribute("tabindex", "0");
        nextNode.focus();
        EventHandler.add(nextNode, "blur", this.focusOut, this);
        this.updateIdAttr(preNode, nextNode);
      }
    };
    TreeView2.prototype.updateIdAttr = function(preNode, nextNode) {
      this.element.removeAttribute("aria-activedescendant");
      if (preNode) {
        preNode.removeAttribute("id");
      }
      nextNode.setAttribute("id", this.element.id + "_active");
      this.element.setAttribute("aria-activedescendant", this.element.id + "_active");
    };
    TreeView2.prototype.focusIn = function() {
      if (!this.mouseDownStatus) {
        var focusedElement = this.getFocusedNode();
        if (focusedElement.classList.contains("e-disable") || focusedElement.classList.contains("e-prevent")) {
          focusedElement.setAttribute("tabindex", "-1");
          this.navigateNode(true);
        } else {
          focusedElement.setAttribute("tabindex", "0");
          addClass([focusedElement], FOCUS);
          EventHandler.add(focusedElement, "blur", this.focusOut, this);
        }
        this.mouseDownStatus = false;
      }
    };
    TreeView2.prototype.focusOut = function(event) {
      var focusedElement = this.getFocusedNode();
      if (event.target === focusedElement) {
        removeClass([focusedElement], FOCUS);
        EventHandler.remove(focusedElement, "blur", this.focusOut);
      }
    };
    TreeView2.prototype.onMouseOver = function(e) {
      if (Browser.isDevice) {
        return;
      }
      var target = e.target;
      var classList2 = target.classList;
      var currentLi = closest(target, "." + LISTITEM);
      if (!currentLi || classList2.contains(PARENTITEM) || classList2.contains(LISTITEM)) {
        this.removeHover();
        return;
      } else {
        if (currentLi && !currentLi.classList.contains("e-disable")) {
          this.setHover(currentLi);
        }
      }
    };
    TreeView2.prototype.setHover = function(li) {
      if (!li.classList.contains(HOVER) && !li.classList.contains(PREVENTSELECT)) {
        this.removeHover();
        addClass([li], HOVER);
      }
    };
    TreeView2.prototype.onMouseLeave = function() {
      this.removeHover();
    };
    TreeView2.prototype.removeHover = function() {
      var hoveredNode = selectAll("." + HOVER, this.element);
      if (hoveredNode && hoveredNode.length) {
        removeClass(hoveredNode, HOVER);
      }
    };
    TreeView2.prototype.getNodeData = function(currLi, fromDS) {
      if (!isNullOrUndefined(currLi) && currLi.classList.contains(LISTITEM) && !isNullOrUndefined(closest(currLi, "." + CONTROL3)) && closest(currLi, "." + CONTROL3).classList.contains(ROOT5)) {
        var id = currLi.getAttribute("data-uid");
        var text = this.getText(currLi, fromDS);
        var pNode = closest(currLi.parentNode, "." + LISTITEM);
        var pid = pNode ? pNode.getAttribute("data-uid") : null;
        var selected = currLi.classList.contains(ACTIVE2);
        var selectable = currLi.classList.contains(PREVENTSELECT) ? false : true;
        var expanded = currLi.getAttribute("aria-expanded") === "true" ? true : false;
        var hasChildren = currLi.getAttribute("aria-expanded") !== null ? true : (select("." + EXPANDABLE, currLi) || select("." + COLLAPSIBLE, currLi)) != null ? true : false;
        var checked = null;
        var checkboxElement = select("." + CHECKBOXWRAP, currLi);
        if (this.showCheckBox && checkboxElement) {
          checked = currLi.getAttribute("aria-checked");
        }
        return {
          id,
          text,
          parentID: pid,
          selected,
          selectable,
          expanded,
          isChecked: checked,
          hasChildren
        };
      }
      return { id: "", text: "", parentID: "", selected: false, expanded: false, isChecked: "", hasChildren: false };
    };
    TreeView2.prototype.getText = function(currLi, fromDS) {
      if (fromDS) {
        var nodeData = this.getNodeObject(currLi.getAttribute("data-uid"));
        var level = parseFloat(currLi.getAttribute("aria-level"));
        var nodeFields = this.getFields(this.fields, level, 1);
        return getValue(nodeFields.text, nodeData);
      }
      return select("." + LISTTEXT, currLi).textContent;
    };
    TreeView2.prototype.getExpandEvent = function(currLi, e) {
      var nodeData = this.getNodeData(currLi);
      return { cancel: false, isInteracted: isNullOrUndefined(e) ? false : true, node: currLi, nodeData, event: e };
    };
    TreeView2.prototype.renderNodeTemplate = function(data, textEle, dataId) {
      var tempArr = this.nodeTemplateFn(data, this, "nodeTemplate" + dataId, this.element.id + "nodeTemplate", this.isStringTemplate, void 0, textEle, this.root);
      if (tempArr) {
        tempArr = Array.prototype.slice.call(tempArr);
        append(tempArr, textEle);
      }
    };
    TreeView2.prototype.destroyTemplate = function(liEle) {
      this.clearTemplate(["nodeTemplate" + liEle.getAttribute("data-uid")]);
    };
    TreeView2.prototype.reRenderNodes = function() {
      this.updateListProp(this.fields);
      if (Browser.isIE) {
        this.ulElement = this.element.querySelector(".e-list-parent.e-ul");
        this.ulElement.parentElement.removeChild(this.ulElement);
      } else {
        this.element.innerHTML = "";
      }
      if (!isNullOrUndefined(this.nodeTemplateFn)) {
        this.clearTemplate();
      }
      this.setTouchClass();
      this.setProperties({ selectedNodes: [], checkedNodes: [], expandedNodes: [] }, true);
      this.checkedElement = [];
      this.isLoaded = false;
      this.setDataBinding(true);
    };
    TreeView2.prototype.setCssClass = function(oldClass, newClass) {
      if (!isNullOrUndefined(oldClass) && oldClass !== "") {
        removeClass([this.element], oldClass.split(" "));
      }
      if (!isNullOrUndefined(newClass) && newClass !== "") {
        addClass([this.element], newClass.split(" "));
      }
    };
    TreeView2.prototype.editingHandler = function(e) {
      var target = e.target;
      if (!target || target.classList.contains(ROOT5) || target.classList.contains(PARENTITEM) || target.classList.contains(LISTITEM) || target.classList.contains(ICON3) || target.classList.contains(INPUT2) || target.classList.contains(INPUTGROUP2)) {
        return;
      } else {
        var liEle = closest(target, "." + LISTITEM);
        this.createTextbox(liEle);
      }
    };
    TreeView2.prototype.createTextbox = function(liEle) {
      var _this = this;
      var oldInpEle = select("." + TREEINPUT, this.element);
      if (oldInpEle) {
        oldInpEle.blur();
      }
      var textEle = select("." + LISTTEXT, liEle);
      this.updateOldText(liEle);
      var innerEle = this.createElement("input", { className: TREEINPUT, attrs: { value: this.oldText } });
      var eventArgs = this.getEditEvent(liEle, null, innerEle.outerHTML);
      this.trigger("nodeEditing", eventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          var inpWidth = textEle.offsetWidth + 5;
          var style_1 = "width:" + inpWidth + "px";
          addClass([liEle], EDITING);
          if (!isNullOrUndefined(_this.nodeTemplateFn)) {
            _this.destroyTemplate(liEle);
          }
          if (_this.isReact) {
            setTimeout(function() {
              _this.renderTextBox(eventArgs, textEle, style_1);
            }, 5);
          } else {
            _this.renderTextBox(eventArgs, textEle, style_1);
          }
        }
      });
    };
    TreeView2.prototype.renderTextBox = function(eventArgs, textEle, style) {
      textEle.innerHTML = eventArgs.innerHtml;
      var inpEle = select("." + TREEINPUT, textEle);
      this.inputObj = Input.createInput({
        element: inpEle,
        properties: {
          enableRtl: this.enableRtl
        }
      }, this.createElement);
      this.inputObj.container.setAttribute("style", style);
      inpEle.focus();
      var inputEle = inpEle;
      inputEle.setSelectionRange(0, inputEle.value.length);
      this.wireInputEvents(inpEle);
    };
    TreeView2.prototype.updateOldText = function(liEle) {
      var id = liEle.getAttribute("data-uid");
      this.editData = this.getNodeObject(id);
      var level = parseFloat(liEle.getAttribute("aria-level"));
      this.editFields = this.getFields(this.fields, level, 1);
      this.oldText = getValue(this.editFields.text, this.editData);
    };
    TreeView2.prototype.inputFocusOut = function(e) {
      if (!select("." + TREEINPUT, this.element)) {
        return;
      }
      var target = e.target;
      var newText = target.value;
      var txtEle = closest(target, "." + LISTTEXT);
      var liEle = closest(target, "." + LISTITEM);
      detach(this.inputObj.container);
      Input.destroy({ element: target, properties: this.properties });
      if (this.fields.dataSource instanceof DataManager && !this.isOffline) {
        this.crudOperation("update", null, liEle, newText, null, null, true);
      } else {
        this.appendNewText(liEle, txtEle, newText, true);
      }
      EventHandler.remove(target, "blur", this.inputFocusOut);
    };
    TreeView2.prototype.appendNewText = function(liEle, txtEle, newText, isInput) {
      var _this = this;
      var eventArgs = this.getEditEvent(liEle, newText, null);
      this.trigger("nodeEdited", eventArgs, function(observedArgs) {
        newText = observedArgs.cancel ? observedArgs.oldText : observedArgs.newText;
        _this.updateText(liEle, txtEle, newText, isInput);
        if (observedArgs.oldText !== newText) {
          _this.triggerEvent("nodeEdited", [_this.getNode(liEle)]);
        }
      });
    };
    TreeView2.prototype.updateText = function(liEle, txtEle, newText, isInput) {
      var newData = setValue(this.editFields.text, newText, this.editData);
      if (!isNullOrUndefined(this.nodeTemplateFn)) {
        txtEle.innerText = "";
        var dataId = liEle.getAttribute("data-uid");
        this.renderNodeTemplate(newData, txtEle, dataId);
        this.renderReactTemplates();
      } else {
        if (this.enableHtmlSanitizer) {
          txtEle.innerText = SanitizeHtmlHelper.sanitize(newText);
        } else {
          txtEle.innerHTML = newText;
        }
      }
      if (isInput) {
        removeClass([liEle], EDITING);
        liEle.focus();
        EventHandler.add(liEle, "blur", this.focusOut, this);
        addClass([liEle], FOCUS);
      }
      if (this.allowTextWrap) {
        this.calculateWrap(liEle);
      }
    };
    TreeView2.prototype.getElement = function(ele) {
      if (isNullOrUndefined(ele)) {
        return null;
      } else if (typeof ele === "string") {
        return this.element.querySelector('[data-uid="' + ele + '"]');
      } else if (typeof ele === "object") {
        return getElement(ele);
      } else {
        return null;
      }
    };
    TreeView2.prototype.getId = function(ele) {
      if (isNullOrUndefined(ele)) {
        return null;
      } else if (typeof ele === "string") {
        return ele;
      } else if (typeof ele === "object") {
        return getElement(ele).getAttribute("data-uid");
      } else {
        return null;
      }
    };
    TreeView2.prototype.getEditEvent = function(liEle, newText, inpEle) {
      var data = this.getNodeData(liEle);
      return { cancel: false, newText, node: liEle, nodeData: data, oldText: this.oldText, innerHtml: inpEle };
    };
    TreeView2.prototype.getNodeObject = function(id) {
      var childNodes;
      if (isNullOrUndefined(id)) {
        return childNodes;
      } else if (this.dataType === 1) {
        for (var i = 0, objlen = this.treeData.length; i < objlen; i++) {
          var dataId = getValue(this.fields.id, this.treeData[parseInt(i.toString(), 10)]);
          if (!isNullOrUndefined(this.treeData[parseInt(i.toString(), 10)]) && !isNullOrUndefined(dataId) && dataId.toString() === id) {
            return this.treeData[parseInt(i.toString(), 10)];
          }
        }
      } else {
        return this.getChildNodeObject(this.treeData, this.fields, id);
      }
      return childNodes;
    };
    TreeView2.prototype.getChildNodeObject = function(obj, mapper, id) {
      var newList;
      if (isNullOrUndefined(obj)) {
        return newList;
      }
      for (var i = 0, objlen = obj.length; i < objlen; i++) {
        var dataId = getValue(mapper.id, obj[parseInt(i.toString(), 10)]);
        if (obj[parseInt(i.toString(), 10)] && dataId && dataId.toString() === id) {
          return obj[parseInt(i.toString(), 10)];
        } else if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, obj[parseInt(i.toString(), 10)]))) {
          var childData = getValue(mapper.child, obj[parseInt(i.toString(), 10)]);
          newList = this.getChildNodeObject(childData, this.getChildMapper(mapper), id);
          if (newList !== void 0) {
            break;
          }
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", obj[parseInt(i.toString(), 10)]))) {
          var child = "child";
          newList = this.getChildNodeObject(getValue(child, obj[parseInt(i.toString(), 10)]), this.getChildMapper(mapper), id);
          if (newList !== void 0) {
            break;
          }
        } else if (this.isChildObject()) {
          var children = "child";
          var childData = getValue(children, obj[parseInt(i.toString(), 10)]);
          newList = this.getChildNodeObject(childData, this.getChildMapper(mapper), id);
          if (newList !== void 0) {
            break;
          }
        }
      }
      return newList;
    };
    TreeView2.prototype.setDragAndDrop = function(toBind) {
      if (toBind && !this.disabled) {
        this.initializeDrag();
      } else {
        this.destroyDrag();
      }
    };
    TreeView2.prototype.initializeDrag = function() {
      var _this = this;
      var virtualEle;
      this.dragObj = new Draggable(this.element, {
        enableTailMode: true,
        enableAutoScroll: true,
        dragArea: this.dragArea,
        dragTarget: "." + TEXTWRAP,
        enableTapHold: true,
        tapHoldThreshold: 100,
        helper: function(e) {
          _this.dragTarget = e.sender.target;
          var dragRoot = closest(_this.dragTarget, "." + ROOT5);
          var dragWrap = closest(_this.dragTarget, "." + TEXTWRAP);
          _this.dragLi = closest(_this.dragTarget, "." + LISTITEM);
          if (_this.fullRowSelect && !dragWrap && _this.dragTarget.classList.contains(FULLROW)) {
            dragWrap = _this.dragTarget.nextElementSibling;
          }
          if (!_this.dragTarget || !e.element.isSameNode(dragRoot) || !dragWrap || _this.dragTarget.classList.contains(ROOT5) || _this.dragTarget.classList.contains(PARENTITEM) || _this.dragTarget.classList.contains(LISTITEM) || _this.dragLi.classList.contains("e-disable")) {
            return false;
          }
          var cloneEle = dragWrap.cloneNode(true);
          if (isNullOrUndefined(select("div." + ICON3, cloneEle))) {
            var icon = _this.createElement("div", { className: ICON3 + " " + EXPANDABLE });
            cloneEle.insertBefore(icon, cloneEle.children[0]);
          }
          var cssClass2 = DRAGITEM + " " + ROOT5 + " " + _this.cssClass + " " + (_this.enableRtl ? RTL12 : "");
          virtualEle = _this.createElement("div", { className: cssClass2 });
          virtualEle.appendChild(cloneEle);
          var nLen = _this.selectedNodes.length;
          if (nLen > 1 && _this.allowMultiSelection && _this.dragLi.classList.contains(ACTIVE2)) {
            var cNode = _this.createElement("span", { className: DROPCOUNT, innerHTML: "" + nLen });
            virtualEle.appendChild(cNode);
          }
          document.body.appendChild(virtualEle);
          document.body.style.cursor = "";
          _this.dragData = _this.getNodeData(_this.dragLi);
          return virtualEle;
        },
        dragStart: function(e) {
          addClass([_this.element], DRAGGING);
          var listItem = closest(e.target, ".e-list-item");
          var level;
          if (listItem) {
            level = parseInt(listItem.getAttribute("aria-level"), 10);
          }
          var eventArgs = _this.getDragEvent(e.event, _this, null, e.target, null, virtualEle, level);
          if (eventArgs.draggedNode.classList.contains(EDITING)) {
            _this.dragObj.intDestroy(e.event);
            _this.dragCancelAction(virtualEle);
          } else {
            _this.trigger("nodeDragStart", eventArgs, function(observedArgs) {
              if (observedArgs.cancel) {
                _this.dragObj.intDestroy(e.event);
                _this.dragCancelAction(virtualEle);
              } else {
                _this.dragStartAction = true;
              }
            });
          }
        },
        drag: function(e) {
          _this.dragObj.setProperties({ cursorAt: { top: !isNullOrUndefined(e.event.targetTouches) || Browser.isDevice ? 60 : -20 } });
          _this.dragAction(e, virtualEle);
        },
        dragStop: function(e) {
          removeClass([_this.element], DRAGGING);
          if (!e.target.classList.contains("e-sibling")) {
            _this.removeVirtualEle();
          }
          var dropTarget = e.target;
          var preventTargetExpand = false;
          var dropRoot = closest(dropTarget, "." + DROPPABLE);
          var isHelperElement = true;
          if (!dropTarget || !dropRoot) {
            detach(e.helper);
            document.body.style.cursor = "";
          }
          var listItem = closest(dropTarget, ".e-list-item");
          var level;
          if (listItem) {
            level = parseInt(listItem.getAttribute("aria-level"), 10);
          }
          var eventArgs = _this.getDragEvent(e.event, _this, dropTarget, dropTarget, null, e.helper, level);
          eventArgs.preventTargetExpand = preventTargetExpand;
          _this.trigger("nodeDragStop", eventArgs, function(observedArgs) {
            _this.dragParent = observedArgs.draggedParentNode;
            _this.preventExpand = observedArgs.preventTargetExpand;
            if (observedArgs.cancel) {
              if (e.helper.parentNode) {
                detach(e.helper);
              }
              document.body.style.cursor = "";
              isHelperElement = false;
              if (dropTarget.classList.contains("e-sibling")) {
                _this.removeVirtualEle();
              }
            }
            _this.dragStartAction = false;
          });
        }
      });
      this.dropObj = new Droppable(this.element, {
        out: function(e) {
          if (!isNullOrUndefined(e) && !e.target.classList.contains(SIBLING) && (_this.dropObj.dragData.default && _this.dropObj.dragData.default.helper.classList.contains(ROOT5))) {
            document.body.style.cursor = "not-allowed";
          }
        },
        over: function() {
          document.body.style.cursor = "";
        },
        drop: function(e) {
          _this.dropAction(e);
          _this.removeVirtualEle();
        }
      });
    };
    TreeView2.prototype.dragCancelAction = function(virtualEle) {
      detach(virtualEle);
      removeClass([this.element], DRAGGING);
      this.dragStartAction = false;
    };
    TreeView2.prototype.dragAction = function(e, virtualEle) {
      var dropRoot = closest(e.target, "." + DROPPABLE);
      var dropWrap = closest(e.target, "." + TEXTWRAP);
      var icon = select("div." + ICON3, virtualEle);
      removeClass([icon], [DROPIN, DROPNEXT, DROPOUT, NODROP]);
      this.isDropIn = false;
      this.removeVirtualEle();
      document.body.style.cursor = "";
      var classList2 = e.target.classList;
      if (this.fullRowSelect && !dropWrap && !isNullOrUndefined(classList2) && classList2.contains(FULLROW)) {
        dropWrap = e.target.nextElementSibling;
      }
      if (dropRoot) {
        var dropLi = closest(e.target, "." + LISTITEM);
        var checkWrapper = closest(e.target, "." + CHECKBOXWRAP);
        var collapse = closest(e.target, "." + COLLAPSIBLE);
        var expand = closest(e.target, "." + EXPANDABLE);
        if (!dropRoot.classList.contains(ROOT5) || dropWrap && (!dropLi.isSameNode(this.dragLi) && !this.isDescendant(this.dragLi, dropLi))) {
          if (this.hasTemplate && dropLi) {
            var templateTarget = select(this.fullRowSelect ? "." + FULLROW : "." + TEXTWRAP, dropLi);
            if (e && (!expand && !collapse) && e.event.offsetY < 7 && !checkWrapper || (expand && e.event.offsetY < 5 || collapse && e.event.offsetX < 3)) {
              var index = this.fullRowSelect ? 1 : 0;
              this.appendIndicator(dropLi, icon, index);
            } else if (e && (!expand && !collapse) && !checkWrapper && templateTarget && e.event.offsetY > templateTarget.offsetHeight - 10 || (expand && e.event.offsetY > 19 || collapse && e.event.offsetX > 19)) {
              var index = this.fullRowSelect ? 2 : 1;
              this.appendIndicator(dropLi, icon, index);
            } else {
              addClass([icon], DROPIN);
              this.isDropIn = true;
            }
          } else {
            if (dropLi && e && (!expand && !collapse) && e.event.offsetY < 7 && !checkWrapper || (expand && e.event.offsetY < 5 || collapse && e.event.offsetX < 3)) {
              var index = this.fullRowSelect ? 1 : 0;
              this.appendIndicator(dropLi, icon, index);
            } else if (dropLi && e && (!expand && !collapse) && (e.target.offsetHeight > 0 && e.event.offsetY > e.target.offsetHeight - 10) && !checkWrapper || (expand && e.event.offsetY > 19 || collapse && e.event.offsetX > 19)) {
              var index = this.fullRowSelect ? 2 : 1;
              this.appendIndicator(dropLi, icon, index);
            } else {
              addClass([icon], DROPIN);
              this.isDropIn = true;
            }
          }
        } else if (e.target.nodeName === "LI" && (!dropLi.isSameNode(this.dragLi) && !this.isDescendant(this.dragLi, dropLi))) {
          addClass([icon], DROPNEXT);
          this.renderVirtualEle(e);
        } else if (e.target.classList.contains(SIBLING)) {
          addClass([icon], DROPNEXT);
        } else {
          addClass([icon], DROPOUT);
        }
      } else {
        addClass([icon], NODROP);
        document.body.style.cursor = "not-allowed";
      }
      var listItem = closest(e.target, ".e-list-item");
      var level;
      if (listItem) {
        level = parseInt(listItem.getAttribute("aria-level"), 10);
      }
      var eventArgs = this.getDragEvent(e.event, this, e.target, e.target, null, virtualEle, level);
      if (eventArgs.dropIndicator) {
        removeClass([icon], eventArgs.dropIndicator);
      }
      this.trigger("nodeDragging", eventArgs);
      if (eventArgs.dropIndicator) {
        addClass([icon], eventArgs.dropIndicator);
      }
    };
    TreeView2.prototype.appendIndicator = function(dropLi, icon, index) {
      addClass([icon], DROPNEXT);
      var virEle = this.createElement("div", { className: SIBLING });
      dropLi.insertBefore(virEle, dropLi.children[parseInt(index.toString(), 10)]);
    };
    TreeView2.prototype.dropAction = function(e) {
      var offsetY = e.event.offsetY;
      var dropTarget = e.target;
      var dragObj;
      var level;
      var drop = false;
      var nodeData = [];
      var liArray = [];
      var dragInstance = e.dragData.draggable;
      for (var i = 0; i < dragInstance.ej2_instances.length; i++) {
        if (dragInstance.ej2_instances[parseInt(i.toString(), 10)] instanceof TreeView_1) {
          dragObj = dragInstance.ej2_instances[parseInt(i.toString(), 10)];
          break;
        }
      }
      if (dragObj && dragObj.dragTarget) {
        var dragTarget = dragObj.dragTarget;
        var dragLi = closest(dragTarget, "." + LISTITEM);
        var dropLi = closest(dropTarget, "." + LISTITEM);
        liArray.push(dragLi);
        if (dropLi == null && dropTarget.classList.contains(ROOT5)) {
          dropLi = dropTarget.firstElementChild;
        }
        detach(e.droppedElement);
        document.body.style.cursor = "";
        if (!dropLi || dropLi.isSameNode(dragLi) || this.isDescendant(dragLi, dropLi)) {
          if (this.fields.dataSource instanceof DataManager === false) {
            this.preventExpand = false;
          }
          return;
        }
        if (dragObj.allowMultiSelection && dragLi.classList.contains(ACTIVE2)) {
          var sNodes = selectAll("." + ACTIVE2, dragObj.element);
          liArray = sNodes;
          if (e.target.offsetHeight <= 33 && offsetY > e.target.offsetHeight - 10 && offsetY > 6) {
            for (var i = sNodes.length - 1; i >= 0; i--) {
              if (dropLi.isSameNode(sNodes[parseInt(i.toString(), 10)]) || this.isDescendant(sNodes[parseInt(i.toString(), 10)], dropLi)) {
                continue;
              }
              this.appendNode(dropTarget, sNodes[parseInt(i.toString(), 10)], dropLi, e, dragObj, offsetY);
            }
          } else {
            for (var i = 0; i < sNodes.length; i++) {
              if (dropLi.isSameNode(sNodes[parseInt(i.toString(), 10)]) || this.isDescendant(sNodes[parseInt(i.toString(), 10)], dropLi)) {
                continue;
              }
              this.appendNode(dropTarget, sNodes[parseInt(i.toString(), 10)], dropLi, e, dragObj, offsetY);
            }
          }
        } else {
          this.appendNode(dropTarget, dragLi, dropLi, e, dragObj, offsetY);
        }
        level = parseInt(dragLi.getAttribute("aria-level"), 10);
        drop = true;
      }
      if (this.fields.dataSource instanceof DataManager === false) {
        this.preventExpand = false;
      }
      for (var i = 0; i < liArray.length; i++) {
        nodeData.push(this.getNode(liArray[parseInt(i.toString(), 10)]));
      }
      this.trigger("nodeDropped", this.getDragEvent(e.event, dragObj, dropTarget, e.target, e.dragData.draggedElement, null, level, drop));
      if (dragObj.element.id !== this.element.id) {
        dragObj.triggerEvent("nodeDropped", nodeData);
        this.isNodeDropped = true;
        this.fields.dataSource = this.treeData;
      }
      this.triggerEvent("nodeDropped", nodeData);
    };
    TreeView2.prototype.appendNode = function(dropTarget, dragLi, dropLi, e, dragObj, offsetY) {
      var checkWrapper = closest(dropTarget, "." + CHECKBOXWRAP);
      var collapse = closest(e.target, "." + COLLAPSIBLE);
      var expand = closest(e.target, "." + EXPANDABLE);
      if (!dragLi.classList.contains("e-disable") && !checkWrapper && (expand && e.event.offsetY < 5 || collapse && e.event.offsetX < 3 || expand && e.event.offsetY > 19 || collapse && e.event.offsetX > 19 || !expand && !collapse)) {
        if (dropTarget.nodeName === "LI") {
          this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
        } else if (dropTarget.firstElementChild && dropTarget.classList.contains(ROOT5)) {
          if (dropTarget.firstElementChild.nodeName === "UL") {
            this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
          }
        } else if (dropTarget.classList.contains("e-icon-collapsible") || dropTarget.classList.contains("e-icon-expandable")) {
          this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
        } else {
          this.dropAsChildNode(dragLi, dropLi, dragObj, null, e, offsetY, null, dropTarget);
        }
      } else {
        this.dropAsChildNode(dragLi, dropLi, dragObj, null, e, offsetY, true, dropTarget);
      }
      if (this.showCheckBox) {
        this.ensureIndeterminate();
      }
    };
    TreeView2.prototype.dropAsSiblingNode = function(dragLi, dropLi, e, dragObj) {
      var dropUl = closest(dropLi, "." + PARENTITEM);
      var dragParentUl = closest(dragLi, "." + PARENTITEM);
      var dragParentLi = closest(dragParentUl, "." + LISTITEM);
      var pre;
      if (e.target.offsetHeight > 0 && e.event.offsetY > e.target.offsetHeight - 2) {
        pre = false;
      } else if (e.event.offsetY < 2) {
        pre = true;
      } else if (e.target.classList.contains("e-icon-expandable") || e.target.classList.contains("e-icon-collapsible")) {
        if (e.event.offsetY < 5 || e.event.offsetX < 3) {
          pre = true;
        } else if (e.event.offsetY > 15 || e.event.offsetX > 17) {
          pre = false;
        }
      }
      if (e.target.classList.contains("e-icon-expandable") || e.target.classList.contains("e-icon-collapsible")) {
        var target = e.target.closest("li");
        dropUl.insertBefore(dragLi, pre ? target : target.nextElementSibling);
      } else {
        dropUl.insertBefore(dragLi, pre ? e.target : e.target.nextElementSibling);
      }
      this.moveData(dragLi, dropLi, dropUl, pre, dragObj);
      this.updateElement(dragParentUl, dragParentLi);
      this.updateAriaLevel(dragLi);
      if (dragObj.element.id === this.element.id) {
        this.updateList();
      } else {
        dragObj.updateInstance();
        this.updateInstance();
      }
    };
    TreeView2.prototype.dropAsChildNode = function(dragLi, dropLi, dragObj, index, e, pos, isCheck, dropTarget) {
      var dragParentUl = closest(dragLi, "." + PARENTITEM);
      var dragParentLi = closest(dragParentUl, "." + LISTITEM);
      var dropParentUl = closest(dropLi, "." + PARENTITEM);
      var templateTarget;
      if (e && e.target) {
        templateTarget = select(this.fullRowSelect ? "." + FULLROW : "." + TEXTWRAP, dropLi);
      }
      if (e && (pos < 7 && !dropTarget.classList.contains("e-sibling") || dropTarget.classList.contains("e-sibling") && !dropLi.lastChild.classList.contains("e-sibling")) && !isCheck) {
        dropParentUl.insertBefore(dragLi, dropLi);
        this.moveData(dragLi, dropLi, dropParentUl, true, dragObj);
      } else if (e && (e.target.offsetHeight > 0 && pos > e.target.offsetHeight - 10) && !isCheck && !this.hasTemplate) {
        dropParentUl.insertBefore(dragLi, dropLi.nextElementSibling);
        this.moveData(dragLi, dropLi, dropParentUl, false, dragObj);
      } else if (this.hasTemplate && templateTarget && pos > templateTarget.offsetHeight - 10 && !isCheck) {
        dropParentUl.insertBefore(dragLi, dropLi.nextElementSibling);
        this.moveData(dragLi, dropLi, dropParentUl, false, dragObj);
      } else {
        var dropUl = this.expandParent(dropLi);
        var childLi = !isNullOrUndefined(index) ? dropUl.childNodes[parseInt(index.toString(), 10)] : null;
        dropUl.insertBefore(dragLi, childLi);
        this.moveData(dragLi, childLi, dropUl, true, dragObj);
      }
      this.updateElement(dragParentUl, dragParentLi);
      this.updateAriaLevel(dragLi);
      if (dragObj.element.id === this.element.id) {
        this.updateList();
      } else {
        dragObj.updateInstance();
        this.updateInstance();
      }
    };
    TreeView2.prototype.moveData = function(dragLi, dropLi, dropUl, pre, dragObj) {
      var dropParentLi = closest(dropUl, "." + LISTITEM);
      var id = this.getId(dragLi);
      var removedData = dragObj.updateChildField(dragObj.treeData, dragObj.fields, id, null, null, true);
      var refId = this.getId(dropLi);
      var index = this.getDataPos(this.treeData, this.fields, refId);
      var parentId = this.getId(dropParentLi);
      if (this.dataType === 1) {
        this.updateField(this.treeData, this.fields, parentId, "hasChildren", true);
        var pos = isNullOrUndefined(index) ? this.treeData.length : pre ? index : index + 1;
        if (isNullOrUndefined(parentId) && !this.hasPid) {
          delete removedData[0][this.fields.parentID];
        } else {
          var currPid = this.isNumberTypeId ? parseFloat(parentId) : parentId;
          setValue(this.fields.parentID, currPid, removedData[0]);
        }
        this.treeData.splice(pos, 0, removedData[0]);
        if (dragObj.element.id !== this.element.id) {
          var childData = dragObj.removeChildNodes(id);
          pos++;
          for (var i = 0, len = childData.length; i < len; i++) {
            this.treeData.splice(pos, 0, childData[parseInt(i.toString(), 10)]);
            pos++;
          }
          dragObj.groupedData = dragObj.getGroupedData(dragObj.treeData, dragObj.fields.parentID);
        }
        this.groupedData = this.getGroupedData(this.treeData, this.fields.parentID);
      } else {
        this.addChildData(this.treeData, this.fields, parentId, removedData, pre ? index : index + 1);
      }
    };
    TreeView2.prototype.expandParent = function(dropLi) {
      var dropIcon = select("div." + ICON3, dropLi);
      if (dropIcon && dropIcon.classList.contains(EXPANDABLE) && this.preventExpand !== true) {
        this.expandAction(dropLi, dropIcon, null);
      }
      var dropUl = select("." + PARENTITEM, dropLi);
      if (this.preventExpand === true && !dropUl && dropIcon) {
        this.renderChildNodes(dropLi);
      }
      dropUl = select("." + PARENTITEM, dropLi);
      if (!isNullOrUndefined(dropUl) && this.preventExpand === true) {
        dropUl.style.display = "none";
      }
      if (!isNullOrUndefined(dropUl) && this.preventExpand === false) {
        dropUl.style.display = "block";
      }
      if (isNullOrUndefined(dropUl) && this.preventExpand === true) {
        if (isNullOrUndefined(dropIcon)) {
          ListBase.generateIcon(this.createElement, dropLi, EXPANDABLE, this.listBaseOption);
        }
        var icon = select("div." + ICON3, dropLi);
        if (icon) {
          icon.classList.add("e-icon-expandable");
        }
        dropUl = ListBase.generateUL(this.createElement, [], null, this.listBaseOption);
        dropLi.appendChild(dropUl);
        if (icon) {
          removeClass([icon], COLLAPSIBLE);
        } else {
          ListBase.generateIcon(this.createElement, dropLi, EXPANDABLE, this.listBaseOption);
        }
        dropLi.setAttribute("aria-expanded", "false");
        dropUl.style.display = "none";
      }
      if (isNullOrUndefined(dropUl)) {
        var args = this.expandArgs;
        if (isNullOrUndefined(args) || args && args.name !== "nodeExpanding") {
          this.trigger("nodeExpanding", this.getExpandEvent(dropLi, null));
        }
        if (isNullOrUndefined(dropIcon)) {
          ListBase.generateIcon(this.createElement, dropLi, COLLAPSIBLE, this.listBaseOption);
        }
        var icon = select("div." + ICON3, dropLi);
        if (icon) {
          removeClass([icon], EXPANDABLE);
        } else {
          ListBase.generateIcon(this.createElement, dropLi, COLLAPSIBLE, this.listBaseOption);
          icon = select("div." + ICON3, dropLi);
          removeClass([icon], EXPANDABLE);
        }
        dropUl = ListBase.generateUL(this.createElement, [], null, this.listBaseOption);
        dropLi.appendChild(dropUl);
        this.addExpand(dropLi);
        this.trigger("nodeExpanded", this.getExpandEvent(dropLi, null));
      }
      return dropUl;
    };
    TreeView2.prototype.updateElement = function(dragParentUl, dragParentLi) {
      if (dragParentLi && dragParentUl.childElementCount === 0) {
        var dragIcon = select("div." + ICON3, dragParentLi);
        detach(dragParentUl);
        detach(dragIcon);
        var parentId = this.getId(dragParentLi);
        this.updateField(this.treeData, this.fields, parentId, "hasChildren", false);
        this.removeExpand(dragParentLi, true);
      }
    };
    TreeView2.prototype.updateAriaLevel = function(dragLi) {
      var level = this.parents(dragLi, "." + PARENTITEM).length;
      dragLi.setAttribute("aria-level", "" + level);
      this.updateChildAriaLevel(select("." + PARENTITEM, dragLi), level + 1);
    };
    TreeView2.prototype.updateChildAriaLevel = function(element2, level) {
      if (!isNullOrUndefined(element2)) {
        var cNodes = element2.childNodes;
        for (var i = 0, len = cNodes.length; i < len; i++) {
          var liEle = cNodes[parseInt(i.toString(), 10)];
          liEle.setAttribute("aria-level", "" + level);
          this.updateChildAriaLevel(select("." + PARENTITEM, liEle), level + 1);
        }
      }
    };
    TreeView2.prototype.renderVirtualEle = function(e) {
      var pre;
      if (e.event.offsetY > e.target.offsetHeight - 2) {
        pre = false;
      } else if (e.event.offsetY < 2) {
        pre = true;
      }
      var virEle = this.createElement("div", { className: SIBLING });
      var index = this.fullRowSelect ? pre ? 1 : 2 : pre ? 0 : 1;
      e.target.insertBefore(virEle, e.target.children[parseInt(index.toString(), 10)]);
    };
    TreeView2.prototype.removeVirtualEle = function() {
      var sibEle = select("." + SIBLING);
      if (sibEle) {
        detach(sibEle);
      }
    };
    TreeView2.prototype.destroyDrag = function() {
      if (this.dragObj && this.dropObj) {
        this.dragObj.destroy();
        this.dropObj.destroy();
      }
    };
    TreeView2.prototype.getDragEvent = function(event, obj, dropTarget, target, dragNode, cloneEle, level, drop) {
      var dropLi = dropTarget ? closest(dropTarget, "." + LISTITEM) : null;
      var dropData = dropLi ? this.getNodeData(dropLi) : null;
      var draggedNode = obj ? obj.dragLi : dragNode;
      var draggedNodeData = obj ? obj.dragData : null;
      var newParent = dropTarget ? this.parents(dropTarget, "." + LISTITEM) : null;
      var dragLiParent = obj.dragLi.parentElement;
      var dragParent = obj.dragLi ? closest(dragLiParent, "." + LISTITEM) : null;
      var targetParent = null;
      var indexValue = null;
      var iconCss = [DROPNEXT, DROPIN, DROPOUT, NODROP];
      var iconClass = null;
      var node = drop === true ? draggedNode : dropLi;
      var index = node ? closest(node, ".e-list-parent") : null;
      var i = 0;
      var position = null;
      dragParent = obj.dragLi && dragParent === null ? closest(dragLiParent, "." + ROOT5) : dragParent;
      dragParent = drop === true ? this.dragParent : dragParent;
      if (cloneEle) {
        while (i < 4) {
          if (select("." + ICON3, cloneEle).classList.contains(iconCss[parseInt(i.toString(), 10)])) {
            iconClass = iconCss[parseInt(i.toString(), 10)];
            break;
          }
          i++;
        }
      }
      if (index) {
        var dropTar = 0;
        for (i = 0; i < index.childElementCount; i++) {
          dropTar = drop !== true && index.children[parseInt(i.toString(), 10)] === draggedNode && dropLi !== draggedNode ? ++dropTar : dropTar;
          if (drop !== true && index.children[parseInt(i.toString(), 10)].classList.contains("e-hover")) {
            indexValue = event.offsetY >= 23 ? i + 1 : i;
            break;
          } else if (index.children[parseInt(i.toString(), 10)] === node) {
            indexValue = event.offsetY >= 23 ? i : i;
            break;
          }
        }
        indexValue = dropTar !== 0 ? --indexValue : indexValue;
        position = this.isDropIn ? "Inside" : event.offsetY < 7 ? "Before" : "After";
      }
      if (dropTarget) {
        if (newParent.length === 0) {
          targetParent = null;
        } else if (dropTarget.classList.contains(LISTITEM)) {
          targetParent = newParent[0];
        } else {
          targetParent = newParent[1];
        }
      }
      if (dropLi === draggedNode) {
        targetParent = dropLi;
      }
      if (dropTarget && target.offsetHeight <= 33 && event.offsetY < target.offsetHeight - 10 && event.offsetY > 6) {
        targetParent = dropLi;
        if (drop !== true) {
          level = ++level;
          var parent_2 = targetParent ? select(".e-list-parent", targetParent) : null;
          indexValue = parent_2 ? parent_2.children.length : 0;
          if (!(this.fields.dataSource instanceof DataManager) && parent_2 === null && targetParent) {
            var parent_3 = targetParent.hasAttribute("data-uid") ? this.getChildNodes(this.fields.dataSource, targetParent.getAttribute("data-uid").toString()) : null;
            indexValue = parent_3 ? parent_3.length : 0;
          }
        }
      }
      return {
        cancel: false,
        clonedNode: cloneEle,
        event,
        draggedNode,
        draggedNodeData,
        droppedNode: dropLi,
        droppedNodeData: dropData,
        dropIndex: indexValue,
        dropLevel: level,
        draggedParentNode: dragParent,
        dropTarget: targetParent,
        dropIndicator: iconClass,
        target,
        position
      };
    };
    TreeView2.prototype.addFullRow = function(toAdd) {
      var len = this.liList.length;
      if (toAdd) {
        for (var i = 0; i < len; i++) {
          this.createFullRow(this.liList[parseInt(i.toString(), 10)]);
        }
      } else {
        for (var i = 0; i < len; i++) {
          var rowDiv = select("." + FULLROW, this.liList[parseInt(i.toString(), 10)]);
          detach(rowDiv);
        }
      }
    };
    TreeView2.prototype.createFullRow = function(item) {
      var rowDiv = this.createElement("div", { className: FULLROW });
      item.insertBefore(rowDiv, item.childNodes[0]);
    };
    TreeView2.prototype.addMultiSelect = function(toAdd) {
      if (toAdd) {
        var liEles = selectAll("." + LISTITEM + ':not([aria-selected="true"])', this.element);
        for (var _i = 0, liEles_1 = liEles; _i < liEles_1.length; _i++) {
          var ele = liEles_1[_i];
          ele.setAttribute("aria-selected", "false");
        }
      } else {
        var liEles = selectAll("." + LISTITEM + '[aria-selected="false"]', this.element);
        for (var _a = 0, liEles_2 = liEles; _a < liEles_2.length; _a++) {
          var ele = liEles_2[_a];
          ele.removeAttribute("aria-selected");
        }
      }
    };
    TreeView2.prototype.collapseByLevel = function(element2, level, excludeHiddenNodes) {
      if (level > 0 && !isNullOrUndefined(element2)) {
        var cNodes = this.getVisibleNodes(excludeHiddenNodes, element2.childNodes);
        for (var i = 0, len = cNodes.length; i < len; i++) {
          var liEle = cNodes[parseInt(i.toString(), 10)];
          var icon = select("." + COLLAPSIBLE, select("." + TEXTWRAP, liEle));
          if (!isNullOrUndefined(icon)) {
            this.collapseNode(liEle, icon, null);
          }
          this.collapseByLevel(select("." + PARENTITEM, liEle), level - 1, excludeHiddenNodes);
        }
      }
    };
    TreeView2.prototype.collapseAllNodes = function(excludeHiddenNodes) {
      var cIcons = this.getVisibleNodes(excludeHiddenNodes, selectAll("." + COLLAPSIBLE, this.element));
      for (var i = 0, len = cIcons.length; i < len; i++) {
        var icon = cIcons[parseInt(i.toString(), 10)];
        var liEle = closest(icon, "." + LISTITEM);
        this.collapseNode(liEle, icon, null);
      }
    };
    TreeView2.prototype.expandByLevel = function(element2, level, excludeHiddenNodes) {
      if (level > 0 && !isNullOrUndefined(element2)) {
        var eNodes = this.getVisibleNodes(excludeHiddenNodes, element2.childNodes);
        for (var i = 0, len = eNodes.length; i < len; i++) {
          var liEle = eNodes[parseInt(i.toString(), 10)];
          var icon = select("." + EXPANDABLE, select("." + TEXTWRAP, liEle));
          if (!isNullOrUndefined(icon)) {
            this.expandAction(liEle, icon, null);
          }
          this.expandByLevel(select("." + PARENTITEM, liEle), level - 1, excludeHiddenNodes);
        }
      }
    };
    TreeView2.prototype.expandAllNodes = function(excludeHiddenNodes) {
      var eIcons = this.getVisibleNodes(excludeHiddenNodes, selectAll("." + EXPANDABLE, this.element));
      for (var i = 0, len = eIcons.length; i < len; i++) {
        var icon = eIcons[parseInt(i.toString(), 10)];
        var liEle = closest(icon, "." + LISTITEM);
        this.expandAction(liEle, icon, null, true);
      }
    };
    TreeView2.prototype.getVisibleNodes = function(excludeHiddenNodes, nodes) {
      var vNodes = Array.prototype.slice.call(nodes);
      if (excludeHiddenNodes) {
        for (var i = 0; i < vNodes.length; i++) {
          if (!isVisible(vNodes[parseInt(i.toString(), 10)])) {
            vNodes.splice(i, 1);
            i--;
          }
        }
      }
      return vNodes;
    };
    TreeView2.prototype.removeNode = function(node) {
      var dragParentUl = closest(node, "." + PARENTITEM);
      var dragParentLi = closest(dragParentUl, "." + LISTITEM);
      if (!isNullOrUndefined(this.nodeTemplateFn)) {
        this.destroyTemplate(node);
      }
      detach(node);
      this.updateElement(dragParentUl, dragParentLi);
      this.removeData(node);
    };
    TreeView2.prototype.updateInstance = function() {
      this.updateList();
      this.updateSelectedNodes();
      this.updateExpandedNodes();
    };
    TreeView2.prototype.updateList = function() {
      this.liList = Array.prototype.slice.call(selectAll("." + LISTITEM, this.element));
    };
    TreeView2.prototype.updateSelectedNodes = function() {
      this.setProperties({ selectedNodes: [] }, true);
      var sNodes = selectAll("." + ACTIVE2, this.element);
      this.selectGivenNodes(sNodes);
    };
    TreeView2.prototype.updateExpandedNodes = function() {
      this.setProperties({ expandedNodes: [] }, true);
      var eNodes = selectAll('[aria-expanded="true"]', this.element);
      for (var i = 0, len = eNodes.length; i < len; i++) {
        this.addExpand(eNodes[parseInt(i.toString(), 10)]);
      }
    };
    TreeView2.prototype.removeData = function(node) {
      if (this.dataType === 1) {
        var dm = new DataManager(this.treeData);
        var id = this.getId(node);
        var data = {};
        var newId = this.isNumberTypeId ? parseFloat(id) : id;
        data[this.fields.id] = newId;
        dm.remove(this.fields.id, data);
        this.removeChildNodes(id);
      } else {
        var id = this.getId(node);
        this.updateChildField(this.treeData, this.fields, id, null, null, true);
      }
    };
    TreeView2.prototype.removeChildNodes = function(parentId) {
      var cNodes = this.getChildGroup(this.groupedData, parentId, false);
      var childData = [];
      if (cNodes) {
        for (var i = 0, len = cNodes.length; i < len; i++) {
          var dm = new DataManager(this.treeData);
          var id = getValue(this.fields.id, cNodes[parseInt(i.toString(), 10)]).toString();
          var data = {};
          var currId = this.isNumberTypeId ? parseFloat(id) : id;
          data[this.fields.id] = currId;
          var nodeData = dm.remove(this.fields.id, data);
          childData.push(nodeData[0]);
          this.removeChildNodes(id);
        }
      }
      return childData;
    };
    TreeView2.prototype.doGivenAction = function(nodes, selector, toExpand) {
      for (var i = 0, len = nodes.length; i < len; i++) {
        var liEle = this.getElement(nodes[parseInt(i.toString(), 10)]);
        if (isNullOrUndefined(liEle)) {
          continue;
        }
        var icon = select("." + selector, select("." + TEXTWRAP, liEle));
        if (!isNullOrUndefined(icon)) {
          if (toExpand) {
            this.expandAction(liEle, icon, null);
          } else {
            this.collapseNode(liEle, icon, null);
          }
        }
      }
    };
    TreeView2.prototype.addGivenNodes = function(nodes, dropLi, index, isRemote, dropEle) {
      if (nodes.length === 0) {
        return;
      }
      var sNodes = this.getSortedData(nodes);
      var level = dropLi ? parseFloat(dropLi.getAttribute("aria-level")) + 1 : 1;
      if (isRemote) {
        this.updateMapper(level);
      }
      var li = ListBase.createListItemFromJson(this.createElement, sNodes, this.listBaseOption, level);
      var id = this.getId(dropLi);
      var dropIcon1;
      if (!isNullOrUndefined(dropLi)) {
        dropIcon1 = select("div." + ICON3, dropLi);
      }
      if (this.dataType === 1 && dropIcon1 && dropIcon1.classList.contains(EXPANDABLE) && !isNullOrUndefined(this.element.offsetParent) && !this.element.offsetParent.parentElement.classList.contains("e-filemanager")) {
        this.preventExpand = true;
      }
      if (this.dataType !== 1) {
        this.addChildData(this.treeData, this.fields, id, nodes, index);
        this.isFirstRender = false;
      }
      var dropUl;
      if (!dropEle) {
        dropUl = dropLi ? this.expandParent(dropLi) : select("." + PARENTITEM, this.element);
      } else {
        dropUl = dropEle;
      }
      var refNode = !isNullOrUndefined(index) ? dropUl.childNodes[parseInt(index.toString(), 10)] : null;
      if (!this.isFirstRender || this.dataType === 1) {
        var args = this.expandArgs;
        if (refNode || this.sortOrder === "None") {
          for (var i = 0; i < li.length; i++) {
            dropUl.insertBefore(li[parseInt(i.toString(), 10)], refNode);
          }
          if (this.dataType === 1 && !isNullOrUndefined(dropLi) && !isNullOrUndefined(this.element.offsetParent) && !this.element.offsetParent.parentElement.classList.contains("e-filemanager")) {
            this.preventExpand = false;
            var dropIcon = select("div." + ICON3, dropLi);
            if (dropIcon && dropIcon.classList.contains(EXPANDABLE) && (isNullOrUndefined(args) || args.name !== "nodeExpanding")) {
              this.expandAction(dropLi, dropIcon, null);
            }
          }
        }
        if (!refNode && (this.sortOrder === "Ascending" || this.sortOrder === "Descending")) {
          if (dropUl.childNodes.length === 0) {
            for (var i = 0; i < li.length; i++) {
              dropUl.insertBefore(li[parseInt(i.toString(), 10)], refNode);
            }
            if (this.dataType === 1 && !isNullOrUndefined(dropLi) && !isNullOrUndefined(this.element.offsetParent) && !this.element.offsetParent.parentElement.classList.contains("e-filemanager")) {
              this.preventExpand = false;
              var dropIcon = select("div." + ICON3, dropLi);
              if (dropIcon && dropIcon.classList.contains(EXPANDABLE) && (isNullOrUndefined(args) || args.name !== "nodeExpanding")) {
                this.expandAction(dropLi, dropIcon, null);
              }
            }
          } else {
            var cNodes = dropUl.childNodes;
            for (var i = 0; i < li.length; i++) {
              for (var j = 0; j < cNodes.length; j++) {
                var returnValue = this.sortOrder === "Ascending" ? cNodes[parseInt(j.toString(), 10)].textContent.toUpperCase() > li[parseInt(i.toString(), 10)].innerText.toUpperCase() : cNodes[parseInt(j.toString(), 10)].textContent.toUpperCase() < li[parseInt(i.toString(), 10)].innerText.toUpperCase();
                if (returnValue) {
                  dropUl.insertBefore(li[parseInt(i.toString(), 10)], cNodes[parseInt(j.toString(), 10)]);
                  break;
                }
                dropUl.insertBefore(li[parseInt(i.toString(), 10)], cNodes[cNodes.length]);
              }
            }
          }
        }
      }
      if (this.dataType === 1) {
        this.updateField(this.treeData, this.fields, id, "hasChildren", true);
        var refId = this.getId(refNode);
        var pos = isNullOrUndefined(refId) ? this.treeData.length : this.getDataPos(this.treeData, this.fields, refId);
        for (var j = 0; j < nodes.length; j++) {
          if (!isNullOrUndefined(id)) {
            var currId = this.isNumberTypeId ? parseFloat(id) : id;
            setValue(this.fields.parentID, currId, nodes[parseInt(j.toString(), 10)]);
          }
          this.treeData.splice(pos, 0, nodes[parseInt(j.toString(), 10)]);
          pos++;
        }
      }
      this.finalizeNode(dropUl);
    };
    TreeView2.prototype.updateMapper = function(level) {
      var mapper = level === 1 ? this.fields : this.getChildFields(this.fields, level - 1, 1);
      this.updateListProp(mapper);
    };
    TreeView2.prototype.updateListProp = function(mapper) {
      var prop = this.getActualProperties(mapper);
      this.listBaseOption.fields = prop;
      this.listBaseOption.fields.url = Object.prototype.hasOwnProperty.call(prop, "navigateUrl") ? prop.navigateUrl : "navigateUrl";
    };
    TreeView2.prototype.getDataPos = function(obj, mapper, id) {
      var pos = null;
      for (var i = 0, objlen = obj.length; i < objlen; i++) {
        var nodeId = getValue(mapper.id, obj[parseInt(i.toString(), 10)]);
        if (obj[parseInt(i.toString(), 10)] && nodeId && nodeId.toString() === id) {
          return i;
        } else if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, obj[parseInt(i.toString(), 10)]))) {
          var data = getValue(mapper.child, obj[parseInt(i.toString(), 10)]);
          pos = this.getDataPos(data, this.getChildMapper(mapper), id);
          if (pos !== null) {
            break;
          }
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", obj[parseInt(i.toString(), 10)]))) {
          var items = getValue("child", obj[parseInt(i.toString(), 10)]);
          pos = this.getDataPos(items, this.getChildMapper(mapper), id);
          if (pos !== null) {
            break;
          }
        }
      }
      return pos;
    };
    TreeView2.prototype.addChildData = function(obj, mapper, id, data, index) {
      var updated;
      if (isNullOrUndefined(id)) {
        index = isNullOrUndefined(index) ? obj.length : index;
        for (var k = 0, len = data.length; k < len; k++) {
          obj.splice(index, 0, data[parseInt(k.toString(), 10)]);
          index++;
        }
        return updated;
      }
      for (var i = 0, objlen = obj.length; i < objlen; i++) {
        var nodeId = getValue(mapper.id, obj[parseInt(i.toString(), 10)]);
        if (obj[parseInt(i.toString(), 10)] && nodeId && nodeId.toString() === id) {
          if (typeof mapper.child === "string" && (Object.prototype.hasOwnProperty.call(obj[parseInt(i.toString(), 10)], mapper.child) && obj[parseInt(i.toString(), 10)][mapper.child] !== null) || this.fields.dataSource instanceof DataManager && Object.prototype.hasOwnProperty.call(obj[parseInt(i.toString(), 10)], "child")) {
            var key = typeof mapper.child === "string" ? mapper.child : "child";
            var childData = getValue(key, obj[parseInt(i.toString(), 10)]);
            if (isNullOrUndefined(childData)) {
              childData = [];
            }
            index = isNullOrUndefined(index) ? childData.length : index;
            for (var k = 0, len = data.length; k < len; k++) {
              childData.splice(index, 0, data[parseInt(k.toString(), 10)]);
              index++;
            }
          } else {
            var key = typeof mapper.child === "string" ? mapper.child : "child";
            obj[parseInt(i.toString(), 10)]["" + key] = data;
          }
          return true;
        } else if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, obj[parseInt(i.toString(), 10)]))) {
          var childObj = getValue(mapper.child, obj[parseInt(i.toString(), 10)]);
          updated = this.addChildData(childObj, this.getChildMapper(mapper), id, data, index);
          if (updated !== void 0) {
            break;
          }
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", obj[parseInt(i.toString(), 10)]))) {
          var childData = getValue("child", obj[parseInt(i.toString(), 10)]);
          updated = this.addChildData(childData, this.getChildMapper(mapper), id, data, index);
          if (updated !== void 0) {
            break;
          }
        }
      }
      return updated;
    };
    TreeView2.prototype.doDisableAction = function(nodes) {
      var validNodes = this.nodeType(nodes);
      var validID = this.checkValidId(validNodes);
      this.validArr = [];
      for (var i = 0, len = validID.length; i < len; i++) {
        var id = validID[parseInt(i.toString(), 10)][this.fields.id].toString();
        if (id && this.disableNode.indexOf(id) === -1) {
          this.disableNode.push(id);
        }
        var liEle = this.getElement(id);
        if (liEle) {
          liEle.setAttribute("aria-disabled", "true");
          addClass([liEle], DISABLE);
        }
      }
    };
    TreeView2.prototype.doEnableAction = function(nodes) {
      var strNodes = this.nodeType(nodes);
      for (var i = 0, len = strNodes.length; i < len; i++) {
        var liEle = this.getElement(strNodes[parseInt(i.toString(), 10)]);
        var id = strNodes[parseInt(i.toString(), 10)];
        if (id && this.disableNode.indexOf(id) !== -1) {
          this.disableNode.splice(this.disableNode.indexOf(id), 1);
        }
        if (liEle) {
          liEle.removeAttribute("aria-disabled");
          removeClass([liEle], DISABLE);
        }
      }
    };
    TreeView2.prototype.nodeType = function(nodes) {
      var validID = [];
      for (var i = 0, len = nodes.length; i < len; i++) {
        var id = void 0;
        if (typeof nodes[parseInt(i.toString(), 10)] == "string") {
          id = nodes[parseInt(i.toString(), 10)] ? nodes[parseInt(i.toString(), 10)].toString() : null;
        } else if (typeof nodes[parseInt(i.toString(), 10)] === "object") {
          id = nodes[parseInt(i.toString(), 10)] ? nodes[parseInt(i.toString(), 10)].getAttribute("data-uid").toString() : null;
        }
        if (validID.indexOf(id) === -1) {
          validID.push(id);
        }
      }
      return validID;
    };
    TreeView2.prototype.checkValidId = function(node) {
      var _this = this;
      if (this.dataType === 1) {
        this.validArr = this.treeData.filter(function(data) {
          return node.indexOf(data[_this.fields.id] ? data[_this.fields.id].toString() : null) !== -1;
        });
      } else if (this.dataType === 2) {
        for (var k = 0; k < this.treeData.length; k++) {
          var id = this.treeData[parseInt(k.toString(), 10)][this.fields.id] ? this.treeData[parseInt(k.toString(), 10)][this.fields.id].toString() : null;
          if (node.indexOf(id) !== -1) {
            this.validArr.push(this.treeData[parseInt(k.toString(), 10)]);
          }
          var childItems = getValue(this.fields.child.toString(), this.treeData[parseInt(k.toString(), 10)]);
          if (childItems) {
            this.filterNestedChild(childItems, node);
          }
        }
      }
      return this.validArr;
    };
    TreeView2.prototype.filterNestedChild = function(treeData, nodes) {
      for (var k = 0; k < treeData.length; k++) {
        var id = treeData[parseInt(k.toString(), 10)][this.fields.id] ? treeData[parseInt(k.toString(), 10)][this.fields.id].toString() : null;
        if (nodes.indexOf(id) !== -1) {
          this.validArr.push(treeData[parseInt(k.toString(), 10)]);
        }
        var childItems = getValue(this.fields.child.toString(), treeData[parseInt(k.toString(), 10)]);
        if (childItems) {
          this.filterNestedChild(childItems, nodes);
        }
      }
    };
    TreeView2.prototype.setTouchClass = function() {
      var ele = closest(this.element, "." + BIGGER);
      this.touchClass = isNullOrUndefined(ele) ? "" : SMALL;
    };
    TreeView2.prototype.updatePersistProp = function() {
      this.removeField(this.treeData, this.fields, ["selected", "expanded"]);
      var sleNodes = this.selectedNodes;
      for (var l = 0, slelen = sleNodes.length; l < slelen; l++) {
        this.updateField(this.treeData, this.fields, sleNodes[parseInt(l.toString(), 10)], "selected", true);
      }
      var enodes = this.expandedNodes;
      for (var k = 0, nodelen = enodes.length; k < nodelen; k++) {
        this.updateField(this.treeData, this.fields, enodes[parseInt(k.toString(), 10)], "expanded", true);
      }
      if (this.showCheckBox) {
        this.removeField(this.treeData, this.fields, ["isChecked"]);
        var cnodes = this.checkedNodes;
        for (var m = 0, nodelen = cnodes.length; m < nodelen; m++) {
          this.updateField(this.treeData, this.fields, cnodes[parseInt(m.toString(), 10)], "isChecked", true);
        }
      }
    };
    TreeView2.prototype.removeField = function(obj, mapper, names) {
      if (isNullOrUndefined(obj) || isNullOrUndefined(mapper)) {
        return;
      }
      for (var i = 0, objlen = obj.length; i < objlen; i++) {
        for (var j = 0; j < names.length; j++) {
          var field = this.getMapperProp(mapper, names[parseInt(j.toString(), 10)]);
          if (!isNullOrUndefined(obj[parseInt(i.toString(), 10)]["" + field])) {
            delete obj[parseInt(i.toString(), 10)]["" + field];
          }
        }
        if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, obj[parseInt(i.toString(), 10)]))) {
          this.removeField(getValue(mapper.child, obj[parseInt(i.toString(), 10)]), this.getChildMapper(mapper), names);
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", obj[parseInt(i.toString(), 10)]))) {
          this.removeField(getValue("child", obj[parseInt(i.toString(), 10)]), this.getChildMapper(mapper), names);
        }
      }
    };
    TreeView2.prototype.getMapperProp = function(mapper, fieldName) {
      switch (fieldName) {
        case "selected":
          return !isNullOrUndefined(mapper.selected) ? mapper.selected : "selected";
        case "expanded":
          return !isNullOrUndefined(mapper.expanded) ? mapper.expanded : "expanded";
        case "isChecked":
          return !isNullOrUndefined(mapper.isChecked) ? mapper.isChecked : "isChecked";
        case "hasChildren":
          return !isNullOrUndefined(mapper.hasChildren) ? mapper.hasChildren : "hasChildren";
        default:
          return fieldName;
      }
    };
    TreeView2.prototype.updateField = function(obj, mapper, id, key, value) {
      if (isNullOrUndefined(id)) {
        return;
      } else if (this.dataType === 1) {
        var newId = this.isNumberTypeId ? parseFloat(id) : id;
        var resultData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.id, "equal", newId, false));
        setValue(this.getMapperProp(mapper, key), value, resultData[0]);
      } else {
        this.updateChildField(obj, mapper, id, key, value);
      }
    };
    TreeView2.prototype.updateChildField = function(obj, mapper, id, key, value, remove2) {
      var removedData;
      if (isNullOrUndefined(obj)) {
        return removedData;
      }
      for (var i = 0, objlen = obj.length; i < objlen; i++) {
        var nodeId = getValue(mapper.id, obj[parseInt(i.toString(), 10)]);
        if (obj[parseInt(i.toString(), 10)] && nodeId && nodeId.toString() === id) {
          if (remove2) {
            removedData = obj.splice(i, 1);
          } else {
            setValue(this.getMapperProp(mapper, key), value, obj[parseInt(i.toString(), 10)]);
            removedData = [];
          }
          return removedData;
        } else if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, obj[parseInt(i.toString(), 10)]))) {
          var childData = getValue(mapper.child, obj[parseInt(i.toString(), 10)]);
          removedData = this.updateChildField(childData, this.getChildMapper(mapper), id, key, value, remove2);
          if (removedData !== void 0) {
            break;
          }
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", obj[parseInt(i.toString(), 10)]))) {
          var childItems = getValue("child", obj[parseInt(i.toString(), 10)]);
          removedData = this.updateChildField(childItems, this.getChildMapper(mapper), id, key, value, remove2);
          if (removedData !== void 0) {
            break;
          }
        }
      }
      return removedData;
    };
    TreeView2.prototype.triggerEvent = function(action, node) {
      this.renderReactTemplates();
      if (action === "addNodes") {
        var nodeData = [];
        for (var i = 0; i < node.length; i++) {
          nodeData.push(this.getNode(this.getElement(isNullOrUndefined(node[parseInt(i.toString(), 10)][this.fields.id]) ? getValue(this.fields.id, node[parseInt(i.toString(), 10)]).toString() : null)));
        }
        node = nodeData;
      }
      var eventArgs = { data: this.treeData, action, nodeData: node };
      this.trigger("dataSourceChanged", eventArgs);
    };
    TreeView2.prototype.wireInputEvents = function(inpEle) {
      EventHandler.add(inpEle, "blur", this.inputFocusOut, this);
    };
    TreeView2.prototype.wireEditingEvents = function(toBind) {
      var _this = this;
      if (toBind && !this.disabled) {
        this.touchEditObj = new Touch(this.element, {
          tap: function(e) {
            if (_this.isDoubleTapped(e) && e.tapCount === 2) {
              e.originalEvent.preventDefault();
              _this.editingHandler(e.originalEvent);
            }
          }
        });
      } else {
        if (this.touchEditObj) {
          this.touchEditObj.destroy();
        }
      }
    };
    TreeView2.prototype.wireClickEvent = function(toBind) {
      var _this = this;
      if (toBind) {
        this.touchClickObj = new Touch(this.element, {
          tap: function(e) {
            _this.clickHandler(e);
          }
        });
      } else {
        if (this.touchClickObj) {
          this.touchClickObj.destroy();
        }
      }
    };
    TreeView2.prototype.wireExpandOnEvent = function(toBind) {
      var _this = this;
      if (toBind) {
        this.touchExpandObj = new Touch(this.element, {
          tap: function(e) {
            if ((_this.expandOnType === "Click" || _this.expandOnType === "DblClick" && _this.isDoubleTapped(e) && e.tapCount === 2) && e.originalEvent.which !== 3) {
              _this.expandHandler(e);
            }
          }
        });
      } else {
        if (this.touchExpandObj) {
          this.touchExpandObj.destroy();
        }
      }
    };
    TreeView2.prototype.mouseDownHandler = function(e) {
      this.mouseDownStatus = true;
      if (e.shiftKey || e.ctrlKey) {
        e.preventDefault();
      }
      if (e.ctrlKey && this.allowMultiSelection) {
        EventHandler.add(this.element, "contextmenu", this.preventContextMenu, this);
      }
    };
    TreeView2.prototype.preventContextMenu = function(e) {
      e.preventDefault();
    };
    TreeView2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "mousedown", this.mouseDownHandler, this);
      this.wireClickEvent(true);
      if (this.expandOnType !== "None") {
        this.wireExpandOnEvent(true);
      }
      EventHandler.add(this.element, "mouseover", this.onMouseOver, this);
      EventHandler.add(this.element, "mouseout", this.onMouseLeave, this);
      this.keyboardModule = new KeyboardEvents(this.element, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
    };
    TreeView2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "mousedown", this.mouseDownHandler);
      this.wireClickEvent(false);
      this.wireExpandOnEvent(false);
      EventHandler.remove(this.element, "mouseover", this.onMouseOver);
      EventHandler.remove(this.element, "mouseout", this.onMouseLeave);
      if (!this.disabled) {
        this.keyboardModule.destroy();
      }
    };
    TreeView2.prototype.parents = function(element2, selector) {
      var matched = [];
      var el = element2.parentNode;
      while (!isNullOrUndefined(el)) {
        if (matches(el, selector)) {
          matched.push(el);
        }
        el = el.parentNode;
      }
      return matched;
    };
    TreeView2.prototype.isDoubleTapped = function(e) {
      var target = e.originalEvent.target;
      var secondTap;
      if (target && e.tapCount) {
        if (e.tapCount === 1) {
          this.firstTap = closest(target, "." + LISTITEM);
        } else if (e.tapCount === 2) {
          secondTap = closest(target, "." + LISTITEM);
        }
      }
      return this.firstTap === secondTap;
    };
    TreeView2.prototype.isDescendant = function(parent, child) {
      var node = child.parentNode;
      while (!isNullOrUndefined(node)) {
        if (node === parent) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    };
    TreeView2.prototype.showSpinner = function(element2) {
      addClass([element2], LOAD);
      createSpinner({
        target: element2,
        width: Browser.isDevice ? 16 : 14
      }, this.createElement);
      showSpinner(element2);
    };
    TreeView2.prototype.hideSpinner = function(element2) {
      hideSpinner(element2);
      element2.innerHTML = "";
      removeClass([element2], LOAD);
    };
    TreeView2.prototype.setCheckedNodes = function(nodes) {
      nodes = JSON.parse(JSON.stringify(nodes));
      this.uncheckAll(this.checkedNodes);
      this.setIndeterminate(nodes);
      if (nodes.length > 0) {
        this.checkAll(nodes);
      }
    };
    TreeView2.prototype.setValidCheckedNode = function(node) {
      if (this.dataType === 1) {
        var mapper = this.fields;
        var resultData = new DataManager(this.treeData).executeLocal(new Query().where(mapper.id, "equal", node, true));
        if (resultData[0]) {
          this.setChildCheckState(resultData, node, resultData[0]);
          if (this.autoCheck) {
            var parent_4 = resultData[0][this.fields.parentID] ? resultData[0][this.fields.parentID].toString() : null;
            var childNodes = this.getChildNodes(this.treeData, parent_4);
            var count = 0;
            for (var len = 0; len < childNodes.length; len++) {
              var childId = childNodes[parseInt(len.toString(), 10)][this.fields.id].toString();
              if (this.checkedNodes.indexOf(childId) !== -1) {
                count++;
              }
            }
            if (count === childNodes.length && this.checkedNodes.indexOf(parent_4) === -1 && parent_4) {
              this.checkedNodes.push(parent_4);
            }
          }
        }
      } else if (this.dataType === 2) {
        for (var a = 0; a < this.treeData.length; a++) {
          var index = this.treeData[parseInt(a.toString(), 10)][this.fields.id] ? this.treeData[parseInt(a.toString(), 10)][this.fields.id].toString() : "";
          if (index === node && this.checkedNodes.indexOf(node) === -1) {
            this.checkedNodes.push(node);
            break;
          }
          var childItems = getValue(this.fields.child.toString(), this.treeData[parseInt(a.toString(), 10)]);
          if (childItems) {
            this.setChildCheckState(childItems, node, this.treeData[parseInt(a.toString(), 10)]);
          }
        }
      }
    };
    TreeView2.prototype.setChildCheckState = function(childItems, node, treeData) {
      var checkedParent;
      var count = 0;
      if (this.dataType === 1) {
        if (treeData) {
          checkedParent = treeData[this.fields.id] ? treeData[this.fields.id].toString() : null;
        }
        for (var index = 0; index < childItems.length; index++) {
          var checkNode = childItems[parseInt(index.toString(), 10)][this.fields.id] ? childItems[parseInt(index.toString(), 10)][this.fields.id].toString() : null;
          if (treeData && checkedParent && this.autoCheck) {
            if (this.checkedNodes.indexOf(checkedParent) !== -1 && this.checkedNodes.indexOf(checkNode) === -1) {
              this.checkedNodes.push(checkNode);
            }
          }
          if (checkNode === node && this.checkedNodes.indexOf(node) === -1) {
            this.checkedNodes.push(node);
          }
          var subChildItems = this.getChildNodes(this.treeData, checkNode);
          if (subChildItems) {
            this.setChildCheckState(subChildItems, node, treeData);
          }
        }
      } else {
        if (treeData) {
          checkedParent = treeData[this.fields.id] ? treeData[this.fields.id].toString() : "";
        }
        for (var index = 0; index < childItems.length; index++) {
          var checkedChild = childItems[parseInt(index.toString(), 10)][this.fields.id] ? childItems[parseInt(index.toString(), 10)][this.fields.id].toString() : "";
          if (treeData && checkedParent && this.autoCheck) {
            if (this.checkedNodes.indexOf(checkedParent) !== -1 && this.checkedNodes.indexOf(checkedChild) === -1) {
              this.checkedNodes.push(checkedChild);
            }
          }
          if (checkedChild === node && this.checkedNodes.indexOf(node) === -1) {
            this.checkedNodes.push(node);
          }
          var subChildItems = getValue(this.fields.child.toString(), childItems[parseInt(index.toString(), 10)]);
          if (subChildItems) {
            this.setChildCheckState(subChildItems, node, childItems[parseInt(index.toString(), 10)]);
          }
          if (this.checkedNodes.indexOf(checkedChild) !== -1 && this.autoCheck) {
            count++;
          }
          if (count === childItems.length && this.checkedNodes.indexOf(checkedParent) === -1 && this.autoCheck) {
            this.checkedNodes.push(checkedParent);
          }
        }
      }
    };
    TreeView2.prototype.setIndeterminate = function(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        this.setValidCheckedNode(nodes[parseInt(i.toString(), 10)]);
      }
    };
    TreeView2.prototype.updatePosition = function(id, newData, isRefreshChild, childValue) {
      if (this.dataType === 1) {
        var pos = this.getDataPos(this.treeData, this.fields, id);
        this.treeData.splice(pos, 1, newData);
        if (isRefreshChild) {
          this.removeChildNodes(id);
          for (var j = 0; j < childValue.length; j++) {
            this.treeData.splice(pos, 0, childValue[parseInt(j.toString(), 10)]);
            pos++;
          }
        }
        this.groupedData = this.getGroupedData(this.treeData, this.fields.parentID);
      } else {
        this.updateChildPosition(this.treeData, this.fields, id, [newData], void 0);
      }
    };
    TreeView2.prototype.updateChildPosition = function(treeData, mapper, currID, newData, index) {
      var found;
      for (var i = 0, objlen = treeData.length; i < objlen; i++) {
        var nodeId = getValue(mapper.id, treeData[parseInt(i.toString(), 10)]);
        if (treeData[parseInt(i.toString(), 10)] && nodeId && nodeId.toString() === currID) {
          treeData[parseInt(i.toString(), 10)] = newData[0];
          return true;
        } else if (typeof mapper.child === "string" && !isNullOrUndefined(getValue(mapper.child, treeData[parseInt(i.toString(), 10)]))) {
          var childObj = getValue(mapper.child, treeData[parseInt(i.toString(), 10)]);
          found = this.updateChildPosition(childObj, this.getChildMapper(mapper), currID, newData, index);
          if (found !== void 0) {
            break;
          }
        } else if (this.fields.dataSource instanceof DataManager && !isNullOrUndefined(getValue("child", treeData[parseInt(i.toString(), 10)]))) {
          var childData = getValue("child", treeData[parseInt(i.toString(), 10)]);
          found = this.updateChildPosition(childData, this.getChildMapper(mapper), currID, newData, index);
          if (found !== void 0) {
            break;
          }
        }
      }
      return found;
    };
    TreeView2.prototype.dynamicState = function() {
      this.setDragAndDrop(this.allowDragAndDrop);
      this.wireEditingEvents(this.allowEditing);
      if (!this.disabled) {
        this.wireEvents();
        this.setRipple();
      } else {
        this.unWireEvents();
        this.rippleFn();
        this.rippleIconFn();
      }
    };
    TreeView2.prototype.crudOperation = function(operation, nodes, target, newText, newNode, index, prevent) {
      var _this = this;
      var data = this.fields.dataSource;
      var matchedArr = [];
      var query = this.getQuery(this.fields);
      var key = this.fields.id;
      var crud;
      var changes = {
        addedRecords: [],
        deletedRecords: [],
        changedRecords: []
      };
      var nodesID = [];
      if (nodes) {
        nodesID = this.nodeType(nodes);
      } else if (target) {
        if (typeof target == "string") {
          nodesID[0] = target.toString();
        } else if (typeof target === "object") {
          nodesID[0] = target.getAttribute("data-uid").toString();
        }
      }
      for (var i = 0, len = nodesID.length; i < len; i++) {
        var liEle = this.getElement(nodesID[parseInt(i.toString(), 10)]);
        if (isNullOrUndefined(liEle)) {
          continue;
        }
        var removedData = this.getNodeObject(nodesID[parseInt(i.toString(), 10)]);
        matchedArr.push(removedData);
      }
      switch (operation) {
        case "delete":
          if (nodes.length === 1) {
            crud = data.remove(key, matchedArr[0], query.fromTable, query);
          } else {
            changes.deletedRecords = matchedArr;
            crud = data.saveChanges(changes, key, query.fromTable, query);
          }
          crud.then(function() {
            return _this.deleteSuccess(nodesID);
          }).catch(function(e) {
            return _this.dmFailure(e);
          });
          break;
        case "update":
          matchedArr[0][this.fields.text] = newText;
          crud = data.update(key, matchedArr[0], query.fromTable, query);
          crud.then(function() {
            return _this.editSucess(target, newText, prevent);
          }).catch(function(e) {
            return _this.dmFailure(e, target, prevent);
          });
          break;
        case "insert":
          if (newNode.length === 1) {
            crud = data.insert(newNode[0], query.fromTable, query);
          } else {
            var arr = [];
            for (var i = 0, len = newNode.length; i < len; i++) {
              arr.push(newNode[parseInt(i.toString(), 10)]);
            }
            changes.addedRecords = arr;
            crud = data.saveChanges(changes, key, query.fromTable, query);
          }
          crud.then(function() {
            var dropLi = _this.getElement(target);
            _this.addSuccess(newNode, dropLi, index);
            _this.preventExpand = false;
          }).catch(function(e) {
            return _this.dmFailure(e);
          });
          break;
      }
    };
    TreeView2.prototype.deleteSuccess = function(nodes) {
      var nodeData = [];
      for (var i = 0, len = nodes.length; i < len; i++) {
        var liEle = this.getElement(nodes[parseInt(i.toString(), 10)]);
        nodeData.push(this.getNode(liEle));
        if (isNullOrUndefined(liEle)) {
          continue;
        }
        this.removeNode(liEle);
      }
      this.updateInstance();
      if (this.dataType === 1) {
        this.groupedData = this.getGroupedData(this.treeData, this.fields.parentID);
      }
      this.triggerEvent("removeNode", nodeData);
    };
    TreeView2.prototype.editSucess = function(target, newText, prevent) {
      var liEle = this.getElement(target);
      var txtEle = select("." + LISTTEXT, liEle);
      this.appendNewText(liEle, txtEle, newText, prevent);
    };
    TreeView2.prototype.addSuccess = function(nodes, dropLi, index) {
      var _this = this;
      var dropUl;
      var icon = dropLi ? dropLi.querySelector("." + ICON3) : null;
      if (dropLi && icon && icon.classList.contains(EXPANDABLE) && dropLi.querySelector("." + PARENTITEM) === null) {
        this.renderChildNodes(dropLi, null, function() {
          dropUl = dropLi.querySelector("." + PARENTITEM);
          _this.addGivenNodes(nodes, dropLi, index, true, dropUl);
          _this.triggerEvent("addNodes", nodes);
        });
      } else {
        this.addGivenNodes(nodes, dropLi, index, true);
        this.triggerEvent("addNodes", nodes);
      }
    };
    TreeView2.prototype.dmFailure = function(e, target, prevent) {
      if (target) {
        this.updatePreviousText(target, prevent);
      }
      this.trigger("actionFailure", { error: e });
    };
    TreeView2.prototype.updatePreviousText = function(target, prevent) {
      var liEle = this.getElement(target);
      var txtEle = select("." + LISTTEXT, liEle);
      this.updateText(liEle, txtEle, this.oldText, prevent);
    };
    TreeView2.prototype.getHierarchicalParentId = function(node, data, parentsID) {
      var _this = this;
      var index = data.findIndex(function(data2) {
        return data2[_this.fields.id] && data2[_this.fields.id].toString() === node;
      });
      if (index === -1) {
        for (var i = 0; i < data.length; i++) {
          var childItems = getValue(this.fields.child.toString(), data[parseInt(i.toString(), 10)]);
          if (!isNullOrUndefined(childItems)) {
            index = childItems.findIndex(function(data2) {
              return data2[_this.fields.id] && data2[_this.fields.id].toString() === node;
            });
            if (index === -1) {
              this.getHierarchicalParentId(node, childItems, parentsID);
            } else {
              parentsID.push(data[parseInt(i.toString(), 10)][this.fields.id].toString());
              this.getHierarchicalParentId(data[parseInt(i.toString(), 10)][this.fields.id].toString(), this.treeData, parentsID);
              break;
            }
          }
        }
      }
      return parentsID;
    };
    TreeView2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "allowDragAndDrop":
            this.setDragAndDrop(this.allowDragAndDrop);
            break;
          case "dragArea":
            if (this.allowDragAndDrop) {
              this.dragObj.dragArea = this.dragArea;
            }
            break;
          case "allowEditing":
            this.wireEditingEvents(this.allowEditing);
            break;
          case "allowMultiSelection":
            if (this.selectedNodes.length > 1) {
              var sNode = this.getElement(this.selectedNodes[0]);
              this.isLoaded = false;
              this.removeSelectAll();
              this.selectNode(sNode, null);
              this.isLoaded = true;
            }
            this.setMultiSelect(this.allowMultiSelection);
            this.addMultiSelect(this.allowMultiSelection);
            break;
          case "allowTextWrap":
            this.setTextWrap();
            this.updateWrap();
            break;
          case "checkedNodes":
            if (this.showCheckBox) {
              this.checkedNodes = oldProp.checkedNodes;
              this.setCheckedNodes(newProp.checkedNodes);
            }
            break;
          case "autoCheck":
            if (this.showCheckBox) {
              this.autoCheck = newProp.autoCheck;
              this.ensureIndeterminate();
            }
            break;
          case "cssClass":
            this.setCssClass(oldProp.cssClass, newProp.cssClass);
            break;
          case "enableRtl":
            this.setEnableRtl();
            break;
          case "expandedNodes":
            this.isAnimate = false;
            this.setProperties({ expandedNodes: [] }, true);
            this.collapseAll();
            this.isInitalExpand = true;
            this.setProperties({ expandedNodes: isNullOrUndefined(newProp.expandedNodes) ? [] : newProp.expandedNodes }, true);
            this.doExpandAction();
            this.isInitalExpand = false;
            this.isAnimate = true;
            break;
          case "expandOn":
            this.wireExpandOnEvent(false);
            this.setExpandOnType();
            if (this.expandOnType !== "None" && !this.disabled) {
              this.wireExpandOnEvent(true);
            }
            break;
          case "disabled":
            this.setDisabledMode();
            this.dynamicState();
            break;
          case "fields":
            this.isAnimate = false;
            this.isFieldChange = true;
            this.initialRender = true;
            if (!this.isReact || this.isReact && !(this.fields.dataSource instanceof DataManager)) {
              if (!this.element.classList.contains("e-filtering")) {
                this.DDTTreeData = JSON.parse(JSON.stringify(this.fields.dataSource));
              }
              this.reRenderNodes();
            }
            this.initialRender = false;
            this.isAnimate = true;
            this.isFieldChange = false;
            break;
          case "fullRowSelect":
            this.setFullRow(this.fullRowSelect);
            this.addFullRow(this.fullRowSelect);
            if (this.allowTextWrap) {
              this.setTextWrap();
              this.updateWrap();
            }
            break;
          case "loadOnDemand":
            if (this.loadOnDemand === false && !this.onLoaded) {
              var nodes = this.element.querySelectorAll("li");
              var i = 0;
              while (i < nodes.length) {
                if (nodes[parseInt(i.toString(), 10)].getAttribute("aria-expanded") !== "true") {
                  this.renderChildNodes(nodes[parseInt(i.toString(), 10)], true, null, true);
                }
                i++;
              }
              this.onLoaded = true;
            }
            break;
          case "nodeTemplate":
            this.hasTemplate = false;
            this.nodeTemplateFn = this.templateComplier(this.nodeTemplate);
            this.reRenderNodes();
            break;
          case "selectedNodes":
            this.removeSelectAll();
            this.setProperties({ selectedNodes: newProp.selectedNodes }, true);
            this.doSelectionAction();
            break;
          case "showCheckBox":
            this.reRenderNodes();
            break;
          case "sortOrder":
            this.reRenderNodes();
            break;
          case "fullRowNavigable":
            this.setProperties({ fullRowNavigable: newProp.fullRowNavigable }, true);
            this.listBaseOption.itemNavigable = newProp.fullRowNavigable;
            this.reRenderNodes();
            break;
        }
      }
    };
    TreeView2.prototype.destroy = function() {
      this.clearTemplate();
      this.element.removeAttribute("aria-activedescendant");
      this.unWireEvents();
      this.wireEditingEvents(false);
      if (!this.disabled) {
        this.rippleFn();
        this.rippleIconFn();
      }
      this.setCssClass(this.cssClass, null);
      this.setDragAndDrop(false);
      this.setFullRow(false);
      if (this.ulElement && this.ulElement.parentElement) {
        this.ulElement.parentElement.removeChild(this.ulElement);
      }
      this.ulElement = null;
      this.liList = null;
      this.startNode = null;
      this.firstTap = null;
      this.expandArgs = null;
      this.dragLi = null;
      this.dragTarget = null;
      this.dragParent = null;
      this.dragObj = null;
      this.dropObj = null;
      this.inputObj = null;
      this.touchEditObj = null;
      this.touchExpandObj = null;
      this.touchClickObj = null;
      _super.prototype.destroy.call(this);
    };
    TreeView2.prototype.addNodes = function(nodes, target, index, preventTargetExpand) {
      if (isNullOrUndefined(nodes)) {
        return;
      }
      nodes = JSON.parse(JSON.stringify(nodes));
      var dropLi = this.getElement(target);
      this.preventExpand = preventTargetExpand;
      if (this.fields.dataSource instanceof DataManager) {
        if (!this.isOffline) {
          this.crudOperation("insert", null, target, null, nodes, index, this.preventExpand);
        } else {
          this.addSuccess(nodes, dropLi, index);
        }
      } else if (this.dataType === 2) {
        this.addGivenNodes(nodes, dropLi, index);
      } else {
        if (dropLi) {
          this.addGivenNodes(nodes, dropLi, index);
        } else {
          nodes = this.getSortedData(nodes);
          for (var i = 0; i < nodes.length; i++) {
            var pid = getValue(this.fields.parentID, nodes[parseInt(i.toString(), 10)]);
            dropLi = pid ? this.getElement(pid.toString()) : pid;
            this.addGivenNodes([nodes[parseInt(i.toString(), 10)]], dropLi, index);
          }
        }
        this.groupedData = this.getGroupedData(this.treeData, this.fields.parentID);
      }
      this.updateCheckedStateFromDS();
      if (this.showCheckBox && dropLi) {
        this.ensureParentCheckState(dropLi);
      }
      if (this.fields.dataSource instanceof DataManager === false) {
        this.preventExpand = false;
        this.triggerEvent("addNodes", nodes);
      }
    };
    TreeView2.prototype.beginEdit = function(node) {
      var ele = this.getElement(node);
      if (isNullOrUndefined(ele) || this.disabled) {
        return;
      }
      this.createTextbox(ele);
    };
    TreeView2.prototype.checkAll = function(nodes) {
      if (this.showCheckBox) {
        this.doCheckBoxAction(nodes, true);
      }
    };
    TreeView2.prototype.collapseAll = function(nodes, level, excludeHiddenNodes) {
      if (!isNullOrUndefined(nodes)) {
        this.doGivenAction(nodes, COLLAPSIBLE, false);
      } else {
        if (level > 0) {
          this.collapseByLevel(select("." + PARENTITEM, this.element), level, excludeHiddenNodes);
        } else {
          this.collapseAllNodes(excludeHiddenNodes);
        }
      }
    };
    TreeView2.prototype.disableNodes = function(nodes) {
      if (!isNullOrUndefined(nodes)) {
        this.doDisableAction(nodes);
      }
    };
    TreeView2.prototype.enableNodes = function(nodes) {
      if (!isNullOrUndefined(nodes)) {
        this.doEnableAction(nodes);
      }
    };
    TreeView2.prototype.ensureVisible = function(node) {
      var parentsId = [];
      if (this.dataType === 1) {
        var nodeData = this.getTreeData(node);
        while (nodeData.length !== 0 && !isNullOrUndefined(nodeData[0][this.fields.parentID])) {
          parentsId.push(nodeData[0][this.fields.parentID].toString());
          nodeData = this.getTreeData(nodeData[0][this.fields.parentID].toString());
        }
      } else if (this.dataType === 2) {
        parentsId = this.getHierarchicalParentId(node, this.treeData, parentsId);
      }
      this.expandAll(parentsId.reverse());
      var liEle = this.getElement(node);
      if (!isNullOrUndefined(liEle)) {
        if (typeof node == "object") {
          var parents = this.parents(liEle, "." + LISTITEM);
          this.expandAll(parents);
        }
        setTimeout(function() {
          liEle.scrollIntoView({ behavior: "smooth" });
        }, 450);
      }
    };
    TreeView2.prototype.expandAll = function(nodes, level, excludeHiddenNodes) {
      if (!isNullOrUndefined(nodes)) {
        this.doGivenAction(nodes, EXPANDABLE, true);
      } else {
        if (level > 0) {
          this.expandByLevel(select("." + PARENTITEM, this.element), level, excludeHiddenNodes);
        } else {
          this.expandAllNodes(excludeHiddenNodes);
        }
      }
    };
    TreeView2.prototype.getAllCheckedNodes = function() {
      var checkNodes = this.checkedNodes;
      return checkNodes;
    };
    TreeView2.prototype.getDisabledNodes = function() {
      var disabledNodes = this.disableNode;
      return disabledNodes;
    };
    TreeView2.prototype.getNode = function(node) {
      var ele = this.getElement(node);
      return this.getNodeData(ele, true);
    };
    TreeView2.prototype.getTreeData = function(node) {
      var id = this.getId(node);
      this.updatePersistProp();
      if (isNullOrUndefined(id)) {
        return this.treeData;
      } else {
        var data = this.getNodeObject(id);
        return isNullOrUndefined(data) ? [] : [data];
      }
    };
    TreeView2.prototype.moveNodes = function(sourceNodes, target, index, preventTargetExpand) {
      var dropLi = this.getElement(target);
      var nodeData = [];
      if (isNullOrUndefined(dropLi)) {
        return;
      }
      for (var i = 0; i < sourceNodes.length; i++) {
        var dragLi = this.getElement(sourceNodes[parseInt(i.toString(), 10)]);
        nodeData.push(this.getNode(dragLi));
        if (isNullOrUndefined(dragLi) || dropLi.isSameNode(dragLi) || this.isDescendant(dragLi, dropLi)) {
          continue;
        }
        this.preventExpand = preventTargetExpand;
        this.dropAsChildNode(dragLi, dropLi, this, index, null, null, null, dropLi);
      }
      if (this.fields.dataSource instanceof DataManager === false) {
        this.preventExpand = false;
      }
      this.triggerEvent("moveNodes", nodeData);
    };
    TreeView2.prototype.refreshNode = function(target, newData) {
      if (isNullOrUndefined(target) || isNullOrUndefined(newData)) {
        return;
      }
      var isRefreshChild = false;
      if (this.dataType === 1 && newData.length > 1) {
        isRefreshChild = true;
      } else if (this.dataType === 2 && newData.length === 1) {
        var updatedChildValue = getValue(this.fields.child.toString(), newData[0]);
        if (!isNullOrUndefined(updatedChildValue)) {
          isRefreshChild = true;
        }
      }
      var liEle = this.getElement(target);
      var id = liEle ? liEle.getAttribute("data-uid") : target ? target.toString() : null;
      this.refreshData = this.getNodeObject(id);
      newData = JSON.parse(JSON.stringify(newData));
      var newNodeData;
      var parentData;
      if (this.dataType === 1 && isRefreshChild) {
        for (var k = 0; k < newData.length; k++) {
          if (isNullOrUndefined(newData[parseInt(k.toString(), 10)][this.fields.parentID])) {
            parentData = newData[parseInt(k.toString(), 10)];
            newData.splice(k, 1);
            break;
          }
        }
        newNodeData = extend({}, this.refreshData, parentData);
      } else {
        newNodeData = extend({}, this.refreshData, newData[0]);
      }
      if (isNullOrUndefined(liEle)) {
        this.updatePosition(id, newNodeData, isRefreshChild, newData);
        return;
      }
      this.isRefreshed = true;
      var level = parseFloat(liEle.getAttribute("aria-level"));
      var newliEle = ListBase.createListItemFromJson(this.createElement, [newNodeData], this.listBaseOption, level);
      var ul = select("." + PARENTITEM, liEle);
      var childItems = getValue(this.fields.child.toString(), newNodeData);
      if (isRefreshChild && ul || isRefreshChild && !isNullOrUndefined(childItems)) {
        var parentEle = liEle.parentElement;
        var index = Array.prototype.indexOf.call(parentEle.childNodes, liEle);
        remove(liEle);
        parentEle.insertBefore(newliEle[0], parentEle.childNodes[parseInt(index.toString(), 10)]);
        this.updatePosition(id, newNodeData, isRefreshChild, newData);
        if (isRefreshChild && ul) {
          this.expandAll([id]);
        }
      } else {
        var txtEle = select("." + TEXTWRAP, liEle);
        var newTextEle = select("." + TEXTWRAP, newliEle[0]);
        var icon = select("div." + ICON3, txtEle);
        var newIcon = select("div." + ICON3, newTextEle);
        if (icon && newIcon) {
          if (newIcon.classList.contains(EXPANDABLE) && icon.classList.contains(COLLAPSIBLE)) {
            removeClass([newIcon], EXPANDABLE);
            addClass([newIcon], COLLAPSIBLE);
          } else if (newIcon.classList.contains(COLLAPSIBLE) && icon.classList.contains(EXPANDABLE)) {
            removeClass([newIcon], COLLAPSIBLE);
            addClass([newIcon], EXPANDABLE);
          } else if (icon.classList.contains("interaction")) {
            addClass([newIcon], "interaction");
          }
        }
        remove(txtEle);
        var fullEle = select("." + FULLROW, liEle);
        fullEle.parentNode.insertBefore(newTextEle, fullEle.nextSibling);
        this.updatePosition(id, newNodeData, isRefreshChild, newData);
      }
      liEle = this.getElement(target);
      if (newNodeData[this.fields.tooltip]) {
        liEle.setAttribute("title", newNodeData[this.fields.tooltip]);
      }
      if (Object.prototype.hasOwnProperty.call(newNodeData, this.fields.htmlAttributes) && newNodeData[this.fields.htmlAttributes]) {
        var attr = {};
        merge(attr, newNodeData[this.fields.htmlAttributes]);
        if (attr.class) {
          addClass([liEle], attr.class.split(" "));
          delete attr.class;
        } else {
          attributes(liEle, attr);
        }
      }
      if (this.selectedNodes.indexOf(id) !== -1) {
        liEle.setAttribute("aria-selected", "true");
        addClass([liEle], ACTIVE2);
      }
      this.isRefreshed = false;
      this.triggerEvent("refreshNode", [this.getNode(liEle)]);
    };
    TreeView2.prototype.removeNodes = function(nodes) {
      if (!isNullOrUndefined(nodes)) {
        if (this.fields.dataSource instanceof DataManager && !this.isOffline) {
          this.crudOperation("delete", nodes);
        } else {
          this.deleteSuccess(nodes);
        }
      }
    };
    TreeView2.prototype.updateNode = function(target, newText) {
      var _this = this;
      if (isNullOrUndefined(target) || isNullOrUndefined(newText) || !this.allowEditing) {
        return;
      }
      var liEle = this.getElement(target);
      if (isNullOrUndefined(liEle)) {
        return;
      }
      var txtEle = select("." + LISTTEXT, liEle);
      this.updateOldText(liEle);
      var eventArgs = this.getEditEvent(liEle, null, null);
      this.trigger("nodeEditing", eventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          if (_this.fields.dataSource instanceof DataManager && !_this.isOffline) {
            _this.crudOperation("update", null, target, newText, null, null, false);
          } else {
            _this.appendNewText(liEle, txtEle, newText, false);
          }
        }
      });
    };
    TreeView2.prototype.uncheckAll = function(nodes) {
      if (this.showCheckBox) {
        this.doCheckBoxAction(nodes, false);
      }
    };
    var TreeView_1;
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "allowDragAndDrop", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "allowEditing", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "allowMultiSelection", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "allowTextWrap", void 0);
    __decorate38([
      Complex({}, NodeAnimationSettings)
    ], TreeView2.prototype, "animation", void 0);
    __decorate38([
      Property()
    ], TreeView2.prototype, "checkedNodes", void 0);
    __decorate38([
      Property("")
    ], TreeView2.prototype, "cssClass", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "disabled", void 0);
    __decorate38([
      Property(null)
    ], TreeView2.prototype, "dragArea", void 0);
    __decorate38([
      Property(true)
    ], TreeView2.prototype, "enableHtmlSanitizer", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "enablePersistence", void 0);
    __decorate38([
      Property()
    ], TreeView2.prototype, "expandedNodes", void 0);
    __decorate38([
      Property("Auto")
    ], TreeView2.prototype, "expandOn", void 0);
    __decorate38([
      Complex({}, FieldsSettings)
    ], TreeView2.prototype, "fields", void 0);
    __decorate38([
      Property(true)
    ], TreeView2.prototype, "fullRowSelect", void 0);
    __decorate38([
      Property(true)
    ], TreeView2.prototype, "loadOnDemand", void 0);
    __decorate38([
      Property()
    ], TreeView2.prototype, "locale", void 0);
    __decorate38([
      Property()
    ], TreeView2.prototype, "nodeTemplate", void 0);
    __decorate38([
      Property()
    ], TreeView2.prototype, "selectedNodes", void 0);
    __decorate38([
      Property("None")
    ], TreeView2.prototype, "sortOrder", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "showCheckBox", void 0);
    __decorate38([
      Property(true)
    ], TreeView2.prototype, "autoCheck", void 0);
    __decorate38([
      Property(false)
    ], TreeView2.prototype, "fullRowNavigable", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "actionFailure", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "created", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "dataBound", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "dataSourceChanged", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "drawNode", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "destroyed", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "keyPress", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeChecked", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeChecking", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeClicked", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeCollapsed", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeCollapsing", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeDragging", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeDragStart", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeDragStop", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeDropped", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeEdited", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeEditing", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeExpanded", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeExpanding", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeSelected", void 0);
    __decorate38([
      Event()
    ], TreeView2.prototype, "nodeSelecting", void 0);
    TreeView2 = TreeView_1 = __decorate38([
      NotifyPropertyChanges
    ], TreeView2);
    return TreeView2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/sidebar/sidebar.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CONTROL4 = "e-control";
var ROOT6 = "e-sidebar";
var DOCKER = "e-dock";
var CLOSE2 = "e-close";
var OPEN = "e-open";
var TRASITION = "e-transition";
var DEFAULTBACKDROP = "e-sidebar-overlay";
var RTL13 = "e-rtl";
var RIGHT = "e-right";
var LEFT = "e-left";
var OVER = "e-over";
var PUSH = "e-push";
var SLIDE = "e-slide";
var VISIBILITY = "e-visibility";
var DISPLAY = "e-sidebar-display";
var MAINCONTENTANIMATION = "e-content-animation";
var DISABLEANIMATION = "e-disable-animation";
var CONTEXT = "e-sidebar-context";
var SIDEBARABSOLUTE = "e-sidebar-absolute";
var Sidebar = (
  /** @class */
  function(_super) {
    __extends40(Sidebar2, _super);
    function Sidebar2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    Sidebar2.prototype.preRender = function() {
      this.setWidth();
    };
    Sidebar2.prototype.render = function() {
      this.initialize();
      this.wireEvents();
      this.renderComplete();
    };
    Sidebar2.prototype.initialize = function() {
      this.setTarget();
      this.addClass();
      this.setZindex();
      if (this.enableDock) {
        this.setDock();
      }
      if (this.isOpen) {
        this.show();
        this.firstRender = true;
      } else {
        this.setMediaQuery();
      }
      this.checkType(true);
      this.setType(this.type);
      this.setCloseOnDocumentClick();
      this.setEnableRTL();
      if (Browser.isDevice) {
        this.windowWidth = window.innerWidth;
      }
    };
    Sidebar2.prototype.setEnableRTL = function() {
      (this.enableRtl ? addClass : removeClass)([this.element], RTL13);
    };
    Sidebar2.prototype.setTarget = function() {
      this.targetEle = this.element.nextElementSibling;
      this.sidebarEleCopy = this.element.cloneNode(true);
      if (typeof this.target === "string") {
        this.setProperties({ target: document.querySelector(this.target) }, true);
      }
      if (this.target) {
        this.target.insertBefore(this.element, this.target.children[0]);
        addClass([this.element], SIDEBARABSOLUTE);
        addClass([this.target], CONTEXT);
        this.targetEle = this.getTargetElement();
      }
    };
    Sidebar2.prototype.getTargetElement = function() {
      var siblingElement = this.element.nextElementSibling;
      while (!isNullOrUndefined(siblingElement)) {
        if (!siblingElement.classList.contains(ROOT6)) {
          break;
        }
        siblingElement = siblingElement.nextElementSibling;
      }
      return siblingElement;
    };
    Sidebar2.prototype.setCloseOnDocumentClick = function() {
      if (this.closeOnDocumentClick) {
        EventHandler.add(document, "mousedown touchstart", this.documentclickHandler, this);
      } else {
        EventHandler.remove(document, "mousedown touchstart", this.documentclickHandler);
      }
    };
    Sidebar2.prototype.setWidth = function() {
      if (this.enableDock && this.position === "Left") {
        setStyleAttribute(this.element, { "width": this.setDimension(this.dockSize) });
      } else if (this.enableDock && this.position === "Right") {
        setStyleAttribute(this.element, { "width": this.setDimension(this.dockSize) });
      } else if (!this.enableDock) {
        setStyleAttribute(this.element, { "width": this.setDimension(this.width) });
      }
    };
    Sidebar2.prototype.setDimension = function(width) {
      if (typeof width === "number") {
        width = formatUnit(width);
      } else if (typeof width === "string") {
        width = width.match(/px|%|em/) ? width : formatUnit(width);
      } else {
        width = "100%";
      }
      return width;
    };
    Sidebar2.prototype.setZindex = function() {
      setStyleAttribute(this.element, { "z-index": "" + this.zIndex });
    };
    Sidebar2.prototype.addClass = function() {
      if (this.element.tagName === "EJS-SIDEBAR") {
        addClass([this.element], DISPLAY);
      }
      var classELement = document.querySelector(".e-main-content");
      if (!isNullOrUndefined(classELement || this.targetEle)) {
        addClass([classELement || this.targetEle], [MAINCONTENTANIMATION]);
      }
      this.tabIndex = this.element.hasAttribute("tabindex") ? this.element.getAttribute("tabindex") : null;
      if (!this.enableDock && this.type !== "Auto") {
        addClass([this.element], [VISIBILITY]);
      }
      removeClass([this.element], [OPEN, CLOSE2, RIGHT, LEFT, SLIDE, PUSH, OVER]);
      this.element.classList.add(ROOT6);
      addClass([this.element], this.position === "Right" ? RIGHT : LEFT);
      if (this.enableDock) {
        addClass([this.element], DOCKER);
      }
      if (!isNullOrUndefined(this.tabIndex)) {
        this.element.setAttribute("tabindex", this.tabIndex);
      }
      if (this.type === "Auto" && !Browser.isDevice) {
        this.show();
      } else if (!this.isOpen) {
        addClass([this.element], [CLOSE2, DISABLEANIMATION]);
      }
    };
    Sidebar2.prototype.checkType = function(val) {
      if (!(this.type === "Push" || this.type === "Over" || this.type === "Slide")) {
        this.type = "Auto";
      } else {
        if (!this.element.classList.contains(CLOSE2) && !val) {
          this.hide();
        }
      }
    };
    Sidebar2.prototype.transitionEnd = function(e) {
      this.setDock();
      if (!isNullOrUndefined(e) && !this.firstRender) {
        this.triggerChange();
      }
      this.firstRender = false;
      EventHandler.remove(this.element, "transitionend", this.transitionEnd);
    };
    Sidebar2.prototype.destroyBackDrop = function() {
      var sibling = document.querySelector(".e-main-content") || this.targetEle;
      if (this.target && this.showBackdrop && sibling && !isNullOrUndefined(this.defaultBackdropDiv)) {
        removeClass([this.defaultBackdropDiv], DEFAULTBACKDROP);
      } else if (this.showBackdrop && this.modal) {
        this.modal.style.display = "none";
        this.modal.outerHTML = "";
        this.modal = null;
      }
    };
    Sidebar2.prototype.hide = function(e) {
      var _this = this;
      var closeArguments = {
        model: this,
        element: this.element,
        cancel: false,
        isInteracted: !isNullOrUndefined(e),
        event: e || null
      };
      this.trigger("close", closeArguments, function(observedcloseArgs) {
        if (!observedcloseArgs.cancel) {
          if (_this.element.classList.contains(CLOSE2)) {
            return;
          }
          if (_this.element.classList.contains(OPEN) && !_this.animate) {
            _this.triggerChange();
          }
          addClass([_this.element], CLOSE2);
          removeClass([_this.element], OPEN);
          setStyleAttribute(_this.element, { "width": formatUnit(_this.enableDock ? _this.dockSize : _this.width) });
          _this.setType(_this.type);
          var sibling = document.querySelector(".e-main-content") || _this.targetEle;
          if (!_this.enableDock && sibling) {
            sibling.style.transform = "translateX(0px)";
            sibling.style[_this.position === "Left" ? "marginLeft" : "marginRight"] = "0px";
          }
          _this.destroyBackDrop();
          _this.setAnimation();
          if (_this.type === "Slide") {
            document.body.classList.remove("e-sidebar-overflow");
          }
          _this.setProperties({ isOpen: false }, true);
          if (_this.enableDock) {
            setTimeout(function() {
              return _this.setTimeOut();
            }, 50);
          }
          EventHandler.add(_this.element, "transitionend", _this.transitionEnd, _this);
        }
      });
    };
    Sidebar2.prototype.setTimeOut = function() {
      var sibling = document.querySelector(".e-main-content") || this.targetEle;
      var elementWidth = this.element.getBoundingClientRect().width;
      if (this.element.classList.contains(OPEN) && sibling && !(this.type === "Over" && this.enableDock)) {
        if (this.position === "Left") {
          sibling.style.marginLeft = this.setDimension(this.width === "auto" ? elementWidth : this.width);
        } else {
          sibling.style.marginRight = this.setDimension(this.width === "auto" ? elementWidth : this.width);
        }
      } else if (this.element.classList.contains(CLOSE2) && sibling) {
        if (this.position === "Left") {
          sibling.style.marginLeft = this.setDimension(this.dockSize === "auto" ? elementWidth : this.dockSize);
        } else {
          sibling.style.marginRight = this.setDimension(this.dockSize === "auto" ? elementWidth : this.dockSize);
        }
      }
    };
    Sidebar2.prototype.show = function(e) {
      var _this = this;
      var openArguments = {
        model: this,
        element: this.element,
        cancel: false,
        isInteracted: !isNullOrUndefined(e),
        event: e || null
      };
      this.trigger("open", openArguments, function(observedopenArgs) {
        if (!observedopenArgs.cancel) {
          removeClass([_this.element], [VISIBILITY, DISABLEANIMATION]);
          if (_this.element.classList.contains(OPEN)) {
            return;
          }
          if (_this.element.classList.contains(CLOSE2) && !_this.animate) {
            _this.triggerChange();
          }
          addClass([_this.element], [OPEN, TRASITION]);
          setStyleAttribute(_this.element, { "transform": "" });
          removeClass([_this.element], CLOSE2);
          setStyleAttribute(_this.element, { "width": formatUnit(_this.width) });
          _this.setType(_this.type);
          _this.createBackDrop();
          _this.setAnimation();
          if (_this.type === "Slide") {
            document.body.classList.add("e-sidebar-overflow");
          }
          _this.setProperties({ isOpen: true }, true);
          EventHandler.add(_this.element, "transitionend", _this.transitionEnd, _this);
        }
      });
    };
    Sidebar2.prototype.setAnimation = function() {
      if (this.animate) {
        removeClass([this.element], DISABLEANIMATION);
      } else {
        addClass([this.element], DISABLEANIMATION);
      }
    };
    Sidebar2.prototype.triggerChange = function() {
      var changeArguments = { name: "change", element: this.element };
      this.trigger("change", changeArguments);
    };
    Sidebar2.prototype.setDock = function() {
      if (this.enableDock && this.position === "Left" && !this.getState()) {
        setStyleAttribute(this.element, { "transform": "translateX(-100%) translateX(" + this.setDimension(this.dockSize) + ")" });
      } else if (this.enableDock && this.position === "Right" && !this.getState()) {
        setStyleAttribute(this.element, { "transform": "translateX(100%) translateX(-" + this.setDimension(this.dockSize) + ")" });
      }
      if (this.element.classList.contains(CLOSE2) && this.enableDock) {
        setStyleAttribute(this.element, { "width": this.setDimension(this.dockSize) });
      }
    };
    Sidebar2.prototype.createBackDrop = function() {
      if (this.target && this.showBackdrop && this.getState()) {
        var targetString = this.target;
        var sibling = document.querySelector(".e-main-content") || this.targetEle;
        this.defaultBackdropDiv = this.createElement("div");
        addClass([this.defaultBackdropDiv], DEFAULTBACKDROP);
        setStyleAttribute(this.defaultBackdropDiv, { height: targetString.style.height });
        sibling.appendChild(this.defaultBackdropDiv);
      } else if (this.showBackdrop && !this.modal && this.getState()) {
        this.modal = this.createElement("div");
        this.modal.className = DEFAULTBACKDROP;
        this.modal.style.display = "block";
        document.body.appendChild(this.modal);
      }
    };
    Sidebar2.prototype.getPersistData = function() {
      return this.addOnPersist(["type", "position", "isOpen"]);
    };
    Sidebar2.prototype.getModuleName = function() {
      return "sidebar";
    };
    Sidebar2.prototype.toggle = function() {
      if (this.element.classList.contains(OPEN)) {
        this.hide();
      } else {
        this.show();
      }
    };
    Sidebar2.prototype.getState = function() {
      return this.element.classList.contains(OPEN) ? true : false;
    };
    Sidebar2.prototype.setMediaQuery = function() {
      if (this.mediaQuery) {
        var media = false;
        if (typeof this.mediaQuery === "string") {
          media = window.matchMedia(this.mediaQuery).matches;
        } else {
          media = this.mediaQuery.matches;
        }
        if (media && this.windowWidth !== window.innerWidth) {
          this.show();
        } else if (this.getState() && this.windowWidth !== window.innerWidth) {
          this.hide();
        }
      }
    };
    Sidebar2.prototype.resize = function() {
      if (this.type === "Auto") {
        if (Browser.isDevice) {
          addClass([this.element], OVER);
        } else {
          addClass([this.element], PUSH);
        }
      }
      this.setMediaQuery();
      if (Browser.isDevice) {
        this.windowWidth = window.innerWidth;
      }
    };
    Sidebar2.prototype.documentclickHandler = function(e) {
      if (closest(e.target, "." + CONTROL4 + "." + ROOT6)) {
        return;
      }
      this.hide(e);
    };
    Sidebar2.prototype.enableGestureHandler = function(args) {
      if (!this.isOpen && this.position === "Left" && args.swipeDirection === "Right" && (args.startX <= 20 && args.distanceX >= 50 && args.velocity >= 0.5)) {
        this.show();
      } else if (this.isOpen && this.position === "Left" && args.swipeDirection === "Left") {
        this.hide();
      } else if (this.isOpen && this.position === "Right" && args.swipeDirection === "Right") {
        this.hide();
      } else if (!this.isOpen && this.position === "Right" && args.swipeDirection === "Left" && (window.innerWidth - args.startX <= 20 && args.distanceX >= 50 && args.velocity >= 0.5)) {
        this.show();
      }
    };
    Sidebar2.prototype.setEnableGestures = function() {
      if (this.enableGestures) {
        this.mainContentEle = new Touch(document.body, { swipe: this.enableGestureHandler.bind(this) });
        this.sidebarEle = new Touch(this.element, { swipe: this.enableGestureHandler.bind(this) });
      } else {
        if (this.mainContentEle && this.sidebarEle) {
          this.mainContentEle.destroy();
          this.sidebarEle.destroy();
        }
      }
    };
    Sidebar2.prototype.wireEvents = function() {
      this.setEnableGestures();
      EventHandler.add(window, "resize", this.resize, this);
    };
    Sidebar2.prototype.unWireEvents = function() {
      EventHandler.remove(window, "resize", this.resize);
      EventHandler.remove(document, "mousedown touchstart", this.documentclickHandler);
      if (this.mainContentEle) {
        this.mainContentEle.destroy();
      }
      if (this.sidebarEle) {
        this.sidebarEle.destroy();
      }
    };
    Sidebar2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var sibling = document.querySelector(".e-main-content") || this.targetEle;
      var isRendered = this.isServerRendered;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "isOpen":
            if (this.isOpen) {
              this.show();
            } else {
              this.hide();
            }
            break;
          case "width":
            this.setWidth();
            if (!this.getState()) {
              this.setDock();
            }
            break;
          case "animate":
            this.setAnimation();
            break;
          case "type":
            this.checkType(false);
            removeClass([this.element], [VISIBILITY]);
            this.addClass();
            addClass([this.element], this.type === "Auto" ? Browser.isDevice ? ["e-over"] : ["e-push"] : ["e-" + this.type.toLowerCase()]);
            break;
          case "position":
            this.element.style.transform = "";
            this.setDock();
            if (sibling) {
              sibling.style[this.position === "Left" ? "marginRight" : "marginLeft"] = "0px";
            }
            if (this.position === "Right") {
              removeClass([this.element], LEFT);
              addClass([this.element], RIGHT);
            } else {
              removeClass([this.element], RIGHT);
              addClass([this.element], LEFT);
            }
            this.setType(this.type);
            break;
          case "showBackdrop":
            if (this.showBackdrop) {
              this.createBackDrop();
            } else {
              if (this.modal) {
                this.modal.style.display = "none";
                this.modal.outerHTML = "";
                this.modal = null;
              }
            }
            break;
          case "target":
            if (typeof this.target === "string") {
              this.setProperties({ target: document.querySelector(this.target) }, true);
            }
            if (isNullOrUndefined(this.target)) {
              removeClass([this.element], SIDEBARABSOLUTE);
              removeClass([oldProp.target], CONTEXT);
              setStyleAttribute(sibling, { "margin-left": 0, "margin-right": 0 });
              document.body.insertAdjacentElement("afterbegin", this.element);
            }
            this.isServerRendered = false;
            _super.prototype.refresh.call(this);
            this.isServerRendered = isRendered;
            break;
          case "closeOnDocumentClick":
            this.setCloseOnDocumentClick();
            break;
          case "enableDock":
            if (!this.getState()) {
              this.setDock();
            }
            break;
          case "zIndex":
            this.setZindex();
            break;
          case "mediaQuery":
            this.setMediaQuery();
            break;
          case "enableGestures":
            this.setEnableGestures();
            break;
          case "enableRtl":
            this.setEnableRTL();
            break;
        }
      }
    };
    Sidebar2.prototype.setType = function(type) {
      var elementWidth = this.element.getBoundingClientRect().width;
      this.setZindex();
      var sibling = document.querySelector(".e-main-content") || this.targetEle;
      if (sibling) {
        sibling.style.transform = "translateX(0px)";
        if (!Browser.isDevice && this.type !== "Auto" && !(this.type === "Over" && this.enableDock)) {
          sibling.style[this.position === "Left" ? "marginLeft" : "marginRight"] = "0px";
        }
      }
      var margin = this.position === "Left" ? elementWidth + "px" : elementWidth + "px";
      var eleWidth = this.position === "Left" ? elementWidth : -elementWidth;
      removeClass([this.element], [PUSH, OVER, SLIDE]);
      switch (type) {
        case "Push":
          addClass([this.element], [PUSH]);
          if (sibling && (this.enableDock || this.element.classList.contains(OPEN))) {
            sibling.style[this.position === "Left" ? "marginLeft" : "marginRight"] = margin;
          }
          break;
        case "Slide":
          addClass([this.element], [SLIDE]);
          if (sibling && (this.enableDock || this.element.classList.contains(OPEN))) {
            sibling.style.transform = "translateX(" + eleWidth + "px)";
          }
          break;
        case "Over":
          addClass([this.element], [OVER]);
          if (this.enableDock && (this.element.classList.contains(CLOSE2) || this.isOpen)) {
            if (sibling) {
              sibling.style[this.position === "Left" ? "marginLeft" : "marginRight"] = this.setDimension(this.dockSize);
            }
          }
          break;
        case "Auto":
          addClass([this.element], [TRASITION]);
          if (Browser.isDevice) {
            if (sibling && this.enableDock && !this.getState()) {
              sibling.style[this.position === "Left" ? "marginLeft" : "marginRight"] = margin;
              addClass([this.element], PUSH);
            } else {
              addClass([this.element], OVER);
            }
          } else {
            addClass([this.element], PUSH);
            if (sibling && (this.enableDock || this.element.classList.contains(OPEN))) {
              sibling.style[this.position === "Left" ? "marginLeft" : "marginRight"] = margin;
            }
          }
          this.createBackDrop();
      }
    };
    Sidebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.target) {
        removeClass([this.target], CONTEXT);
      }
      this.destroyBackDrop();
      if (this.element) {
        removeClass([this.element], [OPEN, CLOSE2, PUSH, SLIDE, OVER, LEFT, RIGHT, TRASITION, DISABLEANIMATION]);
        removeClass([this.element], SIDEBARABSOLUTE);
        this.element.style.width = "";
        this.element.style.zIndex = "";
        this.element.style.transform = "";
        if (!isNullOrUndefined(this.sidebarEleCopy.getAttribute("tabindex"))) {
          this.element.setAttribute("tabindex", this.tabIndex);
        } else {
          this.element.removeAttribute("tabindex");
        }
      }
      this.windowWidth = null;
      var sibling = document.querySelector(".e-main-content") || this.targetEle;
      if (!isNullOrUndefined(sibling)) {
        sibling.style.margin = "";
        sibling.style.transform = "";
      }
      this.unWireEvents();
    };
    __decorate39([
      Property("auto")
    ], Sidebar2.prototype, "dockSize", void 0);
    __decorate39([
      Property(null)
    ], Sidebar2.prototype, "mediaQuery", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "enableDock", void 0);
    __decorate39([
      Property("en-US")
    ], Sidebar2.prototype, "locale", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "enablePersistence", void 0);
    __decorate39([
      Property(true)
    ], Sidebar2.prototype, "enableGestures", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "isOpen", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "enableRtl", void 0);
    __decorate39([
      Property(true)
    ], Sidebar2.prototype, "animate", void 0);
    __decorate39([
      Property("auto")
    ], Sidebar2.prototype, "height", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "closeOnDocumentClick", void 0);
    __decorate39([
      Property("Left")
    ], Sidebar2.prototype, "position", void 0);
    __decorate39([
      Property(null)
    ], Sidebar2.prototype, "target", void 0);
    __decorate39([
      Property(false)
    ], Sidebar2.prototype, "showBackdrop", void 0);
    __decorate39([
      Property("Auto")
    ], Sidebar2.prototype, "type", void 0);
    __decorate39([
      Property("auto")
    ], Sidebar2.prototype, "width", void 0);
    __decorate39([
      Property(1e3)
    ], Sidebar2.prototype, "zIndex", void 0);
    __decorate39([
      Event()
    ], Sidebar2.prototype, "created", void 0);
    __decorate39([
      Event()
    ], Sidebar2.prototype, "close", void 0);
    __decorate39([
      Event()
    ], Sidebar2.prototype, "open", void 0);
    __decorate39([
      Event()
    ], Sidebar2.prototype, "change", void 0);
    __decorate39([
      Event()
    ], Sidebar2.prototype, "destroyed", void 0);
    Sidebar2 = __decorate39([
      NotifyPropertyChanges
    ], Sidebar2);
    return Sidebar2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/breadcrumb/breadcrumb.js
var __extends41 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ICONRIGHT = "e-icon-right";
var ITEMTEXTCLASS = "e-breadcrumb-text";
var ICONCLASS = "e-breadcrumb-icon";
var MENUCLASS = "e-breadcrumb-menu";
var ITEMCLASS = "e-breadcrumb-item";
var POPUPCLASS = "e-breadcrumb-popup";
var WRAPMODECLASS = "e-breadcrumb-wrap-mode";
var SCROLLMODECLASS = "e-breadcrumb-scroll-mode";
var TABINDEX = "tabindex";
var DISABLEDCLASS = "e-disabled";
var ARIADISABLED = "aria-disabled";
var DOT = ".";
var BreadcrumbOverflowMode;
(function(BreadcrumbOverflowMode2) {
  BreadcrumbOverflowMode2["Hidden"] = "Hidden";
  BreadcrumbOverflowMode2["Collapsed"] = "Collapsed";
  BreadcrumbOverflowMode2["Menu"] = "Menu";
  BreadcrumbOverflowMode2["Wrap"] = "Wrap";
  BreadcrumbOverflowMode2["Scroll"] = "Scroll";
  BreadcrumbOverflowMode2["None"] = "None";
})(BreadcrumbOverflowMode || (BreadcrumbOverflowMode = {}));
var BreadcrumbItem = (
  /** @class */
  function(_super) {
    __extends41(BreadcrumbItem2, _super);
    function BreadcrumbItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate40([
      Property("")
    ], BreadcrumbItem2.prototype, "text", void 0);
    __decorate40([
      Property("")
    ], BreadcrumbItem2.prototype, "id", void 0);
    __decorate40([
      Property("")
    ], BreadcrumbItem2.prototype, "url", void 0);
    __decorate40([
      Property(null)
    ], BreadcrumbItem2.prototype, "iconCss", void 0);
    __decorate40([
      Property(false)
    ], BreadcrumbItem2.prototype, "disabled", void 0);
    return BreadcrumbItem2;
  }(ChildProperty)
);
var Breadcrumb = (
  /** @class */
  function(_super) {
    __extends41(Breadcrumb2, _super);
    function Breadcrumb2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isPopupCreated = false;
      return _this;
    }
    Breadcrumb2.prototype.preRender = function() {
    };
    Breadcrumb2.prototype.render = function() {
      this.initialize();
      this.renderItems(this.items);
      this.wireEvents();
    };
    Breadcrumb2.prototype.initialize = function() {
      this._maxItems = this.maxItems;
      if (isNullOrUndefined(this.element.getAttribute("aria-label"))) {
        this.element.setAttribute("aria-label", "breadcrumb");
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.enableRtl) {
        this.element.classList.add("e-rtl");
      }
      if (this.disabled) {
        this.element.classList.add(DISABLEDCLASS);
        this.element.setAttribute(ARIADISABLED, "true");
      }
      if (this.overflowMode === "Wrap") {
        this.element.classList.add(WRAPMODECLASS);
      } else if (this.overflowMode === "Scroll") {
        this.element.classList.add(SCROLLMODECLASS);
      }
      this.initItems();
      this.initPvtProps();
    };
    Breadcrumb2.prototype.initPvtProps = function() {
      if (this.overflowMode === "Hidden" && this._maxItems > 0) {
        this.endIndex = this.getEndIndex();
        this.startIndex = this.endIndex + 1 - (this._maxItems - 1);
      }
      if (this.overflowMode === "Menu") {
        if (this._maxItems >= 0) {
          this.startIndex = this._maxItems > 1 ? 1 : 0;
          this.endIndex = this.getEndIndex();
          this.popupUl = this.createElement("ul", { attrs: { TABINDEX: "0", "role": "menu" } });
        } else {
          this.startIndex = this.endIndex = null;
        }
      }
    };
    Breadcrumb2.prototype.getEndIndex = function() {
      var _this = this;
      var endIndex;
      if (this.activeItem) {
        this.items.forEach(function(item, idx) {
          if (item.url === _this.activeItem || item.text === _this.activeItem) {
            endIndex = idx;
          }
        });
      } else {
        endIndex = this.items.length - 1;
      }
      return endIndex;
    };
    Breadcrumb2.prototype.initItems = function() {
      if (!this.items.length) {
        var baseUri = void 0;
        var uri = void 0;
        var items = [];
        if (this.url) {
          var url = new URL(this.url, window.location.origin);
          baseUri = url.origin + "/";
          uri = url.href.split(baseUri)[1].split("/");
        } else {
          baseUri = window.location.origin + "/";
          uri = window.location.href.split(baseUri)[1].split("/");
        }
        items.push({ iconCss: "e-icons e-home", url: baseUri });
        for (var i = 0; i < uri.length; i++) {
          if (uri[i]) {
            items.push({ text: uri[i], url: baseUri + uri[i] });
            baseUri += uri[i] + "/";
          }
        }
        this.setProperties({ items }, true);
      }
    };
    Breadcrumb2.prototype.renderItems = function(items) {
      var _this = this;
      var item;
      var isSingleLevel;
      var isIconRight = this.element.classList.contains(ICONRIGHT);
      var itemsLength = items.length;
      if (itemsLength) {
        var isActiveItem = void 0;
        var isLastItem = void 0;
        var isLastItemInPopup_1;
        var j_1 = 0;
        var wrapDiv = void 0;
        var len = itemsLength * 2 - 1;
        var isItemCancelled_1 = false;
        var ol = this.createElement("ol", { className: this.overflowMode === "Wrap" ? "e-breadcrumb-wrapped-ol" : "" });
        var firstOl = this.createElement("ol", { className: this.overflowMode === "Wrap" ? "e-breadcrumb-first-ol" : "" });
        var showIcon = this.hasField(items, "iconCss");
        var isCollasped = this.overflowMode === "Collapsed" && this._maxItems > 0 && itemsLength > this._maxItems && !this.isExpanded;
        var isDefaultOverflowMode_1 = this.overflowMode === "Hidden" && this._maxItems > 0;
        if (this.overflowMode === "Menu" && this.popupUl) {
          this.popupUl.innerHTML = "";
        }
        var listBaseOptions = {
          moduleName: this.getModuleName(),
          showIcon,
          itemNavigable: true,
          itemCreated: function(args) {
            var isLastItem2 = args.curData.isLastItem;
            if (isLastItem2 && args.item.children.length && !_this.itemTemplate) {
              delete args.curData.isLastItem;
              if (!isLastItemInPopup_1 && !_this.enableActiveItemNavigation) {
                args.item.innerHTML = _this.createElement("span", { className: ITEMTEXTCLASS, innerHTML: args.item.children[0].innerHTML }).outerHTML;
              }
            }
            if (args.curData.iconCss && !args.curData.text && !_this.itemTemplate) {
              args.item.classList.add("e-icon-item");
            }
            if (isDefaultOverflowMode_1) {
              args.item.setAttribute("item-index", j_1.toString());
            }
            var eventArgs = {
              item: extend({}, args.curData.properties ? args.curData.properties : args.curData),
              element: args.item,
              cancel: false
            };
            _this.trigger("beforeItemRender", eventArgs);
            isItemCancelled_1 = eventArgs.cancel;
            var containsRightIcon = isIconRight || eventArgs.element.classList.contains(ICONRIGHT);
            if (containsRightIcon && args.curData.iconCss && !_this.itemTemplate) {
              args.item.querySelector(".e-anchor-wrap").appendChild(args.item.querySelector(DOT + ICONCLASS));
            }
            if (eventArgs.item.disabled) {
              args.item.setAttribute(ARIADISABLED, "true");
              args.item.classList.add(DISABLEDCLASS);
            }
            if (eventArgs.item.id) {
              args.item.setAttribute("id", eventArgs.item.id);
            }
            if ((eventArgs.item.disabled || _this.disabled) && args.item.children.length && !_this.itemTemplate) {
              args.item.children[0].setAttribute(TABINDEX, "-1");
            }
            if (args.curData.isEmptyUrl) {
              args.item.children[0].removeAttribute("href");
              if ((!isLastItem2 || isLastItem2 && _this.enableActiveItemNavigation) && !(eventArgs.item.disabled || _this.disabled)) {
                args.item.children[0].setAttribute(TABINDEX, "0");
                EventHandler.add(args.item.children[0], "keydown", _this.keyDownHandler, _this);
              }
            }
            args.item.removeAttribute("role");
            if (isLastItem2) {
              args.item.setAttribute("data-active-item", "");
            }
            if (!_this.itemTemplate) {
              _this.beforeItemRenderChanges(args.curData, eventArgs.item, args.item, containsRightIcon);
            }
          }
        };
        for (var i = 0; i < len; i % 2 && j_1++, i++) {
          isActiveItem = this.activeItem && (this.activeItem === items[j_1].url || this.activeItem === items[j_1].text);
          if (isCollasped && i > 1 && i < len - 2) {
            continue;
          } else if (isDefaultOverflowMode_1 && ((j_1 < this.startIndex || j_1 > this.endIndex) && (i % 2 ? j_1 !== this.startIndex - 1 : true)) && j_1 !== 0) {
            continue;
          }
          if (i % 2) {
            wrapDiv = this.createElement("div", { className: "e-breadcrumb-item-wrapper" });
            if (this.separatorTemplate && this.separatorTemplate === "/" || isNullOrUndefined(this.separatorTemplate)) {
              listBaseOptions.template = initializeCSPTemplate(function() {
                return "/";
              });
            } else {
              listBaseOptions.template = this.separatorTemplate;
            }
            listBaseOptions.itemClass = "e-breadcrumb-separator";
            isSingleLevel = false;
            item = [{ previousItem: items[j_1], nextItem: items[j_1 + 1] }];
          } else {
            listBaseOptions.itemClass = "";
            if (this.itemTemplate) {
              listBaseOptions.template = this.itemTemplate;
              isSingleLevel = false;
            } else {
              isSingleLevel = true;
            }
            item = [extend({}, items[j_1].properties ? items[j_1].properties : items[j_1])];
            if (!item[0].url && !this.itemTemplate) {
              item = [extend({}, item[0], { isEmptyUrl: true, url: "#" })];
            }
            isLastItem = (isDefaultOverflowMode_1 || this.overflowMode === "Menu") && j_1 === this.endIndex;
            if ((i === len - 1 || isLastItem) && !this.itemTemplate || isActiveItem) {
              item[0].isLastItem = true;
            }
          }
          var parent_1 = ol;
          var lastPopupItemIdx = this.startIndex + this.endIndex - this._maxItems;
          if (this.overflowMode === "Menu" && (j_1 >= this.startIndex && (j_1 <= lastPopupItemIdx && (i % 2 ? !(j_1 === lastPopupItemIdx) : true)) && this.endIndex >= this._maxItems && this._maxItems > 0 || this._maxItems === 0)) {
            if (i % 2) {
              continue;
            } else {
              parent_1 = this.popupUl;
              if (isLastItem) {
                isLastItemInPopup_1 = true;
              }
            }
          } else if (this.overflowMode === "Wrap") {
            if (i === 0) {
              parent_1 = firstOl;
            } else {
              parent_1 = wrapDiv;
            }
          }
          var li = ListBase.createList(this.createElement, item, listBaseOptions, isSingleLevel, this).childNodes;
          if (!isItemCancelled_1) {
            append(li, parent_1);
          } else if (isDefaultOverflowMode_1 || isCollasped || this.overflowMode === "Menu" || this.overflowMode === "Wrap") {
            items.splice(j_1, 1);
            this.initPvtProps();
            return this.reRenderItems();
          } else if (i === len - 1 || isLastItem) {
            remove(parent_1.lastElementChild);
          }
          if (this.overflowMode === "Wrap" && i !== 0 && i % 2 === 0) {
            ol.appendChild(wrapDiv);
          }
          if (isCollasped && i === 1) {
            var li_1 = this.createElement("li", { className: "e-icons e-breadcrumb-collapsed", attrs: { TABINDEX: "0" } });
            EventHandler.add(li_1, "keyup", this.expandHandler, this);
            ol.appendChild(li_1);
          }
          if (this.overflowMode === "Menu" && this.startIndex === i && this.endIndex >= this._maxItems && this._maxItems >= 0) {
            var menu = this.getMenuElement();
            EventHandler.add(menu, "keyup", this.keyDownHandler, this);
            ol.appendChild(menu);
          }
          if (isActiveItem || isLastItem) {
            break;
          }
          if (isItemCancelled_1) {
            i++;
          }
        }
        if (this.isReact) {
          this.renderReactTemplates();
          setTimeout(function() {
            _this.calculateMaxItems();
          }, 5);
        }
        if (this.overflowMode === "Wrap") {
          this.element.appendChild(firstOl);
        }
        this.element.appendChild(ol);
        if (!this.isReact) {
          this.calculateMaxItems();
        }
      }
    };
    Breadcrumb2.prototype.calculateMaxItems = function() {
      if (this.overflowMode === "Hidden" || this.overflowMode === "Collapsed" || this.overflowMode === "Menu") {
        var maxItems = void 0;
        var width = this.element.offsetWidth;
        var liElems = [].slice.call(this.element.children[0].children).reverse();
        var liWidth = this.overflowMode === "Menu" ? 0 : liElems[liElems.length - 1].offsetWidth + (liElems[liElems.length - 2] ? liElems[liElems.length - 2].offsetWidth : 0);
        if (this.overflowMode === "Menu") {
          var menuEle = this.getMenuElement();
          this.element.appendChild(menuEle);
          liWidth += menuEle.offsetWidth;
          remove(menuEle);
        }
        for (var i = 0; i < liElems.length - 2; i++) {
          if (liWidth > width) {
            maxItems = Math.ceil((i - 1) / 2) + (this.overflowMode === "Menu" && i <= 2 ? 0 : 1);
            if ((this.maxItems > maxItems && !(this.maxItems > -1 && maxItems === -1) || this.maxItems === -1) && this._maxItems !== maxItems) {
              this._maxItems = maxItems;
              this.initPvtProps();
              return this.reRenderItems();
            } else {
              break;
            }
          } else {
            if (this.overflowMode === "Menu" && i === 2) {
              liWidth += liElems[liElems.length - 1].offsetWidth + liElems[liElems.length - 2].offsetWidth;
              if (liWidth > width) {
                this._maxItems = 1;
                this.initPvtProps();
                return this.reRenderItems();
              }
            }
            if (!(this.overflowMode === "Menu" && liElems[i].classList.contains(MENUCLASS))) {
              liWidth += liElems[i].offsetWidth;
            }
          }
        }
      } else if ((this.overflowMode === "Wrap" || this.overflowMode === "Scroll") && this._maxItems > 0) {
        var width = 0;
        var liElems = this.element.querySelectorAll(DOT + ITEMCLASS);
        if (liElems.length > this._maxItems + this._maxItems - 1) {
          for (var i = this.overflowMode === "Wrap" ? 1 : 0; i < this._maxItems + this._maxItems - 1; i++) {
            width += liElems[i].offsetWidth;
          }
          width = width + 5 + parseInt(getComputedStyle(this.element.children[0]).paddingLeft, 10) * 2;
          if (this.overflowMode === "Wrap") {
            this.element.querySelector(".e-breadcrumb-wrapped-ol").style.width = width + "px";
          } else {
            this.element.style.width = width + "px";
          }
        }
      }
    };
    Breadcrumb2.prototype.hasField = function(items, field) {
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]["" + field]) {
          return true;
        }
      }
      return false;
    };
    Breadcrumb2.prototype.getMenuElement = function() {
      return this.createElement("li", { className: "e-icons e-breadcrumb-menu", attrs: { TABINDEX: "0" } });
    };
    Breadcrumb2.prototype.beforeItemRenderChanges = function(prevItem, currItem, elem, isRightIcon) {
      var wrapElem = elem.querySelector(".e-anchor-wrap");
      if (wrapElem) {
        wrapElem.parentElement.setAttribute("aria-label", "home");
      }
      if (currItem.text !== prevItem.text && wrapElem) {
        wrapElem.childNodes.forEach(function(child) {
          if (child.nodeType === Node.TEXT_NODE) {
            child.textContent = currItem.text;
          }
        });
      }
      if (currItem.iconCss !== prevItem.iconCss && wrapElem) {
        var iconElem = elem.querySelector(DOT + ICONCLASS);
        if (iconElem) {
          if (currItem.iconCss) {
            removeClass([iconElem], prevItem.iconCss.split(" "));
            addClass([iconElem], currItem.iconCss.split(" "));
          } else {
            remove(iconElem);
          }
        } else if (currItem.iconCss) {
          var iconElem_1 = this.createElement("span", { className: ICONCLASS + " " + currItem.iconCss });
          if (isRightIcon) {
            append([iconElem_1], wrapElem);
          } else {
            wrapElem.insertBefore(iconElem_1, wrapElem.childNodes[0]);
          }
        }
      }
      if (currItem.url !== prevItem.url && this.enableNavigation) {
        var anchor = elem.querySelector("a." + ITEMTEXTCLASS);
        if (anchor) {
          if (currItem.url) {
            anchor.setAttribute("href", currItem.url);
          } else {
            anchor.removeAttribute("href");
          }
        }
      }
    };
    Breadcrumb2.prototype.reRenderItems = function() {
      this.element.innerHTML = "";
      this.renderItems(this.items);
    };
    Breadcrumb2.prototype.clickHandler = function(e) {
      var li = closest(e.target, DOT + ITEMCLASS + ":not(.e-breadcrumb-separator)");
      if (!this.enableNavigation) {
        e.preventDefault();
      }
      if (li && (closest(e.target, DOT + ITEMTEXTCLASS) || this.itemTemplate)) {
        var idx = void 0;
        if (this.overflowMode === "Wrap") {
          idx = [].slice.call(this.element.querySelectorAll(DOT + ITEMCLASS)).indexOf(li);
        } else {
          idx = [].slice.call(li.parentElement.children).indexOf(li);
        }
        if (this.overflowMode === "Menu") {
          if (closest(e.target, DOT + POPUPCLASS)) {
            idx += this.startIndex;
            this.endIndex = idx;
            if (e.type === "keydown") {
              this.documentClickHandler(e);
            }
          } else if (this.element.querySelector(DOT + MENUCLASS)) {
            if (idx > [].slice.call(this.element.children[0].children).indexOf(this.element.querySelector(DOT + MENUCLASS))) {
              idx += this.popupUl.childElementCount * 2 - 2;
              idx = Math.floor(idx / 2);
              this.endIndex = idx;
            } else {
              this.startIndex = this.endIndex = idx;
            }
          } else {
            idx = Math.floor(idx / 2);
            this.startIndex = this.endIndex = idx;
          }
        } else {
          idx = Math.floor(idx / 2);
        }
        if (this.overflowMode === "Hidden" && this._maxItems > 0 && this.endIndex !== 0) {
          idx = parseInt(li.getAttribute("item-index"), 10);
          if (this.startIndex > 1) {
            this.startIndex -= this.endIndex - idx;
          }
          this.endIndex = idx;
        }
        var itemClickArgs = {
          element: li,
          item: this.items[idx],
          event: e,
          cancel: false
        };
        this.trigger("itemClick", itemClickArgs);
        if (itemClickArgs.cancel) {
          return;
        }
        if (this.items[idx]) {
          this.activeItem = this.items[idx].url || this.items[idx].text;
        }
        this.dataBind();
      }
      if (e.target.classList.contains("e-breadcrumb-collapsed")) {
        this.isExpanded = true;
        this.reRenderItems();
      }
      if (e.target.classList.contains(MENUCLASS) && !this.isPopupCreated) {
        this.renderPopup();
      }
    };
    Breadcrumb2.prototype.renderPopup = function() {
      var _this = this;
      var wrapper = this.createElement("div", { className: POPUPCLASS + " " + this.cssClass + (this.enableRtl ? " e-rtl" : "") });
      document.body.appendChild(wrapper);
      this.isPopupCreated = true;
      this.popupObj = new Popup(wrapper, {
        content: this.popupUl,
        relateTo: this.element.querySelector(DOT + MENUCLASS),
        enableRtl: this.enableRtl,
        position: { X: "left", Y: "bottom" },
        collision: { X: "fit", Y: "flip" },
        open: function() {
          if (_this.popupUl) {
            _this.popupUl.focus();
          }
        }
      });
      this.popupWireEvents();
      this.popupObj.show();
    };
    Breadcrumb2.prototype.documentClickHandler = function(e) {
      if (this.overflowMode === "Menu" && this.popupObj && this.popupObj.element.classList.contains("e-popup-open") && !closest(e.target, DOT + MENUCLASS)) {
        this.popupObj.hide();
        this.popupObj.destroy();
        this.isPopupCreated = false;
        detach(this.popupObj.element);
      }
    };
    Breadcrumb2.prototype.resize = function() {
      this._maxItems = this.maxItems;
      this.initPvtProps();
      this.reRenderItems();
    };
    Breadcrumb2.prototype.expandHandler = function(e) {
      if (e.key === "Enter") {
        this.isExpanded = true;
        this.reRenderItems();
      }
    };
    Breadcrumb2.prototype.keyDownHandler = function(e) {
      if (e.key === "Enter") {
        this.clickHandler(e);
      }
    };
    Breadcrumb2.prototype.popupKeyDownHandler = function(e) {
      if (e.key === "Escape") {
        this.documentClickHandler(e);
      }
    };
    Breadcrumb2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "items":
          case "enableActiveItemNavigation":
            this.reRenderItems();
            break;
          case "activeItem":
            this._maxItems = this.maxItems;
            this.initPvtProps();
            this.reRenderItems();
            break;
          case "overflowMode":
          case "maxItems":
            this._maxItems = this.maxItems;
            this.initPvtProps();
            this.reRenderItems();
            if (oldProp.overflowMode === "Wrap") {
              this.element.classList.remove(WRAPMODECLASS);
            } else if (newProp.overflowMode === "Wrap") {
              this.element.classList.add(WRAPMODECLASS);
            }
            if (oldProp.overflowMode === "Scroll") {
              this.element.classList.remove(SCROLLMODECLASS);
            } else if (newProp.overflowMode === "Scroll") {
              this.element.classList.add(SCROLLMODECLASS);
            }
            break;
          case "url":
            this.initItems();
            this.reRenderItems();
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            if (oldProp.cssClass && oldProp.cssClass.indexOf(ICONRIGHT) > -1 && !(newProp.cssClass && newProp.cssClass.indexOf(ICONRIGHT) > -1) || !(oldProp.cssClass && oldProp.cssClass.indexOf(ICONRIGHT) > -1) && (newProp.cssClass && newProp.cssClass.indexOf(ICONRIGHT) > -1)) {
              this.reRenderItems();
            }
            break;
          case "enableRtl":
            this.element.classList.toggle("e-rtl");
            break;
          case "disabled":
            this.element.classList.toggle(DISABLEDCLASS);
            this.element.setAttribute(ARIADISABLED, newProp.disabled + "");
            break;
        }
      }
    };
    Breadcrumb2.prototype.wireEvents = function() {
      this.delegateClickHanlder = this.documentClickHandler.bind(this);
      EventHandler.add(document, "click", this.delegateClickHanlder, this);
      EventHandler.add(this.element, "click", this.clickHandler, this);
      window.addEventListener("resize", this.resize.bind(this));
    };
    Breadcrumb2.prototype.popupWireEvents = function() {
      EventHandler.add(this.popupObj.element, "click", this.clickHandler, this);
      EventHandler.add(this.popupObj.element, "keydown", this.popupKeyDownHandler, this);
    };
    Breadcrumb2.prototype.unWireEvents = function() {
      EventHandler.remove(document, "click", this.delegateClickHanlder);
      EventHandler.remove(this.element, "click", this.clickHandler);
      window.removeEventListener("resize", this.resize.bind(this));
      if (this.popupObj) {
        EventHandler.remove(this.popupObj.element, "click", this.clickHandler);
        EventHandler.remove(this.popupObj.element, "keydown", this.popupKeyDownHandler);
      }
    };
    Breadcrumb2.prototype.getPersistData = function() {
      return this.addOnPersist(["activeItem"]);
    };
    Breadcrumb2.prototype.getModuleName = function() {
      return "breadcrumb";
    };
    Breadcrumb2.prototype.destroy = function() {
      var _this = this;
      var classes = [];
      var attributes2 = ["aria-label"];
      if (this.cssClass) {
        classes.concat(this.cssClass.split(" "));
      }
      if (this.enableRtl) {
        classes.push("e-rtl");
      }
      if (this.disabled) {
        classes.push(DISABLEDCLASS);
        attributes2.push(ARIADISABLED);
      }
      if (this.overflowMode === "Wrap") {
        classes.push(WRAPMODECLASS);
      } else if (this.overflowMode === "Scroll") {
        classes.push(SCROLLMODECLASS);
      }
      this.unWireEvents();
      this.element.innerHTML = "";
      removeClass([this.element], classes);
      attributes2.forEach(function(attribute) {
        _this.element.removeAttribute(attribute);
      });
      _super.prototype.destroy.call(this);
    };
    __decorate40([
      Property("")
    ], Breadcrumb2.prototype, "url", void 0);
    __decorate40([
      Collection([], BreadcrumbItem)
    ], Breadcrumb2.prototype, "items", void 0);
    __decorate40([
      Property("")
    ], Breadcrumb2.prototype, "activeItem", void 0);
    __decorate40([
      Property(-1)
    ], Breadcrumb2.prototype, "maxItems", void 0);
    __decorate40([
      Property("Menu")
    ], Breadcrumb2.prototype, "overflowMode", void 0);
    __decorate40([
      Property("")
    ], Breadcrumb2.prototype, "cssClass", void 0);
    __decorate40([
      Property(null)
    ], Breadcrumb2.prototype, "itemTemplate", void 0);
    __decorate40([
      Property("/")
    ], Breadcrumb2.prototype, "separatorTemplate", void 0);
    __decorate40([
      Property(true)
    ], Breadcrumb2.prototype, "enableNavigation", void 0);
    __decorate40([
      Property(false)
    ], Breadcrumb2.prototype, "enableActiveItemNavigation", void 0);
    __decorate40([
      Property(false)
    ], Breadcrumb2.prototype, "disabled", void 0);
    __decorate40([
      Property("")
    ], Breadcrumb2.prototype, "locale", void 0);
    __decorate40([
      Event()
    ], Breadcrumb2.prototype, "beforeItemRender", void 0);
    __decorate40([
      Event()
    ], Breadcrumb2.prototype, "itemClick", void 0);
    __decorate40([
      Event()
    ], Breadcrumb2.prototype, "created", void 0);
    Breadcrumb2 = __decorate40([
      NotifyPropertyChanges
    ], Breadcrumb2);
    return Breadcrumb2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/carousel/carousel.js
var __extends42 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_CAROUSEL = "e-carousel";
var CLS_ACTIVE3 = "e-active";
var CLS_RTL6 = "e-rtl";
var CLS_PARTIAL = "e-partial";
var CLS_SWIPE = "e-swipe";
var CLS_SLIDE_CONTAINER = "e-carousel-slide-container";
var CLS_ITEMS3 = "e-carousel-items";
var CLS_CLONED = "e-cloned";
var CLS_ITEM4 = "e-carousel-item";
var CLS_PREVIOUS = "e-previous";
var CLS_NEXT = "e-next";
var CLS_PREV_ICON = "e-previous-icon";
var CLS_NEXT_ICON = "e-next-icon";
var CLS_NAVIGATORS = "e-carousel-navigators";
var CLS_INDICATORS = "e-carousel-indicators";
var CLS_INDICATOR_BARS = "e-indicator-bars";
var CLS_INDICATOR_BAR = "e-indicator-bar";
var CLS_INDICATOR2 = "e-indicator";
var CLS_ICON2 = "e-icons";
var CLS_PLAY_PAUSE = "e-play-pause";
var CLS_PLAY_ICON = "e-play-icon";
var CLS_PAUSE_ICON = "e-pause-icon";
var CLS_PREV_BUTTON = "e-previous-button";
var CLS_NEXT_BUTTON = "e-next-button";
var CLS_PLAY_BUTTON = "e-play-button";
var CLS_FLAT = "e-flat";
var CLS_ROUND = "e-round";
var CLS_HOVER_ARROWS = "e-hover-arrows";
var CLS_HOVER = "e-carousel-hover";
var CLS_TEMPLATE3 = "e-template";
var CLS_SLIDE_ANIMATION = "e-carousel-slide-animation";
var CLS_FADE_ANIMATION = "e-carousel-fade-animation";
var CLS_CUSTOM_ANIMATION = "e-carousel-custom-animation";
var CLS_ANIMATION_NONE = "e-carousel-animation-none";
var CLS_PREV_SLIDE = "e-prev";
var CLS_NEXT_SLIDE = "e-next";
var CLS_TRANSITION_START = "e-transition-start";
var CLS_TRANSITION_END = "e-transition-end";
var CarouselSwipeMode;
(function(CarouselSwipeMode2) {
  CarouselSwipeMode2[CarouselSwipeMode2["Touch"] = 1] = "Touch";
  CarouselSwipeMode2[CarouselSwipeMode2["Mouse"] = 2] = "Mouse";
})(CarouselSwipeMode || (CarouselSwipeMode = {}));
var CarouselItem = (
  /** @class */
  function(_super) {
    __extends42(CarouselItem2, _super);
    function CarouselItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate41([
      Property()
    ], CarouselItem2.prototype, "cssClass", void 0);
    __decorate41([
      Property()
    ], CarouselItem2.prototype, "interval", void 0);
    __decorate41([
      Property()
    ], CarouselItem2.prototype, "template", void 0);
    __decorate41([
      Property()
    ], CarouselItem2.prototype, "htmlAttributes", void 0);
    return CarouselItem2;
  }(ChildProperty)
);
var Carousel = (
  /** @class */
  function(_super) {
    __extends42(Carousel2, _super);
    function Carousel2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isSwipe = false;
      return _this;
    }
    Carousel2.prototype.getModuleName = function() {
      return CLS_CAROUSEL.replace("e-", "");
    };
    Carousel2.prototype.getPersistData = function() {
      return this.addOnPersist(["selectedIndex"]);
    };
    Carousel2.prototype.preRender = function() {
      this.keyConfigs = {
        home: "home",
        end: "end",
        space: "space",
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        moveDown: "downarrow"
      };
      var defaultLocale = {
        nextSlide: "Next slide",
        of: "of",
        pauseSlideTransition: "Pause slide transition",
        playSlideTransition: "Play slide transition",
        previousSlide: "Previous slide",
        slide: "Slide",
        slideShow: "Slide show"
      };
      this.localeObj = new L10n(this.getModuleName(), defaultLocale, this.locale);
    };
    Carousel2.prototype.render = function() {
      this.initialize();
      this.renderSlides();
      this.renderNavigators();
      this.renderPlayButton();
      this.renderIndicators();
      this.applyAnimation();
      this.wireEvents();
    };
    Carousel2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var target;
      var rtlElement;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "animationEffect":
            this.applyAnimation();
            break;
          case "cssClass":
            classList(this.element, [newProp.cssClass], [oldProp.cssClass]);
            break;
          case "selectedIndex":
            this.setActiveSlide(this.selectedIndex, oldProp.selectedIndex > this.selectedIndex ? "Previous" : "Next");
            this.autoSlide();
            break;
          case "htmlAttributes":
            if (!isNullOrUndefined(this.htmlAttributes)) {
              this.setHtmlAttributes(this.htmlAttributes, this.element);
            }
            break;
          case "enableTouchSwipe":
            if (!this.enableTouchSwipe && this.touchModule) {
              this.touchModule.destroy();
            }
            if (this.element.querySelector("." + CLS_ITEMS3)) {
              this.renderTouchActions();
            }
            break;
          case "loop":
            if (this.loop && isNullOrUndefined(this.autoSlideInterval)) {
              this.applySlideInterval();
            }
            this.handleNavigatorsActions(this.selectedIndex);
            if (this.partialVisible || !(this.swipeMode === (~CarouselSwipeMode.Touch & ~CarouselSwipeMode.Mouse))) {
              this.reRenderSlides();
            }
            break;
          case "enableRtl":
            rtlElement = [].slice.call(this.element.querySelectorAll("." + CLS_PREV_BUTTON + ",\n                ." + CLS_NEXT_BUTTON + ", ." + CLS_PLAY_BUTTON));
            rtlElement.push(this.element);
            if (this.enableRtl) {
              addClass(rtlElement, CLS_RTL6);
            } else {
              removeClass(rtlElement, CLS_RTL6);
            }
            if (this.partialVisible || !(this.swipeMode === (~CarouselSwipeMode.Touch & ~CarouselSwipeMode.Mouse))) {
              var cloneCount = this.loop ? this.getNumOfItems() : 0;
              var slideWidth = this.itemsContainer.firstElementChild.clientWidth;
              this.itemsContainer.style.transform = this.getTranslateX(slideWidth, this.selectedIndex + cloneCount);
            }
            break;
          case "buttonsVisibility":
            target = this.element.querySelector("." + CLS_NAVIGATORS);
            if (target) {
              switch (this.buttonsVisibility) {
                case "Hidden":
                  this.resetTemplates(["previousButtonTemplate", "nextButtonTemplate"]);
                  remove(target);
                  break;
                case "VisibleOnHover":
                  addClass([].slice.call(target.childNodes), CLS_HOVER_ARROWS);
                  break;
                case "Visible":
                  removeClass([].slice.call(target.childNodes), CLS_HOVER_ARROWS);
                  break;
              }
            } else {
              this.renderNavigators();
              this.renderPlayButton();
            }
            break;
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(this.width) });
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(this.height) });
            break;
          case "autoPlay":
            if (this.showPlayButton && isNullOrUndefined(this.playButtonTemplate)) {
              this.playButtonClickHandler(null, true);
            }
            this.autoSlide();
            break;
          case "interval":
            this.autoSlide();
            break;
          case "showIndicators":
          case "indicatorsType":
            target = this.element.querySelector("." + CLS_INDICATORS);
            if (target) {
              this.resetTemplates(["indicatorsTemplate"]);
              remove(target);
            }
            this.renderIndicators();
            break;
          case "showPlayButton":
            target = this.element.querySelector("." + CLS_PLAY_PAUSE);
            if (!this.showPlayButton && target) {
              remove(target);
              this.resetTemplates(["playButtonTemplate"]);
            }
            this.renderPlayButton();
            break;
          case "items":
          case "dataSource": {
            var selectedData = prop === "dataSource" ? this.dataSource : this.items;
            if (!isNullOrUndefined(selectedData) && selectedData.length > 0 && this.selectedIndex >= selectedData.length) {
              this.setActiveSlide(selectedData.length - 1, "Previous");
              this.autoSlide();
            }
            this.reRenderSlides();
            this.reRenderIndicators();
            break;
          }
          case "partialVisible":
            if (this.partialVisible) {
              addClass([this.element], CLS_PARTIAL);
            } else {
              removeClass([this.element], CLS_PARTIAL);
            }
            this.reRenderSlides();
            break;
          case "swipeMode":
            EventHandler.remove(this.element, "mousedown touchstart", this.swipeStart);
            EventHandler.remove(this.element, "mousemove touchmove", this.swiping);
            EventHandler.remove(this.element, "mouseup touchend", this.swipStop);
            this.swipeModehandlers();
            this.reRenderSlides();
            break;
        }
      }
    };
    Carousel2.prototype.reRenderSlides = function() {
      var target = this.element.querySelector("." + CLS_ITEMS3);
      if (target) {
        this.resetTemplates(["itemTemplate"]);
        remove(target);
      }
      this.renderSlides();
    };
    Carousel2.prototype.reRenderIndicators = function() {
      var target = this.element.querySelector("." + CLS_INDICATORS);
      if (target) {
        this.resetTemplates(["indicatorsTemplate"]);
        remove(target);
      }
      this.renderIndicators();
    };
    Carousel2.prototype.initialize = function() {
      var carouselClasses = [];
      carouselClasses.push(CLS_CAROUSEL);
      if (this.cssClass) {
        carouselClasses.push(this.cssClass);
      }
      if (this.enableRtl) {
        carouselClasses.push(CLS_RTL6);
      }
      if (this.partialVisible) {
        carouselClasses.push(CLS_PARTIAL);
      }
      if (!(this.swipeMode === (~CarouselSwipeMode.Touch & ~CarouselSwipeMode.Mouse))) {
        carouselClasses.push(CLS_SWIPE);
      }
      addClass([this.element], carouselClasses);
      setStyleAttribute(this.element, { "width": formatUnit(this.width), "height": formatUnit(this.height) });
      attributes(this.element, { "role": "group", "aria-roledescription": "carousel", "aria-label": this.localeObj.getConstant("slideShow") });
      if (!isNullOrUndefined(this.htmlAttributes)) {
        this.setHtmlAttributes(this.htmlAttributes, this.element);
      }
    };
    Carousel2.prototype.renderSlides = function() {
      var _this = this;
      var slideContainer = this.element.querySelector("." + CLS_SLIDE_CONTAINER);
      if (!slideContainer) {
        slideContainer = this.createElement("div", { className: CLS_SLIDE_CONTAINER, attrs: { "tabindex": "0", "role": "tabpanel" } });
        this.element.appendChild(slideContainer);
      }
      this.itemsContainer = this.createElement("div", { className: CLS_ITEMS3, attrs: { "aria-live": this.autoPlay ? "off" : "polite" } });
      slideContainer.appendChild(this.itemsContainer);
      var numOfItems = this.getNumOfItems();
      if (numOfItems > 0 && this.loop) {
        if (this.items.length > 0) {
          this.items.slice(-numOfItems).forEach(function(item, index) {
            _this.renderSlide(item, item.template, index, _this.itemsContainer, true);
          });
        } else if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0) {
          this.dataSource.slice(-numOfItems).forEach(function(item, index) {
            _this.renderSlide(item, _this.itemTemplate, index, _this.itemsContainer, true);
          });
        }
      }
      if (this.items.length > 0) {
        this.slideItems = this.items;
        this.items.forEach(function(item, index) {
          _this.renderSlide(item, item.template, index, _this.itemsContainer);
        });
      } else if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0) {
        this.slideItems = this.dataSource;
        this.dataSource.forEach(function(item, index) {
          _this.renderSlide(item, _this.itemTemplate, index, _this.itemsContainer);
        });
      }
      if (numOfItems > 0 && this.loop) {
        if (this.items.length > 0) {
          this.items.slice(0, numOfItems).forEach(function(item, index) {
            _this.renderSlide(item, item.template, index, _this.itemsContainer, true);
          });
        } else if (!isNullOrUndefined(this.dataSource) && this.dataSource.length > 0) {
          this.dataSource.slice(0, numOfItems).forEach(function(item, index) {
            _this.renderSlide(item, _this.itemTemplate, index, _this.itemsContainer, true);
          });
        }
      }
      this.renderTemplates();
      this.itemsContainer.style.setProperty("--carousel-items-count", "" + this.itemsContainer.children.length);
      var slideWidth = isNullOrUndefined(this.itemsContainer.firstElementChild) ? 0 : this.itemsContainer.firstElementChild.clientWidth;
      this.itemsContainer.style.transitionProperty = "none";
      var cloneCount = this.loop ? numOfItems : 0;
      this.itemsContainer.style.transform = this.getTranslateX(slideWidth, this.selectedIndex + cloneCount);
      this.autoSlide();
      this.renderTouchActions();
      this.renderKeyboardActions();
    };
    Carousel2.prototype.getTranslateX = function(slideWidth, count) {
      if (count === void 0) {
        count = 1;
      }
      return this.enableRtl ? "translateX(" + slideWidth * count + "px)" : "translateX(" + -slideWidth * count + "px)";
    };
    Carousel2.prototype.renderSlide = function(item, itemTemplate, index, container, isClone) {
      if (isClone === void 0) {
        isClone = false;
      }
      var itemEle = this.createElement("div", {
        id: getUniqueID("carousel_item"),
        className: CLS_ITEM4 + " " + (item.cssClass ? item.cssClass : "") + " " + (this.selectedIndex === index && !isClone ? CLS_ACTIVE3 : ""),
        attrs: {
          "aria-hidden": this.selectedIndex === index && !isClone ? "false" : "true",
          "data-index": index.toString(),
          "role": "group",
          "aria-roledescription": "slide"
        }
      });
      if (isClone) {
        itemEle.classList.add(CLS_CLONED);
      }
      if (!isNullOrUndefined(item.htmlAttributes)) {
        this.setHtmlAttributes(item.htmlAttributes, itemEle);
      }
      var templateId = this.element.id + "_template";
      var template = this.templateParser(itemTemplate)(item, this, "itemTemplate", templateId, false);
      append(template, itemEle);
      container.appendChild(itemEle);
    };
    Carousel2.prototype.renderNavigators = function() {
      if (this.buttonsVisibility === "Hidden") {
        return;
      }
      var navigators = this.createElement("div", { className: CLS_NAVIGATORS });
      var itemsContainer = this.element.querySelector("." + CLS_SLIDE_CONTAINER);
      itemsContainer.insertAdjacentElement("afterend", navigators);
      if (!isNullOrUndefined(this.slideItems) && this.slideItems.length > 1) {
        this.renderNavigatorButton("Previous");
        this.renderNavigatorButton("Next");
      }
      this.renderTemplates();
    };
    Carousel2.prototype.renderNavigatorButton = function(direction) {
      var buttonContainer = this.createElement("div", {
        className: (direction === "Previous" ? CLS_PREVIOUS : CLS_NEXT) + " " + (this.buttonsVisibility === "VisibleOnHover" ? CLS_HOVER_ARROWS : "")
      });
      if (direction === "Previous" && this.previousButtonTemplate) {
        addClass([buttonContainer], CLS_TEMPLATE3);
        var templateId = this.element.id + "_previousButtonTemplate";
        var template = this.templateParser(this.previousButtonTemplate)({ type: "Previous" }, this, "previousButtonTemplate", templateId, false);
        append(template, buttonContainer);
      } else if (direction === "Next" && this.nextButtonTemplate) {
        addClass([buttonContainer], CLS_TEMPLATE3);
        var templateId = this.element.id + "_nextButtonTemplate";
        var template = this.templateParser(this.nextButtonTemplate)({ type: "Next" }, this, "nextButtonTemplate", templateId, false);
        append(template, buttonContainer);
      } else {
        var button = this.createElement("button", {
          attrs: { "aria-label": this.localeObj.getConstant(direction === "Previous" ? "previousSlide" : "nextSlide"), "type": "button" }
        });
        var buttonObj = new Button({
          cssClass: CLS_FLAT + " " + CLS_ROUND + " " + (direction === "Previous" ? CLS_PREV_BUTTON : CLS_NEXT_BUTTON),
          iconCss: CLS_ICON2 + " " + (direction === "Previous" ? CLS_PREV_ICON : CLS_NEXT_ICON),
          enableRtl: this.enableRtl,
          disabled: !this.loop && this.selectedIndex === (direction === "Previous" ? 0 : this.slideItems.length - 1)
        });
        buttonObj.appendTo(button);
        buttonContainer.appendChild(button);
      }
      this.element.querySelector("." + CLS_NAVIGATORS).appendChild(buttonContainer);
      EventHandler.add(buttonContainer, "click", this.navigatorClickHandler, this);
    };
    Carousel2.prototype.renderPlayButton = function() {
      if (isNullOrUndefined(this.slideItems) || this.buttonsVisibility === "Hidden" || !this.showPlayButton || this.slideItems.length <= 1) {
        return;
      }
      var playPauseWrap = this.createElement("div", {
        className: CLS_PLAY_PAUSE + " " + (this.buttonsVisibility === "VisibleOnHover" ? CLS_HOVER_ARROWS : "")
      });
      if (this.playButtonTemplate) {
        addClass([playPauseWrap], CLS_TEMPLATE3);
        var templateId = this.element.id + "_playButtonTemplate";
        var template = this.templateParser(this.playButtonTemplate)({}, this, "playButtonTemplate", templateId, false);
        append(template, playPauseWrap);
      } else {
        var playButton = this.createElement("button", {
          attrs: { "aria-label": this.localeObj.getConstant(this.autoPlay ? "pauseSlideTransition" : "playSlideTransition"), "type": "button" }
        });
        var isLastSlide = this.selectedIndex === this.slideItems.length - 1 && !this.loop;
        var buttonObj = new Button({
          cssClass: CLS_FLAT + " " + CLS_ROUND + " " + CLS_PLAY_BUTTON,
          iconCss: CLS_ICON2 + " " + (this.autoPlay && !isLastSlide ? CLS_PAUSE_ICON : CLS_PLAY_ICON),
          isToggle: true,
          enableRtl: this.enableRtl
        });
        if (isLastSlide) {
          this.setProperties({ autoPlay: false }, true);
          playButton.setAttribute("aria-label", this.localeObj.getConstant("playSlideTransition"));
          this.itemsContainer.setAttribute("aria-live", "polite");
        }
        buttonObj.appendTo(playButton);
        playPauseWrap.appendChild(playButton);
      }
      var navigators = this.element.querySelector("." + CLS_NAVIGATORS);
      navigators.insertBefore(playPauseWrap, navigators.lastElementChild);
      this.renderTemplates();
      EventHandler.add(playPauseWrap, "click", this.playButtonClickHandler, this);
    };
    Carousel2.prototype.renderIndicators = function() {
      var _this = this;
      if (!this.showIndicators || isNullOrUndefined(this.indicatorsType)) {
        return;
      }
      var indicatorClass = "e-default";
      if (!this.indicatorsTemplate) {
        indicatorClass = "e-" + this.indicatorsType.toLowerCase();
      }
      var indicatorWrap = this.createElement("div", { className: CLS_INDICATORS + " " + indicatorClass });
      var indicatorBars = this.createElement("div", { className: CLS_INDICATOR_BARS });
      indicatorWrap.appendChild(indicatorBars);
      var progress;
      if (this.slideItems) {
        switch (this.indicatorsType) {
          case "Fraction":
            if (this.indicatorsTemplate) {
              this.renderIndicatorTemplate(indicatorBars, this.selectedIndex + 1);
            } else {
              indicatorBars.innerText = this.selectedIndex + 1 + " / " + this.slideItems.length;
            }
            break;
          case "Progress":
            if (this.indicatorsTemplate) {
              this.renderIndicatorTemplate(indicatorBars, this.selectedIndex + 1);
            } else {
              progress = this.createElement("div", { className: CLS_INDICATOR_BAR });
              progress.style.setProperty("--carousel-items-current", "" + (this.selectedIndex + 1));
              progress.style.setProperty("--carousel-items-count", "" + this.slideItems.length);
              indicatorBars.appendChild(progress);
            }
            break;
          case "Default":
          case "Dynamic":
            this.slideItems.forEach(function(item, index) {
              var indicatorBar = _this.createElement("div", {
                className: CLS_INDICATOR_BAR + " " + (_this.selectedIndex === index ? CLS_ACTIVE3 : _this.selectedIndex - 1 === index ? CLS_PREV_SLIDE : _this.selectedIndex + 1 === index ? CLS_NEXT_SLIDE : ""),
                attrs: { "data-index": index.toString(), "aria-current": _this.selectedIndex === index ? "true" : "false" }
              });
              indicatorBar.style.setProperty("--carousel-items-current", "" + _this.selectedIndex);
              if (_this.indicatorsTemplate) {
                _this.renderIndicatorTemplate(indicatorBar, index);
              } else if (_this.indicatorsType === "Default") {
                var indicator = _this.createElement("button", { className: CLS_INDICATOR2, attrs: { "type": "button", "aria-label": _this.localeObj.getConstant("slide") + " " + (index + 1) + " " + _this.localeObj.getConstant("of") + " " + _this.slideItems.length } });
                indicatorBar.appendChild(indicator);
                indicator.appendChild(_this.createElement("div", {}));
                var buttonObj = new Button({ cssClass: "e-flat e-small" });
                buttonObj.appendTo(indicator);
              }
              indicatorBars.appendChild(indicatorBar);
              if (_this.indicatorsType === "Default") {
                EventHandler.add(indicatorBar, "click", _this.indicatorClickHandler, _this);
              }
            });
            break;
        }
      }
      this.element.appendChild(indicatorWrap);
    };
    Carousel2.prototype.renderIndicatorTemplate = function(indicatorBar, index) {
      if (index === void 0) {
        index = 0;
      }
      addClass([indicatorBar], CLS_TEMPLATE3);
      var templateId = this.element.id + "_indicatorsTemplate";
      var template = this.templateParser(this.indicatorsTemplate)({ index, selectedIndex: this.selectedIndex }, this, "indicatorsTemplate", templateId, false);
      append(template, indicatorBar);
    };
    Carousel2.prototype.renderKeyboardActions = function() {
      this.keyModule = new KeyboardEvents(this.element, { keyAction: this.keyHandler.bind(this), keyConfigs: this.keyConfigs });
    };
    Carousel2.prototype.renderTouchActions = function() {
      if (!this.enableTouchSwipe) {
        return;
      }
      this.touchModule = new Touch(this.element, { swipe: this.swipeHandler.bind(this) });
    };
    Carousel2.prototype.applyAnimation = function() {
      removeClass([this.element], [CLS_CUSTOM_ANIMATION, CLS_FADE_ANIMATION, CLS_SLIDE_ANIMATION, CLS_ANIMATION_NONE]);
      switch (this.animationEffect) {
        case "Slide":
          addClass([this.element], CLS_SLIDE_ANIMATION);
          break;
        case "Fade":
          addClass([this.element], CLS_FADE_ANIMATION);
          break;
        case "None":
          addClass([this.element], CLS_ANIMATION_NONE);
          break;
        case "Custom":
          addClass([this.element], CLS_CUSTOM_ANIMATION);
          break;
      }
    };
    Carousel2.prototype.autoSlide = function() {
      if (isNullOrUndefined(this.slideItems) || this.slideItems.length <= 1) {
        return;
      }
      this.resetSlideInterval();
      this.applySlideInterval();
    };
    Carousel2.prototype.autoSlideChange = function() {
      var activeSlide = this.element.querySelector("." + CLS_ACTIVE3);
      if (isNullOrUndefined(activeSlide)) {
        return;
      }
      var activeIndex = parseInt(activeSlide.dataset.index, 10);
      if (!this.loop && activeIndex === this.slideItems.length - 1) {
        this.resetSlideInterval();
      } else {
        var index = (activeIndex + 1) % this.slideItems.length;
        if (!this.element.classList.contains(CLS_HOVER)) {
          this.setActiveSlide(index, "Next");
        }
        this.autoSlide();
      }
    };
    Carousel2.prototype.applySlideInterval = function() {
      var _this = this;
      if (!this.autoPlay || this.element.classList.contains(CLS_HOVER)) {
        return;
      }
      var itemInterval = this.interval;
      if (this.items.length > 0 && !isNullOrUndefined(this.items[this.selectedIndex || 0].interval)) {
        itemInterval = this.items[this.selectedIndex || 0].interval;
      }
      this.autoSlideInterval = setInterval(function() {
        return _this.autoSlideChange();
      }, itemInterval);
    };
    Carousel2.prototype.resetSlideInterval = function() {
      clearInterval(this.autoSlideInterval);
      this.autoSlideInterval = null;
    };
    Carousel2.prototype.getSlideIndex = function(direction) {
      var currentIndex = this.selectedIndex || 0;
      if (direction === "Previous") {
        currentIndex--;
        if (currentIndex < 0) {
          currentIndex = this.slideItems.length - 1;
        }
      } else {
        currentIndex++;
        if (currentIndex === this.slideItems.length) {
          currentIndex = 0;
        }
      }
      return currentIndex;
    };
    Carousel2.prototype.setActiveSlide = function(currentIndex, direction, isSwiped) {
      var _this = this;
      if (isSwiped === void 0) {
        isSwiped = false;
      }
      if (this.element.querySelectorAll("." + CLS_ITEM4 + "." + CLS_PREV_SLIDE + ",." + CLS_ITEM4 + "." + CLS_NEXT_SLIDE).length > 0) {
        return;
      }
      currentIndex = isNullOrUndefined(currentIndex) ? 0 : currentIndex;
      var allSlides = [].slice.call(this.element.querySelectorAll("." + CLS_ITEM4 + ":not(.e-cloned)"));
      var activeSlide = this.element.querySelector("." + CLS_ITEM4 + "." + CLS_ACTIVE3);
      if (isNullOrUndefined(activeSlide) && this.showIndicators) {
        var activeIndicator = this.element.querySelector("." + CLS_INDICATOR_BAR + "." + CLS_ACTIVE3);
        var activeIndex_1 = parseInt(activeIndicator.dataset.index, 10);
        addClass([allSlides[parseInt(activeIndex_1.toString(), 10)]], CLS_ACTIVE3);
        return;
      } else if (isNullOrUndefined(activeSlide)) {
        addClass([allSlides[parseInt(currentIndex.toString(), 10)]], CLS_ACTIVE3);
        return;
      }
      var activeIndex = parseInt(activeSlide.dataset.index, 10);
      var currentSlide = allSlides[parseInt(currentIndex.toString(), 10)];
      var eventArgs = {
        currentIndex: activeIndex,
        nextIndex: currentIndex,
        currentSlide: activeSlide,
        nextSlide: currentSlide,
        slideDirection: direction,
        isSwiped,
        cancel: false
      };
      this.trigger("slideChanging", eventArgs, function(args) {
        if (args.cancel) {
          return;
        }
        _this.setProperties({ selectedIndex: currentIndex }, true);
        attributes(args.currentSlide, { "aria-hidden": "true" });
        attributes(args.nextSlide, { "aria-hidden": "false" });
        _this.refreshIndicators(activeIndex, currentIndex);
        _this.slideChangedEventArgs = {
          currentIndex: args.nextIndex,
          previousIndex: args.currentIndex,
          currentSlide: args.nextSlide,
          previousSlide: args.currentSlide,
          slideDirection: direction,
          isSwiped
        };
        var slideWidth = allSlides[parseInt(currentIndex.toString(), 10)].clientWidth;
        var numOfItems = _this.getNumOfItems();
        if (!_this.isSwipe) {
          _this.itemsContainer.style.transitionDuration = "0.6s";
        }
        _this.isSwipe = false;
        if (_this.animationEffect === "Fade") {
          _this.itemsContainer.classList.add("e-fade-in-out");
        } else {
          _this.itemsContainer.style.transitionProperty = "transform";
        }
        if (_this.loop) {
          if (_this.slideChangedEventArgs.currentIndex === 0 && _this.slideChangedEventArgs.slideDirection === "Next") {
            _this.itemsContainer.style.transform = _this.getTranslateX(slideWidth, allSlides.length + numOfItems);
          } else if (_this.slideChangedEventArgs.currentIndex === _this.slideItems.length - 1 && _this.slideChangedEventArgs.slideDirection === "Previous") {
            _this.itemsContainer.style.transform = _this.partialVisible ? _this.getTranslateX(slideWidth) : "translateX(0px)";
          } else {
            _this.itemsContainer.style.transform = _this.getTranslateX(slideWidth, currentIndex + numOfItems);
          }
        } else {
          _this.itemsContainer.style.transform = _this.getTranslateX(slideWidth, currentIndex);
        }
        if (_this.animationEffect === "Slide") {
          if (direction === "Previous") {
            addClass([args.nextSlide], CLS_PREV_SLIDE);
            args.nextSlide.setAttribute("data-slide-height", args.nextSlide.offsetHeight.toString());
            addClass([args.currentSlide, args.nextSlide], CLS_TRANSITION_END);
          } else {
            addClass([args.nextSlide], CLS_NEXT_SLIDE);
            args.nextSlide.setAttribute("data-slide-height", args.nextSlide.offsetHeight.toString());
            addClass([args.currentSlide, args.nextSlide], CLS_TRANSITION_START);
          }
        } else if (_this.animationEffect === "Fade") {
          removeClass([args.currentSlide], CLS_ACTIVE3);
          addClass([args.nextSlide], CLS_ACTIVE3);
        } else if (_this.animationEffect === "Custom") {
          if (direction === "Previous") {
            addClass([args.nextSlide], CLS_NEXT_SLIDE);
            addClass([args.currentSlide], CLS_PREV_SLIDE);
          } else {
            addClass([args.currentSlide], CLS_PREV_SLIDE);
            addClass([args.nextSlide], CLS_NEXT_SLIDE);
          }
        } else {
          _this.onTransitionEnd();
        }
        _this.handleNavigatorsActions(currentIndex);
      });
    };
    Carousel2.prototype.onTransitionEnd = function() {
      var _this = this;
      removeClass(this.element.querySelectorAll("." + CLS_ITEMS3), "e-fade-in-out");
      var numOfItems = this.getNumOfItems();
      if (this.slideChangedEventArgs) {
        this.itemsContainer.style.transitionProperty = "none";
        if (this.loop && (this.slideChangedEventArgs.currentIndex === 0 && this.slideChangedEventArgs.slideDirection === "Next" || this.slideChangedEventArgs.currentIndex === this.slideItems.length - 1 && this.slideChangedEventArgs.slideDirection === "Previous")) {
          var slideWidth = this.slideChangedEventArgs.currentSlide.clientWidth;
          this.itemsContainer.style.transform = this.getTranslateX(slideWidth, this.slideChangedEventArgs.currentIndex + numOfItems);
        }
        addClass([this.slideChangedEventArgs.currentSlide], CLS_ACTIVE3);
        removeClass([this.slideChangedEventArgs.previousSlide], CLS_ACTIVE3);
        this.trigger("slideChanged", this.slideChangedEventArgs, function() {
          removeClass(_this.element.querySelectorAll("." + CLS_ITEM4), [CLS_PREV_SLIDE, CLS_NEXT_SLIDE, CLS_TRANSITION_START, CLS_TRANSITION_END]);
          _this.slideChangedEventArgs = null;
        });
      }
    };
    Carousel2.prototype.refreshIndicators = function(activeIndex, currentIndex) {
      var _this = this;
      var slideIndicator = this.element.querySelector("." + CLS_INDICATOR_BARS);
      if (isNullOrUndefined(slideIndicator)) {
        return;
      }
      var indicators = [].slice.call(slideIndicator.childNodes);
      switch (this.indicatorsType) {
        case "Default":
        case "Dynamic":
          attributes(indicators[parseInt(activeIndex.toString(), 10)], { "aria-current": "false" });
          attributes(indicators[parseInt(currentIndex.toString(), 10)], { "aria-current": "true" });
          removeClass(indicators, [CLS_ACTIVE3, CLS_PREV_SLIDE, CLS_NEXT_SLIDE]);
          addClass([indicators[parseInt(currentIndex.toString(), 10)]], CLS_ACTIVE3);
          if (indicators[currentIndex - 1]) {
            addClass([indicators[currentIndex - 1]], CLS_PREV_SLIDE);
          }
          if (indicators[currentIndex + 1]) {
            addClass([indicators[currentIndex + 1]], CLS_NEXT_SLIDE);
          }
          indicators.forEach(function(item) {
            return item.style.setProperty("--carousel-items-current", "" + _this.selectedIndex);
          });
          break;
        case "Fraction":
          if (this.indicatorsTemplate) {
            if (slideIndicator.children.length > 0) {
              slideIndicator.removeChild(slideIndicator.firstElementChild);
            }
            this.renderIndicatorTemplate(slideIndicator, currentIndex + 1);
          } else {
            slideIndicator.innerText = this.selectedIndex + 1 + " / " + this.slideItems.length;
          }
          break;
        case "Progress":
          if (this.indicatorsTemplate) {
            if (slideIndicator.children.length > 0) {
              slideIndicator.removeChild(slideIndicator.firstElementChild);
            }
            this.renderIndicatorTemplate(slideIndicator, currentIndex + 1);
          } else {
            slideIndicator.firstElementChild.style.setProperty("--carousel-items-current", "" + (this.selectedIndex + 1));
          }
          break;
      }
    };
    Carousel2.prototype.setHtmlAttributes = function(attribute, element2) {
      var keys = Object.keys(attribute);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (key === "class") {
          addClass([element2], attribute["" + key]);
        } else {
          element2.setAttribute(key, attribute["" + key]);
        }
      }
    };
    Carousel2.prototype.templateParser = function(template) {
      if (template) {
        try {
          if (typeof template !== "function" && document.querySelectorAll(template).length) {
            return compile(document.querySelector(template).innerHTML.trim());
          } else {
            return compile(template);
          }
        } catch (error) {
          return compile(template);
        }
      }
      return void 0;
    };
    Carousel2.prototype.getNavigatorState = function(target, isPrevious) {
      var button = target.querySelector("." + (isPrevious ? CLS_PREV_BUTTON : CLS_NEXT_BUTTON));
      if (button) {
        var buttonObj = getInstance(button, Button);
        return buttonObj.disabled;
      }
      return false;
    };
    Carousel2.prototype.navigatorClickHandler = function(e) {
      var target = e.currentTarget;
      var isDisabled = this.getNavigatorState(target, target.classList.contains(CLS_PREVIOUS));
      if (isDisabled) {
        return;
      }
      var direction = target.classList.contains(CLS_PREVIOUS) ? "Previous" : "Next";
      this.setActiveSlide(this.getSlideIndex(direction), direction);
      this.autoSlide();
    };
    Carousel2.prototype.indicatorClickHandler = function(e) {
      var target = closest(e.target, "." + CLS_INDICATOR_BAR);
      var index = parseInt(target.dataset.index, 10);
      if (this.selectedIndex !== index) {
        this.setActiveSlide(index, this.selectedIndex > index ? "Previous" : "Next");
        this.autoSlide();
      }
    };
    Carousel2.prototype.playButtonClickHandler = function(e, isPropertyChange) {
      if (isPropertyChange === void 0) {
        isPropertyChange = false;
      }
      var playButton = this.element.querySelector("." + CLS_PLAY_BUTTON);
      if (playButton) {
        var buttonObj = getInstance(playButton, Button);
        if (!isPropertyChange) {
          this.setProperties({ autoPlay: !this.autoPlay }, true);
        }
        playButton.setAttribute("aria-label", this.localeObj.getConstant(this.autoPlay ? "pauseSlideTransition" : "playSlideTransition"));
        buttonObj.iconCss = CLS_ICON2 + " " + (this.autoPlay ? CLS_PAUSE_ICON : CLS_PLAY_ICON);
        buttonObj.dataBind();
        this.itemsContainer.setAttribute("aria-live", this.autoPlay ? "off" : "polite");
        if (this.autoPlay && !this.loop && this.selectedIndex === this.slideItems.length - 1) {
          this.setActiveSlide(0, "Next");
        }
        this.autoSlide();
      }
    };
    Carousel2.prototype.keyHandler = function(e) {
      var direction;
      var slideIndex;
      var isSlideTransition = false;
      var target = e.target;
      e.preventDefault();
      switch (e.action) {
        case "space":
          if (this.showIndicators && target.classList.contains(CLS_INDICATOR2)) {
            target.click();
          } else if (target.classList.contains(CLS_CAROUSEL) || target.classList.contains(CLS_PLAY_BUTTON)) {
            this.playButtonClickHandler(e);
          } else if (target.classList.contains(CLS_NEXT_BUTTON)) {
            this.next();
          } else if (target.classList.contains(CLS_PREV_BUTTON)) {
            this.prev();
          }
          break;
        case "end":
          slideIndex = this.slideItems.length - 1;
          direction = "Next";
          isSlideTransition = true;
          break;
        case "home":
          slideIndex = 0;
          direction = "Previous";
          isSlideTransition = true;
          break;
        case "moveUp":
        case "moveLeft":
        case "moveDown":
        case "moveRight":
          if (this.showIndicators && isNullOrUndefined(this.indicatorsTemplate)) {
            this.element.focus();
          }
          direction = e.action === "moveUp" || e.action === "moveLeft" ? "Previous" : "Next";
          slideIndex = this.getSlideIndex(direction);
          isSlideTransition = !this.isSuspendSlideTransition(slideIndex, direction);
          break;
      }
      if (isSlideTransition) {
        this.setActiveSlide(slideIndex, direction);
        this.autoSlide();
        isSlideTransition = false;
      }
    };
    Carousel2.prototype.swipeHandler = function(e) {
      if (this.element.classList.contains(CLS_HOVER) || isNullOrUndefined(this.slideItems) || this.slideItems.length <= 1) {
        return;
      }
      var direction = e.swipeDirection === "Right" ? "Previous" : "Next";
      var slideIndex = this.getSlideIndex(direction);
      if (!this.isSuspendSlideTransition(slideIndex, direction)) {
        this.setActiveSlide(slideIndex, direction, true);
        this.autoSlide();
      }
    };
    Carousel2.prototype.isSuspendSlideTransition = function(index, direction) {
      return !this.loop && (direction === "Next" && index === 0 || direction === "Previous" && index === this.slideItems.length - 1);
    };
    Carousel2.prototype.handleNavigatorsActions = function(index) {
      if (this.buttonsVisibility === "Hidden") {
        return;
      }
      if (this.showPlayButton) {
        var playButton = this.element.querySelector("." + CLS_PLAY_BUTTON);
        var isLastSlide = this.selectedIndex === this.slideItems.length - 1 && !this.loop;
        var isButtonUpdate = isNullOrUndefined(this.playButtonTemplate) && playButton && isLastSlide;
        if (isNullOrUndefined(this.playButtonTemplate) && playButton && !isLastSlide) {
          isButtonUpdate = !playButton.classList.contains(CLS_ACTIVE3);
        }
        if (isButtonUpdate) {
          this.setProperties({ autoPlay: !isLastSlide }, true);
          playButton.setAttribute("aria-label", this.localeObj.getConstant(this.autoPlay ? "pauseSlideTransition" : "playSlideTransition"));
          this.itemsContainer.setAttribute("aria-live", this.autoPlay ? "off" : "polite");
          var buttonObj = getInstance(playButton, Button);
          buttonObj.iconCss = CLS_ICON2 + " " + (this.autoPlay ? CLS_PAUSE_ICON : CLS_PLAY_ICON);
          buttonObj.dataBind();
        }
      }
      var prevButton = this.element.querySelector("." + CLS_PREV_BUTTON);
      if (prevButton && isNullOrUndefined(this.previousButtonTemplate)) {
        var buttonObj = getInstance(prevButton, Button);
        buttonObj.disabled = !this.loop && index === 0;
        buttonObj.dataBind();
      }
      var nextButton = this.element.querySelector("." + CLS_NEXT_BUTTON);
      if (nextButton && isNullOrUndefined(this.nextButtonTemplate)) {
        var buttonObj = getInstance(nextButton, Button);
        buttonObj.disabled = !this.loop && index === this.slideItems.length - 1;
        buttonObj.dataBind();
      }
    };
    Carousel2.prototype.onHoverActions = function(e) {
      var navigator2 = this.element.querySelector("." + CLS_NAVIGATORS);
      switch (e.type) {
        case "mouseenter":
          if (this.buttonsVisibility === "VisibleOnHover" && navigator2) {
            removeClass([].slice.call(navigator2.childNodes), CLS_HOVER_ARROWS);
          }
          if (this.pauseOnHover) {
            addClass([this.element], CLS_HOVER);
          }
          break;
        case "mouseleave":
          if (this.buttonsVisibility === "VisibleOnHover" && navigator2) {
            addClass([].slice.call(navigator2.childNodes), CLS_HOVER_ARROWS);
          }
          removeClass([this.element], CLS_HOVER);
          break;
      }
      this.autoSlide();
    };
    Carousel2.prototype.onFocusActions = function(e) {
      switch (e.type) {
        case "focusin":
          addClass([this.element], CLS_HOVER);
          break;
        case "focusout":
          removeClass([this.element], CLS_HOVER);
          break;
      }
      this.autoSlide();
    };
    Carousel2.prototype.destroyButtons = function() {
      var buttonCollections = [].slice.call(this.element.querySelectorAll(".e-control.e-btn"));
      for (var _i = 0, buttonCollections_1 = buttonCollections; _i < buttonCollections_1.length; _i++) {
        var button = buttonCollections_1[_i];
        var instance = getInstance(button, Button);
        if (instance) {
          instance.destroy();
        }
      }
    };
    Carousel2.prototype.getNumOfItems = function() {
      return this.partialVisible ? 2 : 1;
    };
    Carousel2.prototype.getTranslateValue = function(element2) {
      var style = getComputedStyle(element2);
      return window.WebKitCSSMatrix ? new WebKitCSSMatrix(style.webkitTransform).m41 : 0;
    };
    Carousel2.prototype.swipeStart = function(e) {
      if (!this.timeStampStart) {
        this.timeStampStart = Date.now();
      }
      this.isSwipe = false;
      this.itemsContainer.classList.add("e-swipe-start");
      this.prevPageX = e.touches ? e.touches[0].pageX : e.pageX;
      this.initialTranslate = this.getTranslateValue(this.itemsContainer);
    };
    Carousel2.prototype.swiping = function(e) {
      if (!this.itemsContainer.classList.contains("e-swipe-start")) {
        return;
      }
      e.preventDefault();
      var pageX = e.touches ? e.touches[0].pageX : e.pageX;
      var positionDiff = this.prevPageX - pageX;
      if (!this.loop && (this.enableRtl && (this.selectedIndex === 0 && positionDiff > 0 || this.selectedIndex === this.itemsContainer.childElementCount - 1 && positionDiff < 0) || !this.enableRtl && (this.selectedIndex === 0 && positionDiff < 0 || this.selectedIndex === this.itemsContainer.childElementCount - 1 && positionDiff > 0))) {
        return;
      }
      this.itemsContainer.style.transform = "translateX(" + (this.initialTranslate + (this.enableRtl ? positionDiff : -positionDiff)) + "px)";
    };
    Carousel2.prototype.swipStop = function() {
      this.isSwipe = true;
      var time = Date.now() - this.timeStampStart;
      var distanceX = this.getTranslateValue(this.itemsContainer) - this.initialTranslate;
      distanceX = distanceX < 0 ? distanceX * -1 : distanceX;
      if (this.isSwipe) {
        var offsetDist = distanceX * (Browser.isDevice ? 6 : 1.66);
        this.itemsContainer.style.transitionDuration = (Browser.isDevice ? distanceX : offsetDist) / time / 10 + "s";
      }
      var slideWidth = this.itemsContainer.firstElementChild.clientWidth;
      var threshold = slideWidth / 2;
      this.itemsContainer.classList.remove("e-swipe-start");
      var value = this.getTranslateValue(this.itemsContainer);
      if (value - this.initialTranslate < -threshold) {
        this.swipeNavigation(!this.enableRtl);
      } else if (value - this.initialTranslate > threshold) {
        this.swipeNavigation(this.enableRtl);
      } else {
        this.itemsContainer.style.transform = "translateX(" + this.initialTranslate + "px)";
        if (this.animationEffect === "Fade") {
          this.itemsContainer.classList.add("e-fade-in-out");
        }
      }
    };
    Carousel2.prototype.swipeNavigation = function(isRtl) {
      if (isRtl) {
        this.next();
      } else {
        this.prev();
      }
    };
    Carousel2.prototype.swipeModehandlers = function() {
      if ((this.swipeMode & CarouselSwipeMode.Touch) === CarouselSwipeMode.Touch) {
        EventHandler.add(this.itemsContainer, "touchstart", this.swipeStart, this);
        EventHandler.add(this.itemsContainer, "touchmove", this.swiping, this);
        EventHandler.add(this.itemsContainer, "touchend", this.swipStop, this);
      }
      if ((this.swipeMode & CarouselSwipeMode.Mouse) === CarouselSwipeMode.Mouse) {
        EventHandler.add(this.itemsContainer, "mousedown", this.swipeStart, this);
        EventHandler.add(this.itemsContainer, "mousemove", this.swiping, this);
        EventHandler.add(this.itemsContainer, "mouseup", this.swipStop, this);
      }
      if (this.swipeMode === 0 && (this.swipeMode & CarouselSwipeMode.Mouse & CarouselSwipeMode.Touch) === (CarouselSwipeMode.Mouse & CarouselSwipeMode.Touch)) {
        EventHandler.add(this.itemsContainer, "mousedown touchstart", this.swipeStart, this);
        EventHandler.add(this.itemsContainer, "mousemove touchmove", this.swiping, this);
        EventHandler.add(this.itemsContainer, "mouseup touchend", this.swipStop, this);
      }
    };
    Carousel2.prototype.resizeHandler = function() {
      if (this.itemsContainer && this.itemsContainer.firstElementChild) {
        var numOfItems = this.getNumOfItems();
        var slideWidth = this.itemsContainer.firstElementChild.clientWidth;
        if (this.loop) {
          this.itemsContainer.style.transform = this.getTranslateX(slideWidth, this.selectedIndex + numOfItems);
        } else {
          this.itemsContainer.style.transform = this.getTranslateX(slideWidth, this.selectedIndex);
        }
      }
    };
    Carousel2.prototype.wireEvents = function() {
      if (!(this.animationEffect === "Custom")) {
        this.swipeModehandlers();
      }
      EventHandler.add(this.element, "focusin focusout", this.onFocusActions, this);
      EventHandler.add(this.element, "mouseenter mouseleave", this.onHoverActions, this);
      EventHandler.add(this.element.firstElementChild, "animationend", this.onTransitionEnd, this);
      EventHandler.add(this.element.firstElementChild, "transitionend", this.onTransitionEnd, this);
      EventHandler.add(window, "resize", this.resizeHandler, this);
    };
    Carousel2.prototype.unWireEvents = function() {
      var _this = this;
      var indicators = [].slice.call(this.element.querySelectorAll("." + CLS_INDICATOR_BAR));
      indicators.forEach(function(indicator) {
        EventHandler.remove(indicator, "click", _this.indicatorClickHandler);
      });
      var navigators = [].slice.call(this.element.querySelectorAll("." + CLS_PREVIOUS + ",." + CLS_NEXT));
      navigators.forEach(function(navigator2) {
        EventHandler.remove(navigator2, "click", _this.navigatorClickHandler);
      });
      var playIcon = this.element.querySelector("." + CLS_PLAY_PAUSE);
      if (playIcon) {
        EventHandler.remove(playIcon, "click", this.playButtonClickHandler);
      }
      EventHandler.remove(this.element.firstElementChild, "animationend", this.onTransitionEnd);
      EventHandler.remove(this.element.firstElementChild, "transitionend", this.onTransitionEnd);
      EventHandler.clearEvents(this.element);
      EventHandler.clearEvents(this.itemsContainer);
      EventHandler.remove(window, "resize", this.resizeHandler);
    };
    Carousel2.prototype.prev = function() {
      if (!this.loop && this.selectedIndex === 0) {
        return;
      }
      var index = this.selectedIndex === 0 ? this.slideItems.length - 1 : this.selectedIndex - 1;
      this.setActiveSlide(index, "Previous");
      this.autoSlide();
    };
    Carousel2.prototype.next = function() {
      if (!this.loop && this.selectedIndex === this.slideItems.length - 1) {
        return;
      }
      var index = this.selectedIndex === this.slideItems.length - 1 ? 0 : this.selectedIndex + 1;
      this.setActiveSlide(index, "Next");
      this.autoSlide();
    };
    Carousel2.prototype.play = function() {
      var playIcon = this.element.querySelector("." + CLS_PLAY_ICON);
      if (this.showPlayButton && playIcon) {
        classList(playIcon, [CLS_PAUSE_ICON], [CLS_PLAY_ICON]);
        var playButton = this.element.querySelector("." + CLS_PLAY_BUTTON);
        playButton.setAttribute("aria-label", this.localeObj.getConstant("pauseSlideTransition"));
      }
      this.setProperties({ autoPlay: true }, true);
      this.itemsContainer.setAttribute("aria-live", "off");
      this.applySlideInterval();
    };
    Carousel2.prototype.pause = function() {
      var pauseIcon = this.element.querySelector("." + CLS_PAUSE_ICON);
      if (this.showPlayButton && pauseIcon) {
        var playButton = this.element.querySelector("." + CLS_PLAY_BUTTON);
        playButton.setAttribute("aria-label", this.localeObj.getConstant("playSlideTransition"));
        classList(pauseIcon, [CLS_PLAY_ICON], [CLS_PAUSE_ICON]);
      }
      this.setProperties({ autoPlay: false }, true);
      this.itemsContainer.setAttribute("aria-live", "off");
      this.resetSlideInterval();
    };
    Carousel2.prototype.renderTemplates = function() {
      if (this.isAngular || this.isReact) {
        this.renderReactTemplates();
      }
    };
    Carousel2.prototype.resetTemplates = function(templates) {
      if (this.isAngular || this.isReact) {
        this.clearTemplate(templates);
      }
    };
    Carousel2.prototype.destroy = function() {
      var _this = this;
      this.resetTemplates();
      if (this.touchModule) {
        this.touchModule.destroy();
        this.touchModule = null;
      }
      this.keyModule.destroy();
      this.keyModule = null;
      this.resetSlideInterval();
      this.destroyButtons();
      this.unWireEvents();
      [].slice.call(this.element.children).forEach(function(ele) {
        _this.element.removeChild(ele);
      });
      removeClass([this.element], [CLS_CAROUSEL, this.cssClass, CLS_RTL6, CLS_SWIPE]);
      ["role", "style"].forEach(function(attr) {
        _this.element.removeAttribute(attr);
      });
      this.itemsContainer = null;
      _super.prototype.destroy.call(this);
    };
    __decorate41([
      Collection([], CarouselItem)
    ], Carousel2.prototype, "items", void 0);
    __decorate41([
      Property("Slide")
    ], Carousel2.prototype, "animationEffect", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "previousButtonTemplate", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "nextButtonTemplate", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "indicatorsTemplate", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "playButtonTemplate", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "cssClass", void 0);
    __decorate41([
      Property([])
    ], Carousel2.prototype, "dataSource", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "itemTemplate", void 0);
    __decorate41([
      Property(0)
    ], Carousel2.prototype, "selectedIndex", void 0);
    __decorate41([
      Property("100%")
    ], Carousel2.prototype, "width", void 0);
    __decorate41([
      Property("100%")
    ], Carousel2.prototype, "height", void 0);
    __decorate41([
      Property(5e3)
    ], Carousel2.prototype, "interval", void 0);
    __decorate41([
      Property(true)
    ], Carousel2.prototype, "autoPlay", void 0);
    __decorate41([
      Property(true)
    ], Carousel2.prototype, "pauseOnHover", void 0);
    __decorate41([
      Property(true)
    ], Carousel2.prototype, "loop", void 0);
    __decorate41([
      Property(false)
    ], Carousel2.prototype, "showPlayButton", void 0);
    __decorate41([
      Property(true)
    ], Carousel2.prototype, "enableTouchSwipe", void 0);
    __decorate41([
      Property(true)
    ], Carousel2.prototype, "showIndicators", void 0);
    __decorate41([
      Property("Default")
    ], Carousel2.prototype, "indicatorsType", void 0);
    __decorate41([
      Property("Visible")
    ], Carousel2.prototype, "buttonsVisibility", void 0);
    __decorate41([
      Property(false)
    ], Carousel2.prototype, "partialVisible", void 0);
    __decorate41([
      Property(CarouselSwipeMode.Touch)
    ], Carousel2.prototype, "swipeMode", void 0);
    __decorate41([
      Property()
    ], Carousel2.prototype, "htmlAttributes", void 0);
    __decorate41([
      Event()
    ], Carousel2.prototype, "slideChanging", void 0);
    __decorate41([
      Event()
    ], Carousel2.prototype, "slideChanged", void 0);
    Carousel2 = __decorate41([
      NotifyPropertyChanges
    ], Carousel2);
    return Carousel2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/appbar/appbar.js
var __extends43 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_APPBAR = "e-appbar";
var CLS_HORIZONTAL_BOTTOM = "e-horizontal-bottom";
var CLS_STICKY = "e-sticky";
var CLS_PROMINENT = "e-prominent";
var CLS_DENSE = "e-dense";
var CLS_RTL7 = "e-rtl";
var CLS_LIGHT = "e-light";
var CLS_DARK = "e-dark";
var CLS_PRIMARY = "e-primary";
var CLS_INHERIT = "e-inherit";
var AppBar = (
  /** @class */
  function(_super) {
    __extends43(AppBar2, _super);
    function AppBar2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    AppBar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.element.classList.remove(CLS_APPBAR);
      this.element.removeAttribute("style");
      this.element.removeAttribute("role");
    };
    AppBar2.prototype.getModuleName = function() {
      return "appbar";
    };
    AppBar2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    AppBar2.prototype.preRender = function() {
    };
    AppBar2.prototype.render = function() {
      this.element.classList.add(CLS_APPBAR);
      if (this.element.tagName !== "HEADER") {
        this.element.setAttribute("role", "banner");
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
      }
      if (this.position === "Bottom") {
        this.element.classList.add(CLS_HORIZONTAL_BOTTOM);
      }
      if (this.isSticky) {
        this.element.classList.add(CLS_STICKY);
      }
      if (this.enableRtl) {
        this.element.classList.add(CLS_RTL7);
      }
      this.setHeightMode();
      this.setColorMode();
      if (!isNullOrUndefined(this.htmlAttributes)) {
        this.setHtmlAttributes(this.htmlAttributes, this.element);
      }
    };
    AppBar2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "mode":
            removeClass([this.element], [CLS_DENSE, CLS_PROMINENT]);
            this.setHeightMode();
            break;
          case "position":
            if (this.position === "Bottom") {
              addClass([this.element], CLS_HORIZONTAL_BOTTOM);
            } else {
              removeClass([this.element], CLS_HORIZONTAL_BOTTOM);
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.split(" "));
            }
            break;
          case "isSticky":
            if (this.isSticky) {
              addClass([this.element], CLS_STICKY);
            } else {
              removeClass([this.element], CLS_STICKY);
            }
            break;
          case "htmlAttributes":
            if (!isNullOrUndefined(this.htmlAttributes)) {
              if (!isNullOrUndefined(oldProp.htmlAttributes)) {
                var keys = Object.keys(oldProp.htmlAttributes);
                for (var _b = 0, keys_1 = keys; _b < keys_1.length; _b++) {
                  var key = keys_1[_b];
                  if (key === "class") {
                    removeClass([this.element], oldProp.htmlAttributes["" + key]);
                  } else {
                    this.element.removeAttribute(key);
                  }
                }
              }
              this.setHtmlAttributes(newProp.htmlAttributes, this.element);
            }
            break;
          case "colorMode":
            removeClass([this.element], [CLS_DARK, CLS_PRIMARY, CLS_INHERIT, CLS_LIGHT]);
            this.setColorMode();
            break;
          case "enableRtl":
            if (this.enableRtl) {
              addClass([this.element], CLS_RTL7);
            } else {
              removeClass([this.element], CLS_RTL7);
            }
            break;
        }
      }
    };
    AppBar2.prototype.setHtmlAttributes = function(attribute, element2) {
      var keys = Object.keys(attribute);
      for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        if (key === "class") {
          addClass([element2], attribute["" + key]);
        } else {
          element2.setAttribute(key, attribute["" + key]);
        }
      }
    };
    AppBar2.prototype.setHeightMode = function() {
      if (this.mode === "Prominent") {
        this.element.classList.add(CLS_PROMINENT);
      } else if (this.mode === "Dense") {
        this.element.classList.add(CLS_DENSE);
      }
    };
    AppBar2.prototype.setColorMode = function() {
      switch (this.colorMode) {
        case "Light":
          this.element.classList.add(CLS_LIGHT);
          break;
        case "Dark":
          this.element.classList.add(CLS_DARK);
          break;
        case "Primary":
          this.element.classList.add(CLS_PRIMARY);
          break;
        case "Inherit":
          this.element.classList.add(CLS_INHERIT);
          break;
      }
    };
    __decorate42([
      Property("Regular")
    ], AppBar2.prototype, "mode", void 0);
    __decorate42([
      Property("Top")
    ], AppBar2.prototype, "position", void 0);
    __decorate42([
      Property()
    ], AppBar2.prototype, "cssClass", void 0);
    __decorate42([
      Property(false)
    ], AppBar2.prototype, "isSticky", void 0);
    __decorate42([
      Property()
    ], AppBar2.prototype, "htmlAttributes", void 0);
    __decorate42([
      Property("Light")
    ], AppBar2.prototype, "colorMode", void 0);
    __decorate42([
      Event()
    ], AppBar2.prototype, "created", void 0);
    __decorate42([
      Event()
    ], AppBar2.prototype, "destroyed", void 0);
    AppBar2 = __decorate42([
      NotifyPropertyChanges
    ], AppBar2);
    return AppBar2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/stepper-base/stepper-base.js
var __extends44 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PROGRESSVALUE = "--progress-value";
var StepStatus;
(function(StepStatus2) {
  StepStatus2["NotStarted"] = "NotStarted";
  StepStatus2["InProgress"] = "InProgress";
  StepStatus2["Completed"] = "Completed";
})(StepStatus || (StepStatus = {}));
var Step = (
  /** @class */
  function(_super) {
    __extends44(Step2, _super);
    function Step2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate43([
      Property("")
    ], Step2.prototype, "cssClass", void 0);
    __decorate43([
      Property(false)
    ], Step2.prototype, "disabled", void 0);
    __decorate43([
      Property("")
    ], Step2.prototype, "iconCss", void 0);
    __decorate43([
      Property(null)
    ], Step2.prototype, "isValid", void 0);
    __decorate43([
      Property("")
    ], Step2.prototype, "label", void 0);
    __decorate43([
      Property(false)
    ], Step2.prototype, "optional", void 0);
    __decorate43([
      Property(StepStatus.NotStarted)
    ], Step2.prototype, "status", void 0);
    __decorate43([
      Property("")
    ], Step2.prototype, "text", void 0);
    return Step2;
  }(ChildProperty)
);
var StepperOrientation;
(function(StepperOrientation2) {
  StepperOrientation2["Horizontal"] = "Horizontal";
  StepperOrientation2["Vertical"] = "Vertical";
})(StepperOrientation || (StepperOrientation = {}));
var StepperBase = (
  /** @class */
  function(_super) {
    __extends44(StepperBase2, _super);
    function StepperBase2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    StepperBase2.prototype.preRender = function() {
    };
    StepperBase2.prototype.getModuleName = function() {
      return "stepperBase";
    };
    StepperBase2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    StepperBase2.prototype.render = function() {
    };
    StepperBase2.prototype.updateOrientaion = function(wrapper) {
      if (wrapper.classList.contains("e-horizontal") || wrapper.classList.contains("e-vertical")) {
        wrapper.classList.remove("e-horizontal", "e-vertical");
      }
      if (!isNullOrUndefined(this.orientation)) {
        wrapper.classList.add("e-" + this.orientation.toLocaleLowerCase());
      }
    };
    StepperBase2.prototype.renderProgressBar = function(wrapper) {
      this.progressStep = this.createElement("div", { className: "e-stepper-progressbar" });
      this.progressbar = this.createElement("div", { className: "e-progressbar-value" });
      this.progressStep.appendChild(this.progressbar);
      wrapper.prepend(this.progressStep);
      this.progressbar.style.setProperty(PROGRESSVALUE, "0%");
      var beforeLabel = wrapper.querySelector("li").querySelector(".e-step-label-container");
      if (wrapper.classList.contains("e-vertical")) {
        if (wrapper.classList.contains("e-label-bottom") || wrapper.classList.contains("e-label-top")) {
          var stepsContainer = wrapper.querySelector(".e-stepper-steps");
          this.progressStep.style.setProperty("--progress-position", stepsContainer.offsetWidth / 2 + "px");
        } else {
          this.progressStep.style.setProperty("--progress-position", this.progressBarPosition / 2 - 1 + "px");
        }
      }
      if (beforeLabel && beforeLabel.classList.contains("e-label-before")) {
        this.progressStep.style.setProperty("--progress-position", this.progressBarPosition - 1 + 5 + "px");
      }
      if (wrapper.classList.contains("e-horizontal")) {
        this.setProgressPosition(wrapper);
      }
    };
    StepperBase2.prototype.setProgressPosition = function(wrapper, isResize) {
      var stepItemContainer = wrapper.querySelector(".e-step-container");
      var stepItemEle = stepItemContainer.firstElementChild;
      if (isResize !== true) {
        var topPos = 0;
        if (wrapper.classList.contains("e-label-before")) {
          topPos = stepItemContainer.offsetParent.offsetHeight - stepItemEle.offsetHeight / 2 - 1;
        } else {
          topPos = stepItemEle.offsetHeight / 2;
        }
        this.progressStep.style.setProperty("--progress-top-position", topPos + "px");
      }
      var lastEle = wrapper.querySelector(".e-stepper-steps").lastChild.firstChild;
      if (wrapper.classList.contains("e-rtl")) {
        var leftPost = stepItemEle.offsetLeft + stepItemEle.offsetWidth - wrapper.querySelector(".e-stepper-steps").offsetWidth;
        this.progressStep.style.setProperty("--progress-left-position", Math.abs(leftPost) + "px");
        this.progressStep.style.setProperty("--progress-bar-width", Math.abs(lastEle.offsetLeft - stepItemEle.offsetLeft) + "px");
      } else {
        this.progressStep.style.setProperty("--progress-left-position", stepItemEle.offsetLeft + 1 + "px");
        this.progressStep.style.setProperty("--progress-bar-width", lastEle.offsetWidth + lastEle.offsetLeft - 2 - (stepItemEle.offsetLeft + 2) + "px");
      }
    };
    StepperBase2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    __decorate43([
      Collection([], Step)
    ], StepperBase2.prototype, "steps", void 0);
    __decorate43([
      Property("")
    ], StepperBase2.prototype, "cssClass", void 0);
    __decorate43([
      Property(false)
    ], StepperBase2.prototype, "readOnly", void 0);
    __decorate43([
      Property(StepperOrientation.Horizontal)
    ], StepperBase2.prototype, "orientation", void 0);
    __decorate43([
      Event()
    ], StepperBase2.prototype, "created", void 0);
    StepperBase2 = __decorate43([
      NotifyPropertyChanges
    ], StepperBase2);
    return StepperBase2;
  }(Component)
);

// node_modules/@syncfusion/ej2-navigations/src/stepper/stepper.js
var __extends45 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ITEMCONTAINER2 = "e-step-container";
var ITEMLIST2 = "e-stepper-steps";
var ICONCSS2 = "e-indicator";
var TEXTCSS = "e-step-text-container";
var STEPLABEL = "e-step-label-container";
var OPTIONAL = "e-step-label-optional";
var SELECTED4 = "e-step-selected";
var INPROGRESS = "e-step-inprogress";
var NOTSTARTED = "e-step-notstarted";
var FOCUS2 = "e-step-focus";
var COMPLETED = "e-step-completed";
var DISABLED9 = "e-step-disabled";
var READONLY2 = "e-stepper-readonly";
var PROGRESSVALUE2 = "--progress-value";
var RTL14 = "e-rtl";
var TEMPLATE = "e-step-template";
var LABELAFTER = "e-label-after";
var LABELBEFORE = "e-label-before";
var VERTICALSTEP = "e-vertical";
var HORIZSTEP = "e-horizontal";
var STEPICON = "e-step-item";
var STEPTEXT = "e-step-text";
var TEXT = "e-text";
var STEPSLABEL = "e-step-label";
var LABEL4 = "e-label";
var STEPINDICATOR = "e-step-type-indicator";
var LABELINDICATOR = "e-step-type-label";
var INDICATORICON = "e-step-indicator";
var STEPPERTOOLTIP = "e-stepper-tooltip";
var STEPPERIPROGRESSTIP = "e-step-inprogress-tip";
var LINEARSTEP = "e-linear";
var PREVSTEP = "e-previous";
var NEXTSTEP = "e-next";
var StepperAnimationSettings = (
  /** @class */
  function(_super) {
    __extends45(StepperAnimationSettings2, _super);
    function StepperAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate44([
      Property(true)
    ], StepperAnimationSettings2.prototype, "enable", void 0);
    __decorate44([
      Property(2e3)
    ], StepperAnimationSettings2.prototype, "duration", void 0);
    __decorate44([
      Property(0)
    ], StepperAnimationSettings2.prototype, "delay", void 0);
    return StepperAnimationSettings2;
  }(ChildProperty)
);
var StepLabelPosition;
(function(StepLabelPosition2) {
  StepLabelPosition2["Top"] = "Top";
  StepLabelPosition2["Bottom"] = "Bottom";
  StepLabelPosition2["Start"] = "Start";
  StepLabelPosition2["End"] = "End";
})(StepLabelPosition || (StepLabelPosition = {}));
var StepType;
(function(StepType2) {
  StepType2["Default"] = "Default";
  StepType2["Label"] = "Label";
  StepType2["Indicator"] = "Indicator";
})(StepType || (StepType = {}));
var Stepper = (
  /** @class */
  function(_super) {
    __extends45(Stepper2, _super);
    function Stepper2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.stepperItemElements = [];
      return _this;
    }
    Stepper2.prototype.preRender = function() {
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      var localeText = { optional: "Optional" };
      this.l10n = new L10n("stepper", localeText, this.locale);
      this.keyConfigs = {
        downarrow: "downarrow",
        leftarrow: "leftarrow",
        rightarrow: "rightarrow",
        uparrow: "uparrow",
        space: "space",
        enter: "enter",
        home: "home",
        end: "end",
        tab: "tab",
        shiftTab: "shift+tab",
        escape: "escape"
      };
      this.tooltipOpen = false;
    };
    Stepper2.prototype.getModuleName = function() {
      return "stepper";
    };
    Stepper2.prototype.render = function() {
      this.initialize();
      this.navigationHandler(this.activeStep, null, false);
      this.updateStepperStatus(true);
    };
    Stepper2.prototype.initialize = function() {
      var _this = this;
      this.element.setAttribute("aria-label", this.element.id);
      this.updatePosition();
      this.stepperItemList = this.createElement("ol", { className: ITEMLIST2 });
      this.updateOrientaion(this.element);
      this.updateStepType();
      this.element.appendChild(this.stepperItemList);
      if (this.cssClass) {
        addClass([this.element], this.cssClass.trim().split(" "));
      }
      if (this.readOnly) {
        this.element.classList.add(READONLY2);
      }
      if (this.enableRtl) {
        this.element.classList.add(RTL14);
      }
      this.wireEvents();
      this.updateTemplateFunction();
      this.renderItems();
      if (this.steps.length > 0) {
        if (this.steps.length > 1) {
          if (this.isAngular && this.template) {
            setTimeout(function() {
              _this.renderProgressBar(_this.element);
            });
          } else {
            this.renderProgressBar(this.element);
          }
        }
        this.checkValidStep();
        this.updateAnimation();
        this.updateTooltip();
        this.wireKeyboardEvent();
      }
    };
    Stepper2.prototype.updatePosition = function() {
      this.progressBarPosition = this.beforeLabelWidth = this.textEleWidth = 0;
    };
    Stepper2.prototype.renderDefault = function(index) {
      return !this.steps[parseInt(index.toString(), 10)].iconCss && !this.steps[parseInt(index.toString(), 10)].text && !this.steps[parseInt(index.toString(), 10)].label ? true : false;
    };
    Stepper2.prototype.updateAnimation = function() {
      var progressEle = this.element.querySelector(".e-progressbar-value");
      if (this.animation.enable) {
        if (this.animation.duration >= 0) {
          if (progressEle) {
            progressEle.style.setProperty("--duration", this.animation.duration + "ms");
          }
        }
        if (this.animation.delay >= 0) {
          if (progressEle) {
            progressEle.style.setProperty("--delay", this.animation.delay + "ms");
          }
        }
      } else {
        if (progressEle) {
          progressEle.style.setProperty("--delay", "0ms");
          progressEle.style.setProperty("--duration", "0ms");
        }
      }
    };
    Stepper2.prototype.updateStepType = function() {
      if (!isNullOrUndefined(this.stepType) && (this.stepType.toLowerCase() === "indicator" || this.stepType.toLowerCase() === "label" || this.stepType.toLowerCase() === "default")) {
        if (this.stepType.toLowerCase() !== "default") {
          this.element.classList.add("e-step-type-" + this.stepType.toLowerCase());
        }
        if ((this.stepType.toLowerCase() === "indicator" || "label") && this.labelContainer) {
          this.clearLabelPosition();
        }
      }
    };
    Stepper2.prototype.wireEvents = function() {
      var _this = this;
      EventHandler.add(window, "resize", function() {
        if (_this.stepperItemList && _this.progressbar && _this.element.classList.contains(HORIZSTEP)) {
          _this.setProgressPosition(_this.element, true);
        }
        _this.navigateToStep(_this.activeStep, null, null, false);
      }, this);
      EventHandler.add(window, "click", function() {
        _this.updateStepFocus();
      }, this);
    };
    Stepper2.prototype.unWireEvents = function() {
      var _this = this;
      EventHandler.remove(window, "resize", function() {
        if (_this.stepperItemList && _this.progressbar && _this.element.classList.contains(HORIZSTEP)) {
          _this.setProgressPosition(_this.element, true);
        }
      });
      EventHandler.remove(window, "click", function() {
        _this.updateStepFocus();
      });
    };
    Stepper2.prototype.updateStepFocus = function() {
      if (this.isKeyNavFocus) {
        this.isKeyNavFocus = false;
        var isFocus = this.element.querySelector("." + FOCUS2);
        if (isFocus) {
          isFocus.classList.remove(FOCUS2);
          this.element.classList.remove("e-steps-focus");
        }
      }
    };
    Stepper2.prototype.updateStepperStatus = function(isInitial) {
      for (var index = 0; index < this.steps.length; index++) {
        var item = this.steps[parseInt(index.toString(), 10)];
        var status_1 = item.status.toLowerCase();
        if (isInitial && this.activeStep === 0 && index === 0) {
          var prevOnChange = this.isProtectedOnChange;
          this.isProtectedOnChange = true;
          item.status = StepStatus.InProgress;
          this.isProtectedOnChange = prevOnChange;
        }
        if (item && status_1 !== "notstarted" && index === this.activeStep) {
          for (var i = 0; i < this.steps.length; i++) {
            var itemElement = this.stepperItemElements[parseInt(i.toString(), 10)];
            itemElement.classList.remove(SELECTED4, INPROGRESS, COMPLETED, NOTSTARTED);
            var prevOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            if (status_1 === "completed") {
              this.updateStatusClass(i, index, itemElement);
            } else {
              this.updateStatusClass(i, index, itemElement, true);
            }
            this.isProtectedOnChange = prevOnChange;
          }
        } else if (item && status_1 !== "notstarted" && index !== this.activeStep) {
          this.navigationHandler(this.activeStep, null, true);
        }
      }
    };
    Stepper2.prototype.updateStatusClass = function(currentStep, index, ele, isInprogress) {
      var stepItem = this.steps[parseInt(currentStep.toString(), 10)];
      if (currentStep < index) {
        ele.classList.add(COMPLETED);
        stepItem.status = StepStatus.Completed;
      } else if (currentStep === index) {
        ele.classList.add(isInprogress ? INPROGRESS : COMPLETED, SELECTED4);
      } else {
        ele.classList.add(NOTSTARTED);
      }
    };
    Stepper2.prototype.renderItems = function() {
      var _this = this;
      for (var index = 0; index < this.steps.length; index++) {
        this.stepperItemContainer = this.createElement("li", { className: ITEMCONTAINER2 });
        this.stepperItemContainer.classList[index === 0 ? "add" : "remove"](SELECTED4, INPROGRESS);
        this.stepperItemContainer.classList[index !== 0 ? "add" : "remove"](NOTSTARTED);
        if (this.element.classList.contains(HORIZSTEP)) {
          this.stepperItemContainer.style.setProperty("--max-width", 100 / this.steps.length + "%");
        }
        var stepSpan = this.createElement("span", { className: "e-step" });
        var item = this.steps[parseInt(index.toString(), 10)];
        if (this.renderDefault(index) && (isNullOrUndefined(this.template) || this.template === "")) {
          var isIndicator = !this.element.classList.contains("e-step-type-default") && this.stepType.toLowerCase() === "indicator" ? true : false;
          if (isIndicator) {
            stepSpan.classList.add("e-icons", INDICATORICON);
          }
          if (!isIndicator && item.isValid == null) {
            stepSpan.classList.add("e-step-content");
            stepSpan.innerHTML = (index + 1).toString();
          }
          this.stepperItemContainer.appendChild(stepSpan);
        } else if (isNullOrUndefined(this.template) || this.template === "") {
          var isRender = true;
          if ((item.iconCss || !item.iconCss && item.text && item.label) && (!item.text && !item.label || !this.element.classList.contains(LABELINDICATOR))) {
            if (item.iconCss) {
              var itemIcon = item.iconCss.trim().split(" ");
              stepSpan.classList.add(ICONCSS2);
              for (var i = 0; i < itemIcon.length; i++) {
                stepSpan.classList.add(itemIcon[parseInt(i.toString(), 10)]);
              }
              this.stepperItemContainer.classList.add(STEPICON);
            } else if (!item.iconCss && item.text && item.label) {
              stepSpan.classList.add(ICONCSS2);
              stepSpan.innerHTML = item.text;
              this.stepperItemContainer.classList.add(STEPICON);
            }
            this.stepperItemContainer.appendChild(stepSpan);
            if (this.element.classList.contains(HORIZSTEP) && (this.labelPosition.toLowerCase() === "start" || this.labelPosition.toLowerCase() === "end") && item.label || this.element.classList.contains(VERTICALSTEP) && (this.labelPosition.toLowerCase() === "top" || this.labelPosition.toLowerCase() === "bottom") && item.label) {
              this.element.classList.add("e-label-" + this.labelPosition.toLowerCase());
              var textSpan = this.createElement("span", { className: TEXTCSS + " " + TEXT });
              textSpan.innerText = item.label;
              this.stepperItemContainer.appendChild(textSpan);
              this.stepperItemContainer.classList.add(STEPTEXT);
              isRender = false;
            }
          }
          if (item.text && (!item.iconCss || !this.element.classList.contains(STEPINDICATOR)) && isRender && !(item.iconCss && item.label)) {
            if (!item.iconCss && this.element.classList.contains(STEPINDICATOR) || (!item.iconCss || this.element.classList.contains(LABELINDICATOR)) && !item.label) {
              if (!item.iconCss && !item.label) {
                this.element.classList.add("e-step-type-indicator");
              }
              this.checkValidState(item, stepSpan);
              var prevOnChange = this.isProtectedOnChange;
              this.isProtectedOnChange = true;
              item.label = null;
              this.isProtectedOnChange = prevOnChange;
            } else {
              var textSpan = this.createElement("span", { className: TEXT });
              if (!item.label) {
                textSpan.innerText = item.text;
                textSpan.classList.add(TEXTCSS);
                this.stepperItemContainer.appendChild(textSpan);
                this.stepperItemContainer.classList.add(STEPTEXT);
              }
              if (item.label && this.element.classList.contains(LABELINDICATOR)) {
                textSpan.innerText = item.label;
              }
              var prevOnChange = this.isProtectedOnChange;
              this.isProtectedOnChange = true;
              item.text = item.label ? null : item.text;
              this.isProtectedOnChange = prevOnChange;
            }
          }
          if (item.label && (!item.iconCss || !this.element.classList.contains(STEPINDICATOR)) && isRender) {
            if (!item.iconCss && !item.text && this.element.classList.contains(STEPINDICATOR)) {
              this.checkValidState(item, stepSpan, true);
            } else if (!(this.element.classList.contains(LABELINDICATOR) && item.text) || this.element.classList.contains(LABELINDICATOR) && item.label) {
              this.labelContainer = this.createElement("span", { className: STEPLABEL });
              var labelSpan = this.createElement("span", { className: LABEL4 });
              labelSpan.innerText = item.label;
              this.labelContainer.appendChild(labelSpan);
              this.stepperItemContainer.classList.add(STEPSLABEL);
              this.updateLabelPosition();
              if (!item.iconCss && !item.text && !this.stepperItemContainer.classList.contains(STEPICON) || this.element.classList.contains(LABELINDICATOR)) {
                this.stepperItemContainer.classList.add("e-step-label-only");
                if (item.isValid !== null) {
                  var iconSpan = this.createElement("span", { className: "e-step-validation-icon e-icons" });
                  this.labelContainer.appendChild(iconSpan);
                }
              }
            }
          }
        }
        if (item.optional) {
          var optionalSpan = this.createElement("span", { className: OPTIONAL });
          this.l10n.setLocale(this.locale);
          var optionalContent = this.l10n.getConstant("optional");
          optionalSpan.innerText = optionalContent;
          if (item.label && (this.labelContainer && (this.element.classList.contains(LABELAFTER) && !this.stepperItemContainer.classList.contains("e-step-label-only") || this.element.classList.contains(HORIZSTEP) && this.element.classList.contains(LABELBEFORE) && !this.stepperItemContainer.classList.contains("e-step-label-only"))) || this.element.classList.contains(VERTICALSTEP) && this.element.classList.contains(LABELBEFORE)) {
            this.labelContainer.appendChild(optionalSpan);
          } else {
            this.stepperItemContainer.appendChild(optionalSpan);
          }
          if (item.isValid !== null) {
            this.stepperItemContainer.classList.add(item.isValid ? "e-step-valid" : "e-step-error");
          }
        }
        if (item.cssClass) {
          addClass([this.stepperItemContainer], item.cssClass.trim().split(" "));
        }
        if (item.disabled) {
          this.stepperItemContainer.classList[item.disabled ? "add" : "remove"](DISABLED9);
          attributes(this.stepperItemContainer, { "tabindex": "-1", "aria-disabled": "true" });
        }
        if (item.isValid !== null) {
          if (item.isValid) {
            this.stepperItemContainer.classList.add("e-step-valid");
          } else {
            this.stepperItemContainer.classList.add("e-step-error");
          }
        }
        this.renderItemContent(index, false);
        if (this.stepperItemContainer.classList.contains(INPROGRESS)) {
          attributes(this.stepperItemContainer, { "tabindex": "0", "aria-current": "true" });
        } else {
          attributes(this.stepperItemContainer, { "tabindex": "-1" });
        }
        this.wireItemsEvents(this.stepperItemContainer, index);
        this.stepperItemElements.push(this.stepperItemContainer);
        var eventArgs = { element: this.stepperItemContainer, index };
        this.trigger("beforeStepRender", eventArgs, function(args) {
          _this.stepperItemList.appendChild(args.element);
        });
        if (this.isAngular && this.template) {
          setTimeout(function() {
            _this.calculateProgressBarPosition();
          });
        } else {
          this.calculateProgressBarPosition();
        }
      }
      if (this.element.classList.contains(VERTICALSTEP)) {
        if (this.element.classList.contains(LABELBEFORE)) {
          var listItems = this.stepperItemList.querySelectorAll("." + LABEL4);
          for (var i = 0; i < listItems.length; i++) {
            var labelEle = listItems[parseInt(i.toString(), 10)];
            labelEle.style.setProperty("--label-width", this.beforeLabelWidth + 5 + "px");
          }
        }
      }
    };
    Stepper2.prototype.calculateProgressBarPosition = function() {
      var isBeforeLabel = this.element.classList.contains(LABELBEFORE) ? true : false;
      var isStepVertical = this.element.classList.contains(VERTICALSTEP) ? true : false;
      if (isStepVertical) {
        var iconOnly = this.stepperItemContainer.classList.contains(STEPICON) && !this.stepperItemContainer.classList.contains(STEPTEXT) && !this.stepperItemContainer.classList.contains(STEPSLABEL) ? true : false;
        var textEle = this.stepperItemContainer.querySelector("." + TEXTCSS);
        if (textEle) {
          this.textEleWidth = this.textEleWidth < textEle.offsetWidth ? textEle.offsetWidth : this.textEleWidth;
        }
        if (isBeforeLabel) {
          var itemWidth = void 0;
          var labelWidth = this.stepperItemContainer.querySelector("." + LABEL4).offsetWidth + 15;
          if (this.beforeLabelWidth < labelWidth) {
            this.beforeLabelWidth = labelWidth;
          }
          if (this.element.querySelector("ol").lastChild.querySelector("." + ICONCSS2)) {
            itemWidth = this.beforeLabelWidth + this.stepperItemContainer.querySelector("." + ICONCSS2).offsetWidth / 2;
          } else if (this.stepperItemContainer.querySelector("." + TEXTCSS)) {
            itemWidth = this.beforeLabelWidth + this.stepperItemContainer.querySelector("." + TEXTCSS).offsetWidth / 2;
          }
          if (this.progressBarPosition < itemWidth) {
            this.progressBarPosition = itemWidth;
          }
        } else if (this.progressBarPosition < (iconOnly ? this.stepperItemContainer.offsetWidth : this.element.querySelector("ol").lastChild.firstChild.offsetWidth)) {
          this.progressBarPosition = iconOnly ? this.stepperItemContainer.offsetWidth : this.element.querySelector("ol").lastChild.firstChild.offsetWidth;
        }
      }
    };
    Stepper2.prototype.checkValidState = function(item, stepSpan, isLabel) {
      if (item.isValid == null) {
        stepSpan.classList.add("e-step-content");
        if (isLabel) {
          stepSpan.innerHTML = item.label;
        } else {
          stepSpan.innerHTML = item.label ? item.label : item.text;
        }
        this.stepperItemContainer.appendChild(stepSpan);
      } else {
        stepSpan.classList.add(ICONCSS2);
        this.stepperItemContainer.appendChild(stepSpan);
        this.stepperItemContainer.classList.add(STEPICON);
      }
    };
    Stepper2.prototype.updateCurrentLabel = function() {
      var currentLabelPos;
      if (this.element.classList.contains(HORIZSTEP)) {
        currentLabelPos = this.labelPosition.toLowerCase() === "top" ? "before" : this.labelPosition.toLowerCase() === "bottom" ? "after" : this.labelPosition.toLowerCase();
      } else {
        currentLabelPos = this.labelPosition.toLowerCase() === "start" ? "before" : this.labelPosition.toLowerCase() === "end" ? "after" : this.labelPosition.toLowerCase();
      }
      return currentLabelPos;
    };
    Stepper2.prototype.updateLabelPosition = function() {
      this.clearLabelPosition();
      this.labelContainer.classList.add("e-label-" + this.updateCurrentLabel());
      if (this.labelPosition.toLowerCase() === "start" && this.orientation.toLowerCase() === "vertical") {
        if (this.stepperItemContainer.firstChild) {
          this.stepperItemContainer.firstChild.before(this.labelContainer);
        } else {
          this.stepperItemContainer.appendChild(this.labelContainer);
        }
      } else {
        this.stepperItemContainer.appendChild(this.labelContainer);
      }
      this.element.classList.add("e-label-" + this.updateCurrentLabel());
    };
    Stepper2.prototype.clearLabelPosition = function() {
      var removeCss = this.labelContainer.classList.value.match(/(e-label-[after|before]+)/g);
      if (removeCss) {
        removeClass([this.labelContainer], removeCss);
        removeClass([this.element], removeCss);
      }
    };
    Stepper2.prototype.checkValidStep = function() {
      for (var index = 0; index < this.steps.length; index++) {
        var item = this.steps[parseInt(index.toString(), 10)];
        var itemElement = this.stepperItemElements[parseInt(index.toString(), 10)];
        if (item.isValid !== null) {
          var indicatorEle = void 0;
          var iconEle = void 0;
          if (this.element.classList.contains(STEPINDICATOR) && !item.iconCss) {
            indicatorEle = itemElement.querySelector("." + ICONCSS2);
          } else {
            iconEle = itemElement.querySelector("." + ICONCSS2);
          }
          if (!indicatorEle && this.element.classList.contains(STEPINDICATOR) && this.renderDefault(index)) {
            indicatorEle = itemElement.querySelector("." + INDICATORICON);
          }
          var textLabelIcon = itemElement.querySelector(".e-step-validation-icon");
          var itemIcon = item.iconCss.trim().split(" ");
          var validStep = itemElement.classList.contains("e-step-valid");
          if (indicatorEle) {
            indicatorEle.classList.remove(INDICATORICON);
            if (indicatorEle.innerHTML !== "") {
              indicatorEle.innerHTML = "";
            }
            indicatorEle.classList.add("e-icons", validStep ? "e-check" : "e-circle-info", ICONCSS2);
          }
          if (this.renderDefault(index) && !this.element.classList.contains(STEPINDICATOR)) {
            var stepSpan = itemElement.querySelector(".e-step");
            stepSpan.classList.add("e-icons", validStep ? "e-check" : "e-circle-info", ICONCSS2);
          }
          if (iconEle) {
            if (iconEle.innerHTML !== "") {
              iconEle.innerHTML = "";
            } else if (itemIcon.length > 0) {
              for (var i = 0; i < itemIcon.length; i++) {
                iconEle.classList.remove(itemIcon[parseInt(i.toString(), 10)]);
              }
            }
            iconEle.classList.add("e-icons", validStep ? "e-check" : "e-circle-info");
          }
          if (textLabelIcon) {
            textLabelIcon.classList.add(validStep ? "e-circle-check" : "e-circle-info");
            if (this.element.classList.contains(VERTICALSTEP)) {
              var labelEle = itemElement.querySelector("." + LABEL4);
              var textEle = itemElement.querySelector("." + TEXT);
              var itemWidth = textEle ? textEle.offsetWidth + textEle.getBoundingClientRect().left : labelEle.offsetWidth + labelEle.getBoundingClientRect().left;
              var validationIcon = itemElement.querySelector(".e-step-validation-icon");
              validationIcon.style.setProperty("--icon-position", itemWidth + 20 + "px");
            }
          }
        }
      }
    };
    Stepper2.prototype.updateTooltip = function() {
      if (this.showTooltip) {
        this.tooltipObj = new Tooltip({
          target: ".e-step-container",
          windowCollision: true,
          opensOn: "Custom",
          cssClass: this.cssClass ? STEPPERTOOLTIP + " " + this.cssClass : STEPPERTOOLTIP,
          position: "TopCenter"
        });
        this.tooltipObj.appendTo(this.stepperItemList);
      } else {
        if (!isNullOrUndefined(this.tooltipObj)) {
          this.tooltipObj.destroy();
          this.tooltipObj = null;
        }
      }
    };
    Stepper2.prototype.wireItemsEvents = function(itemElement, index) {
      var _this = this;
      EventHandler.add(itemElement, "click", function(e) {
        if (_this.linear) {
          var linearModeValue = index - _this.activeStep;
          if (Math.abs(linearModeValue) === 1) {
            _this.stepClickHandler(index, e, itemElement);
          }
        } else {
          _this.stepClickHandler(index, e, itemElement);
        }
      }, this);
      EventHandler.add(itemElement, "mouseover", function() {
        return _this.openStepperTooltip(index);
      }, this);
      EventHandler.add(itemElement, "mouseleave", function() {
        return _this.closeStepperTooltip();
      }, this);
    };
    Stepper2.prototype.openStepperTooltip = function(index) {
      var currentStep = this.steps[parseInt(index.toString(), 10)];
      if (this.showTooltip && (currentStep.label || currentStep.text)) {
        if (!this.tooltipOpen) {
          this.updateTooltipContent(index);
          this.tooltipObj.open(this.stepperItemElements[parseInt(index.toString(), 10)]);
          if (this.stepType.toLocaleLowerCase() !== "label" && (this.stepType.toLocaleLowerCase() === "indicator" || currentStep.label !== "" && currentStep.iconCss !== "" || currentStep.label === null && currentStep.iconCss === "" && currentStep.text !== "")) {
            var tooltipPopupClass = currentStep.status.toLowerCase() === "inprogress" ? STEPPERTOOLTIP + " " + STEPPERIPROGRESSTIP + " " + (this.cssClass ? this.cssClass : "") : STEPPERTOOLTIP + " " + (this.cssClass ? this.cssClass : "");
            this.tooltipObj.setProperties({ cssClass: tooltipPopupClass.trim() });
          }
          this.tooltipOpen = true;
        }
      }
    };
    Stepper2.prototype.closeStepperTooltip = function() {
      if (this.tooltipOpen) {
        this.tooltipObj.close();
        this.tooltipOpen = false;
      }
    };
    Stepper2.prototype.updateTooltipContent = function(index) {
      if (this.showTooltip) {
        if (this.isReact) {
          this.clearTemplate(["stepperTooltipTemplate"]);
        }
        var content = void 0;
        var currentStep = this.steps[parseInt(index.toString(), 10)];
        if (this.tooltipTemplate) {
          content = this.createElement("span", { className: "e-stepper-tooltip-content" });
          var templateFunction = this.getTemplateFunction(this.tooltipTemplate);
          append(templateFunction({ value: currentStep }, this, "stepperTooltipTemplate", this.element.id + "tooltipTemplate", this.isStringTemplate), content);
          this.tooltipObj.setProperties({ content }, true);
        } else {
          var content_1 = currentStep.label ? currentStep.label : currentStep.text;
          this.tooltipObj.setProperties({ content: initializeCSPTemplate(function() {
            return content_1;
          }) }, true);
        }
        this.renderReactTemplates();
      }
    };
    Stepper2.prototype.stepClickHandler = function(index, e, itemElement) {
      var clickEventArgs = {
        element: itemElement,
        event: e,
        previousStep: this.activeStep,
        activeStep: index
      };
      this.trigger("stepClick", clickEventArgs);
      this.navigateToStep(index, e, itemElement, true);
    };
    Stepper2.prototype.updateTemplateFunction = function() {
      this.templateFunction = this.template ? this.getTemplateFunction(this.template) : null;
    };
    Stepper2.prototype.renderItemContent = function(index, isrerender) {
      var listItems = this.stepperItemList.querySelectorAll("li");
      if (isrerender) {
        this.removeItemContent(listItems[parseInt(index.toString(), 10)]);
      }
      if (this.template) {
        if (isrerender) {
          listItems[parseInt(index.toString(), 10)].classList.add(TEMPLATE);
        } else {
          this.stepperItemContainer.classList.add(TEMPLATE);
        }
        var item = this.steps[parseInt(index.toString(), 10)];
        append(this.templateFunction({ step: item, currentStep: index }, this, "stepperTemplate", this.element.id + "_stepperTemplate", this.isStringTemplate), isrerender ? listItems[parseInt(index.toString(), 10)] : this.stepperItemContainer);
      }
      this.renderReactTemplates();
    };
    Stepper2.prototype.removeItemContent = function(ele) {
      ele.classList.remove(TEMPLATE);
      var firstChild = ele.firstElementChild;
      for (var i = 0; i < ele.childElementCount; i++) {
        firstChild.remove();
      }
    };
    Stepper2.prototype.updateContent = function() {
      if (this.isReact) {
        this.clearTemplate(["stepperTemplate"]);
      }
      for (var i = 0; i < this.steps.length; i++) {
        this.renderItemContent(i, true);
      }
    };
    Stepper2.prototype.getTemplateFunction = function(template) {
      if (typeof template === "string") {
        var content = "";
        try {
          var tempEle = select(template);
          if (tempEle) {
            content = tempEle.tagName === "SCRIPT" ? tempEle.innerHTML : tempEle.outerHTML;
          } else {
            content = template;
          }
        } catch (e) {
          content = template;
        }
        return compile(content);
      } else {
        return compile(template);
      }
    };
    Stepper2.prototype.navigateToStep = function(index, e, itemElement, isInteracted, isUpdated) {
      var _this = this;
      var eventArgs = {
        element: itemElement,
        event: e,
        isInteracted,
        previousStep: this.activeStep,
        activeStep: index,
        cancel: false
      };
      if (isUpdated !== false) {
        var previousStep_1 = this.activeStep;
        this.trigger("stepChanging", eventArgs, function(args) {
          if (args.cancel) {
            return;
          }
          _this.navigationHandler(index);
          var eventArgs2 = {
            element: itemElement,
            event: e,
            isInteracted,
            previousStep: previousStep_1,
            activeStep: _this.activeStep
          };
          _this.trigger("stepChanged", eventArgs2);
        });
      } else {
        this.navigationHandler(index);
      }
    };
    Stepper2.prototype.navigationHandler = function(index, stepStatus, isUpdated) {
      index = index >= this.steps.length - 1 ? this.steps.length - 1 : index;
      var Itemslength = this.stepperItemElements.length;
      if (index >= 0 && index < Itemslength - 1) {
        index = this.stepperItemElements[parseInt(index.toString(), 10)].classList.contains(DISABLED9) ? this.activeStep : index;
      }
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      this.activeStep = parseInt(index.toString(), 10);
      this.isProtectedOnChange = prevOnChange;
      for (var i = 0; i < this.steps.length; i++) {
        var itemElement = this.stepperItemElements[parseInt(i.toString(), 10)];
        var item = this.steps[parseInt(i.toString(), 10)];
        itemElement.classList.remove(SELECTED4, INPROGRESS, COMPLETED, NOTSTARTED);
        if (i === this.activeStep) {
          itemElement.classList.add(SELECTED4);
        }
        if (this.activeStep >= 0 && this.progressbar) {
          if (this.element.classList.contains(HORIZSTEP)) {
            if ((this.element.classList.contains(LABELBEFORE) || this.element.classList.contains(LABELAFTER)) && !this.element.classList.contains(STEPINDICATOR) && this.stepperItemElements[parseInt(this.activeStep.toString(), 10)].classList.contains(STEPICON)) {
              var progressPos = this.element.querySelector(".e-stepper-progressbar");
              var selectedEle = this.stepperItemElements[parseInt(this.activeStep.toString(), 10)].firstChild;
              var value = this.activeStep === 0 ? 0 : (selectedEle.offsetLeft - progressPos.offsetLeft + selectedEle.offsetWidth / 2) / progressPos.offsetWidth * 100;
              if (this.element.classList.contains(RTL14)) {
                value = (progressPos.getBoundingClientRect().right - selectedEle.getBoundingClientRect().right + selectedEle.offsetWidth / 2) / progressPos.offsetWidth * 100;
                this.progressbar.style.setProperty(PROGRESSVALUE2, value + "%");
              } else {
                this.progressbar.style.setProperty(PROGRESSVALUE2, value + "%");
              }
            } else {
              var totalLiWidth = 0;
              var activeLiWidth = 0;
              for (var j = 0; j < this.stepperItemElements.length; j++) {
                totalLiWidth = totalLiWidth + this.stepperItemElements[parseInt(j.toString(), 10)].offsetWidth;
                if (j <= this.activeStep) {
                  if (j < this.activeStep) {
                    activeLiWidth = activeLiWidth + this.stepperItemElements[parseInt(j.toString(), 10)].offsetWidth;
                  } else if (j === this.activeStep && j !== 0) {
                    activeLiWidth = activeLiWidth + this.stepperItemElements[parseInt(j.toString(), 10)].offsetWidth / 2;
                  }
                }
              }
              var spaceWidth = (this.stepperItemList.offsetWidth - totalLiWidth) / (this.stepperItemElements.length - 1);
              var progressValue = (activeLiWidth + spaceWidth * this.activeStep) / this.stepperItemList.offsetWidth * 100;
              this.progressbar.style.setProperty(PROGRESSVALUE2, progressValue + "%");
            }
          } else {
            this.progressbar.style.setProperty(PROGRESSVALUE2, 100 / (this.steps.length - 1) * index + "%");
          }
        } else if (this.activeStep < 0 && this.progressbar) {
          this.progressbar.style.setProperty(PROGRESSVALUE2, "0%");
        }
        if (i === this.activeStep) {
          itemElement.classList.add(INPROGRESS);
        } else if (this.activeStep > 0 && i < this.activeStep) {
          itemElement.classList.add(COMPLETED);
        } else {
          itemElement.classList.add(NOTSTARTED);
        }
        if (itemElement.classList.contains(INPROGRESS)) {
          attributes(itemElement, { "tabindex": "0", "aria-current": "true" });
        } else {
          attributes(itemElement, { "tabindex": "-1", "aria-current": "false" });
        }
        var prevOnChange_1 = this.isProtectedOnChange;
        this.isProtectedOnChange = true;
        if (isUpdated !== false) {
          if (i < this.activeStep || this.steps.length - 1 === this.activeStep && item.status.toLowerCase() === "completed") {
            item.status = StepStatus.Completed;
          } else if (i === this.activeStep) {
            item.status = StepStatus.InProgress;
          } else if (i > this.activeStep) {
            item.status = StepStatus.NotStarted;
          }
          if (stepStatus && this.activeStep === i) {
            item.status = stepStatus;
          }
          if (item.status.toLowerCase() === "completed") {
            itemElement.classList.remove(SELECTED4, INPROGRESS, NOTSTARTED);
            itemElement.classList.add(COMPLETED);
          }
          if (item.status.toLowerCase() === "notstarted") {
            itemElement.classList.remove(SELECTED4, INPROGRESS, COMPLETED);
            itemElement.classList.add(NOTSTARTED);
          }
        }
        this.isProtectedOnChange = prevOnChange_1;
        if (this.renderDefault(i) && this.element.classList.contains(STEPINDICATOR) && !itemElement.classList.contains("e-step-valid") && !itemElement.classList.contains("e-step-error")) {
          if (itemElement.classList.contains(COMPLETED)) {
            itemElement.firstChild.classList.remove("e-icons", "e-step-indicator");
            itemElement.firstChild.classList.add(ICONCSS2, "e-icons", "e-check");
          } else if (itemElement.classList.contains(INPROGRESS) || itemElement.classList.contains(NOTSTARTED)) {
            itemElement.firstChild.classList.remove(ICONCSS2, "e-icons", "e-check");
            itemElement.firstChild.classList.add("e-icons", "e-step-indicator");
          }
        }
      }
      this.updateStepInteractions();
    };
    Stepper2.prototype.updateStepInteractions = function() {
      var _this = this;
      this.element.classList.toggle(LINEARSTEP, this.linear);
      this.stepperItemElements.forEach(function(step, index) {
        var isPreviousStep = index === _this.activeStep - 1;
        var isNextStep = index === _this.activeStep + 1;
        step.classList.toggle(PREVSTEP, isPreviousStep);
        step.classList.toggle(NEXTSTEP, isNextStep);
      });
    };
    Stepper2.prototype.removeItemElements = function() {
      for (var i = 0; i < this.stepperItemElements.length; i++) {
        remove(this.stepperItemElements[parseInt(i.toString(), 10)]);
      }
      this.stepperItemElements = [];
    };
    Stepper2.prototype.nextStep = function() {
      if (this.activeStep !== this.steps.length - 1) {
        this.navigateToStep(this.activeStep + 1, null, null, false);
      }
    };
    Stepper2.prototype.previousStep = function() {
      if (this.activeStep > 0) {
        this.navigateToStep(this.activeStep - 1, null, null, false);
      }
    };
    Stepper2.prototype.reset = function() {
      if (this.activeStep === 0) {
        this.updateStepInteractions();
      } else {
        var isDisabled = this.stepperItemElements[0].classList.contains(DISABLED9) ? true : false;
        this.navigateToStep(isDisabled ? -1 : 0, null, null, false);
      }
    };
    Stepper2.prototype.refreshProgressbar = function() {
      if (this.stepperItemList && this.progressbar) {
        this.setProgressPosition(this.element);
      }
      this.navigateToStep(this.activeStep, null, null, false);
    };
    Stepper2.prototype.updateElementClassArray = function() {
      var classArray = [
        RTL14,
        READONLY2,
        "e-steps-focus",
        LABELAFTER,
        LABELBEFORE,
        "e-label-top",
        "e-label-bottom",
        "e-label-start",
        "e-label-end",
        STEPINDICATOR,
        LABELINDICATOR,
        VERTICALSTEP,
        HORIZSTEP,
        LINEARSTEP
      ];
      removeClass([this.element], classArray);
    };
    Stepper2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unWireEvents();
      this.removeItemElements();
      this.clearTemplate();
      if (this.stepperItemList) {
        remove(this.stepperItemList);
      }
      this.stepperItemList = null;
      if (this.progressStep) {
        remove(this.progressStep);
      }
      this.progressStep = null;
      this.progressbar = null;
      this.progressBarPosition = null;
      this.stepperItemContainer = null;
      this.textContainer = null;
      this.labelContainer = null;
      this.updateElementClassArray();
      this.element.removeAttribute("aria-label");
      if (this.showTooltip) {
        this.tooltipObj.destroy();
        this.tooltipObj = null;
      }
      if (this.keyboardModuleStepper) {
        this.keyboardModuleStepper.destroy();
      }
      this.keyboardModuleStepper = null;
    };
    Stepper2.prototype.wireKeyboardEvent = function() {
      this.keyboardModuleStepper = new KeyboardEvents(this.element, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
    };
    Stepper2.prototype.keyActionHandler = function(e) {
      if (this.readOnly) {
        return;
      }
      switch (e.action) {
        case "uparrow":
        case "downarrow":
        case "leftarrow":
        case "rightarrow":
        case "tab":
        case "shiftTab":
          this.handleNavigation(this.enableRtl && this.element.classList.contains(HORIZSTEP) ? e.action === "leftarrow" || e.action === "tab" || e.action === "uparrow" : e.action === "rightarrow" || e.action === "tab" || e.action === "downarrow", e);
          break;
        case "space":
        case "enter":
        case "escape":
          this.handleNavigation(null, e);
          break;
        case "home":
        case "end":
          this.handleNavigation(null, e, this.enableRtl);
          break;
      }
    };
    Stepper2.prototype.handleNavigation = function(isNextStep, e, isRTL) {
      this.isKeyNavFocus = true;
      this.element.classList.add("e-steps-focus");
      var focusedEle = this.element.querySelector("." + FOCUS2);
      if (!focusedEle) {
        focusedEle = this.element.querySelector("." + SELECTED4);
      }
      var stepItems = Array.prototype.slice.call(this.stepperItemList.children);
      var index = stepItems.indexOf(focusedEle);
      if (e.action === "tab" || e.action === "shiftTab" || e.action === "downarrow" || e.action === "uparrow" || e.action === "space" || e.action === "home" || e.action === "end") {
        if (e.action === "tab" && index === stepItems.length - 1 || e.action === "shiftTab" && index === 0) {
          if (focusedEle.classList.contains(FOCUS2)) {
            this.updateStepFocus();
            return;
          }
        } else {
          e.preventDefault();
        }
      }
      if (e.action === "escape") {
        stepItems[parseInt(index.toString(), 10)].classList.remove(FOCUS2);
        this.element.classList.remove("e-steps-focus");
      }
      if (!(e.action === "space" || e.action === "enter")) {
        var prevIndex = index;
        index = isNextStep ? index + 1 : index - 1;
        while (index >= 0 && index < stepItems.length && stepItems[parseInt(index.toString(), 10)].classList.contains(DISABLED9)) {
          index = isNextStep ? index + 1 : index - 1;
        }
        index = index < 0 ? 0 : index > stepItems.length - 1 ? stepItems.length - 1 : index;
        if (stepItems[parseInt(prevIndex.toString(), 10)].classList.contains(FOCUS2)) {
          stepItems[parseInt(prevIndex.toString(), 10)].classList.remove(FOCUS2);
        }
        if (e.action === "home" || e.action === "end") {
          if (e.action === "home") {
            index = isRTL ? stepItems.length - 1 : 0;
          } else {
            index = isRTL ? 0 : stepItems.length - 1;
          }
        }
        if (index >= 0 && index < stepItems.length) {
          stepItems[parseInt(index.toString(), 10)].classList.add(FOCUS2);
        }
      } else if (e.action === "space" || e.action === "enter") {
        var isupdateFocus = false;
        if (this.linear) {
          var linearModeValue = this.activeStep - index;
          if (Math.abs(linearModeValue) === 1) {
            this.navigateToStep(index, null, null, true);
            isupdateFocus = true;
          }
        } else {
          this.navigateToStep(index, null, null, true);
          isupdateFocus = true;
        }
        if (isupdateFocus) {
          this.updateStepFocus();
          this.stepperItemElements[index].focus();
        }
      }
    };
    Stepper2.prototype.renderStepperItems = function(isUpdate, isStepType) {
      this.updateElementClassArray();
      this.removeItemElements();
      this.element.querySelector(".e-stepper-progressbar").remove();
      if (isUpdate) {
        this.updatePosition();
      }
      if (isStepType) {
        this.updateStepType();
      }
      if (this.readOnly && !this.element.classList.contains(READONLY2)) {
        this.element.classList.add(READONLY2);
      }
      if (this.enableRtl && !this.element.classList.contains(RTL14)) {
        this.element.classList.add(RTL14);
      }
      this.updateOrientaion(this.element);
      this.renderItems();
      this.renderProgressBar(this.element);
      this.checkValidStep();
      this.updateAnimation();
      this.navigateToStep(this.activeStep, null, this.stepperItemElements[this.activeStep], true);
    };
    Stepper2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "steps": {
            if (!(newProp.steps instanceof Array && oldProp.steps instanceof Array)) {
              var stepCounts = Object.keys(newProp.steps);
              for (var i = 0; i < stepCounts.length; i++) {
                var index = parseInt(Object.keys(newProp.steps)[i], 10);
                var changedPropsCount = Object.keys(newProp.steps[index]).length;
                for (var j = 0; j < changedPropsCount; j++) {
                  var property = Object.keys(newProp.steps[index])[j];
                  if (property === "status") {
                    if (this.activeStep === index) {
                      this.navigationHandler(index, newProp.steps[index].status);
                    } else {
                      this.steps[index].status = oldProp.steps[index].status;
                    }
                  } else {
                    this.removeItemElements();
                    this.renderItems();
                    this.updateStepperStatus();
                  }
                  this.checkValidStep();
                }
              }
            } else {
              this.renderStepperItems(true, true);
            }
            break;
          }
          case "orientation":
            this.updateOrientaion(this.element);
            this.renderStepperItems(true);
            break;
          case "activeStep":
            this.activeStep = newProp.activeStep > this.steps.length - 1 || newProp.activeStep < -1 ? oldProp.activeStep : this.activeStep;
            if (this.activeStep >= 0 && this.stepperItemElements[parseInt(this.activeStep.toString(), 10)].classList.contains(DISABLED9)) {
              this.activeStep = oldProp.activeStep;
            }
            if (this.linear) {
              var linearModeValue = oldProp.activeStep - this.activeStep;
              if (Math.abs(linearModeValue) === 1) {
                this.navigateToStep(this.activeStep, null, null, true);
              }
            } else {
              this.navigateToStep(this.activeStep, null, this.stepperItemElements[this.activeStep], true);
            }
            break;
          case "enableRtl":
            this.element.classList[this.enableRtl ? "add" : "remove"](RTL14);
            break;
          case "readOnly":
            this.element.classList[this.readOnly ? "add" : "remove"](READONLY2);
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.trim().split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.trim().split(" "));
            }
            if (this.tooltipObj) {
              this.tooltipObj.setProperties({ cssClass: this.cssClass ? STEPPERTOOLTIP + " " + this.cssClass : STEPPERTOOLTIP });
            }
            break;
          case "labelPosition":
            this.renderStepperItems(true);
            break;
          case "showTooltip":
            this.updateTooltip();
            break;
          case "stepType":
            this.renderStepperItems(true, true);
            break;
          case "template":
            this.updateTemplateFunction();
            this.updateContent();
            break;
          case "animation":
            this.updateAnimation();
            break;
          case "linear":
            this.updateStepInteractions();
            break;
        }
      }
    };
    __decorate44([
      Property(0)
    ], Stepper2.prototype, "activeStep", void 0);
    __decorate44([
      Complex({}, StepperAnimationSettings)
    ], Stepper2.prototype, "animation", void 0);
    __decorate44([
      Property(false)
    ], Stepper2.prototype, "linear", void 0);
    __decorate44([
      Property(false)
    ], Stepper2.prototype, "showTooltip", void 0);
    __decorate44([
      Property("")
    ], Stepper2.prototype, "template", void 0);
    __decorate44([
      Property("")
    ], Stepper2.prototype, "tooltipTemplate", void 0);
    __decorate44([
      Property(StepLabelPosition.Bottom)
    ], Stepper2.prototype, "labelPosition", void 0);
    __decorate44([
      Property(StepType.Default)
    ], Stepper2.prototype, "stepType", void 0);
    __decorate44([
      Event()
    ], Stepper2.prototype, "stepChanged", void 0);
    __decorate44([
      Event()
    ], Stepper2.prototype, "stepChanging", void 0);
    __decorate44([
      Event()
    ], Stepper2.prototype, "stepClick", void 0);
    __decorate44([
      Event()
    ], Stepper2.prototype, "beforeStepRender", void 0);
    Stepper2 = __decorate44([
      NotifyPropertyChanges
    ], Stepper2);
    return Stepper2;
  }(StepperBase)
);

// node_modules/@syncfusion/ej2-image-editor/src/image-editor/renderer/toolbar.js
var ToolbarModule = (
  /** @class */
  function() {
    function ToolbarModule2(parent) {
      this.defToolbarItems = [];
      this.toolbarHeight = 46;
      this.currToolbar = "";
      this.preventZoomBtn = false;
      this.currentToolbar = "main";
      this.selFhdColor = "#42a5f5";
      this.preventEnableDisableUr = false;
      this.isAspectRatio = true;
      this.isFrameToolbar = false;
      this.presetColors = {
        "custom": [
          "#000000",
          "#f44336",
          "#e91e63",
          "#9c27b0",
          "#673ab7",
          "#2196f3",
          "#03a9f4",
          "#00bcd4",
          "#009688",
          "#ffeb3b",
          "#ffffff",
          "#ffebee",
          "#fce4ec",
          "#f3e5f5",
          "#ede7f6",
          "#e3f2fd",
          "#e1f5fe",
          "#e0f7fa",
          "#e0f2f1",
          "#fffde7",
          "#f2f2f2",
          "#ffcdd2",
          "#f8bbd0",
          "#e1bee7",
          "#d1c4e9",
          "#bbdefb",
          "#b3e5fc",
          "#b2ebf2",
          "#b2dfdb",
          "#fff9c4",
          "#e6e6e6",
          "#ef9a9a",
          "#f48fb1",
          "#ce93d8",
          "#b39ddb",
          "#90caf9",
          "#81d4fa",
          "#80deea",
          "#80cbc4",
          "#fff59d",
          "#cccccc",
          "#e57373",
          "#f06292",
          "#ba68c8",
          "#9575cd",
          "#64b5f6",
          "#4fc3f7",
          "#4dd0e1",
          "#4db6ac",
          "#fff176",
          "#b3b3b3",
          "#ef5350",
          "#ec407a",
          "#ab47bc",
          "#7e57c2",
          "#42a5f5",
          "#29b6f6",
          "#26c6da",
          "#26a69a",
          "#ffee58",
          "#999999",
          "#e53935",
          "#d81b60",
          "#8e24aa",
          "#5e35b1",
          "#1e88e5",
          "#039be5",
          "#00acc1",
          "#00897b",
          "#fdd835",
          "#808080",
          "#d32f2f",
          "#c2185b",
          "#7b1fa2",
          "#512da8",
          "#1976d2",
          "#0288d1",
          "#0097a7",
          "#00796b",
          "#fbc02d",
          "#666666",
          "#c62828",
          "#ad1457",
          "#6a1b9a",
          "#4527a0",
          "#1565c0",
          "#0277bd",
          "#00838f",
          "#00695c",
          "#f9a825",
          "#4d4d4d",
          "#b71c1c",
          "#880e4f",
          "#4a148c",
          "#311b92",
          "#0d47a1",
          "#01579b",
          "#006064",
          "#004d40",
          "#f57f17"
        ]
      };
      this.isSlider = false;
      this.currentQuality = 1;
      this.imageQuality = "highest";
      this.parent = parent;
      this.addEventListener();
      this.initLocale();
    }
    ToolbarModule2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    ToolbarModule2.prototype.addEventListener = function() {
      this.parent.on("toolbar", this.toolbar, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    ToolbarModule2.prototype.removeEventListener = function() {
      this.parent.off("toolbar", this.toolbar);
      this.parent.off("destroyed", this.destroy);
    };
    ToolbarModule2.prototype.initLocale = function() {
      this.defaultLocale = {
        Crop: "Crop",
        ZoomIn: "Zoom In",
        ZoomOut: "Zoom Out",
        Undo: "Undo",
        Redo: "Redo",
        Transform: "Transform",
        Annotation: "Annotation",
        Finetune: "Finetune",
        Brightness: "Brightness",
        Contrast: "Contrast",
        Hue: "Hue",
        Saturation: "Saturation",
        Opacity: "Opacity",
        Blur: "Blur",
        Sharpen: "Sharpen",
        Exposure: "Exposure",
        Filter: "Filter",
        Default: "Default",
        Chrome: "Chrome",
        Cold: "Cold",
        Warm: "Warm",
        Grayscale: "Grayscale",
        BlackAndWhite: "Black and White",
        Sepia: "Sepia",
        Invert: "Invert",
        Text: "Add Text",
        Pen: "Pen",
        Reset: "Reset",
        Save: "Save",
        Select: "Select",
        RotateLeft: "Rotate Left",
        RotateRight: "Rotate Right",
        HorizontalFlip: "Horizontal Flip",
        VerticalFlip: "Vertical Flip",
        OK: "Apply",
        Cancel: "Discard",
        FillColor: "Fill Color",
        StrokeColor: "Stroke Color",
        StrokeWidth: "Stroke Width",
        FontFamily: "Font Family",
        FontStyle: "Font Style",
        FontSize: "Font Size",
        FontColor: "Font Color",
        Pan: "Pan",
        Move: "Move",
        Load: "Load",
        Custom: "Custom",
        Square: "Square",
        Circle: "Circle",
        Ellipse: "Ellipse",
        Rectangle: "Rectangle",
        Line: "Line",
        Arrow: "Arrow",
        Path: "Path",
        Bold: "Bold",
        Italic: "Italic",
        BoldItalic: "Bold Italic",
        XSmall: "X-Small",
        Small: "Small",
        Medium: "Medium",
        Large: "Large",
        XLarge: "X-Large",
        ABC: "ABC",
        Browse: "Browse",
        Duplicate: "Duplicate",
        Remove: "Remove",
        EditText: "Edit Text",
        Start: "Start",
        End: "End",
        Bar: "Bar",
        ArrowSolid: "Arrow Solid",
        CircleSolid: "Circle Solid",
        SquareSolid: "Square Solid",
        None: "None",
        CropAndTransform: "Crop and Transform",
        CropSelection: "Crop Selection",
        Image: "Add Image",
        Transparency: "Transparency",
        Height: "Height",
        Width: "Width",
        AspectRatio: "Maintain aspect ratio",
        W: "W",
        H: "H",
        DragText: "Drag and drop your image here or",
        DropText: "Drop your image here or",
        BrowseText: "Browse here...",
        SupportText: "Supports:",
        Frame: "Frame",
        Mat: "Mat",
        Bevel: "Bevel",
        Inset: "Inset",
        Hook: "Hook",
        Color: "Color",
        Size: "Size",
        Offset: "Offset",
        Radius: "Radius",
        Amount: "Amount",
        Resize: "Resize",
        0: "0%",
        20: "20%",
        40: "40%",
        60: "60%",
        80: "80%",
        100: "100%",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        Border: "Border",
        Solid: "Solid",
        Dashed: "Dashed",
        Dotted: "Dotted",
        GradientColor: "Gradient Color",
        ConfirmDialogHeader: "Confirm Save Changes",
        ConfirmDialogContent: "Do you want to save the changes you made to the image?",
        AlertDialogHeader: "Unsupported file",
        AlertDialogContent: "The selected file is unsupported.",
        Yes: "Yes",
        No: "No",
        ImageErrorDialogHeader: "Image Selection Error",
        ImageErrorDialogContent: "Please select only one image to open.",
        Straighten: "Straighten",
        NoOutline: "No outline",
        DlgOK: "OK",
        SaveAs: "Save As",
        ImageName: "Image name",
        Format: "Format",
        Quality: "Quality",
        Download: "Download",
        Close: "Close",
        ImageSize: "Image Size",
        QualityInfo: "The image quality option is only available for JPEG format",
        Good: "Good",
        Great: "Great",
        Highest: "Highest",
        BringForward: "Bring Forward",
        SendBackward: "Send Backward",
        SendToBack: "Send to Back",
        BringToFront: "Bring to Front",
        ZOrder: "Z-Order"
      };
      this.l10n = new L10n("image-editor", this.defaultLocale, this.parent.locale);
    };
    ToolbarModule2.prototype.toolbar = function(args) {
      var parent = this.parent;
      this.updatePrivateVariables();
      switch (args.prop) {
        case "create-toolbar":
          this.createToolbar();
          break;
        case "create-contextual-toolbar":
          this.createContextualToolbar();
          break;
        case "update-toolbar-items":
          this.updateToolbarItems();
          break;
        case "refresh-toolbar":
          this.refreshToolbar(args.value["type"], args.value["isApplyBtn"], args.value["isCropping"], args.value["isZooming"], args.value["cType"]);
          break;
        case "renderQAT":
          this.renderQAT(args.value["isPenEdit"]);
          break;
        case "enable-disable-btns":
          this.enableDisableTbrBtn();
          break;
        case "init-main-toolbar":
          this.initMainToolbar(args.value["isApplyBtn"], args.value["isDevice"], args.value["isOkBtn"], args.value["isResize"], args.value["isFrame"], args.value["isMainToolbar"]);
          break;
        case "create-bottom-toolbar":
          this.createBottomToolbar();
          break;
        case "refresh-main-toolbar":
          this.refreshMainToolbar();
          break;
        case "create-qa-toolbar":
          this.createQuickAccessToolbar();
          break;
        case "destroy-qa-toolbar":
          this.destroyQuickAccessToolbar();
          break;
        case "zoom-up-handler":
          this.zoomBtnMouseUpHandler();
          break;
        case "refresh-dropdown-btn":
          this.refreshDropDownBtn(args.value["isDisabled"]);
          break;
        case "close-contextual-toolbar":
          this.closeContextualToolbar();
          break;
        case "destroy-bottom-toolbar":
          this.destroyBottomToolbar();
          break;
        case "destroy-top-toolbar":
          this.destroyTopToolbar();
          break;
        case "destroySubComponents":
          this.destroySubComponents();
          break;
        case "setLocale":
          this.l10n.setLocale(args.value["locale"]);
          break;
        case "setPreventZoomBtn":
          this.preventZoomBtn = args.value["isPrevent"];
          break;
        case "getToolbarHeight":
          args.value["obj"]["toolbarHeight"] = this.toolbarHeight;
          break;
        case "setToolbarHeight":
          if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") > -1) {
            this.toolbarHeight = args.value["height"];
          }
          break;
        case "setCurrentToolbar":
          this.currentToolbar = args.value["type"];
          break;
        case "setSelectedFreehandColor":
          this.selFhdColor = args.value["color"];
          break;
        case "setInitialAdjustmentValue":
          parent.initialAdjustmentValue = args.value["value"];
          break;
        case "getCanvasFilter":
          args.value["obj"]["canvasFilter"] = parent.canvasFilter;
          break;
        case "getDefToolbarItems":
          args.value["obj"]["defToolbarItems"] = this.defToolbarItems;
          break;
        case "getPenStroke":
          this.getPenStroke(args.value["value"]);
          break;
        case "performDefToolbarClickAction":
          this.performDefTbrClick(args.value["type"], args.value["isContextualToolbar"], args.value["isDisabledAdjustment"], args.value["isDisabledFilter"], args.value["isFilterFinetune"]);
          break;
        case "setTempFilterProperties":
          parent.setTempFilterProperties();
          break;
        case "refreshSlider":
          this.refreshSlider();
          break;
        case "getCurrAdjustmentValue":
          parent.getCurrAdjustmentValue(args.value["type"]);
          break;
        case "setCurrAdjustmentValue":
          parent.setCurrAdjustmentValue(args.value["type"], args.value["value"]);
          break;
        case "refreshShapeDrawing":
          this.refreshShapeDrawing();
          break;
        case "setEnableDisableUndoRedo":
          this.preventEnableDisableUr = args.value["isPrevent"];
          break;
        case "reset":
          this.reset();
          break;
        case "getLocaleText":
          args.value["obj"]["value"] = this.l10n.getConstant(args.value["obj"]["key"]);
          break;
        case "initResizeToolbar":
          this.initResizeToolbar();
          break;
        case "getFrameToolbar":
          args.value["obj"]["bool"] = this.isFrameToolbar;
          break;
        case "callFrameToolbar":
          this.callFrameToolbar();
          break;
        case "resizeClick":
          this.resizeClick();
          break;
        case "frameToolbarClick":
          this.frameToolbarClick();
          break;
        case "performCropTransformClick":
          this.performCropTransformClick(args.value["shape"], args.value["isTransform"]);
          break;
        case "duplicateShape":
          this.duplicateShape(args.value["isPreventUndoRedo"], true);
          break;
        case "editText":
          this.editText();
          break;
        case "setInitialSize":
          this.initialSize = Number(args.value["value"]);
          break;
      }
    };
    ToolbarModule2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      this.inMemoryCanvas = parent.inMemoryCanvas;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (this.inMemoryCanvas) {
        this.inMemoryContext = this.inMemoryCanvas.getContext("2d");
      }
    };
    ToolbarModule2.prototype.reset = function() {
      var parent = this.parent;
      this.toolbarHeight = 46;
      parent.prevCurrSelectionPoint = null;
      this.zoomBtnHold = null;
      this.currToolbar = "";
      parent.cxtTbarHeight = null;
      this.currentToolbar = "main";
      this.selFhdColor = "#42a5f5";
      parent.currentFilter = "";
      this.preventZoomBtn = parent.isCropToolbar = this.preventEnableDisableUr = this.isFrameToolbar = false;
      parent.initialAdjustmentValue = parent.canvasFilter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.tempStraighten = 0;
      parent.isStraightening = false;
    };
    ToolbarModule2.prototype.destroyTopToolbar = function() {
      var parent = this.parent;
      var toolbar = document.getElementById(parent.element.id + "_toolbar");
      if (this.isToolbar() && toolbar && toolbar.classList.contains("e-control")) {
        getComponent(toolbar, "toolbar").destroy();
      }
    };
    ToolbarModule2.prototype.destroyBottomToolbar = function() {
      var parent = this.parent;
      var toolbar = document.getElementById(parent.element.id + "_bottomToolbar");
      if (toolbar && toolbar.classList.contains("e-control")) {
        getComponent(toolbar, "toolbar").destroy();
      }
    };
    ToolbarModule2.prototype.isToolbar = function() {
      var parent = this.parent;
      return isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 || !isNullOrUndefined(parent.toolbarTemplate);
    };
    ToolbarModule2.prototype.createToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        parent.element.appendChild(parent.createElement("div", {
          id: id + "_toolbarArea",
          className: "e-toolbar-area"
        }));
        var toolbarItems = {
          cssClass: "e-image-upload",
          align: "Left",
          type: "Input",
          tooltipText: this.l10n.getConstant("Browse"),
          template: new Uploader({ allowedExtensions: ".jpg, .jpeg, .png,.svg", multiple: false })
        };
        if (isNullOrUndefined(this.defToolbarItems)) {
          this.defToolbarItems = [];
        }
        this.defToolbarItems.push(toolbarItems);
        var toolbarArea = document.getElementById(id + "_toolbarArea");
        var toolbar_1 = parent.createElement("div", { id: id + "_toolbar" });
        toolbarArea.appendChild(toolbar_1);
        var uploadItems = [
          {
            cssClass: "e-image-upload",
            align: "Left",
            type: "Input",
            tooltipText: this.l10n.getConstant("Browse"),
            template: new Uploader({
              allowedExtensions: ".jpg, .jpeg, .png,.svg",
              multiple: false,
              selected: function() {
                var toolbar = document.getElementById(id + "_toolbar");
                var bToolbar = document.getElementById(id + "_bottomToolbar");
                if (!parent.disabled) {
                  if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && toolbar) {
                      getComponent(toolbar, "toolbar").destroy();
                    }
                    if (bToolbar) {
                      getComponent(bToolbar, "toolbar").destroy();
                    }
                    _this.initMainToolbar(false, Browser.isDevice, null);
                    _this.createBottomToolbar();
                  } else {
                    if (_this.defToolbarItems.length > 0 && toolbar) {
                      getComponent(toolbar, "toolbar").destroy();
                    }
                    _this.initMainToolbar(false, false, null);
                  }
                }
              }
            })
          }
        ];
        var toolbarObj = new Toolbar({
          items: uploadItems,
          width: "100%",
          created: function() {
            parent.trigger("toolbarCreated", { toolbarType: "main" });
          },
          clicked: this.defToolbarClicked.bind(this)
        });
        toolbarObj.appendTo("#" + id + "_toolbar");
        this.createLeftToolbarControls();
        var mToolbar = document.getElementById(id + "_toolbar");
        if (toolbar_1) {
          this.toolbarHeight = mToolbar.clientHeight;
          if (parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1) {
            var toolabr = getComponent(document.getElementById(parent.element.id + "_toolbar"), "toolbar");
            if (toolabr) {
              toolabr.destroy();
              document.getElementById(parent.element.id + "_toolbar").innerHTML = "";
            }
          }
        }
      } else {
        this.toolbarHeight = 0;
      }
    };
    ToolbarModule2.prototype.createContextualToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        parent.element.appendChild(parent.createElement("div", {
          id: id + "_contextualToolbarArea",
          className: "e-contextual-toolbar-wrapper e-hide",
          attrs: { style: "position: absolute;" }
        }));
        var toolbarArea = document.getElementById(id + "_contextualToolbarArea");
        var toolbar_2 = parent.createElement("div", { id: id + "_contextualToolbar" });
        toolbarArea.appendChild(toolbar_2);
      }
    };
    ToolbarModule2.prototype.createBottomToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.element.querySelector("#" + id + "_bottomToolbarArea")) {
        parent.element.querySelector("#" + id + "_bottomToolbarArea").remove();
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        parent.element.appendChild(parent.createElement("div", {
          id: id + "_bottomToolbarArea",
          className: "e-bottom-toolbar"
        }));
        if (!parent.toolbarTemplate) {
          var toolbarArea = document.getElementById(id + "_bottomToolbarArea");
          var toolbarElem = parent.createElement("div", {
            id: id + "_bottomToolbar"
          });
          toolbarArea.appendChild(toolbarElem);
        }
        this.initBottomToolbar();
      }
    };
    ToolbarModule2.prototype.createQuickAccessToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.showQuickAccessToolbar) {
        var toolbarItems = {
          cssClass: "e-image-upload",
          align: "Left",
          type: "Input",
          tooltipText: this.l10n.getConstant("Browse"),
          template: new Uploader({ allowedExtensions: ".jpg, .jpeg, .png,.svg", multiple: false })
        };
        if (isNullOrUndefined(this.defToolbarItems)) {
          this.defToolbarItems = [];
        }
        this.defToolbarItems.push(toolbarItems);
        var toolbarArea = document.getElementById(id + "_quickAccessToolbarArea");
        var toolbar_3 = parent.createElement("div", {
          id: id + "_quickAccessToolbar"
        });
        toolbarArea.appendChild(toolbar_3);
        var toolbarObj = new Toolbar({ clicked: this.defToolbarClicked.bind(this) });
        toolbarObj.appendTo("#" + id + "_quickAccessToolbar");
      }
    };
    ToolbarModule2.prototype.initMainToolbar = function(isApplyOption, isDevice, isOkBtn, isResize, isFrame, isMainToolbar) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (this.isToolbar()) {
        var leftItem = this.getLeftToolbarItem(isOkBtn, isResize);
        var rightItem = this.getRightToolbarItem(isOkBtn, isMainToolbar);
        var mainItem = this.getMainToolbarItem(isApplyOption, isFrame);
        var zoomItem = this.getZoomToolbarItem();
        if (isDevice) {
          if (isFrame) {
            this.defToolbarItems = mainItem;
          } else {
            this.defToolbarItems = leftItem.concat(rightItem);
          }
        } else {
          this.defToolbarItems = leftItem.concat(mainItem, rightItem, zoomItem);
        }
        var args = { toolbarType: "main", toolbarItems: this.defToolbarItems };
        parent.trigger("toolbarUpdating", args);
        this.defToolbarItems = args.toolbarItems;
        if (this.defToolbarItems.length > 0) {
          var toolbarObj = new Toolbar({
            width: "100%",
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function() {
              if (!isDevice) {
                _this.renderAnnotationBtn();
              }
              _this.wireZoomBtnEvents();
              parent.trigger("toolbarCreated", { toolbarType: "main" });
            }
          });
          if (isDevice && isFrame) {
            toolbarObj.appendTo("#" + id + "_bottomToolbar");
          } else {
            toolbarObj.appendTo("#" + id + "_toolbar");
          }
          this.createLeftToolbarControls();
          this.enableDisableTbrBtn();
          if (this.isToolbar() && document.getElementById(id + "_toolbar")) {
            var toolbar_4 = getComponent(id + "_toolbar", "toolbar");
            toolbar_4.refreshOverflow();
          }
        }
      }
    };
    ToolbarModule2.prototype.initBottomToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        var items = this.getMainToolbarItem();
        var args = { toolbarType: "bottom-toolbar", toolbarItems: items };
        parent.trigger("toolbarUpdating", args);
        items = args.toolbarItems;
        var toolbarObj = new Toolbar({
          items,
          width: "100%",
          created: function() {
            _this.renderAnnotationBtn();
            _this.renderCropBtn();
            _this.renderTransformBtn();
            parent.trigger("toolbarCreated", { toolbarType: "main" });
          },
          clicked: this.defToolbarClicked.bind(this)
        });
        toolbarObj.appendTo("#" + id + "_bottomToolbar");
        if (this.defToolbarItems.length > 0 && document.getElementById(id + "_bottomToolbar")) {
          var toolbar_5 = getComponent(id + "_bottomToolbar", "toolbar");
          toolbar_5.refreshOverflow();
        }
      }
    };
    ToolbarModule2.prototype.getLeftToolbarItem = function(isOkBtn, isResize) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (!isOkBtn || isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Open") > -1) {
          toolbarItems.push({ id: id + "_upload", cssClass: "e-image-upload", align: "Left", type: "Input", template: new Uploader({ allowedExtensions: ".jpg, .jpeg, .png,.svg", multiple: false }) });
          toolbarItems.push({ visible: false, cssClass: "e-image-position e-btn e-flat", tooltipText: this.l10n.getConstant("Browse"), align: "Left" });
        } else if (Browser.isDevice && (parent.toolbar && parent.toolbar.indexOf("Open") === -1)) {
          toolbarItems.push({ visible: false, id: id + "_upload", cssClass: "e-image-upload", align: "Left", type: "Input", template: new Uploader({ allowedExtensions: ".jpg, .jpeg, .png,.svg", multiple: false }) });
          toolbarItems.push({ visible: false, cssClass: "e-image-position e-btn e-flat", tooltipText: this.l10n.getConstant("Browse"), align: "Left" });
        }
      }
      if (parent.allowUndoRedo && !isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Undo") > -1) {
          toolbarItems.push({
            id: id + "_undo",
            prefixIcon: "e-icons e-undo",
            cssClass: "top-icon e-undo",
            tooltipText: this.l10n.getConstant("Undo"),
            align: "Left"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Redo") > -1) {
          toolbarItems.push({
            id: id + "_redo",
            prefixIcon: "e-icons e-redo",
            cssClass: "top-icon e-redo",
            tooltipText: this.l10n.getConstant("Redo"),
            align: "Left"
          });
        }
      }
      if (!this.preventZoomBtn && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar && !isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("ZoomOut") > -1) {
          toolbarItems.push({
            id: id + "_zoomOut",
            prefixIcon: "e-icons e-zoom-out",
            cssClass: "top-icon e-dec-zoom",
            tooltipText: this.l10n.getConstant("ZoomOut"),
            align: "Left"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("ZoomIn") > -1) {
          toolbarItems.push({
            id: id + "_zoomIn",
            prefixIcon: "e-icons e-zoom-in",
            cssClass: "top-icon e-inc-zoom",
            tooltipText: this.l10n.getConstant("ZoomIn"),
            align: "Left"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("left");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getRightToolbarItem = function(isOkBtn, isMainToolbar) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isOkBtn) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      if ((isMainToolbar || !Browser.isDevice) && (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Reset") > -1)) {
        toolbarItems.push({
          id: id + "_reset",
          prefixIcon: "e-icons e-btn-reset",
          cssClass: "top-icon e-img-reset",
          tooltipText: this.l10n.getConstant("Reset"),
          align: "Right"
        });
      }
      if (!isOkBtn) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Save") > -1) {
          toolbarItems.push({
            id: id + "_save",
            prefixIcon: "e-icons e-btn-save",
            cssClass: "e-caret-hide top-icon e-save",
            tooltipText: this.l10n.getConstant("Save"),
            align: "Right"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("right");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getMainToolbarItem = function(isApplyOption, isFrame) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isFrame) {
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("None") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_none",
            prefixIcon: "e-icons e-frame-none",
            cssClass: "top-icon e-frame-none",
            tooltipText: this.l10n.getConstant("None"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Mat") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_mat",
            prefixIcon: "e-icons e-frame-mat",
            cssClass: "top-icon e-frame-mat",
            tooltipText: this.l10n.getConstant("Mat"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Bevel") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_bevel",
            prefixIcon: "e-icons e-frame-bevel",
            cssClass: "top-icon e-frame-bevel",
            tooltipText: this.l10n.getConstant("Bevel"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Line") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_line",
            prefixIcon: "e-icons e-frame-line",
            cssClass: "top-icon e-frame-line",
            tooltipText: this.l10n.getConstant("Line"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Inset") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_inset",
            prefixIcon: "e-icons e-frame-inset",
            cssClass: "top-icon e-frame-inset",
            tooltipText: this.l10n.getConstant("Inset"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Hook") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_hook",
            prefixIcon: "e-icons e-frame-hook",
            cssClass: "top-icon e-frame-hook",
            tooltipText: this.l10n.getConstant("Hook"),
            align: "Center"
          });
        }
      } else {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Crop") > -1) {
          toolbarItems.push({
            id: id + "_cropTransform",
            prefixIcon: "e-icons e-crop",
            cssClass: "top-icon e-crop",
            tooltipText: this.l10n.getConstant("CropAndTransform"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Annotate") > -1) {
          toolbarItems.push({
            id: id + "_annotation",
            tooltipText: this.l10n.getConstant("Annotation"),
            align: "Center",
            template: '<button id="' + id + '_annotationBtn"></button>'
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Finetune") > -1) {
          toolbarItems.push({
            id: id + "_adjustment",
            prefixIcon: "e-icons e-adjustment",
            cssClass: "top-icon e-adjustment",
            tooltipText: this.l10n.getConstant("Finetune"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Filter") > -1) {
          toolbarItems.push({
            id: id + "_filter",
            prefixIcon: "e-icons e-filters",
            cssClass: "top-icon e-filters",
            tooltipText: this.l10n.getConstant("Filter"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_frame",
            prefixIcon: "e-icons e-border-frame",
            cssClass: "top-icon e-border-frame",
            tooltipText: this.l10n.getConstant("Frame"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Resize") > -1) {
          toolbarItems.push({
            id: id + "_resize",
            prefixIcon: "e-icons e-resize",
            cssClass: "top-icon e-resize",
            tooltipText: this.l10n.getConstant("Resize"),
            align: "Center"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (isApplyOption) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getZoomToolbarItem = function() {
      var toolbarItems = [];
      return toolbarItems;
    };
    ToolbarModule2.prototype.updateContextualToolbar = function(type, cType, isSelect) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarArea = parent.element.querySelector("#" + id + "_toolbarArea");
      var contextualToolbarArea = parent.element.querySelector("#" + id + "_contextualToolbarArea");
      if (!contextualToolbarArea) {
        return;
      }
      contextualToolbarArea.classList.remove("e-hide");
      contextualToolbarArea.style.left = toolbarArea.offsetLeft + "px";
      if (type === "filter") {
        var toolbar_6 = document.getElementById(id + "_toolbar");
        if (toolbar_6 && this.defToolbarItems.length > 0) {
          getComponent(toolbar_6, "toolbar").destroy();
        }
        if (Browser.isDevice) {
          this.initMainToolbar(false, true, true);
        } else {
          this.initMainToolbar(true, null, null);
        }
        this.refreshSlider();
        this.initFilterToolbarItem();
      } else {
        var ctxToolbar = document.querySelector("#" + id + "_contextualToolbar");
        if (ctxToolbar.classList.contains("e-control")) {
          getComponent(ctxToolbar, "toolbar").destroy();
        }
        this.refreshSlider();
        if (type === "frame") {
          this.initFrameToolbarItem();
        } else {
          this.renderSlider(cType, isSelect);
        }
      }
      if (parent.toolbarTemplate) {
        this.toolbarHeight = parent.element.querySelector("#" + id + "_toolbarArea").clientHeight;
      } else if (parent.element.querySelector("#" + id + "_toolbar")) {
        this.toolbarHeight = parent.element.querySelector("#" + id + "_toolbar").clientHeight;
      }
      parent.toolbarHeight = this.toolbarHeight;
      if (Browser.isDevice) {
        var cHt = contextualToolbarArea.offsetHeight + 1;
        var cusWrapper = parent.element.querySelector("#" + id + "_customizeWrapper");
        if (this.isFrameToolbar && cusWrapper) {
          cHt = cusWrapper.offsetHeight + 2;
        }
        var ht = parent.element.querySelector("#" + id + "_canvasWrapper").offsetHeight;
        contextualToolbarArea.style.top = this.toolbarHeight + 1 + ht - cHt + "px";
        if (cType === "straighten") {
          parent.isStraightening = true;
          var ctxToolbar = parent.element.querySelector("#" + id + "_contextualToolbarArea");
          if (ctxToolbar.style.position === "absolute") {
            ctxToolbar.style.position = "";
            parent.element.insertBefore(ctxToolbar, parent.element.querySelector("#" + id + "_bottomToolbarArea"));
            parent.update();
            if (isSelect) {
              parent.notify("draw", {
                prop: "select",
                onPropertyChange: false,
                value: {
                  type: this.getCropTextContent(document.getElementById(id + "_cropBtn")).toLowerCase(),
                  startX: null,
                  startY: null,
                  width: null,
                  height: null
                }
              });
            }
          }
        }
      } else {
        contextualToolbarArea.style.top = this.toolbarHeight + 1 + "px";
      }
    };
    ToolbarModule2.prototype.processToolbar = function(position) {
      var parent = this.parent;
      var toolbarItems = [];
      if (parent.toolbar) {
        for (var i = 0, len = parent.toolbar.length; i < len; i++) {
          if (typeof parent.toolbar[i] === "object") {
            if (isNullOrUndefined(parent.toolbar[i].align)) {
              if (position === "left") {
                toolbarItems.push(parent.toolbar[i]);
              }
            } else if (parent.toolbar[i].align.toLowerCase() === position) {
              toolbarItems.push(parent.toolbar[i]);
            }
          }
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.processSubToolbar = function(items) {
      var toolbarItems = [];
      if (items) {
        for (var i = 0, len = items.length; i < len; i++) {
          if (typeof items[i] === "object") {
            items[i].align = "Center";
            toolbarItems.push(items[i]);
          }
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.wireZoomBtnEvents = function() {
      var zoomIn = document.querySelector("#" + this.parent.element.id + "_zoomIn");
      var zoomOut = document.querySelector("#" + this.parent.element.id + "_zoomOut");
      if (zoomIn) {
        zoomIn.addEventListener("mousedown", this.zoomInBtnMouseDownHandler.bind(this));
        zoomIn.addEventListener("mouseup", this.zoomBtnMouseUpHandler.bind(this));
        zoomIn.addEventListener("click", this.zoomInBtnClickHandler.bind(this));
        zoomIn.addEventListener("touchstart", this.zoomInBtnClickHandler.bind(this));
      }
      if (zoomOut) {
        zoomOut.addEventListener("mousedown", this.zoomOutBtnMouseDownHandler.bind(this));
        zoomOut.addEventListener("mouseup", this.zoomBtnMouseUpHandler.bind(this));
        zoomOut.addEventListener("click", this.zoomOutBtnClickHandler.bind(this));
        zoomIn.addEventListener("touchstart", this.zoomInBtnClickHandler.bind(this));
      }
    };
    ToolbarModule2.prototype.widthPress = function(e) {
      if (e.keyCode === 109) {
        e.preventDefault();
        return;
      }
    };
    ToolbarModule2.prototype.heightPress = function(e) {
      if (e.keyCode === 109) {
        e.preventDefault();
        return;
      }
    };
    ToolbarModule2.prototype.widthAspectRatio = function(e) {
      if (e.keyCode === 109 || e.keyCode === 9) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var icon = parent.element.querySelector("#" + id + "_aspectratio");
      var originalWidth2 = parent.img.destWidth;
      var originalHeight2 = parent.img.destHeight;
      var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value);
      var val = aspectRatioHeightValue / (originalHeight2 / originalWidth2);
      var width = val % 1 >= 0.5 || val % 1 <= -0.5 ? Math.round(val) : val < 0 ? Math.ceil(val) : Math.floor(val);
      var widthNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      var heightNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      if (icon) {
        if (width != null && !isNaN(width)) {
          if (isNullOrUndefined(widthNumeric.value)) {
            widthNumeric.placeholder = width + " px";
            aspectRatioWidth.placeholder = width.toString() + " px";
          } else {
            widthNumeric.value = width;
            aspectRatioWidth.value = width.toString() + " px";
          }
        } else {
          if (isNullOrUndefined(widthNumeric.value)) {
            widthNumeric.placeholder = "0 px";
            aspectRatioWidth.placeholder = "0 px";
            if (isNullOrUndefined(heightNumeric.value) && !isNullOrUndefined(heightNumeric.placeholder)) {
              widthNumeric.placeholder = "" + parent.img.srcWidth;
              aspectRatioWidth.placeholder = "" + parent.img.srcWidth;
            }
          } else {
            widthNumeric.value = 0;
            aspectRatioWidth.value = "0 px";
          }
        }
      }
    };
    ToolbarModule2.prototype.heightAspectRatio = function(e) {
      if (e.keyCode === 109 || e.keyCode === 9) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var icon = parent.element.querySelector("#" + id + "_aspectratio");
      var originalWidth2 = parent.img.destWidth;
      var originalHeight2 = parent.img.destHeight;
      var aspectRatioWidthValue = parseFloat(aspectRatioWidth.value);
      var value = aspectRatioWidthValue / (originalWidth2 / originalHeight2);
      var ht = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
      var heightNumeric = getComponent(aspectRatioHeight, "numerictextbox");
      var widthNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      if (icon) {
        if (!isNaN(ht)) {
          if (isNullOrUndefined(heightNumeric.value)) {
            heightNumeric.placeholder = ht + " px";
            aspectRatioHeight.placeholder = ht.toString() + " px";
          } else {
            heightNumeric.value = ht;
            aspectRatioHeight.value = ht.toString() + " px";
          }
        } else {
          if (isNullOrUndefined(heightNumeric.value)) {
            heightNumeric.placeholder = "0 px";
            aspectRatioHeight.placeholder = "0 px";
            if (isNullOrUndefined(widthNumeric.value) && !isNullOrUndefined(widthNumeric.placeholder)) {
              heightNumeric.placeholder = "" + parent.img.srcHeight;
              aspectRatioHeight.placeholder = "" + parent.img.srcHeight;
            }
          } else {
            heightNumeric.value = 0;
            aspectRatioHeight.value = "0 px";
          }
        }
      }
    };
    ToolbarModule2.prototype.getResizeToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var isResize = parent.aspectWidth && parent.aspectHeight ? true : false;
      var width = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ? Math.ceil(this.parent.img.srcHeight).toString() : Math.ceil(this.parent.img.srcWidth).toString();
      var height = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ? Math.ceil(this.parent.img.srcWidth).toString() : Math.ceil(this.parent.img.srcHeight).toString();
      var toolbarItems = [];
      var spanWidth = document.createElement("span");
      spanWidth.innerHTML = this.l10n.getConstant("W");
      toolbarItems.push({ id: id + "_width", cssClass: "e-ie-resize-width", template: spanWidth, align: "Center" });
      toolbarItems.push({
        id: id + "_resizeWidth",
        prefixIcon: "e-icons e-anti-clock-wise",
        tooltipText: this.l10n.getConstant("Width"),
        align: "Center",
        type: "Input",
        template: new NumericTextBox({
          width: 75,
          htmlAttributes: { maxLength: "4" },
          showSpinButton: false,
          value: isResize ? parent.aspectWidth : null,
          placeholder: isResize ? null : width,
          format: "###.## px"
        })
      });
      var spanHeight = document.createElement("span");
      spanHeight.innerHTML = this.l10n.getConstant("H");
      toolbarItems.push({ id: id + "_height", cssClass: "e-ie-resize-height", template: spanHeight, align: "Center" });
      toolbarItems.push({
        id: id + "_resizeHeight",
        prefixIcon: "e-icons e-clock-wise",
        tooltipText: this.l10n.getConstant("Height"),
        align: "Center",
        type: "Input",
        template: new NumericTextBox({
          width: 75,
          htmlAttributes: { maxLength: "4" },
          showSpinButton: false,
          value: isResize ? parent.aspectHeight : null,
          placeholder: isResize ? null : height,
          format: "###.## px"
        })
      });
      if (!this.isAspectRatio) {
        toolbarItems.push({
          id: id + "_aspectratio",
          prefixIcon: "e-icons e-lock",
          align: "Center",
          tooltipText: this.l10n.getConstant("AspectRatio"),
          type: "Button",
          tabIndex: 0
        });
        this.isAspectRatio = true;
      } else {
        toolbarItems.push({ id: id + "_nonaspectratio", prefixIcon: "e-icons e-unlock", align: "Center", tooltipText: this.l10n.getConstant("AspectRatio"), type: "Button" });
        this.isAspectRatio = false;
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initResizeToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem(false, true);
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getResizeToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "resize", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.wireResizeBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && !isNullOrUndefined(document.getElementById(id + "_bottomToolbar"))) {
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && !isNullOrUndefined(document.getElementById(id + "_toolbar"))) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      parent.isResize = false;
      this.enableDisableTbrBtn();
      parent.isResize = true;
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.wireResizeBtnEvents = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      if (!isNullOrUndefined(aspectRatioHeight)) {
        aspectRatioHeight.addEventListener("keydown", this.widthPress.bind(this));
        aspectRatioWidth.addEventListener("keyup", this.heightAspectRatio.bind(this));
      }
      if (!isNullOrUndefined(aspectRatioWidth)) {
        aspectRatioWidth.addEventListener("keydown", this.heightPress.bind(this));
        aspectRatioHeight.addEventListener("keyup", this.widthAspectRatio.bind(this));
      }
    };
    ToolbarModule2.prototype.enableDisableTbrBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (!this.preventEnableDisableUr) {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var undoRedoObj = { undoRedoStep: null };
        parent.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
        var undo = parent.element.querySelector("#" + id + "_undo");
        if (undo && undoRedoObj["undoRedoStep"] === 0) {
          undo.classList.add("e-disabled");
          undo.parentElement.classList.add("e-overlay");
        } else if (undo && undoRedoObj["undoRedoStep"] > 0) {
          undo.classList.remove("e-disabled");
          undo.parentElement.classList.remove("e-overlay");
        }
        var redo = parent.element.querySelector("#" + id + "_redo");
        if (redo && undoRedoObj["undoRedoStep"] === object["appliedUndoRedoColl"].length) {
          redo.classList.add("e-disabled");
          redo.parentElement.classList.add("e-overlay");
        } else if (redo && (undoRedoObj["undoRedoStep"] === 0 && object["appliedUndoRedoColl"].length > 0)) {
          redo.classList.remove("e-disabled");
          redo.parentElement.classList.remove("e-overlay");
        } else if (redo && undoRedoObj["undoRedoStep"] > 0) {
          redo.classList.remove("e-disabled");
          redo.parentElement.classList.remove("e-overlay");
        }
      }
      var zoomIn = document.querySelector("#" + id + "_zoomIn");
      if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
        zoomIn.classList.add("e-disabled");
        zoomIn.parentElement.classList.add("e-overlay");
      } else if (zoomIn) {
        zoomIn.classList.remove("e-disabled");
        zoomIn.parentElement.classList.remove("e-overlay");
      }
      var zoomOut = document.querySelector("#" + id + "_zoomOut");
      if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
        zoomOut.classList.add("e-disabled");
        zoomOut.parentElement.classList.add("e-overlay");
      } else if (zoomOut) {
        zoomOut.classList.remove("e-disabled");
        zoomOut.parentElement.classList.remove("e-overlay");
      }
      var frame = document.querySelector("#" + id + "_frame");
      if (frame && (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop)) {
        frame.classList.add("e-disabled");
      } else if (frame) {
        frame.classList.remove("e-disabled");
      }
    };
    ToolbarModule2.prototype.createLeftToolbarControls = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (this.defToolbarItems !== void 0 && this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
        var uploadDiv = document.getElementById(id + "_toolbar").querySelector(".e-image-upload");
        if (uploadDiv) {
          var uploadElem = uploadDiv.getElementsByTagName("input")[0];
          var uploadBtnElem = uploadDiv.getElementsByTagName("button")[0];
          uploadBtnElem.className = "e-tbar-btn e-tbtn-txt top-icon";
          uploadBtnElem.innerHTML = "";
          uploadBtnElem.appendChild(parent.createElement("span", {
            className: "e-btn-icon e-icons e-upload-icon e-icon-left"
          }));
          uploadElem.onchange = this.fileSelect.bind(this, uploadElem);
        }
      }
    };
    ToolbarModule2.prototype.fileSelect = function(inputElement, args) {
      var type = inputElement.files[0].type.split("/")[1];
      var filesTypes = ["png", "jpg", "jpeg", "svg", "svg+xml"];
      this.fileName = inputElement.files[0].name.split(".")[0];
      this.parent.notify("toolbar", { prop: "setInitialSize", value: { value: inputElement.files[0].size } });
      if (filesTypes.indexOf(type) > -1) {
        this.parent.notify("draw", { prop: "fileSelect", value: { inputElement, args } });
      } else {
        this.parent.showDialogPopup();
      }
    };
    ToolbarModule2.prototype.triggerTbarClickEvent = function(args) {
      var clickEvent = { item: args.item, originalEvent: args.event };
      this.parent.trigger("toolbarItemClicked", clickEvent);
    };
    ToolbarModule2.prototype.renderAnnotationBtn = function(isContextualToolbar) {
      var _this = this;
      var parent = this.parent;
      var isCustomized = false;
      var items = [];
      var id = parent.element.id;
      var defItems = ["Ellipse", "Arrow", "Line", "Rectangle", "Pen", "Path", "Text", "Image"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Pen") > -1) {
        items.push({ text: this.l10n.getConstant("Pen"), id: "pen", iconCss: "e-icons e-free-pen" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Line") > -1) {
        items.push({ text: this.l10n.getConstant("Line"), id: "line", iconCss: "e-icons e-line" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Rectangle") > -1) {
        items.push({ text: this.l10n.getConstant("Rectangle"), id: "rectangle", iconCss: "e-icons e-rectangle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Ellipse") > -1) {
        items.push({ text: this.l10n.getConstant("Ellipse"), id: "ellipse", iconCss: "e-icons e-circle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Arrow") > -1) {
        items.push({ text: this.l10n.getConstant("Arrow"), id: "arrow", iconCss: "e-icons e-arrow-right-up" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Path") > -1) {
        items.push({ text: this.l10n.getConstant("Path"), id: "path", iconCss: "e-icons e-critical-path" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Text") > -1) {
        items.push({ text: this.l10n.getConstant("Text"), id: "text", iconCss: "e-icons e-add-text" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Image") > -1) {
        items.push({ text: this.l10n.getConstant("Image"), id: "image", iconCss: "e-icons e-image" });
      }
      var obj = { freehandDrawSelectedId: null };
      parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
      var duplicateElement = document.querySelector("#" + id + "_duplicate");
      var removeElement = document.querySelector("#" + id + "_remove");
      var editTextElement = document.querySelector("#" + id + "_editText");
      var zOrderElement = document.querySelector("#" + id + "_zOrderBtn");
      if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0 && (isNullOrUndefined(parent.activeObj.pointColl) || parent.activeObj.pointColl && parent.activeObj.pointColl.length === 0) && isNullOrUndefined(obj["freehandDrawSelectedId"])) {
        if (duplicateElement) {
          duplicateElement.classList.add("e-disabled");
        }
        if (removeElement) {
          removeElement.classList.add("e-disabled");
        }
        if (editTextElement) {
          editTextElement.classList.add("e-disabled");
        }
        if (zOrderElement) {
          zOrderElement.classList.add("e-disabled");
        }
      } else {
        if (duplicateElement) {
          duplicateElement.classList.remove("e-disabled");
        }
        if (removeElement) {
          removeElement.classList.remove("e-disabled");
        }
        if (editTextElement) {
          editTextElement.classList.remove("e-disabled");
        }
        if (zOrderElement) {
          zOrderElement.classList.remove("e-disabled");
        }
      }
      var iconCss = isContextualToolbar ? this.getCurrentShapeIcon(parent.activeObj.shape) : "e-annotation";
      var drpDownBtn = new DropDownButton({
        items,
        iconCss: "e-icons " + iconCss,
        cssClass: "e-image-popup",
        open: function(args) {
          if (parent.currObjType.isFiltered) {
            parent.okBtn();
            parent.element.querySelector("#" + id + "_annotationBtn").click();
          }
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          if (parent.activeObj.shape) {
            document.getElementById(parent.activeObj.shape).classList.add("e-selected");
          } else if (parent.togglePen) {
            document.getElementById("pen").classList.add("e-selected");
          }
        },
        select: function(args) {
          parent.noPushUndo = false;
          _this.triggerTbarClickEvent(args);
          parent.okBtn();
          var isCropSelection = false;
          var splitWords;
          if (parent.activeObj.shape !== void 0) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
          } else if (splitWords !== void 0 && splitWords[0] === "crop") {
            isCropSelection = true;
          }
          parent.currObjType.isCustomCrop = false;
          if (isCropSelection || parent.togglePan) {
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
            _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            _this.refreshToolbar("main");
          }
          var obj2 = { currentFreehandDrawIndex: null };
          parent.notify("freehand-draw", { prop: "getCurrentFreehandDrawIndex", value: { obj: obj2 } });
          var prevObj = { shapeSettingsObj: {} };
          var shapeSettings;
          var shapeChangingArgs;
          drpDownBtn.iconCss = "e-icons " + _this.getCurrentShapeIcon(args.item.id);
          parent.notify("draw", { prop: "updateTempObjColl" });
          parent.notify("draw", { prop: "updateTempPointColl" });
          switch (args.item.id) {
            case "pen":
              parent.drawingShape = null;
              parent.notify("draw", { prop: "setTempFreehandCounter", value: { tempFreehandCounter: parent.freehandCounter } });
              parent.notify("draw", { prop: "setTempCurrentFreehandDrawIndex", value: { tempCurrentFreehandDrawIndex: obj2["currentFreehandDrawIndex"] } });
              _this.currentToolbar = "pen";
              parent.freeHandDraw(true);
              parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: prevObj } });
              shapeSettings = prevObj["shapeSettingsObj"];
              shapeSettings.type = ShapeType.FreehandDraw;
              shapeChangingArgs = {
                cancel: false,
                action: "insert",
                previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings
              };
              parent.notify("freehand-draw", { prop: "triggerShapeChanging", value: { shapeChangingArgs } });
              break;
            case "text":
              _this.currentToolbar = "text";
              parent.drawingShape = args.item.id;
              _this.currentToolbar = "text";
              _this.setInitialShapeSettings(args);
              parent.notify("selection", { prop: "annotate", value: { shape: args.item.id } });
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "text",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
              break;
            case "image":
              parent.drawingShape = null;
              _this.currentToolbar = "shapes";
              parent.element.querySelector("#" + id + "_fileUpload").click();
              break;
            case "ellipse":
            case "arrow":
            case "line":
            case "rectangle":
            case "path":
              parent.drawingShape = args.item.id;
              _this.currentToolbar = "shapes";
              _this.setInitialShapeSettings(args);
              parent.notify("selection", { prop: "annotate", value: { shape: args.item.id } });
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
              parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: prevObj } });
              shapeSettings = prevObj["shapeSettingsObj"];
              shapeChangingArgs = {
                cancel: false,
                action: "insert",
                previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings
              };
              parent.trigger("shapeChanging", shapeChangingArgs);
              parent.notify("shape", { prop: "updateShapeChangeEventArgs", value: { shapeSettings: shapeChangingArgs.currentShapeSettings } });
              break;
          }
          _this.updateToolbarItems();
          var tempTogglePen = parent.togglePen;
          if (args.item.id === "pen") {
            parent.togglePen = false;
          }
          parent.notify("draw", { prop: "redrawDownScale" });
          parent.togglePen = tempTogglePen;
        }
      });
      drpDownBtn.appendTo("#" + id + "_annotationBtn");
    };
    ToolbarModule2.prototype.renderStraightenSlider = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && parent.element.querySelector("#" + id + "_straightenSlider")) {
        var slider = this.createSlider(-45, 45, parent.cropObj.straighten, "straighten");
        slider.appendTo("#" + id + "_straightenSlider");
        var sliderHandle = slider.element.querySelector(".e-handle");
        if (sliderHandle && !Browser.isDevice) {
          sliderHandle.addEventListener("mousedown", function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
          sliderHandle.addEventListener("touchstart", function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
        }
      }
    };
    ToolbarModule2.prototype.renderCropBtn = function(shapeString) {
      var _this = this;
      var parent = this.parent;
      var items = [];
      var isCustomized = false;
      var defItems = ["CustomSelection", "CircleSelection", "SquareSelection", "RatioSelection"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("CustomSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Custom"), id: "custom", iconCss: "e-icons e-custom" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("CircleSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Circle"), id: "circle", iconCss: "e-icons e-circle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("SquareSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Square"), id: "square", iconCss: "e-icons e-square" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("RatioSelection") > -1) {
        items.push({ text: "2:3", id: "2:3", iconCss: "e-icons e-custom-f" });
        items.push({ text: "3:2", id: "3:2", iconCss: "e-icons e-custom-a" });
        items.push({ text: "3:4", id: "3:4", iconCss: "e-icons e-custom-g" });
        items.push({ text: "4:3", id: "4:3", iconCss: "e-icons e-custom-b" });
        items.push({ text: "4:5", id: "4:5", iconCss: "e-icons e-custom-h" });
        items.push({ text: "5:4", id: "5:4", iconCss: "e-icons e-custom-c" });
        items.push({ text: "5:7", id: "5:7", iconCss: "e-icons e-custom-i" });
        items.push({ text: "7:5", id: "7:5", iconCss: "e-icons e-custom-d" });
        items.push({ text: "9:16", id: "9:16", iconCss: "e-icons e-custom-j" });
        items.push({ text: "16:9", id: "16:9", iconCss: "e-icons e-custom-e" });
      }
      var iconCss;
      var shape;
      if (shapeString) {
        iconCss = this.getCurrentShapeIcon(shapeString);
        shape = shapeString;
      } else if (parent.activeObj.shape && (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) || parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0) {
        iconCss = this.getCurrentShapeIcon(parent.activeObj.shape);
        shape = parent.activeObj.shape;
      } else if (parent.currSelectionPoint) {
        iconCss = this.getCurrentShapeIcon(parent.currSelectionPoint.shape);
        shape = parent.currSelectionPoint.shape;
      } else {
        iconCss = items[0].iconCss;
        shape = items[0].id;
      }
      var drpDownBtn = new DropDownButton({
        open: function(args) {
          if (parent.togglePan) {
            _this.cancelPan();
          }
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          if (parent.activeObj.shape && parent.activeObj.shape.split("-").length > 1) {
            var elem = document.getElementById(parent.activeObj.shape.split("-")[1]);
            if (elem) {
              elem.classList.add("e-selected");
              elem.focus();
            }
          }
          parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
        },
        items,
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          _this.cropSelect(args);
          drpDownBtn.iconCss = "e-icons " + _this.getCurrentShapeIcon("crop-" + args.item.id);
          drpDownBtn.content = Browser.isDevice ? null : parent.toPascalCase(args.item.id);
        },
        iconCss: "e-icons " + iconCss,
        cssClass: "e-image-popup e-ie-crop-ddb-popup",
        content: Browser.isDevice ? null : parent.toPascalCase(shape.replace("crop-", ""))
      });
      drpDownBtn.appendTo("#" + parent.element.id + "_cropBtn");
    };
    ToolbarModule2.prototype.renderTransformBtn = function() {
      var _this = this;
      var parent = this.parent;
      var items = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("RotateLeft") > -1) {
        items.push({ text: this.l10n.getConstant("RotateLeft"), id: "rotateleft", iconCss: "e-icons e-anti-clock-wise" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("RotateRight") > -1) {
        items.push({ text: this.l10n.getConstant("RotateRight"), id: "rotateright", iconCss: "e-icons e-clock-wise" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("FlipHorizontal") > -1) {
        items.push({ text: this.l10n.getConstant("HorizontalFlip"), id: "horizontalflip", iconCss: "e-icons e-horizontal-flip" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("FlipVertical") > -1) {
        items.push({ text: this.l10n.getConstant("VerticalFlip"), id: "verticalflip", iconCss: "e-icons e-vertical-flip" });
      }
      var drpDownBtn = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var elem = args.element.parentElement;
            var ht = elem.offsetHeight;
            elem.style.display = "none";
            elem.style.top = drpDownBtn.element.getBoundingClientRect().top - ht + "px";
            elem.style.display = "block";
          }
        },
        items,
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          parent.transformSelect.bind(_this);
        },
        iconCss: "e-icons e-transform",
        cssClass: "e-image-popup"
      });
      drpDownBtn.appendTo("#" + parent.element.id + "_transformBtn");
    };
    ToolbarModule2.prototype.saveDialogPopup = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var quality = ["Good", "Great", "Highest"];
      parent.element.appendChild(parent.createElement("div", { id: id + "_saveDialog" }));
      var dialogContent = parent.createElement("div", {
        id: id + "_dialogContent",
        attrs: { style: "display: flex;" }
      });
      var dialogImgContent = dialogContent.appendChild(parent.createElement("div", {
        id: id + "_dialogImgContent",
        className: "e-ie-dlg-img-content"
      }));
      dialogImgContent.appendChild(parent.createElement("canvas", {
        id: id + "_imgPic",
        className: "e-ie-img-dlg-canvas"
      }));
      var imageNameContainer = dialogImgContent.appendChild(parent.createElement("div", {
        id: id + "_imageNameContainer",
        className: "e-ie-img-size"
      }));
      imageNameContainer.appendChild(parent.createElement("span", {
        id: id + "_imageNameLabel",
        className: "e-ie-quality-info"
      }));
      var dialogRightContent = dialogContent.appendChild(parent.createElement("div", {
        id: id + "_dialogRightContent",
        className: "e-ie-dlg-right-content"
      }));
      var imageNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_namediv",
        className: "e-ie-img-save-name"
      }));
      imageNameDiv.appendChild(parent.createElement("span", {
        id: id + "_labelImgname",
        className: "e-ie-img-label-name",
        innerHTML: this.l10n.getConstant("ImageName")
      }));
      imageNameDiv.appendChild(parent.createElement("input", {
        id: id + "_imgNametext",
        className: "e-ie-img-input",
        attrs: { type: "text" }
      }));
      var formatNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_imgNamediv",
        className: "e-ie-img-save-dlg"
      }));
      formatNameDiv.appendChild(parent.createElement("span", {
        id: id + "_labelname",
        className: "e-ie-img-label-name",
        innerHTML: this.l10n.getConstant("Format")
      }));
      formatNameDiv.appendChild(parent.createElement("button", {
        id: id + "_saveDropdownbtn",
        attrs: { tabindex: "1" }
      }));
      var qualityNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_imgQualitydiv",
        className: "e-ie-img-quality-name"
      }));
      var qualityDiv = parent.createElement("div", {
        id: id + "_qualityContainer"
      });
      qualityDiv.appendChild(parent.createElement("span", {
        id: id + "_qualityLabel",
        className: "e-ie-img-quality-label",
        innerHTML: this.l10n.getConstant("Quality")
      }));
      qualityDiv.appendChild(parent.createElement("span", {
        id: id + "_qualityInfo",
        className: "e-circle-info e-icons e-ie-quality-span",
        attrs: { title: this.l10n.getConstant("QualityInfo") }
      }));
      var qualityValueElem = qualityDiv.appendChild(parent.createElement("div", {
        id: id + "_imgsizeSpan",
        className: "e-ie-img-size-value-span"
      }));
      qualityValueElem.appendChild(parent.createElement("span", {
        id: id + "_imgsizeValueSpan",
        className: ""
      }));
      qualityNameDiv.appendChild(qualityDiv);
      var qualityOptionDiv = parent.createElement("div", {
        id: id + "_qualityOptionContainer",
        className: "e-ie-quality-option-container"
      });
      var buttonGroup = qualityNameDiv.appendChild(parent.createElement("div", {
        id: id + "_qualityButtonGroup",
        className: "e-btn-group"
      }));
      quality.forEach(function(option) {
        var input = document.createElement("input");
        input.type = "radio";
        input.id = id + "_" + option.toLowerCase();
        input.name = "quality";
        input.value = option.toLowerCase();
        var label = document.createElement("label");
        label.className = "e-btn";
        label.htmlFor = option.toLowerCase();
        label.textContent = _this.l10n.getConstant(option);
        buttonGroup.appendChild(input);
        buttonGroup.appendChild(label);
      });
      qualityOptionDiv.appendChild(buttonGroup);
      qualityOptionDiv.appendChild(parent.createElement("div", {
        id: id + "_qualitySlider",
        className: "e-ie-img-quality-slider"
      }));
      qualityOptionDiv.appendChild(parent.createElement("button", { id: id + "_qualitybuttonIcon", className: "e-ie-img-icon-button", attrs: { type: "button" } }));
      qualityNameDiv.appendChild(qualityOptionDiv);
      if (Browser.isDevice) {
        qualityNameDiv.appendChild(parent.createElement("span", {
          id: id + "_qualitySize",
          className: "e-ie-img-quality-size"
        }));
      }
      parent.element.querySelector("#" + id + "_saveDialog").style.display = "block";
      parent.element.appendChild(dialogContent);
      var dialog = new Dialog({
        target: parent.element,
        header: this.l10n.getConstant("SaveAs"),
        closeOnEscape: true,
        content: document.getElementById(id + "_dialogContent"),
        width: Browser.isDevice ? "345px" : "570px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        beforeOpen: this.onBeforeopen(),
        close: this.saveDialogClosed.bind(this, id),
        cssClass: "e-ie-save-dialog",
        buttons: [
          {
            "click": function() {
              dialog.hide();
            },
            buttonModel: {
              content: this.l10n.getConstant("Close"),
              cssClass: "e-save-cancel-btn"
            }
          },
          {
            "click": function() {
              _this.download();
              dialog.hide();
              _this.isSlider = false;
            },
            buttonModel: {
              isPrimary: true,
              content: this.l10n.getConstant("Download"),
              cssClass: "e-flat e-save-download-btn"
            }
          }
        ]
      });
      dialog.appendTo("#" + id + "_saveDialog");
    };
    ToolbarModule2.prototype.saveDialogClosed = function(id) {
      if (getComponent(document.getElementById(id + "_saveDropdownbtn"), "dropdownbutton")) {
        getComponent(document.getElementById(id + "_saveDropdownbtn"), "dropdownbutton").destroy();
      }
      this.isSlider = false;
      if (document.querySelector("#" + id + "_qualityButtonGroup") && document.querySelector("#" + id + "_qualitySlider")) {
        document.querySelector("#" + id + "_qualityButtonGroup").remove();
        document.querySelector("#" + id + "_qualitySlider").remove();
        document.querySelector("#" + id + "_imgsizeValueSpan").remove();
        document.querySelector("#" + id + "_imageNameLabel").remove();
        document.querySelector("#" + id + "_imgsizeSpan").remove();
      }
      document.getElementById(id + "_dialogContent").remove();
      getComponent(document.getElementById(id + "_saveDialog"), "dialog").destroy();
      document.getElementById(id + "_saveDialog").remove();
    };
    ToolbarModule2.prototype.onBeforeopen = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var obj = { canvas: null };
      var items = [
        { id: "jpeg", text: "JPEG" },
        { id: "png", text: "PNG" },
        { id: "svg", text: "SVG" }
      ];
      var inputObj = new TextBox({
        placeholder: this.l10n.getConstant("ImageName")
      });
      inputObj.appendTo("#" + id + "_imgNametext");
      var qualityContainer = document.getElementById(id + "_imgQualitydiv");
      var slider = document.getElementById(id + "_qualitySlider");
      var qualityBtnGrp = document.querySelector("#" + id + "_qualityButtonGroup");
      var qualityBtnIcon = document.querySelector("#" + id + "_qualitybuttonIcon");
      var qualitySliderValue = document.querySelector("#" + id + "_imgsizeSpan");
      var imageNameLabel;
      if (Browser.isDevice) {
        imageNameLabel = document.getElementById(id + "_qualitySize");
      } else {
        imageNameLabel = document.getElementById(id + "_imageNameLabel");
      }
      var fileObj = { fileName: "", fileType: "" };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj: fileObj } });
      this.fileType = fileObj["fileType"];
      parent.notify("export", { prop: "exportToCanvas", value: { object: obj } });
      var tempCanvas = obj["canvas"];
      var canvas = document.getElementById(id + "_imgPic");
      canvas.width = tempCanvas.width;
      canvas.height = tempCanvas.height;
      var buttonIcon = new Button({ iconCss: "e-icons e-settings" });
      buttonIcon.appendTo("#" + id + "_qualitybuttonIcon");
      var ddbElem = document.getElementById(id + "_saveDropdownbtn");
      if (ddbElem) {
        var spanElem_1 = document.createElement("span");
        spanElem_1.innerHTML = fileObj["fileType"].toUpperCase();
        if (ddbElem) {
          ddbElem.appendChild(spanElem_1);
        }
        var drpDownBtn_1 = new DropDownButton({
          items,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_1.innerHTML;
            if (activeBtn !== "") {
              args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            qualitySliderValue.style.display = "none";
            _this.fileType = spanElem_1.innerHTML = args.item.text;
            if (args.item.id !== "jpeg") {
              qualityContainer.style.display = "none";
              imageNameLabel.style.display = "block";
              if (_this.initialSize > 1e3) {
                var megabytes = _this.initialSize / 1048576;
                imageNameLabel.innerHTML = _this.l10n.getConstant("ImageSize") + ": " + megabytes.toFixed(2) + " MB";
              } else {
                imageNameLabel.innerHTML = _this.l10n.getConstant("ImageSize") + ": " + _this.initialSize.toFixed(2) + " KB";
              }
              if (slider) {
                if (_this.isSlider) {
                  getComponent(slider, "slider").destroy();
                }
                slider.style.display = "none";
              }
              _this.isSlider = false;
            } else {
              qualityContainer.style.display = "block";
              removeClass([qualityBtnGrp], "e-hide");
              slider.style.display = "none";
              imageNameLabel.style.display = "block";
              _this.updateImageSize(isNullOrUndefined(_this.currentQuality) ? 1 : _this.currentQuality, obj["canvas"]);
              document.getElementById(id + "_" + _this.imageQuality).checked = true;
            }
          }
        });
        drpDownBtn_1.appendTo("#" + id + "_saveDropdownbtn");
        var imgName = document.getElementById(id + "_imgNametext");
        imgName.value = this.fileName ? this.fileName : fileObj["fileName"];
        if (fileObj["fileType"].toUpperCase() !== "JPEG") {
          qualityContainer.style.display = "none";
          qualitySliderValue.style.display = "none";
        }
        if (Browser.isDevice) {
          document.getElementById(id + "_dialogImgContent").style.display = "none";
          document.getElementById(id + "_dialogRightContent").style.width = "100%";
          this.updateImageSize(1, obj["canvas"]);
        } else {
          this.updateImageSize(1, obj["canvas"]);
        }
      }
      document.getElementById(id + "_" + this.imageQuality).checked = true;
      qualityBtnGrp.addEventListener("click", this.qualityBtnClickHandler.bind(this));
      qualityBtnIcon.addEventListener("click", this.qualityBtnClickHandler.bind(this));
    };
    ToolbarModule2.prototype.qualityBtnClickHandler = function(event) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var target = event.target;
      var fileObj = { fileName: "" };
      var obj = { canvas: null };
      var compressionValues = {
        "Good": 0.8,
        "Great": 0.9,
        "Highest": 1
      };
      var qualityBtnGrp = document.querySelector("#" + id + "_qualityButtonGroup");
      var qualitySlider = document.querySelector("#" + id + "_qualitySlider");
      var qualityOption = document.querySelector("#" + id + "_qualityOptionContainer");
      var qualitySliderValueDiv = document.querySelector("#" + id + "_imgsizeSpan");
      var qualitySliderValueSpan = document.querySelector("#" + id + "_imgsizeValueSpan");
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj: fileObj } });
      parent.notify("export", { prop: "exportToCanvas", value: { object: obj } });
      if (event.currentTarget.id === id + "_qualitybuttonIcon" && !this.isSlider) {
        addClass([qualityBtnGrp], "e-hide");
        qualitySlider.style.display = "block";
        qualitySliderValueDiv.style.display = "inline-block";
        qualityOption.style.display = "flex";
        var sliderObj = new Slider({
          tooltip: { placement: "Before", isVisible: true, format: "P0", showOn: "Focus" },
          min: 0.01,
          max: 1,
          step: 0.01,
          value: this.currentQuality,
          type: "MinRange",
          width: Browser.isDevice ? "80%" : "190px",
          created: function() {
            _this.updateImageSize(_this.currentQuality, obj["canvas"]);
            qualitySliderValueSpan.innerHTML = Math.round(_this.currentQuality * 100).toString();
          },
          changed: function(args) {
            _this.currentQuality = args.value;
            qualitySliderValueSpan.innerHTML = Math.round(_this.currentQuality * 100).toString();
            parent.notify("export", { prop: "setImageQuality", value: { value: args.value } });
            _this.updateImageSize(args.value, obj["canvas"]);
          }
        });
        sliderObj.appendTo("#" + id + "_qualitySlider");
        sliderObj.element.parentElement.classList.add("e-ie-quality-slider");
        this.isSlider = true;
      } else if (event.currentTarget.id === id + "_qualitybuttonIcon" && this.isSlider) {
        getComponent(qualitySlider, "slider").destroy();
        qualitySlider.style.display = "none";
        qualitySliderValueDiv.style.display = "none";
        removeClass([qualityBtnGrp], "e-hide");
        qualityOption.style.display = "block";
        this.isSlider = false;
      } else if (compressionValues.hasOwnProperty(target.textContent) && !this.isSlider) {
        event.target.previousElementSibling.checked = true;
        this.currentQuality = compressionValues[target.textContent];
        this.imageQuality = target.textContent.toLowerCase();
        this.updateImageSize(compressionValues[target.textContent], obj["canvas"]);
      }
    };
    ToolbarModule2.prototype.updateImageSize = function(quality, tempCanvas) {
      var fileSize;
      var parent = this.parent;
      var id = parent.element.id;
      var canvas = document.getElementById(id + "_imgPic");
      var ctx = canvas.getContext("2d");
      var imageNameLabel;
      if (Browser.isDevice) {
        imageNameLabel = document.getElementById(id + "_qualitySize");
      } else {
        imageNameLabel = document.getElementById(id + "_imageNameLabel");
      }
      tempCanvas.toBlob((function(blob) {
        fileSize = Math.floor(blob.size / 1024);
        if (fileSize > 1e3) {
          var megabytes = fileSize / 1024;
          imageNameLabel.innerHTML = "Image size: " + megabytes.toFixed(2) + " MB";
          fileSize = +megabytes.toFixed(2);
        } else {
          imageNameLabel.innerHTML = "Image size: " + fileSize.toFixed(2) + " KB";
          fileSize = +fileSize.toFixed(2);
        }
        if (Browser.isDevice) {
          canvas.style.display = "none";
        } else {
          var compressedImage_1 = new Image();
          compressedImage_1.src = URL.createObjectURL(blob);
          compressedImage_1.onload = function() {
            ctx.drawImage(compressedImage_1, 0, 0);
            URL.revokeObjectURL(compressedImage_1.src);
          };
        }
        this.fileSize = fileSize;
      }).bind(this), "image/jpeg", quality);
    };
    ToolbarModule2.prototype.download = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (this.fileType === "JPEG" && this.isSlider) {
        var value = getComponent(document.getElementById(id + "_qualitySlider"), "slider").value;
        parent.notify("export", { prop: "setImageQuality", value: { value } });
      } else {
        parent.notify("export", { prop: "setImageQuality", value: { value: this.currentQuality } });
      }
      var fileName = document.getElementById(id + "_imgNametext").value;
      parent.export(this.fileType, fileName);
    };
    ToolbarModule2.prototype.getCropTransformToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      toolbarItems.push({
        id: id + "_crop",
        tooltipText: this.l10n.getConstant("CropSelection"),
        align: "Center",
        template: '<button id="' + id + '_cropBtn"></button>'
      });
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("RotateLeft") > -1)) {
        toolbarItems.push({ id: id + "_rotateLeft", prefixIcon: "e-icons e-anti-clock-wise", tooltipText: this.l10n.getConstant("RotateLeft"), align: "Center" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("RotateRight") > -1)) {
        toolbarItems.push({ id: id + "_rotateRight", prefixIcon: "e-icons e-clock-wise", tooltipText: this.l10n.getConstant("RotateRight"), align: "Center" });
      }
      if (toolbarItems.length > 2) {
        toolbarItems.push({ align: "Center", type: "Separator" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("HorizontalFlip") > -1)) {
        toolbarItems.push({ id: id + "_horizontalFlip", prefixIcon: "e-icons e-horizontal-flip", tooltipText: this.l10n.getConstant("HorizontalFlip"), align: "Center" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("VerticalFlip") > -1)) {
        toolbarItems.push({ id: id + "_verticalFlip", prefixIcon: "e-icons e-vertical-flip", tooltipText: this.l10n.getConstant("VerticalFlip"), align: "Center" });
      }
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && !Browser.isDevice) {
        toolbarItems.push({ align: "Center", type: "Separator" });
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Straighten") > -1 || parent.toolbar.indexOf("Straighten") > -1)) {
          var spanWidth = document.createElement("span");
          spanWidth.innerHTML = this.l10n.getConstant("Straighten");
          toolbarItems.push({ id: id + "_straightenSpan", cssClass: "e-ie-straighten-span", template: spanWidth, align: "Center" });
          toolbarItems.push({
            id: id + "_straighten",
            cssClass: "top-icon e-straighten",
            tooltipText: this.l10n.getConstant("Straighten"),
            align: "Center",
            type: "Input",
            template: '<div id="' + id + '_straightenSlider"></div>'
          });
          var straightenSpan = document.createElement("span");
          straightenSpan.innerHTML = parent.transform.straighten.toString() + "&#176";
          toolbarItems.push({
            id: id + "_straightenSpan",
            cssClass: "e-ie-straighten-value-span",
            template: straightenSpan,
            align: "Center"
          });
        }
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getShapesToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("fillColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_fillcolor",
          cssClass: "top-icon e-fill",
          tooltipText: this.l10n.getConstant("FillColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_fillColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_strokecolor",
          cssClass: "top-icon e-stroke",
          tooltipText: this.l10n.getConstant("StrokeColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_borderColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeWidth") > -1) {
        toolbarItems.push({
          id: id + "_strokeWidth",
          cssClass: "top-icon e-size",
          tooltipText: "Stroke Width",
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_borderWidthBtn"></button>'
        });
      }
      if (items.indexOf("start") > -1) {
        toolbarItems.push({
          id: id + "_start",
          cssClass: "top-icon e-size",
          tooltipText: "Start",
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_startBtn"></button>'
        });
      }
      if (items.indexOf("end") > -1) {
        toolbarItems.push({
          id: id + "_end",
          cssClass: "top-icon e-size",
          tooltipText: "End",
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_endBtn"></button>'
        });
      }
      if (items.indexOf("flip") > -1) {
        toolbarItems.push({
          id: id + "_rotLeft",
          prefixIcon: "e-anti-clock-wise",
          tooltipText: this.l10n.getConstant("RotateLeft"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_rotRight",
          prefixIcon: "e-clock-wise",
          tooltipText: this.l10n.getConstant("RotateRight"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_hFlip",
          prefixIcon: "e-horizontal-flip",
          tooltipText: this.l10n.getConstant("HorizontalFlip"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_vFlip",
          prefixIcon: "e-vertical-flip",
          tooltipText: this.l10n.getConstant("VerticalFlip"),
          align: "Center"
        });
      }
      if (items.indexOf("transparency") > -1) {
        toolbarItems.push({ align: "Center", type: "Separator" });
        toolbarItems.push({
          id: id + "_transparency",
          prefixIcon: "e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("duplicate") > -1) {
        toolbarItems.push({
          id: id + "_duplicate",
          prefixIcon: "e-icons e-order",
          cssClass: "top-icon e-order",
          tooltipText: this.l10n.getConstant("Duplicate"),
          align: "Center"
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center"
        });
      }
      if (items.indexOf("text") > -1) {
        toolbarItems.push({
          id: id + "_editText",
          prefixIcon: "e-icons e-annotation-edit",
          cssClass: "top-icon e-annotation-edit",
          tooltipText: this.l10n.getConstant("EditText"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] !== "path") {
          toolbarItems.push({
            id: id + "_ok",
            prefixIcon: "e-icons e-check",
            cssClass: "top-icon e-tick",
            tooltipText: this.l10n.getConstant("OK"),
            align: "Right",
            tabIndex: 0
          });
          toolbarItems.push({
            id: id + "_cancel",
            prefixIcon: "e-icons e-close",
            cssClass: "top-icon e-save",
            tooltipText: this.l10n.getConstant("Cancel"),
            align: "Right"
          });
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initCropTransformToolbar = function(shape, isTransform) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getCropTransformToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "crop-transform", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderCropBtn(shape);
          _this.renderStraightenSlider();
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
          if (document.getElementById(id + "_cropBtn") && isNullOrUndefined(isTransform)) {
            if (!Browser.isDevice) {
              parent.notify("draw", {
                prop: "select",
                onPropertyChange: false,
                value: {
                  type: _this.getCropTextContent(document.getElementById(id + "_cropBtn")).toLowerCase(),
                  startX: null,
                  startY: null,
                  width: null,
                  height: null
                }
              });
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      var slider = parent.element.querySelector("#" + id + "_straightenSlider");
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && slider && slider.parentElement.clientHeight > this.toolbarHeight) {
        this.toolbarHeight = parent.toolbarHeight = slider.parentElement.clientHeight;
      }
      this.enableDisableTbrBtn();
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.getCropTextContent = function(elem) {
      if (elem) {
        var classToContentMap = {
          "e-custom": "Custom",
          "e-circle": "Circle",
          "e-square": "Square",
          "e-custom-a": "3:2",
          "e-custom-b": "4:3",
          "e-custom-c": "5:4",
          "e-custom-d": "7:5",
          "e-custom-e": "16:9",
          "e-custom-f": "2:3",
          "e-custom-g": "3:4",
          "e-custom-h": "4:5",
          "e-custom-i": "5:7",
          "e-custom-j": "9:16"
        };
        var classList2 = elem.children[0].classList;
        for (var className in classToContentMap) {
          if (classList2.contains(className)) {
            return classToContentMap[className];
          }
        }
      }
      return "";
    };
    ToolbarModule2.prototype.getCurrentShapeIcon = function(shape) {
      var shapeIcons = {
        rectangle: "e-rectangle",
        ellipse: "e-circle",
        line: "e-line",
        arrow: "e-arrow-right-up",
        path: "e-critical-path",
        text: "e-add-text",
        image: "e-image",
        pen: "e-free-pen",
        "crop-custom": "e-custom",
        "crop-circle": "e-circle",
        "crop-square": "e-square",
        "crop-3:2": "e-custom-a",
        "crop-4:3": "e-custom-b",
        "crop-5:4": "e-custom-c",
        "crop-7:5": "e-custom-d",
        "crop-16:9": "e-custom-e",
        "crop-2:3": "e-custom-f",
        "crop-3:4": "e-custom-g",
        "crop-4:5": "e-custom-h",
        "crop-5:7": "e-custom-i",
        "crop-9:16": "e-custom-j"
      };
      return shapeIcons[shape] ? shapeIcons[shape] : shape && shape.indexOf("crop-") !== -1 ? "e-custom" : "e-free-pen";
    };
    ToolbarModule2.prototype.initShapesToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getShapesToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = {
        toolbarType: parent.activeObj.shape ? parent.activeObj.shape : "shapes",
        toolbarItems: this.defToolbarItems
      };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createShapeColor(items);
          _this.createShapeBtn(items);
          _this.createZOrderBtn(items);
          if (parent.activeObj.shape === "arrow") {
            if (items.some(function(item) {
              return item.toLowerCase().indexOf("start") > -1;
            })) {
              _this.createStartBtn();
            }
            if (items.some(function(item) {
              return item.toLowerCase().indexOf("end") > -1;
            })) {
              _this.createEndBtn();
            }
          }
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.beforeModeSwitch = function(args, inst) {
      this.popupLeft = args.element.offsetParent.style.left;
      if (args.mode === "Picker") {
        inst.showButtons = true;
        inst.dataBind();
        args.element.querySelector(".e-apply").title = this.l10n.getConstant("Apply");
        args.element.querySelector(".e-cancel").title = this.l10n.getConstant("Cancel");
        args.element.querySelector(".e-mode-switch-btn").title = this.l10n.getConstant("StandardColors");
      } else {
        inst.showButtons = false;
        inst.dataBind();
        args.element.querySelector(".e-mode-switch-btn").title = this.l10n.getConstant("MoreColors");
      }
    };
    ToolbarModule2.prototype.createShapeColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fillColor") > -1) {
        parent.element.querySelector(".e-template.e-fill").appendChild(parent.createElement("input", {
          id: id + "_shape_fill"
        }));
        var fillColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: true,
          value: "",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-shape-fill-color",
          beforeModeSwitch: function(args) {
            return _this.beforeModeSwitch(args, fillColor_1);
          },
          presetColors: {
            "custom": [
              "",
              "#f44336",
              "#e91e63",
              "#9c27b0",
              "#673ab7",
              "#2196f3",
              "#03a9f4",
              "#00bcd4",
              "#009688",
              "#ffeb3b",
              "#ffffff",
              "#ffebee",
              "#fce4ec",
              "#f3e5f5",
              "#ede7f6",
              "#e3f2fd",
              "#e1f5fe",
              "#e0f7fa",
              "#e0f2f1",
              "#fffde7",
              "#f2f2f2",
              "#ffcdd2",
              "#f8bbd0",
              "#e1bee7",
              "#d1c4e9",
              "#bbdefb",
              "#b3e5fc",
              "#b2ebf2",
              "#b2dfdb",
              "#fff9c4",
              "#e6e6e6",
              "#ef9a9a",
              "#f48fb1",
              "#ce93d8",
              "#b39ddb",
              "#90caf9",
              "#81d4fa",
              "#80deea",
              "#80cbc4",
              "#fff59d",
              "#cccccc",
              "#e57373",
              "#f06292",
              "#ba68c8",
              "#9575cd",
              "#64b5f6",
              "#4fc3f7",
              "#4dd0e1",
              "#4db6ac",
              "#fff176",
              "#b3b3b3",
              "#ef5350",
              "#ec407a",
              "#ab47bc",
              "#7e57c2",
              "#42a5f5",
              "#29b6f6",
              "#26c6da",
              "#26a69a",
              "#ffee58",
              "#999999",
              "#e53935",
              "#d81b60",
              "#8e24aa",
              "#5e35b1",
              "#1e88e5",
              "#039be5",
              "#00acc1",
              "#00897b",
              "#fdd835",
              "#808080",
              "#d32f2f",
              "#c2185b",
              "#7b1fa2",
              "#512da8",
              "#1976d2",
              "#0288d1",
              "#0097a7",
              "#00796b",
              "#fbc02d",
              "#666666",
              "#c62828",
              "#ad1457",
              "#6a1b9a",
              "#4527a0",
              "#1565c0",
              "#0277bd",
              "#00838f",
              "#00695c",
              "#f9a825",
              "#4d4d4d",
              "#b71c1c",
              "#880e4f",
              "#4a148c",
              "#311b92",
              "#0d47a1",
              "#01579b",
              "#006064",
              "#004d40",
              "#f57f17"
            ]
          },
          beforeTileRender: function(args) {
            if (args.value === "") {
              args.element.classList.add("e-nocolor-item");
            }
          },
          change: function(args) {
            parent.updateFillColor(args.value);
            if (args.currentValue.rgba === "") {
              fillDDB_1.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB_1.element.children[0].classList.remove("e-nocolor-item");
              fillDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            fillDDB_1.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = fillDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            fillDDB_1.toggle();
          }
        }, "#" + id + "_shape_fill");
        var fillDDB_1 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = fillDDB_1.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              parenElem.style.left = parent.element.offsetLeft + "px";
            }
          },
          target: ".e-shape-fill-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_fillColorBtn");
        fillColor_1.inline = true;
        fillColor_1.value = fillColor_1.getValue(fillColor_1.value, "rgba");
        parent.element.querySelector(".e-fill.e-template .e-dropdownbtn-preview").classList.add("e-nocolor-item");
      }
      if (items.indexOf("strokeColor") > -1) {
        parent.element.querySelector(".e-template.e-stroke").appendChild(parent.createElement("input", {
          id: id + "_shape_stroke"
        }));
        var strokeColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: false,
          value: "#fff",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-shape-stroke-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            strokeColor_1.value = parent.activeObj.strokeSettings.strokeColor !== "#fff" ? parent.activeObj.strokeSettings.strokeColor : "#008000ff";
            _this.beforeModeSwitch(args, strokeColor_1);
          },
          presetColors: this.presetColors,
          change: function(args) {
            parent.updateStrokeColor(args.value);
            strokeDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_1.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_1.toggle();
          }
        }, "#" + id + "_shape_stroke");
        var strokeDDB_1 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_1.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              parenElem.style.left = parent.element.offsetLeft + "px";
            }
          },
          target: ".e-shape-stroke-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_borderColorBtn");
        strokeColor_1.inline = true;
        strokeColor_1.value = strokeColor_1.getValue(strokeColor_1.value, "rgba");
        parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createShapeBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("strokeWidth") > -1) {
        var strokeWidthItems = [
          { id: "1", text: this.l10n.getConstant("XSmall") },
          { id: "2", text: this.l10n.getConstant("Small") },
          { id: "3", text: this.l10n.getConstant("Medium") },
          { id: "4", text: this.l10n.getConstant("Large") },
          { id: "5", text: this.l10n.getConstant("XLarge") }
        ];
        if (parent.activeObj.shape && (parent.activeObj.shape === "rectangle" || parent.activeObj.shape === "ellipse")) {
          strokeWidthItems = [
            { id: "1", text: this.l10n.getConstant("NoOutline") },
            { id: "2", text: this.l10n.getConstant("XSmall") },
            { id: "3", text: this.l10n.getConstant("Small") },
            { id: "4", text: this.l10n.getConstant("Medium") },
            { id: "5", text: this.l10n.getConstant("Large") },
            { id: "6", text: this.l10n.getConstant("XLarge") }
          ];
        }
        var strokeWidthBtn = document.getElementById(id + "_borderWidthBtn");
        var spanElem_2 = document.createElement("span");
        spanElem_2.innerHTML = this.l10n.getConstant("XSmall");
        spanElem_2.className = "e-shape-stroke-width";
        strokeWidthBtn.appendChild(spanElem_2);
        var drpDownBtn_2 = new DropDownButton({
          items: strokeWidthItems,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_2.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_2.innerHTML;
            if (activeBtn !== "") {
              args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_2.textContent = args.item.text;
            parent.updateStrokeWidth(args.item.id);
            if (Browser.isDevice) {
              if (document.getElementById(id + "_bottomToolbar")) {
                var toolbar_7 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_7.refreshOverflow();
              }
            } else {
              if (document.getElementById(id + "_toolbar")) {
                var toolbar_8 = getComponent(id + "_toolbar", "toolbar");
                toolbar_8.refreshOverflow();
              }
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        drpDownBtn_2.appendTo("#" + id + "_borderWidthBtn");
      }
    };
    ToolbarModule2.prototype.createZOrderBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("z-order") > -1) {
        var zOrderItems = [
          { text: this.l10n.getConstant("BringForward"), id: "bringForward", iconCss: "e-icons e-bring-forward" },
          { text: this.l10n.getConstant("SendBackward"), id: "sendBackward", iconCss: "e-icons e-send-backward" },
          { text: this.l10n.getConstant("BringToFront"), id: "bringToFront", iconCss: "e-icons e-bring-to-front" },
          { text: this.l10n.getConstant("SendToBack"), id: "sendToBack", iconCss: "e-icons e-send-to-back" }
        ];
        var drpDownBtn_3 = new DropDownButton({
          items: zOrderItems,
          iconCss: "e-icons e-layers",
          beforeOpen: function(args) {
            if (document.getElementById(parent.element.id + "_zOrderBtn").classList.contains("e-disabled")) {
              args.cancel = true;
            }
            var indexObj = { freehandSelectedIndex: -1 };
            parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
            var orderObj = { order: null };
            parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
            var order = parent.activeObj.order ? parent.activeObj.order : parent.getObjFromId(parent.pointColl[indexObj["freehandSelectedIndex"]].id).order;
            if (order && order >= orderObj["order"]) {
              args.items[0].disabled = true;
              args.items[2].disabled = true;
            } else {
              args.items[0].disabled = false;
              args.items[2].disabled = false;
            }
            parent.notify("shape", { prop: "getLowestOrder", onPropertyChange: false, value: { obj: orderObj } });
            if (order && order <= orderObj["order"]) {
              args.items[1].disabled = true;
              args.items[3].disabled = true;
            } else {
              args.items[1].disabled = false;
              args.items[3].disabled = false;
            }
          },
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_3.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            var obj = { freehandDrawSelectedId: null };
            parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
            var shapeId = obj["freehandDrawSelectedId"] ? obj["freehandDrawSelectedId"] : parent.activeObj.currIndex;
            parent.updateShapeOrder(shapeId, args.item.id);
            if (Browser.isDevice) {
              if (document.getElementById(id + "_bottomToolbar")) {
                var toolbar_9 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_9.refreshOverflow();
              }
            } else {
              if (document.getElementById(id + "_toolbar")) {
                var toolbar_10 = getComponent(id + "_toolbar", "toolbar");
                toolbar_10.refreshOverflow();
              }
            }
            if (shapeId.indexOf("shape") > -1) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            } else if (shapeId.indexOf("pen") > -1) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
            }
          }
        });
        drpDownBtn_3.appendTo("#" + id + "_zOrderBtn");
      }
    };
    ToolbarModule2.prototype.createStartBtn = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("None") },
        { id: "2", text: this.l10n.getConstant("Bar") },
        { id: "3", text: this.l10n.getConstant("Arrow") },
        { id: "4", text: this.l10n.getConstant("ArrowSolid") },
        { id: "5", text: this.l10n.getConstant("Circle") },
        { id: "6", text: this.l10n.getConstant("CircleSolid") },
        { id: "7", text: this.l10n.getConstant("Square") },
        { id: "8", text: this.l10n.getConstant("SquareSolid") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_startBtn");
      var spanElem = document.createElement("span");
      if (isNullOrUndefined(parent.activeObj.start)) {
        parent.activeObj.start = "none";
      }
      spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.start);
      spanElem.className = "e-shape-start";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          var activeBtn = spanElem.innerHTML;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          var idToValue = {
            "1": "none",
            "2": "bar",
            "3": "arrow",
            "4": "arrowSolid",
            "5": "circle",
            "6": "circleSolid",
            "7": "square",
            "8": "squareSolid"
          };
          parent.notify("selection", { prop: "setArrowShape", value: { type: "initial", shape: idToValue["" + args.item.id] } });
          _this.triggerTbarClickEvent(args);
          spanElem.textContent = args.item.text;
          parent.updateArrow("startArrow", args.item.id);
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      });
      drpDownBtn.appendTo("#" + id + "_startBtn");
    };
    ToolbarModule2.prototype.createEndBtn = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("None") },
        { id: "2", text: this.l10n.getConstant("Bar") },
        { id: "3", text: this.l10n.getConstant("Arrow") },
        { id: "4", text: this.l10n.getConstant("ArrowSolid") },
        { id: "5", text: this.l10n.getConstant("Circle") },
        { id: "6", text: this.l10n.getConstant("CircleSolid") },
        { id: "7", text: this.l10n.getConstant("Square") },
        { id: "8", text: this.l10n.getConstant("SquareSolid") }
      ];
      var strokeEndBtn = document.getElementById(id + "_endBtn");
      var spanElem = document.createElement("span");
      if (isNullOrUndefined(parent.activeObj.end)) {
        parent.activeObj.end = "arrowSolid";
      }
      spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.end);
      spanElem.className = "e-shape-end";
      strokeEndBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          var activeBtn = spanElem.innerHTML;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          var idToValue = {
            "1": "none",
            "2": "bar",
            "3": "arrow",
            "4": "arrowSolid",
            "5": "circle",
            "6": "circleSolid",
            "7": "square",
            "8": "squareSolid"
          };
          parent.notify("selection", { prop: "setArrowShape", value: { type: "final", shape: idToValue["" + args.item.id] } });
          _this.triggerTbarClickEvent(args);
          spanElem.textContent = args.item.text;
          parent.updateArrow("endArrow", args.item.id);
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      });
      drpDownBtn.appendTo("#" + id + "_endBtn");
    };
    ToolbarModule2.prototype.getTextToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("fontFamily") > -1) {
        toolbarItems.push({
          id: id + "_fontFamily",
          cssClass: "top-icon e-img-font-family",
          tooltipText: this.l10n.getConstant("FontFamily"),
          align: "Center",
          template: '<button id="' + id + '_fontFamilyBtn"></button>'
        });
      }
      if (items.indexOf("fontSize") > -1) {
        toolbarItems.push({
          id: id + "_fontSize",
          cssClass: "top-icon e-img-font-size",
          tooltipText: this.l10n.getConstant("FontSize"),
          align: "Center",
          template: '<button id="' + id + '_fontSizeBtn"></button>'
        });
      }
      if (items.indexOf("fontColor") > -1) {
        toolbarItems.push({
          cssClass: "top-icon e-text-font-color",
          id: id + "_text_strokecolor",
          tooltipText: this.l10n.getConstant("FontColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_fontColorBtn"></button>'
        });
      }
      if (items.indexOf("bold") > -1) {
        toolbarItems.push({
          id: id + "_bold",
          prefixIcon: "e-icons e-bold",
          cssClass: "top-icon e-bold",
          tooltipText: this.l10n.getConstant("Bold"),
          align: "Center"
        });
      }
      if (items.indexOf("italic") > -1) {
        toolbarItems.push({
          id: id + "_italic",
          prefixIcon: "e-icons e-italic",
          cssClass: "top-icon e-italic",
          tooltipText: this.l10n.getConstant("Italic"),
          align: "Center"
        });
      }
      if (items.indexOf("transparency") > -1) {
        toolbarItems.push({
          id: id + "_transparency",
          prefixIcon: "e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("duplicate") > -1) {
        toolbarItems.push({
          id: id + "_duplicate",
          prefixIcon: "e-icons e-order",
          cssClass: "top-icon e-order",
          tooltipText: this.l10n.getConstant("Duplicate"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      if (items.indexOf("text") > -1) {
        toolbarItems.push({
          id: id + "_editText",
          prefixIcon: "e-icons e-annotation-edit",
          cssClass: "top-icon e-annotation-edit",
          tooltipText: this.l10n.getConstant("EditText"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFontFamilyItems = function() {
      var parent = this.parent;
      var items = [];
      if (parent.fontFamily && parent.fontFamily.items && parent.fontFamily.items.length > 0) {
        items = parent.fontFamily.items;
      } else {
        if (Browser.isDevice) {
          items = [
            { id: "arial", text: "ABC" },
            { id: "calibri", text: "ABC" },
            { id: "georgia", text: "ABC" },
            { id: "roboto", text: "ABC" },
            { id: "tahoma", text: "ABC" }
          ];
        } else {
          items = [
            { id: "arial", text: "Arial" },
            { id: "calibri", text: "Calibri" },
            { id: "georgia", text: "Georgia" },
            { id: "roboto", text: "Roboto" },
            { id: "tahoma", text: "Tahoma" }
          ];
        }
      }
      return items;
    };
    ToolbarModule2.prototype.initTextToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getTextToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "text", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createTextColor(items);
          _this.createTextBtn(items);
          _this.createZOrderBtn(items);
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "text" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.createTextColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fontColor") > -1 && parent.element.querySelector(".e-template.e-text-font-color")) {
        parent.element.querySelector(".e-template.e-text-font-color").appendChild(parent.createElement("input", {
          id: id + "_text_font"
        }));
        var fontColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: false,
          value: "#fff",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-text-fontt-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            fontColor_1.value = parent.activeObj.strokeSettings.strokeColor !== "#fff" ? parent.activeObj.strokeSettings.strokeColor : "#008000ff";
            _this.beforeModeSwitch(args, fontColor_1);
          },
          presetColors: this.presetColors,
          change: function(args) {
            parent.updateFontColor(args.value);
            strokeDDB_2.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_2.toggle();
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_2.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_2.toggle();
          }
        }, "#" + id + "_text_font");
        var strokeDDB_2 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_2.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              parenElem.style.left = parent.element.offsetLeft + "px";
            }
          },
          target: ".e-text-fontt-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_fontColorBtn");
        fontColor_1.inline = true;
        fontColor_1.value = fontColor_1.getValue(fontColor_1.value, "rgba");
        parent.element.querySelector(".e-text-font-color.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createTextBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fontFamily") > -1) {
        var fontNameBtn = document.getElementById(id + "_fontFamilyBtn");
        var spanElem_3 = document.createElement("span");
        if (Browser.isDevice) {
          spanElem_3.innerHTML = "ABC";
          spanElem_3.setAttribute("style", "font-family: " + parent.fontFamily.default.toLowerCase() + "'");
        } else {
          spanElem_3.innerHTML = parent.fontFamily.default;
        }
        spanElem_3.className = "e-text-font-family";
        if (fontNameBtn) {
          fontNameBtn.appendChild(spanElem_3);
        }
        var fontFamilyBtn_1 = new DropDownButton({
          items: this.getFontFamilyItems(),
          cssClass: "e-font-family",
          createPopupOnClick: true,
          beforeItemRender: function(args) {
            args.element.setAttribute("style", "font-family:" + args.element.id);
          },
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = fontFamilyBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var fontFamily;
            if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
              fontFamily = parent.textArea.style.fontFamily;
            } else {
              fontFamily = parent.activeObj.textSettings.fontFamily;
            }
            var elem = args.element.querySelector('[id *= "' + fontFamily.toLowerCase() + '"]');
            if (elem) {
              elem.classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_3.textContent = args.item.text;
            if (Browser.isDevice) {
              spanElem_3.setAttribute("style", "font-family:" + args.item.id);
            }
            parent.updateFontFamily(args.item.id);
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        fontFamilyBtn_1.appendTo("#" + id + "_fontFamilyBtn");
      }
      if (items.indexOf("fontSize") > -1) {
        var fontSizeBtnElem = document.getElementById(id + "_fontSizeBtn");
        var fontSizeSpanElem_1 = document.createElement("span");
        var fontSizes = parent.getFontSizes();
        fontSizeSpanElem_1.innerHTML = fontSizes[0].text;
        fontSizeSpanElem_1.className = "e-text-font-size";
        fontSizeBtnElem.appendChild(fontSizeSpanElem_1);
        var fontSizeBtn_1 = new DropDownButton({
          cssClass: "e-font-size",
          items: fontSizes,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = fontSizeBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = fontSizeSpanElem_1.innerHTML;
            args.element.querySelector('[aria-label *= "' + activeBtn + '"]').classList.add("e-selected-btn");
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            fontSizeSpanElem_1.textContent = args.item.text;
            parent.updateFontSize(args.item.text);
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        fontSizeBtn_1.appendTo("#" + id + "_fontSizeBtn");
      }
    };
    ToolbarModule2.prototype.refreshToolbar = function(type, isApplyBtn, isCropping, isZooming, cType, shape, isTransform) {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isImageLoaded || parent.isCropToolbar) {
        return;
      }
      var args = {};
      var aspectIcon;
      var nonAspectIcon;
      if (type !== "filter" && type !== "color") {
        var toolbarElement = document.getElementById(id + "_toolbar");
        var cusWrapper = document.getElementById(id + "_customizeWrapper");
        var bottomToolbar = document.getElementById(id + "_bottomToolbar");
        if (cusWrapper && getComponent(cusWrapper, "toolbar") && this.defToolbarItems.length > 0) {
          getComponent(cusWrapper, "toolbar").destroy();
          cusWrapper.innerHTML = "";
        }
        if (toolbarElement && toolbarElement.classList.contains("e-control") && this.defToolbarItems.length > 0) {
          getComponent(toolbarElement, "toolbar").destroy();
          toolbarElement.innerHTML = "";
        }
        if (toolbarElement && (this.defToolbarItems.length > 0 || parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1)) {
          var toolbar_11 = getComponent(toolbarElement, "toolbar");
          if (!isNullOrUndefined(toolbar_11)) {
            toolbar_11.destroy();
            document.getElementById(parent.element.id + "_toolbar").innerHTML = "";
          }
        }
        if (bottomToolbar && this.defToolbarItems.length > 0) {
          if (bottomToolbar.className.indexOf("e-control") > -1) {
            getComponent(bottomToolbar, "toolbar").destroy();
            bottomToolbar.innerHTML = "";
          }
        }
      }
      this.refreshSlider();
      if (document.querySelector(".e-slider-tooltip")) {
        document.querySelector(".e-slider-tooltip").remove();
      }
      this.isFrameToolbar = parent.isCropTab = false;
      switch (type) {
        case "main":
          if (Browser.isDevice) {
            if (isCropping) {
              this.initMainToolbar(false, true, true, false, false, true);
            } else {
              this.initMainToolbar(false, true, null, false, false, true);
            }
          } else if (!Browser.isDevice || isZooming) {
            if (isZooming) {
              this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
            } else {
              this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
            }
          }
          if (Browser.isDevice) {
            this.initBottomToolbar();
          }
          break;
        case "shapes":
          parent.noPushUndo = true;
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "path") {
            args.toolbarItems = ["strokeColor", "strokeWidth", "z-order", "duplicate", "remove"];
          } else if (parent.activeObj.shape === "arrow") {
            args.toolbarItems = ["strokeColor", "strokeWidth", "start", "end", "z-order", "duplicate", "remove"];
          } else if (parent.activeObj.shape === "image") {
            args.toolbarItems = ["flip", "z-order", "duplicate", "remove", "transparency"];
          } else {
            args.toolbarItems = ["fillColor", "strokeColor", "strokeWidth", "z-order", "duplicate", "remove"];
          }
          this.initShapesToolbarItem(args.toolbarItems);
          break;
        case "text":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          args.toolbarItems = ["fontFamily", "fontSize", "fontColor", "bold", "italic", "z-order", "duplicate", "remove", "text"];
          this.initTextToolbarItem(args.toolbarItems);
          break;
        case "pen":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          args.toolbarItems = ["strokeColor", "strokeWidth", "z-order", "remove", "transparency"];
          this.initPenToolbarItem(args.toolbarItems);
          break;
        case "adjustment":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          this.initAdjustmentToolbarItem();
          break;
        case "filter":
          this.updateContextualToolbar(type);
          break;
        case "resize":
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.aspectHeight = parent.aspectWidth;
            this.isAspectRatio = false;
          }
          this.initResizeToolbar();
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true, true);
          }
          aspectIcon = parent.element.querySelector("#" + id + "_aspectratio");
          nonAspectIcon = parent.element.querySelector("#" + id + "_nonaspectratio");
          if (parent.aspectWidth && parent.aspectHeight) {
            if (nonAspectIcon) {
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
            } else if (aspectIcon) {
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
            }
          }
          break;
        case "color":
          this.updateContextualToolbar(type, cType);
          break;
        case "croptransform":
          if (isNullOrUndefined(isTransform)) {
            parent.allowDownScale = false;
            parent.isCropTab = true;
          }
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          if (isNullOrUndefined(isTransform)) {
            parent.updateCropTransformItems();
          }
          this.initCropTransformToolbar(shape, isTransform);
          if (Browser.isDevice && this.isToolbar()) {
            this.updateContextualToolbar("color", "straighten", true);
          }
          break;
        case "frame":
          this.isFrameToolbar = true;
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
            this.initMainToolbar(false, true, true, false, true);
          } else {
            this.initMainToolbar(true, null, null, false, true);
          }
          var frameElem = parent.element.querySelector("#" + id + "_" + parent.frameObj.type);
          if (frameElem) {
            frameElem.classList.add("e-selected-btn");
          }
          if (parent.frameObj.type !== "none") {
            this.updateContextualToolbar(type, cType);
          }
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
          break;
      }
      this.currToolbar = type;
      this.refreshDropDownBtn(isCropping);
      this.updateKBDNavigation(this.currToolbar);
    };
    ToolbarModule2.prototype.updateKBDNavigation = function(type) {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isKBDNavigation) {
        return;
      }
      if (this.isToolbar()) {
        var tbar = parent.element.querySelectorAll("#" + id + "_toolbar")[0];
        var tbarInitialChild = void 0;
        var tbarInitialBtn_1;
        if (tbar) {
          tbarInitialChild = tbar.querySelector(".e-toolbar-center");
          if (!tbarInitialChild || !tbarInitialChild.children[0]) {
            return;
          }
          tbarInitialBtn_1 = tbarInitialChild.children[0].querySelector(".e-btn");
          var tempElem = tbarInitialChild.children[1];
          if (tempElem) {
            tempElem = tempElem.children[0];
          }
          if (tempElem) {
            tempElem = tempElem.children[0];
          }
          if (type === "resize" && tempElem) {
            tbarInitialBtn_1 = tempElem;
          }
          if (tbarInitialBtn_1) {
            if (type === "main") {
              setTimeout(function() {
                return tbarInitialBtn_1.focus();
              }, 50);
            } else {
              tbarInitialBtn_1.focus();
            }
          }
        }
      }
    };
    ToolbarModule2.prototype.performCropTransformClick = function(shape, isTransform) {
      var parent = this.parent;
      if (isNullOrUndefined(isTransform)) {
        parent.notify("draw", { prop: "setTempStraightenZoomDeg" });
        parent.tempStraighten = parent.transform.straighten;
        if (parent.currObjType.isFiltered) {
          parent.okBtn();
        }
        parent.isStraightening = true;
      }
      this.refreshToolbar("croptransform", null, null, null, null, shape, isTransform);
      if (isNullOrUndefined(isTransform)) {
        parent.notify("draw", { prop: "setDestForStraighten" });
        parent.notify("draw", { prop: "setTempDestForStraighten" });
      }
    };
    ToolbarModule2.prototype.getAdjustmentToolbarItem = function() {
      var toolbarItems = [];
      var parent = this.parent;
      var isCustomized = false;
      var id = parent.element.id;
      var defItems = ["Brightness", "Contrast", "Hue", "Saturation", "Exposure", "Opacity", "Blur"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Brightness") > -1) {
        toolbarItems.push({
          id: id + "_brightness",
          prefixIcon: "e-icons e-brightness",
          cssClass: "top-icon e-brightness",
          tooltipText: this.l10n.getConstant("Brightness"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Contrast") > -1) {
        toolbarItems.push({
          id: id + "_contrast",
          prefixIcon: "e-icons e-contrast",
          cssClass: "top-icon e-contrast",
          tooltipText: this.l10n.getConstant("Contrast"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Hue") > -1) {
        toolbarItems.push({
          id: id + "_hue",
          prefixIcon: "e-icons e-fade",
          cssClass: "top-icon e-fade",
          tooltipText: this.l10n.getConstant("Hue"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Saturation") > -1) {
        toolbarItems.push({
          id: id + "_saturation",
          prefixIcon: "e-icons e-saturation",
          cssClass: "top-icon e-saturation",
          tooltipText: this.l10n.getConstant("Saturation"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Exposure") > -1) {
        toolbarItems.push({
          id: id + "_exposure",
          prefixIcon: "e-icons e-grain",
          cssClass: "top-icon e-grain",
          tooltipText: this.l10n.getConstant("Exposure"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Opacity") > -1) {
        toolbarItems.push({
          id: id + "_opacity",
          prefixIcon: "e-icons e-opacity",
          cssClass: "top-icon e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Blur") > -1) {
        toolbarItems.push({
          id: id + "_blur",
          prefixIcon: "e-icons e-tint",
          cssClass: "top-icon e-tint",
          tooltipText: this.l10n.getConstant("Blur"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFrameToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      toolbarItems.push({
        prefixIcon: "e-icons e-copy",
        id: id + "_frameColor",
        cssClass: "top-icon e-stroke",
        tooltipText: this.l10n.getConstant("Color"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("Color") + '</span><button id="' + id + '_frameColorBtn"></button>'
      });
      toolbarItems.push({
        prefixIcon: "e-icons e-copy",
        id: id + "_frameGradient",
        cssClass: "top-icon e-frame-stroke",
        tooltipText: this.l10n.getConstant("GradientColor"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("GradientColor") + '</span><button id="' + id + '_frameGradientColorBtn"></button>'
      });
      toolbarItems.push({
        id: id + "_frameSize",
        cssClass: "top-icon e-size",
        tooltipText: this.l10n.getConstant("Size"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("Size") + '</span><button id="' + id + '_frameSizeBtn"></button>'
      });
      if (parent.frameObj.type === "line" || parent.frameObj.type === "inset" || parent.frameObj.type === "hook") {
        toolbarItems.push({
          id: id + "_frameInset",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Inset"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Inset") + '</span><button id="' + id + '_frameInsetBtn"></button>'
        });
      }
      if (parent.frameObj.type === "line" || parent.frameObj.type === "inset") {
        toolbarItems.push({
          id: id + "_frameOffset",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Offset"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Offset") + '</span><button id="' + id + '_frameOffsetBtn"></button>'
        });
      }
      if (parent.frameObj.type === "line") {
        toolbarItems.push({
          id: id + "_frameRadius",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Radius"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Radius") + '</span><button id="' + id + '_frameRadiusBtn"></button>'
        });
        toolbarItems.push({
          id: id + "_frameAmount",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Amount"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Amount") + '</span><button id="' + id + '_frameAmountBtn"></button>'
        });
        toolbarItems.push({
          id: id + "_frameBorder",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Border"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Border") + '</span><button id="' + id + '_frameBorderBtn"></button>'
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFilterToolbarItem = function() {
      var toolbarItems = [];
      var parent = this.parent;
      var isCustomized = false;
      var id = parent.element.id;
      var defItems = ["Default", "Chrome", "Cold", "Warm", "Grayscale", "Sepia", "Invert"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Default") > -1) {
        toolbarItems.push({
          id: id + "_default",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Default"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_defaultCanvas tabindex=0></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Default") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Chrome") > -1) {
        toolbarItems.push({
          id: id + "_chrome",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Chrome"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_chromeCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Chrome") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Cold") > -1) {
        toolbarItems.push({
          id: id + "_cold",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Cold"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_coldCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Cold") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Warm") > -1) {
        toolbarItems.push({
          id: id + "_warm",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Warm"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_warmCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Warm") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Grayscale") > -1) {
        toolbarItems.push({
          id: id + "_grayscale",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Grayscale"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_grayscaleCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Grayscale") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Sepia") > -1) {
        toolbarItems.push({
          id: id + "_sepia",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Sepia"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_sepiaCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Sepia") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Invert") > -1) {
        toolbarItems.push({
          id: id + "_invert",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Invert"),
          align: "Center",
          template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + id + '_invertCanvas></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant("Invert") + "</span></div></div>"
        });
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getPenToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("strokeColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_pen_strokecolor",
          cssClass: "top-icon e-pen-stroke-color",
          tooltipText: this.l10n.getConstant("StrokeColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_penColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeWidth") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_pen_strokewidth",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("StrokeWidth"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_penStrokeWidth"></button>'
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initPenToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getPenToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "pen", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createPenColor(items);
          _this.createPenBtn(items);
          _this.createZOrderBtn(items);
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "pen" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.createPenColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("strokeColor") > -1) {
        parent.element.querySelector(".e-template.e-pen-stroke-color").appendChild(parent.createElement("input", {
          id: id + "_pen_stroke"
        }));
        var presentVal = parent.activeObj.strokeSettings.strokeColor;
        var penColor = new ColorPicker({
          modeSwitcher: false,
          value: "#fff",
          showButtons: false,
          mode: "Palette",
          cssClass: "e-pen-color",
          change: function(args) {
            parent.updatePenStrokeColor(args.currentValue.hex);
            _this.selFhdColor = args.currentValue.hex;
            strokeDDB_3.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_3.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
          }
        }, "#" + id + "_pen_stroke");
        var strokeDDB_3 = new DropDownButton({
          open: function(args) {
            var parentElem = args.element.parentElement;
            if (Browser.isDevice) {
              parentElem.style.top = strokeDDB_3.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
              parentElem.style.left = parent.element.offsetLeft + "px";
            }
          },
          target: ".e-pen-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_penColorBtn");
        penColor.inline = true;
        penColor.value = penColor.getValue(parent.activeObj.strokeSettings.strokeColor, "rgba");
        if (penColor.value === "null") {
          penColor.value = presentVal;
        }
        var obj = { tempFreeHandDrawEditingStyles: null };
        parent.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] > -1) {
          parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview").style.background = this.selFhdColor === "#42a5f5" ? obj["tempFreeHandDrawEditingStyles"].strokeColor : parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
        } else {
          parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview").style.background = penColor.value;
        }
      }
    };
    ToolbarModule2.prototype.createPenBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("XSmall") },
        { id: "2", text: this.l10n.getConstant("Small") },
        { id: "3", text: this.l10n.getConstant("Medium") },
        { id: "4", text: this.l10n.getConstant("Large") },
        { id: "5", text: this.l10n.getConstant("XLarge") }
      ];
      if (items.indexOf("strokeWidth") > -1) {
        var strokeWidthBtn = document.getElementById(id + "_penStrokeWidth");
        var spanElem_4 = document.createElement("span");
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] > -1) {
          spanElem_4.innerHTML = this.getPenStroke(parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth);
        } else {
          var obj = { penStrokeWidth: 2 };
          parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj } });
          if (obj["penStrokeWidth"]) {
            spanElem_4.innerHTML = this.getPenStroke(obj["penStrokeWidth"]);
          } else {
            spanElem_4.innerHTML = this.l10n.getConstant("Small");
          }
        }
        spanElem_4.className = "e-pen-stroke-width";
        strokeWidthBtn.appendChild(spanElem_4);
        var drpDownBtn_4 = new DropDownButton({
          items: strokeWidthItems,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_4.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_4.innerHTML;
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_4.textContent = args.item.text;
            parent.updatePenStrokeWidth(args.item.id);
            if (Browser.isDevice) {
              if (document.getElementById(id + "_bottomToolbar")) {
                var toolbar_12 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_12.refreshOverflow();
              }
            } else {
              if (document.getElementById(id + "_toolbar")) {
                var toolbar_13 = getComponent(id + "_toolbar", "toolbar");
                toolbar_13.refreshOverflow();
              }
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
          }
        });
        drpDownBtn_4.appendTo("#" + id + "_penStrokeWidth");
      }
    };
    ToolbarModule2.prototype.getPenStroke = function(value) {
      var textContent = "";
      var valueToTextContent = {
        1: this.l10n.getConstant("XSmall"),
        2: this.l10n.getConstant("Small"),
        3: this.l10n.getConstant("Medium"),
        4: this.l10n.getConstant("Large"),
        5: this.l10n.getConstant("XLarge")
      };
      if (value >= 1 && value <= 5) {
        textContent = valueToTextContent[value];
      }
      return textContent;
    };
    ToolbarModule2.prototype.initAdjustmentToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem(null);
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getAdjustmentToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "finetune", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.wireZoomBtnEvents();
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.initFrameToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var canvasWrapper = document.querySelector("#" + id + "_contextualToolbarArea");
      var frameWrapper = document.querySelector("#" + id + "_frameWrapper");
      if (frameWrapper) {
        frameWrapper.style.display = "block";
      } else {
        frameWrapper = canvasWrapper.appendChild(parent.createElement("div", {
          id: id + "_frameWrapper",
          className: "e-frame-wrapper",
          styles: "position: relative"
        }));
      }
      frameWrapper.appendChild(parent.createElement("div", {
        id: id + "_customizeWrapper",
        styles: "position: absolute"
      }));
      var mainItem = this.getFrameToolbarItem();
      var args = { toolbarType: "frame", toolbarItems: mainItem };
      parent.trigger("toolbarUpdating", args);
      mainItem = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: mainItem,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.createFrameColor();
          _this.createFrameSize();
          var frameType = parent.frameObj.type;
          if (frameType === "line") {
            _this.createFrameRadius();
          }
          if (frameType === "line" || frameType === "inset" || frameType === "hook") {
            _this.createFrameInset();
          }
          if (frameType === "line" || frameType === "inset") {
            _this.createFrameOffset();
          }
          if (frameType === "line") {
            _this.createFrameAmount();
            _this.createFrameBorder();
          }
          _this.createFrameGradientColor();
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && document.getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
          parent.element.querySelector("#" + id + "_" + frameType).focus();
        }
      });
      toolbar.appendTo("#" + id + "_customizeWrapper");
    };
    ToolbarModule2.prototype.createFrameGradientColor = function() {
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      parent.element.querySelector(".e-template.e-frame-stroke").appendChild(parent.createElement("input", {
        id: id + "_frame_gradient_fill"
      }));
      var fillColor = new ColorPicker({
        modeSwitcher: false,
        noColor: true,
        value: parent.frameObj.gradientColor,
        showButtons: false,
        mode: "Palette",
        cssClass: "e-frame-gradient-fill-color",
        change: function(args) {
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.gradientColor;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.gradientColor = args.currentValue.hex;
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (args.currentValue.rgba === "") {
              fillDDB.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB.element.children[0].classList.remove("e-nocolor-item");
              fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.gradientColor = temp;
          }
          fillDDB.toggle();
        }
      }, "#" + id + "_frame_gradient_fill");
      var fillDDB = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = fillDDB.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
            parentElem.style.left = parent.element.offsetLeft + "px";
          }
        },
        target: ".e-frame-gradient-fill-color",
        iconCss: "e-dropdownbtn-preview",
        cssClass: "e-ie-ddb-popup"
      }, "#" + id + "_frameGradientColorBtn");
      fillColor.inline = true;
      if (parent.frameObj.gradientColor === "") {
        parent.element.querySelector(".e-frame-stroke.e-template .e-dropdownbtn-preview").classList.add("e-nocolor-item");
      } else {
        parent.element.querySelector(".e-frame-stroke.e-template .e-dropdownbtn-preview").style.background = parent.frameObj.gradientColor;
      }
    };
    ToolbarModule2.prototype.createFrameColor = function() {
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      parent.element.querySelector(".e-template.e-stroke").appendChild(parent.createElement("input", {
        id: id + "_frame_fill"
      }));
      var fillColor = new ColorPicker({
        modeSwitcher: false,
        value: parent.frameObj.color,
        showButtons: false,
        mode: "Palette",
        cssClass: "e-frame-fill-color",
        change: function(args) {
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.color;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.color = args.currentValue.hex;
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (args.currentValue.rgba === "") {
              fillDDB.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB.element.children[0].classList.remove("e-nocolor-item");
              fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.color = temp;
          }
          fillDDB.toggle();
        }
      }, "#" + id + "_frame_fill");
      var fillDDB = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = fillDDB.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
            parentElem.style.left = parent.element.offsetLeft + "px";
          }
        },
        target: ".e-frame-fill-color",
        iconCss: "e-dropdownbtn-preview",
        cssClass: "e-ie-ddb-popup"
      }, "#" + id + "_frameColorBtn");
      fillColor.inline = true;
      parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview").style.background = parent.frameObj.color;
    };
    ToolbarModule2.prototype.createFrameSize = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameSizeBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.size.toString());
      spanElem.className = "e-frame-stroke-width";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.size;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.size = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.size = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_14 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_14.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_15 = getComponent(id + "_toolbar", "toolbar");
              toolbar_15.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameSizeBtn");
    };
    ToolbarModule2.prototype.createFrameInset = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameInsetBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.inset.toString());
      spanElem.className = "e-frame-inset";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.inset;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.inset = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.inset = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_16 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_16.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_17 = getComponent(id + "_toolbar", "toolbar");
              toolbar_17.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameInsetBtn");
    };
    ToolbarModule2.prototype.createFrameOffset = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameOffsetBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.offset.toString());
      spanElem.className = "e-frame-offset";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            lineCount: parent.frameObj.amount,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border)
          };
          var temp = parent.frameObj.offset;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.offset = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.offset = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_18 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_18.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_19 = getComponent(id + "_toolbar", "toolbar");
              toolbar_19.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameOffsetBtn");
    };
    ToolbarModule2.prototype.createFrameRadius = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("0") },
        { id: "2", text: this.l10n.getConstant("20") },
        { id: "3", text: this.l10n.getConstant("40") },
        { id: "4", text: this.l10n.getConstant("60") },
        { id: "5", text: this.l10n.getConstant("80") },
        { id: "6", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameRadiusBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.radius.toString());
      spanElem.className = "e-frame-radius";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.radius;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.radius = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.radius = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_20 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_20.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_21 = getComponent(id + "_toolbar", "toolbar");
              toolbar_21.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameRadiusBtn");
    };
    ToolbarModule2.prototype.createFrameAmount = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("1") },
        { id: "2", text: this.l10n.getConstant("2") },
        { id: "3", text: this.l10n.getConstant("3") },
        { id: "4", text: this.l10n.getConstant("4") },
        { id: "5", text: this.l10n.getConstant("5") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameAmountBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.amount.toString());
      spanElem.className = "e-frame-amount";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            lineCount: parent.frameObj.amount,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border)
          };
          var temp = parent.frameObj.amount;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.amount = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = { previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting, currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.amount = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_22 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_22.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_23 = getComponent(id + "_toolbar", "toolbar");
              toolbar_23.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameAmountBtn");
    };
    ToolbarModule2.prototype.createFrameBorder = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("Solid") },
        { id: "2", text: this.l10n.getConstant("Dashed") },
        { id: "3", text: this.l10n.getConstant("Dotted") }
      ];
      var strokeWidthBtn = document.getElementById(id + "_frameBorderBtn");
      var spanElem = document.createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.toPascalCase(parent.frameObj.border));
      spanElem.className = "e-frame-border";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            lineCount: parent.frameObj.amount,
            color: parent.frameObj.color,
            borderRadius: parent.frameObj.radius,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            type: parent.toPascalCase(parent.frameObj.type)
          };
          var temp = parent.frameObj.border;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.border = args.item.text.toLowerCase();
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = { previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting, currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.border = temp;
          }
          if (Browser.isDevice) {
            if (document.getElementById(id + "_bottomToolbar")) {
              var toolbar_24 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_24.refreshOverflow();
            }
          } else {
            if (document.getElementById(id + "_toolbar")) {
              var toolbar_25 = getComponent(id + "_toolbar", "toolbar");
              toolbar_25.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameBorderBtn");
    };
    ToolbarModule2.prototype.initFilterToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var mainItem = this.getFilterToolbarItem();
      var args = { toolbarType: "filter", toolbarItems: mainItem };
      parent.trigger("toolbarUpdating", args);
      mainItem = args.toolbarItems;
      if (document.querySelector("#" + id + "_contextualToolbar").classList.contains("e-control")) {
        getComponent(document.getElementById(id + "_contextualToolbar"), "toolbar").destroy();
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: mainItem,
        clicked: this.contextualToolbarClicked.bind(this),
        created: function() {
          _this.updatePrivateVariables();
          _this.createCanvasFilter();
          if (parent.currentFilter === "") {
            parent.currentFilter = id + "_default";
          }
          var hdrWrapper = document.querySelector("#" + id + "_headWrapper");
          if (hdrWrapper) {
            hdrWrapper.style.display = "none";
          }
          var filterElem = document.getElementById(parent.currentFilter + "Canvas");
          if (filterElem) {
            filterElem.parentElement.parentElement.classList.add("e-selected");
          }
          _this.enableDisableTbrBtn();
          toolbar.refreshOverflow();
        }
      });
      toolbar.appendTo("#" + id + "_contextualToolbar");
    };
    ToolbarModule2.prototype.drawDashedLine = function(ctx) {
      ctx.beginPath();
      ctx.setLineDash([5]);
      ctx.rect(10, 10, 280, 130);
      ctx.stroke();
      ctx.closePath();
    };
    ToolbarModule2.prototype.createCanvasFilter = function() {
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var imageData = parent.getCurrentCanvasData();
      this.inMemoryCanvas.width = imageData.width;
      this.inMemoryCanvas.height = imageData.height;
      this.inMemoryContext.putImageData(imageData, 0, 0);
      this.updateFilterCanvas("_defaultCanvas", "default");
      this.updateFilterCanvas("_chromeCanvas", "chrome");
      this.updateFilterCanvas("_coldCanvas", "cold");
      this.updateFilterCanvas("_warmCanvas", "warm");
      this.updateFilterCanvas("_grayscaleCanvas", "grayscale");
      this.updateFilterCanvas("_sepiaCanvas", "sepia");
      this.updateFilterCanvas("_invertCanvas", "invert");
      hideSpinner(parent.element);
      parent.element.style.opacity = "1";
      parent.initialAdjustmentValue = this.lowerContext.filter;
    };
    ToolbarModule2.prototype.updateFilterCanvas = function(selector, type) {
      var parent = this.parent;
      var filter = parent.element.querySelector("#" + parent.element.id + selector);
      if (filter) {
        var ctx = filter.getContext("2d");
        ctx = filter.getContext("2d");
        filter.style.width = "100px";
        filter.style.height = "100px";
        parent.notify("filter", { prop: "updateAdj", value: { type, value: null, isPreview: true, ctx } });
        ctx.drawImage(this.inMemoryCanvas, 0, 0, 300, 150);
      }
    };
    ToolbarModule2.prototype.getQuickAccessToolbarItem = function(isPenEdit) {
      var parent = this.parent;
      var id = parent.element.id;
      var args = { cancel: false, toolbarItems: [] };
      var toolbarItems = [];
      if (isNullOrUndefined(isPenEdit)) {
        if (parent.activeObj.shape === "image") {
          toolbarItems.push("Flip");
        }
        toolbarItems.push("BringToFront");
        toolbarItems.push("Clone");
        toolbarItems.push("Delete");
        if (parent.activeObj.shape === "text") {
          toolbarItems.push("EditText");
        }
        args.shape = parent.toPascalCase(parent.activeObj.shape);
      } else if (isPenEdit) {
        toolbarItems.push("BringToFront");
        toolbarItems.push("Delete");
        args.shape = "Freehand draw";
      }
      args.toolbarItems = extend([], toolbarItems, null, true);
      parent.trigger("quickAccessToolbarOpen", args);
      var orgToolbarItems = [];
      if (args.cancel) {
        orgToolbarItems = [];
      } else {
        for (var i = 0; i < args.toolbarItems.length; i++) {
          switch (args.toolbarItems[i]) {
            case "BringToFront":
              orgToolbarItems.push({
                id: id + "_bringToFront",
                prefixIcon: "e-icons e-bring-to-front",
                tooltipText: this.l10n.getConstant("BringToFront"),
                align: "Left"
              });
              break;
            case "Clone":
              orgToolbarItems.push({
                id: id + "_duplicate",
                prefixIcon: "e-icons e-order",
                cssClass: "top-icon e-order",
                tooltipText: this.l10n.getConstant("Duplicate"),
                align: "Left"
              });
              break;
            case "Delete":
              orgToolbarItems.push({
                id: id + "_remove",
                prefixIcon: "e-icons e-trash",
                cssClass: "top-icon e-trash",
                tooltipText: this.l10n.getConstant("Remove"),
                align: "Left"
              });
              break;
            case "EditText":
              orgToolbarItems.push({
                id: id + "_editText",
                prefixIcon: "e-icons e-annotation-edit",
                cssClass: "top-icon e-annotation-edit",
                tooltipText: this.l10n.getConstant("EditText"),
                align: "Left"
              });
              break;
            case "Flip":
              orgToolbarItems.push({
                id: id + "_hFlip",
                prefixIcon: "e-icons e-horizontal-flip",
                tooltipText: this.l10n.getConstant("HorizontalFlip"),
                align: "Left"
              });
              orgToolbarItems.push({
                id: id + "_vFlip",
                prefixIcon: "e-icons e-vertical-flip",
                tooltipText: this.l10n.getConstant("VerticalFlip"),
                align: "Left"
              });
              break;
            default:
              orgToolbarItems.push(args.toolbarItems[i]);
              break;
          }
        }
      }
      return orgToolbarItems;
    };
    ToolbarModule2.prototype.renderQAT = function(isPenEdit) {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.activeObj && parent.showQuickAccessToolbar) {
        var qtArea = document.getElementById(id + "_quickAccessToolbarArea");
        if (qtArea) {
          this.destroyQuickAccessToolbar();
          qtArea.style.display = "block";
        }
        var items = this.getQuickAccessToolbarItem(isPenEdit);
        if (items.length === 0) {
          return;
        }
        if (isNullOrUndefined(parent.quickAccessToolbarTemplate)) {
          var toolbarObj = new Toolbar({
            items,
            clicked: this.quickAccessToolbarClicked.bind(this)
          });
          toolbarObj.appendTo("#" + id + "_quickAccessToolbar");
        }
        var height = this.toolbarHeight && this.toolbarHeight !== 0 ? this.toolbarHeight : qtArea.clientHeight;
        if (isNullOrUndefined(isPenEdit) && (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0 || parent.activeObj.shape && parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0)) {
          var orderObj = { order: null };
          parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
          if (parent.activeObj.order > orderObj["order"]) {
            document.getElementById(parent.element.id + "_bringToFront").classList.add("e-disabled");
          } else {
            document.getElementById(parent.element.id + "_bringToFront").classList.remove("e-disabled");
          }
          qtArea.style.width = "auto";
          parent.activeObj.activePoint.width = Math.abs(parent.activeObj.activePoint.width);
          parent.activeObj.activePoint.height = Math.abs(parent.activeObj.activePoint.height);
          var x = parent.activeObj.activePoint.startX < parent.activeObj.activePoint.endX ? parent.activeObj.activePoint.startX : parent.activeObj.activePoint.endX;
          var y = parent.activeObj.activePoint.startY < parent.activeObj.activePoint.endY ? parent.activeObj.activePoint.startY : parent.activeObj.activePoint.endY;
          var width = parent.activeObj.activePoint.width;
          if (parent.activeObj.rotatedAngle !== 0 && parent.activeObj.shape !== "arrow") {
            var object = { activePoint: null };
            parent.notify("shape", {
              prop: "getSquarePointForRotatedShape",
              onPropertyChange: false,
              value: { obj: parent.activeObj, object }
            });
            var point = object["activePoint"];
            x = point.startX;
            y = point.startY;
            width = point.width;
          } else if (parent.activeObj.shape === "path") {
            var path = parent.getSquarePointForPath(parent.activeObj);
            x = path.startX;
            y = path.startY;
            width = path.width;
          }
          qtArea.style.left = x + width / 2 - items.length * 25 + "px";
          if (parseFloat(qtArea.style.left) + qtArea.clientWidth / 2 !== x + width / 2) {
            var diff = x + width / 2 - (parseFloat(qtArea.style.left) + qtArea.clientWidth / 2);
            qtArea.style.left = parseFloat(qtArea.style.left) + diff + "px";
          }
          if (y - (height + height / 1.5) < parent.img.destTop) {
            qtArea.style.top = parent.img.destTop + "px";
          } else {
            qtArea.style.top = y - (height + height / 1.5) + "px";
          }
        } else if (isPenEdit) {
          var indexObj = { freehandSelectedIndex: -1 };
          parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
          var orderObj = { order: null };
          parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
          if (parent.getObjFromId(parent.pointColl[indexObj["freehandSelectedIndex"]].id).order >= orderObj["order"]) {
            document.getElementById(parent.element.id + "_bringToFront").classList.add("e-disabled");
          } else {
            document.getElementById(parent.element.id + "_bringToFront").classList.remove("e-disabled");
          }
          var obj = { activePoint: null };
          parent.notify("freehand-draw", {
            prop: "getSqPtFD",
            value: { idx: indexObj["freehandSelectedIndex"], obj }
          });
          var point = obj["activePoint"];
          qtArea.style.width = "auto";
          qtArea.style.left = point.startX + point.width / 2 - items.length * 24 + "px";
          if (point.startY - (height + height / 1.5) < parent.img.destTop) {
            qtArea.style.top = parent.img.destTop + "px";
          } else {
            qtArea.style.top = point.startY - (height + height / 1.5) + "px";
          }
        } else {
          qtArea.style.display = "none";
        }
        if (parseFloat(qtArea.style.top) < 0) {
          qtArea.style.top = "0px";
        }
      }
    };
    ToolbarModule2.prototype.refreshDropDownBtn = function(isDisabled) {
      if (isNullOrUndefined(isDisabled)) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var annotation = document.querySelector("#" + id + "_annotationBtn");
      if (annotation) {
        if (isDisabled) {
          annotation.classList.add("e-disabled");
          annotation.parentElement.classList.add("e-overlay");
        } else {
          annotation.classList.remove("e-disabled");
          annotation.parentElement.classList.remove("e-overlay");
        }
        getComponent(annotation, "dropdown-btn").disabled = isDisabled;
      }
      var transform = document.querySelector("#" + id + "_transformBtn");
      if (transform) {
        if (isDisabled) {
          transform.classList.add("e-disabled");
          transform.parentElement.classList.add("e-overlay");
        } else {
          transform.classList.remove("e-disabled");
          transform.parentElement.classList.remove("e-overlay");
        }
        getComponent(transform, "dropdown-btn").disabled = isDisabled;
      }
      var adjustment = document.querySelector("#" + id + "_adjustment");
      if (adjustment) {
        if (isDisabled) {
          adjustment.classList.add("e-disabled");
          adjustment.parentElement.classList.add("e-overlay");
        } else {
          adjustment.classList.remove("e-disabled");
          adjustment.parentElement.classList.remove("e-overlay");
        }
        getComponent(adjustment, "btn").disabled = isDisabled;
      }
      var filter = document.querySelector("#" + id + "_filter");
      if (filter) {
        if (isDisabled) {
          filter.classList.add("e-disabled");
          filter.parentElement.classList.add("e-overlay");
        } else {
          filter.classList.remove("e-disabled");
          filter.parentElement.classList.remove("e-overlay");
        }
        getComponent(filter, "btn").disabled = isDisabled;
      }
    };
    ToolbarModule2.prototype.cropSelect = function(args) {
      var parent = this.parent;
      parent.isCropTab = true;
      if (isNullOrUndefined(parent.transform.cropZoomFactor)) {
        parent.transform.cropZoomFactor = parent.transform.zoomFactor;
        parent.notify("draw", { prop: "setTempZoomFactor", onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
      }
      parent.transform.zoomFactor = parent.transform.cropZoomFactor;
      var text = args.item.id;
      this.currentToolbar = "crop";
      parent.currSelectionPoint = null;
      parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
      var obj = { prevObj: null };
      parent.notify("crop", { prop: "getPreviousCropCurrentObj", value: { obj } });
      parent.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type: text, startX: null, startY: null, width: null, height: null }
      });
      parent.notify("crop", { prop: "setPreviousCropCurrentObj", value: { obj: obj["prevObj"] } });
      this.enableDisableTbrBtn();
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.quickAccessToolbarClicked = function(args, isContextualToolbar) {
      var parent = this.parent;
      var id = parent.element.id;
      if (args.item) {
        var isPreventUndoRedo = null;
        var obj = { prevActObj: null };
        var object = { tempObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        parent.notify("selection", { prop: "getTempActObj", onPropertyChange: false, value: { obj: object } });
        object["tempObj"]["activePoint"]["height"] = Math.abs(object["tempObj"]["activePoint"]["height"]);
        var pathObject = { isNewPath: null };
        var ctx = void 0;
        parent.notify("draw", { prop: "getNewPath", value: { obj: pathObject } });
        var type = args.item.id.replace(id + "_", "").toLowerCase();
        var left = void 0;
        var right = void 0;
        var indexObj = { freehandSelectedIndex: null };
        var shapeId = void 0;
        var isDisabled = void 0;
        var orderObj = { order: null };
        switch (type) {
          case "duplicate":
            if (!parent.element.querySelector("#" + id + "_duplicate").classList.contains("e-disabled")) {
              this.refreshSlider();
              if (!pathObject["isNewPath"] && JSON.stringify(object["tempObj"]) === JSON.stringify(parent.activeObj)) {
                isPreventUndoRedo = true;
              }
              this.duplicateShape(isPreventUndoRedo);
            }
            break;
          case "remove":
            if (!parent.element.querySelector("#" + id + "_remove").classList.contains("e-disabled")) {
              parent.noPushUndo = false;
              this.refreshSlider();
              parent.notify("selection", { prop: "deleteItem", onPropertyChange: false });
            }
            break;
          case "edittext":
            if (!parent.element.querySelector("#" + id + "_editText").classList.contains("e-disabled")) {
              this.editText();
            }
            break;
          case "rotleft":
          case "rotright":
            left = parent.element.querySelector("#" + id + "_rotLeft");
            right = parent.element.querySelector("#" + id + "_rotRight");
            if (left && !left.classList.contains("e-disabled") || right && !right.classList.contains("e-disabled")) {
              parent.rotateImage(args.item.id.replace(id + "_", "").toLowerCase());
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "hflip":
            if (!parent.element.querySelector("#" + id + "_hFlip").classList.contains("e-disabled")) {
              ctx = parent.activeObj.imageCanvas.getContext("2d");
              parent.horizontalFlip(ctx);
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "vflip":
            if (!parent.element.querySelector("#" + id + "_vFlip").classList.contains("e-disabled")) {
              ctx = parent.activeObj.imageCanvas.getContext("2d");
              parent.verticalFlip(ctx);
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "bringtofront":
            if (!parent.element.querySelector("#" + id + "_bringToFront").classList.contains("e-disabled")) {
              parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
              shapeId = indexObj["freehandSelectedIndex"] !== null ? parent.pointColl[indexObj["freehandSelectedIndex"]].id : parent.activeObj.currIndex;
              parent.updateShapeOrder(shapeId, type);
              isDisabled = false;
              parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
              if (shapeId.indexOf("pen") > -1) {
                parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
                var order = parent.getObjFromId(shapeId).order;
                isDisabled = order >= orderObj["order"] ? true : false;
              } else {
                var order = parent.getObjFromId(shapeId).order;
                isDisabled = order > orderObj["order"] ? true : false;
              }
              if (isDisabled) {
                document.getElementById(parent.element.id + "_bringToFront").classList.add("e-disabled");
              } else {
                document.getElementById(parent.element.id + "_bringToFront").classList.remove("e-disabled");
              }
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
        }
        if (type === "duplicate" || type === "remove") {
          parent.notify("draw", { prop: "redrawDownScale" });
        }
      }
      if (isNullOrUndefined(isContextualToolbar)) {
        parent.trigger("quickAccessToolbarItemClick", args);
      }
    };
    ToolbarModule2.prototype.editText = function() {
      var parent = this.parent;
      var points = { x: parent.activeObj.activePoint.startX, y: parent.activeObj.activePoint.startY };
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("selection", {
        prop: "setTempActObj",
        onPropertyChange: false,
        value: { obj: extend({}, parent.activeObj, {}, true) }
      });
      parent.notify("selection", {
        prop: "setInitialTextEdit",
        onPropertyChange: false,
        value: { bool: true }
      });
      parent.notify("draw", {
        prop: "setPrevActObj",
        onPropertyChange: false,
        value: { prevActObj: extend({}, parent.activeObj, {}, true) }
      });
      if (parent.activeObj.rotatedAngle !== 0) {
        var object = { x: points.x, y: points.y };
        parent.notify("shape", {
          prop: "getTextBoxPosition",
          onPropertyChange: false,
          value: { obj: parent.activeObj, object }
        });
        points.x = object["x"];
        points.y = object["y"];
        var object1 = { x: points.x, y: points.y };
        parent.notify("shape", {
          prop: "setFlipState",
          onPropertyChange: false,
          value: { x: points.x, y: points.y, obj: parent.activeObj, object: object1 }
        });
        points.x = object1["x"];
        points.y = object1["y"];
      }
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("draw", { prop: "redrawDownScale" });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      parent.activeObj = tempActiveObj;
      parent.notify("shape", {
        prop: "renderTextArea",
        onPropertyChange: false,
        value: { x: points.x, y: points.y, actObj: parent.activeObj }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: true } });
      }
      if (document.getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        document.getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
    };
    ToolbarModule2.prototype.duplicateShape = function(isPreventUndoRedo, isPublicMethod) {
      var parent = this.parent;
      var tempObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: []
      };
      parent.notify("selection", {
        prop: "setTempActObj",
        onPropertyChange: false,
        value: { obj: tempObj }
      });
      var obj = { prevActObj: null };
      parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
      var pathObject = { isNewPath: null };
      parent.notify("draw", { prop: "getNewPath", value: { obj: pathObject } });
      var objColl;
      var duplicateObj = extend({}, parent.activeObj, {}, true);
      var orderObj = { order: null };
      parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
      if (duplicateObj.order) {
        parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
        duplicateObj.order = orderObj["order"] > duplicateObj.order ? orderObj["order"] + 1 : duplicateObj.order + 1;
      } else {
        parent.noPushUndo = true;
        parent.okBtn();
        parent.noPushUndo = false;
        parent.selectShape(duplicateObj.currIndex);
        duplicateObj.order = orderObj["order"] > duplicateObj.order ? orderObj["order"] + 1 : duplicateObj.order + 1;
      }
      if (duplicateObj.shape === "image") {
        objColl = extend([], parent.objColl, [], true);
        parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      }
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
      } else if (obj["prevActObj"] || isPublicMethod) {
        parent.activeObj.currIndex = null;
        duplicateObj.currIndex = null;
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
      } else {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      }
      var noPushUndo = parent.noPushUndo;
      parent.noPushUndo = false;
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      parent.noPushUndo = noPushUndo;
      objColl = extend([], parent.objColl, [], true);
      duplicateObj.activePoint.startX += 10;
      duplicateObj.activePoint.startY -= 10;
      duplicateObj.activePoint.endX += 10;
      duplicateObj.activePoint.endY -= 10;
      if (duplicateObj.shape === "path") {
        for (var i = 0; i < duplicateObj.pointColl.length; i++) {
          duplicateObj.pointColl[i].x += 10;
          duplicateObj.pointColl[i].y -= 10;
        }
      } else if (duplicateObj.shape === "image") {
        duplicateObj.imageCanvas = parent.createElement("canvas");
      }
      var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
      parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
      duplicateObj.currIndex = shapeIDObj["id"];
      parent.activeObj = extend({}, duplicateObj, {}, true);
      if (parent.activeObj.shape === "image") {
        var activePoint = extend({}, duplicateObj.activePoint, {}, true);
        var dimObj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: {
            width: parent.activeObj.imageElement.width,
            height: parent.activeObj.imageElement.height,
            obj: dimObj,
            isImgShape: null
          }
        });
        parent.activeObj.activePoint.width = dimObj["width"];
        parent.activeObj.activePoint.height = dimObj["height"];
        if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
          parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: true }
          });
          parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = true;
        } else if (parent.activeObj.isHorImageFlip) {
          parent.activeObj.isHorImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: null }
          });
          parent.activeObj.isHorImageFlip = true;
        } else if (parent.activeObj.isVerImageFlip) {
          parent.activeObj.isVerImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: true }
          });
          parent.activeObj.isVerImageFlip = true;
        } else {
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: null }
          });
        }
        parent.activeObj.activePoint = activePoint;
      }
      if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow") {
        parent.notify("shape", {
          prop: "setPointCollForLineArrow",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      }
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
        canvas: "duplicate",
        obj: parent.activeObj,
        isCropRatio: null,
        points: null,
        isPreventDrag: true
      } });
      parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      this.renderQAT();
    };
    ToolbarModule2.prototype.defToolbarClicked = function(args) {
      var parent = this.parent;
      var id = parent.element.id;
      var isContextualToolbar = false;
      var isFilterFinetune = false;
      if (!this.isFrameToolbar && parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
        if (!parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
          isContextualToolbar = isFilterFinetune = true;
        }
        var straightenObj = { bool: parent.isStraightening };
        if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
          parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        }
      }
      if (args.item) {
        var type = args.item.id.replace(id + "_", "").toLowerCase();
        if (type === "duplicate" || type === "remove" || type === "edittext" || type === "hflip" || type === "vflip" || type === "rotleft" || type === "rotright") {
          this.quickAccessToolbarClicked(args, true);
          parent.trigger("toolbarItemClicked", args);
        } else {
          var isDisabledFilter = false;
          var isDisabledAdjustment = false;
          var adjustment = document.querySelector("#" + id + "_adjustment");
          if (adjustment && adjustment.classList.contains("e-disabled")) {
            isDisabledAdjustment = true;
          }
          var filter = document.querySelector("#" + id + "_filter");
          if (filter && filter.classList.contains("e-disabled")) {
            isDisabledFilter = true;
          }
          this.enableDisableTbrBtn();
          this.performDefTbrClick(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune);
          parent.trigger("toolbarItemClicked", args);
          if (parent.isStraightening) {
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
          }
          var validTypes = [
            "undo",
            "redo",
            "cancel",
            "aspectratio",
            "nonaspectratio",
            "save",
            "duplicate",
            "filter",
            "frame",
            "none",
            "mat",
            "bevel",
            "line",
            "inset",
            "hook",
            "resize",
            "remove"
          ];
          if (validTypes.indexOf(type) !== -1) {
            parent.notify("draw", { prop: "redrawDownScale" });
          }
        }
      }
    };
    ToolbarModule2.prototype.performDefTbrClick = function(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune) {
      var parent = this.parent;
      var id = parent.element.id;
      var zoomIn = parent.element.querySelector("#" + id + "_zoomIn");
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var isCropSelection = false;
      var panBtn;
      var splitWords;
      if (parent.activeObj.shape !== void 0) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords === void 0 && parent.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== void 0 && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (!parent.disabled) {
        switch (type) {
          case "pan":
            parent.currObjType.isCustomCrop = parent.currObjType.isFiltered = false;
            if (parent.currObjType.isUndoAction) {
              parent.notify("undo-redo", { prop: "refreshUrc", value: { bool: null } });
            }
            if (isCropSelection) {
              parent.currObjType.isCustomCrop = false;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              this.refreshToolbar("main");
            }
            if (parent.togglePan) {
              this.cancelPan();
              parent.notify("transform", { prop: "setDisablePan", onPropertyChange: false, value: { bool: true } });
              if (this.currentToolbar === "pen") {
                parent.freeHandDraw(true);
              }
            } else {
              panBtn = parent.element.querySelector(".e-img-pan .e-btn");
              if (panBtn) {
                panBtn.classList.add("e-selected-btn");
              }
              parent.pan(true);
              parent.notify("transform", { prop: "setDisablePan", onPropertyChange: false, value: { bool: false } });
            }
            if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
              zoomIn.classList.add("e-disabled");
              zoomIn.parentElement.classList.add("e-overlay");
            } else if (zoomIn) {
              zoomIn.classList.remove("e-disabled");
              zoomIn.parentElement.classList.remove("e-overlay");
            }
            this.refreshToolbar("main");
            break;
          case "cancel":
            parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar, isFinalCancel: true } });
            break;
          case "ok":
            parent.okBtn(null, true);
            parent.drawingShape = null;
            this.refreshDropDownBtn(false);
            this.currentToolbar = "main";
            parent.isStraightening = false;
            parent.notify("draw", { prop: "resetTempObjColl" });
            parent.notify("draw", { prop: "resetTempPointColl" });
            break;
          case "crop":
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
            if (Browser.isDevice) {
              this.updateContextualToolbar("color", "straighten");
            }
            break;
          case "reset":
            parent.reset();
            this.imageHeight = null;
            this.imageWidth = null;
            parent.aspectHeight = null;
            parent.aspectWidth = null;
            this.isAspectRatio = true;
            this.currentToolbar = "main";
            break;
          case "undo":
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-undo" });
            break;
          case "redo":
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-redo" });
            break;
          case "aspectratio":
            if (!parent.isCircleCrop && isNullOrUndefined(parent.currSelectionPoint) || parent.currSelectionPoint && parent.currSelectionPoint.shape !== "crop-circle") {
              if (getComponent(aspectRatioWidth, "numerictextbox").value) {
                parent.aspectWidth = getComponent(aspectRatioWidth, "numerictextbox").value;
                parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value;
                parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
              } else if (getComponent(aspectRatioHeight, "numerictextbox").value) {
                parent.aspectWidth = parseFloat(getComponent(aspectRatioWidth, "numerictextbox").placeholder);
                parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value;
                parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: true } });
              }
              parent.resizeSrc = {
                startX: parent.img.srcLeft,
                startY: parent.img.srcTop,
                width: parent.img.srcWidth,
                height: parent.img.srcHeight
              };
              this.refreshToolbar("resize");
            }
            break;
          case "nonaspectratio":
            if (getComponent(aspectRatioWidth, "numerictextbox").value || getComponent(aspectRatioHeight, "numerictextbox").value) {
              parent.aspectWidth = getComponent(aspectRatioWidth, "numerictextbox").value ? getComponent(aspectRatioWidth, "numerictextbox").value : parseFloat(getComponent(aspectRatioWidth, "numerictextbox").placeholder);
              parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value ? getComponent(aspectRatioHeight, "numerictextbox").value : parseFloat(getComponent(aspectRatioHeight, "numerictextbox").placeholder);
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
            }
            parent.resizeSrc = {
              startX: parent.img.srcLeft,
              startY: parent.img.srcTop,
              width: parent.img.srcWidth,
              height: parent.img.srcHeight
            };
            this.refreshToolbar("resize");
            break;
          case "resize":
            if (parent.currObjType.isFiltered) {
              parent.okBtn();
            }
            this.resizeClick();
            break;
          case "adjustment":
            if (!isDisabledAdjustment) {
              if (parent.currObjType.isFiltered) {
                parent.okBtn();
              }
              this.refreshToolbar("adjustment");
              parent.setTempFilterProperties();
              parent.notify("draw", { prop: "updateFinetune" });
              parent.notify("filter", { prop: "setTempAdjVal" });
              this.openSlider("brightness");
            }
            break;
          case "brightness":
          case "contrast":
          case "hue":
          case "saturation":
          case "opacity":
          case "blur":
          case "exposure":
            this.openSlider(type);
            break;
          case "filter":
            if (!isDisabledFilter) {
              showSpinner(parent.element);
              this.refreshToolbar("filter");
              parent.setTempFilterProperties();
              hideSpinner(parent.element);
            }
            break;
          case "default":
          case "chrome":
          case "cold":
          case "warm":
          case "grayscale":
          case "blackandwhite":
          case "sepia":
          case "invert":
          case "sharpen":
            parent.currObjType.isFiltered = true;
            parent.notify("filter", { prop: "applyImageFilter", value: { option: type } });
            break;
          case "upload":
            if (isFilterFinetune) {
              parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.remove("e-hide");
            }
            break;
          case "bold":
            parent.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
            if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "italic" }
              });
            } else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "default" }
              });
            } else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bolditalic" }
              });
            } else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bold" }
              });
            }
            if (parent.element.querySelector("#" + id + "_bold").classList.contains("e-selected-btn")) {
              parent.element.querySelector("#" + id + "_bold").classList.remove("e-selected-btn");
            } else {
              parent.element.querySelector("#" + id + "_bold").classList.add("e-selected-btn");
            }
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
          case "italic":
            parent.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
            if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bold" }
              });
            } else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bolditalic" }
              });
            } else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "default" }
              });
            } else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "italic" }
              });
            }
            if (parent.element.querySelector("#" + id + "_italic").classList.contains("e-selected-btn")) {
              parent.element.querySelector("#" + id + "_italic").classList.remove("e-selected-btn");
            } else {
              parent.element.querySelector("#" + id + "_italic").classList.add("e-selected-btn");
            }
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
          case "croptransform":
            this.performCropTransformClick();
            break;
          case "rotateleft":
          case "rotateright":
          case "horizontalflip":
          case "verticalflip":
            parent.transformSelect(type);
            if (type === "rotateleft" || type === "rotateright") {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
            if (Browser.isDevice) {
              this.updateContextualToolbar("color", "straighten");
            }
            break;
          case "save":
            parent.noPushUndo = false;
            parent.okBtn();
            parent.drawingShape = null;
            this.saveDialogPopup();
            break;
          case "transparency":
            this.updateContextualToolbar("transparency", "transparency");
            break;
          case "frame":
            this.frameToolbarClick();
            break;
          case "none":
          case "mat":
          case "bevel":
          case "line":
          case "inset":
          case "hook":
            this.unselectFrameBtn();
            if (parent.element.querySelector("#" + id + "_" + type)) {
              parent.element.querySelector("#" + id + "_" + type).classList.add("e-selected-btn");
            }
            parent.frameObj.type = type;
            parent.frameObj.size = 20;
            parent.frameObj.inset = 20;
            parent.frameObj.radius = 0;
            parent.frameObj.amount = 1;
            if (type === "inset") {
              parent.frameObj.offset = 60;
            } else {
              parent.frameObj.offset = 20;
            }
            this.refreshToolbar("frame");
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.isFrameBtnClick = true;
            parent.curFrameObjEvent = { previousFrameSetting: parent.tempFrameObj, currentFrameSetting: parent.frameObj };
            break;
        }
      }
    };
    ToolbarModule2.prototype.frameToolbarClick = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var frame = document.querySelector("#" + id + "_frame");
      var zoom;
      var frameObj;
      var tempFrameObj;
      parent.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
      if (parent.currObjType.isFiltered) {
        parent.okBtn();
      }
      if (frame && !frame.classList.contains("e-disabled")) {
        zoom = parent.transform.zoomFactor;
        parent.frameDestPoints = extend({}, parent.img, {}, true);
        if (isNullOrUndefined(parent.cxtTbarHeight)) {
          frameObj = extend({}, parent.frameObj, {}, true);
          tempFrameObj = extend({}, parent.tempFrameObj, {}, true);
          this.callFrameToolbar();
          parent.frameObj.type = "mat";
          this.callFrameToolbar();
          parent.cxtTbarHeight = parent.element.querySelector("#" + id + "_customizeWrapper").scrollHeight;
          parent.frameObj = frameObj;
          parent.tempFrameObj = tempFrameObj;
        }
        this.zoomToFrameRange();
        parent.tempFrameZoomLevel = zoom;
        if (Browser.isDevice) {
          parent.img.destTop -= parent.cxtTbarHeight / 2;
        } else {
          parent.img.destTop += parent.cxtTbarHeight / 2;
        }
        this.callFrameToolbar();
      }
    };
    ToolbarModule2.prototype.zoomToFrameRange = function() {
      var parent = this.parent;
      this.isFrameToolbar = false;
      parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
      var isSmaller = true;
      while (isSmaller) {
        if (this.toolbarHeight + parent.img.destTop >= this.toolbarHeight + parent.cxtTbarHeight) {
          isSmaller = false;
          break;
        }
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: -0.1, zoomPoint: null, isResize: true }
        });
      }
      this.isFrameToolbar = true;
    };
    ToolbarModule2.prototype.resizeClick = function() {
      var parent = this.parent;
      parent.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
      parent.upperCanvas.style.cursor = "default";
      parent.notify("transform", { prop: "updateResize", value: { bool: false } });
      if (this.isAspectRatio) {
        this.isAspectRatio = false;
      } else {
        this.isAspectRatio = true;
      }
      parent.isResize = true;
      this.refreshToolbar("resize");
    };
    ToolbarModule2.prototype.callFrameToolbar = function() {
      var parent = this.parent;
      extend(parent.tempFrameObj, parent.frameObj);
      var undoRedoObj = { appliedUndoRedoColl: [] };
      parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: undoRedoObj } });
      if (undoRedoObj["appliedUndoRedoColl"]["length"] === 0) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
          operation: "frame",
          previousObj: object["currObj"],
          previousObjColl: object["currObj"]["objColl"],
          previousPointColl: object["currObj"]["pointColl"],
          previousSelPointColl: object["currObj"]["selPointColl"],
          previousCropObj: extend({}, parent.cropObj, {}, true),
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        } });
      }
      this.refreshToolbar("frame");
    };
    ToolbarModule2.prototype.contextualToolbarClicked = function(args) {
      var parent = this.parent;
      var selEle = parent.element.querySelector(".e-contextual-toolbar-wrapper .e-toolbar-item.e-selected");
      if (selEle) {
        selEle.classList.remove("e-selected");
      }
      var type = args.item.id.replace(parent.element.id, "").split("_")[1];
      var imageFiltering = { filter: parent.toPascalCase(type), cancel: false };
      parent.trigger("imageFiltering", imageFiltering);
      if (imageFiltering.cancel) {
        return;
      }
      document.getElementById(args.item.id + "Canvas").parentElement.parentElement.classList.add("e-selected");
      parent.currObjType.isFiltered = true;
      parent.notify("filter", { prop: "applyImageFilter", value: { option: type.toLowerCase() } });
      parent.notify("draw", { prop: "redrawDownScale" });
      parent.currentFilter = args.item.id;
      this.enableDisableTbrBtn();
      parent.isFilterCanvasClick = true;
      parent.curFilterObjEvent = imageFiltering;
    };
    ToolbarModule2.prototype.refreshShapeDrawing = function() {
      var parent = this.parent;
      var object = { shape: "" };
      parent.notify("selection", { prop: "getCurrentDrawingShape", onPropertyChange: false, value: { obj: object } });
      if (object["shape"] !== "") {
        parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.refreshToolbar("main", false);
      }
    };
    ToolbarModule2.prototype.zoomInBtnClickHandler = function(e) {
      if (e) {
        var parent_1 = this.parent;
        if ((parent_1.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
          parent_1.noPushUndo = false;
          if (parent_1.currObjType.isFiltered) {
            parent_1.okBtn();
          }
          var drawingShape = parent_1.drawingShape;
          if (parent_1.drawingShape) {
            var id = parent_1.activeObj.currIndex;
            parent_1.noPushUndo = true;
            parent_1.okBtn();
            parent_1.noPushUndo = false;
            parent_1.drawingShape = null;
            if (id) {
              parent_1.selectShape(id);
            }
          }
          this.refreshShapeDrawing();
          if (Browser.isDevice && e.type === "touchstart") {
            if (!e.returnValue) {
              return;
            }
            e.preventDefault();
          }
          var zoomIn = document.querySelector("#" + parent_1.element.id + "_zoomIn");
          EventHandler.trigger(zoomIn, "click");
          var obj = { bool: false };
          parent_1.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
          if (obj["bool"]) {
            parent_1.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
            this.destroyQuickAccessToolbar();
          }
          parent_1.isZoomBtnClick = true;
          this.applyPreviewFilter();
          parent_1.currObjType.isFiltered = false;
          if (parent_1.togglePen) {
            parent_1.currObjType.isZoomed = true;
            parent_1.freeHandDraw(false);
            parent_1.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
          parent_1.notify("draw", { prop: "resetCurrentSelectionPoint" });
          parent_1.drawingShape = drawingShape;
          parent_1.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: 0.1, zoomPoint: null, isResize: null }
          });
          parent_1.notify("draw", { prop: "redrawDownScale" });
          if (parent_1.isCropTab || parent_1.activeObj.shape) {
            parent_1.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent_1.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent_1.isStraightening) {
            parent_1.notify("draw", { prop: "resetStraightenDestPoints" });
            parent_1.notify("draw", { prop: "setDestForStraighten" });
          }
        }
      }
    };
    ToolbarModule2.prototype.zoomOutBtnClickHandler = function(e) {
      if (e) {
        var parent_2 = this.parent;
        if ((parent_2.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
          parent_2.noPushUndo = false;
          if (parent_2.currObjType.isFiltered) {
            parent_2.okBtn();
          }
          var drawingShape = parent_2.drawingShape;
          if (parent_2.drawingShape) {
            var id = parent_2.activeObj.currIndex;
            parent_2.noPushUndo = true;
            parent_2.okBtn();
            parent_2.noPushUndo = false;
            parent_2.drawingShape = null;
            if (id) {
              parent_2.selectShape(id);
            }
          }
          this.refreshShapeDrawing();
          if (Browser.isDevice && e.type === "touchstart") {
            if (!e.returnValue) {
              return;
            }
            e.preventDefault();
          }
          var zoomOut = document.querySelector("#" + parent_2.element.id + "_zoomOut");
          EventHandler.trigger(zoomOut, "click");
          var obj = { bool: false };
          parent_2.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
          if (obj["bool"]) {
            parent_2.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
            this.destroyQuickAccessToolbar();
          }
          parent_2.isZoomBtnClick = true;
          this.applyPreviewFilter();
          parent_2.currObjType.isFiltered = false;
          if (parent_2.togglePen) {
            parent_2.currObjType.isZoomed = true;
            parent_2.freeHandDraw(false);
            parent_2.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
          parent_2.notify("draw", { prop: "resetCurrentSelectionPoint" });
          parent_2.drawingShape = drawingShape;
          parent_2.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -0.1, zoomPoint: null, isResize: null }
          });
          parent_2.notify("draw", { prop: "redrawDownScale" });
          if (parent_2.isCropTab || parent_2.activeObj.shape) {
            parent_2.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent_2.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent_2.isStraightening) {
            parent_2.notify("draw", { prop: "resetStraightenDestPoints" });
            parent_2.notify("draw", { prop: "setDestForStraighten" });
          }
        }
      }
    };
    ToolbarModule2.prototype.zoomInBtnMouseDownHandler = function(e) {
      e.preventDefault();
      this.zoomBtnHold = setInterval(this.zoomInBtnClickHandler.bind(this), 250);
    };
    ToolbarModule2.prototype.zoomOutBtnMouseDownHandler = function(e) {
      e.preventDefault();
      this.zoomBtnHold = setInterval(this.zoomOutBtnClickHandler.bind(this), 250);
    };
    ToolbarModule2.prototype.zoomBtnMouseUpHandler = function() {
      clearInterval(this.zoomBtnHold);
      this.zoomBtnHold = 0;
    };
    ToolbarModule2.prototype.closeContextualToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var isContextualToolbar = false;
      var straightenObj = { bool: parent.isStraightening };
      if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
        if (parent.element.querySelector("#" + id + "_contextualToolbar") && !parent.element.querySelector("#" + id + "_contextualToolbar").parentElement.classList.contains("e-hide") || parent.element.querySelector("#" + id + "_headWrapper") && !parent.element.querySelector("#" + id + "_headWrapper").parentElement.classList.contains("e-hide")) {
          parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          parent.okBtn();
          this.refreshMainToolbar();
          isContextualToolbar = true;
        }
      }
      return isContextualToolbar;
    };
    ToolbarModule2.prototype.destroyQuickAccessToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var quickToolbar = document.getElementById(id + "_quickAccessToolbar");
      if (quickToolbar && quickToolbar.classList.contains("e-control")) {
        getComponent(quickToolbar, "toolbar").destroy();
      }
      var qatArea = document.getElementById(id + "_quickAccessToolbarArea");
      if (qatArea) {
        qatArea.style.display = "none";
      }
    };
    ToolbarModule2.prototype.renderSlider = function(type, isSelect) {
      var parent = this.parent;
      var id = parent.element.id;
      var canvasWrapper = document.querySelector("#" + id + "_contextualToolbarArea");
      var hdrWrapper = document.querySelector("#" + id + "_headWrapper");
      var labelWrapper = document.querySelector("#" + id + "_labelWrapper");
      if (hdrWrapper) {
        hdrWrapper.remove();
        labelWrapper.remove();
      }
      hdrWrapper = canvasWrapper.appendChild(parent.createElement("div", {
        id: id + "_headWrapper",
        styles: "position: relative"
      }));
      if (type === "transparency") {
        labelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_labelWrapper",
          className: "e-ie-finetune-slider-label",
          styles: Browser.isDevice ? "position: absolute; top: 31%; left: calc(50% - 150px); font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 31%; left: calc(50% - 220px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
      } else {
        labelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_labelWrapper",
          className: "e-ie-finetune-slider-label",
          styles: Browser.isDevice ? "position: absolute; top: 31%; left: calc(50% - 160px); font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
      }
      labelWrapper.textContent = this.l10n.getConstant(parent.toPascalCase(type === "transparency" ? "opacity" : type));
      var sliderWrapper = hdrWrapper.appendChild(parent.createElement("div", {
        id: id + "_sliderWrapper",
        className: "e-ie-finetune-slider-wrap",
        styles: "position: absolute"
      }));
      var value = parent.getCurrAdjustmentValue(type);
      if (isSelect && type === "straighten" && Browser.isDevice) {
        value = parent.cropObj.straighten;
      }
      var min;
      var max;
      var slider;
      if (type === "brightness" || type === "contrast" || type === "saturation" || type === "exposure") {
        if (parent.finetuneSettings) {
          if (type === "brightness" && parent.finetuneSettings.brightness) {
            min = parent.finetuneSettings.brightness.min;
            max = parent.finetuneSettings.brightness.max;
          } else if (type === "contrast" && parent.finetuneSettings.contrast) {
            min = parent.finetuneSettings.contrast.min;
            max = parent.finetuneSettings.contrast.max;
          } else if (type === "saturation" && parent.finetuneSettings.saturation) {
            min = parent.finetuneSettings.saturation.min;
            max = parent.finetuneSettings.saturation.max;
          } else if (type === "exposure" && parent.finetuneSettings.exposure) {
            min = parent.finetuneSettings.exposure.min;
            max = parent.finetuneSettings.exposure.max;
          } else {
            min = -100;
            max = 100;
          }
        } else {
          min = -100;
          max = 100;
        }
        slider = this.createSlider(min, max, value, type);
      } else if (type === "hue" || type === "blur" || type === "opacity") {
        if (parent.finetuneSettings) {
          if (type === "hue" && parent.finetuneSettings.hue) {
            min = parent.finetuneSettings.hue.min;
            max = parent.finetuneSettings.hue.max;
          } else if (type === "blur" && parent.finetuneSettings.blur) {
            min = parent.finetuneSettings.blur.min;
            max = parent.finetuneSettings.blur.max;
          } else if (type === "opacity" && parent.finetuneSettings.opacity) {
            min = parent.finetuneSettings.opacity.min;
            max = parent.finetuneSettings.opacity.max;
          } else {
            min = 0;
            max = 100;
          }
        } else {
          min = 0;
          max = 100;
        }
        slider = this.createSlider(min, max, value, type);
      } else if (type === "transparency") {
        min = 0;
        max = 100;
        slider = this.createSlider(min, max, value, type);
      } else if (type === "straighten") {
        min = -45;
        max = 45;
        slider = this.createSlider(min, max, value, type);
      }
      slider.appendTo("#" + id + "_sliderWrapper");
      sliderWrapper.style.left = (parseFloat(canvasWrapper.style.width) - parseFloat(slider.width)) / 2 + "px";
      if (type === "straighten" && Browser.isDevice) {
        var sLabelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_sLabelWrapper",
          className: "e-ie-straighten-value-span e-ie-finetune-value-span",
          styles: "position: absolute; top: 31%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
        sLabelWrapper.innerHTML = parent.transform.straighten.toString() + "&#176";
        sliderWrapper.parentElement.classList.add("e-straighten-slider");
      }
      if (type !== "straighten") {
        hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_finetuneSpan",
          className: "e-ie-finetune-value-span",
          styles: Browser.isDevice ? "position: absolute; top: 25%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 25%; left: calc(50% + 190px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
        sliderWrapper.parentElement.classList.add("e-finetune-slider");
        if (type === "transparency" && Browser.isDevice) {
          sliderWrapper.parentElement.classList.add("e-ie-device-transparency-slider");
        }
        this.updateFinetuneSpan(type);
      }
    };
    ToolbarModule2.prototype.createSlider = function(min, max, value, type) {
      var _this = this;
      var parent = this.parent;
      var step = type === "straighten" ? 3 : 1;
      return new Slider({
        value,
        type: "MinRange",
        min,
        max,
        step,
        width: Browser.isDevice ? "180px" : type === "straighten" ? "200px" : "300px",
        cssClass: "e-slider",
        change: function(args) {
          parent.notify("selection", { prop: "setSliderActive", onPropertyChange: false, value: { bool: true } });
          if (type === "transparency") {
            if (parent.activeObj.shape) {
              if (isNullOrUndefined(parent.activeObj.imageRatio)) {
                parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
              }
              parent.notify("shape", { prop: "pushActItemIntoObj" });
              var prevCropObj = extend({}, parent.cropObj, {}, true);
              var object = { currObj: {} };
              parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
              var prevObj = object["currObj"];
              prevObj.objColl = extend([], parent.objColl, [], true);
              prevObj.pointColl = extend([], parent.pointColl, [], true);
              prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
              var selPointCollObj = { selPointColl: null };
              parent.notify("freehand-draw", {
                prop: "getSelPointColl",
                onPropertyChange: false,
                value: { obj: selPointCollObj }
              });
              prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
              parent.objColl.pop();
              parent.activeObj.opacity = args.value / 100;
              _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
              parent.objColl.push(parent.activeObj);
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeTransform",
                  previousObj: prevObj,
                  previousObjColl: prevObj.objColl,
                  previousPointColl: prevObj.pointColl,
                  previousSelPointColl: prevObj.selPointColl,
                  previousCropObj: prevCropObj,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
              parent.notify("selection", { prop: "redrawShape", value: { obj: parent.objColl[parent.objColl.length - 1] } });
              _this.updateFinetuneSpan(type);
            }
          } else if (type === "straighten") {
            parent.setStraighten(args.value);
          } else {
            if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
              parent.isFinetuning = true;
            }
            parent.notify("selection", { prop: "setSliding", value: { bool: true } });
            parent.setCurrAdjustmentValue(type, args.value);
            _this.updateFinetuneSpan(type);
            _this.enableDisableTbrBtn();
            parent.isFinetuning = false;
          }
        },
        changed: function() {
          if (type !== "transparency" && type !== "straighten") {
            parent.notify("selection", { prop: "setSliding", value: { bool: false } });
            parent.notify("draw", { prop: "redrawDownScale" });
          }
          parent.notify("selection", { prop: "setSliderActive", onPropertyChange: false, value: { bool: false } });
          if (type === "transparency") {
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            parent.element.querySelector("#" + parent.element.id + "_transparency").click();
          }
        }
      });
    };
    ToolbarModule2.prototype.updateFinetuneSpan = function(type) {
      var parent = this.parent;
      var ftValPan = parent.element.querySelector(".e-ie-finetune-value-span");
      if (ftValPan) {
        var adjObj = { adjustmentLevel: null };
        parent.notify("filter", { prop: "getAdjustmentLevel", onPropertyChange: false, value: { obj: adjObj } });
        ftValPan.innerHTML = Math.round(adjObj["adjustmentLevel"][type]).toString();
      }
    };
    ToolbarModule2.prototype.applyPreviewFilter = function() {
      var parent = this.parent;
      if (document.querySelector("#" + parent.element.id + "_sliderWrapper") || parent.currObjType.isFiltered) {
        parent.initialAdjustmentValue = this.lowerContext.filter;
        parent.canvasFilter = this.lowerContext.filter;
        parent.currObjType.isFiltered = false;
      }
    };
    ToolbarModule2.prototype.unselectBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var selectors = [
        "#" + id + "_brightness",
        "#" + id + "_contrast",
        "#" + id + "_hue",
        "#" + id + "_saturation",
        "#" + id + "_opacity",
        "#" + id + "_blur",
        "#" + id + "_exposure"
      ];
      for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
        var selector = selectors_1[_i];
        var element2 = document.querySelector(selector);
        if (element2 && element2.classList.contains("e-selected-btn")) {
          element2.classList.remove("e-selected-btn");
          break;
        }
      }
    };
    ToolbarModule2.prototype.openSlider = function(type) {
      this.unselectBtn();
      this.parent.currObjType.isFiltered = true;
      this.refreshToolbar("color", null, null, null, type);
      document.getElementById(this.parent.element.id + "_" + type).classList.add("e-selected-btn");
    };
    ToolbarModule2.prototype.refreshSlider = function() {
      var id = this.parent.element.id;
      var sliderWrapper = document.querySelector("#" + id + "_sliderWrapper");
      var slider = document.querySelector(".e-slider");
      var hdrWrapper = document.querySelector("#" + id + "_headWrapper");
      if (hdrWrapper) {
        hdrWrapper.style.display = "none";
      }
      if (sliderWrapper && slider) {
        slider.ej2_instances[0].destroy();
        sliderWrapper.remove();
      }
    };
    ToolbarModule2.prototype.unselectFrameBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var selectors = [
        "#" + id + "_none",
        "#" + id + "_mat",
        "#" + id + "_line",
        "#" + id + "_inset",
        "#" + id + "_bevel",
        "#" + id + "_hook"
      ];
      for (var _i = 0, selectors_2 = selectors; _i < selectors_2.length; _i++) {
        var selector = selectors_2[_i];
        var element2 = document.querySelector(selector);
        if (element2.classList.contains("e-selected-btn")) {
          element2.classList.remove("e-selected-btn");
          break;
        }
      }
    };
    ToolbarModule2.prototype.updateToolbarItems = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isImageLoaded) {
        return;
      }
      if (this.isToolbar()) {
        var selFillElem = parent.element.querySelector(".e-fill.e-template .e-dropdownbtn-preview");
        var selStrokeElem = parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview");
        var selTextStrokeElem = parent.element.querySelector(".e-text-font-color.e-template .e-dropdownbtn-preview");
        var selPenStrokeElem = parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview");
        var strokeWidthElem = parent.element.querySelector(".e-shape-stroke-width");
        var fontFamilyElem = parent.element.querySelector(".e-text-font-family");
        var fontSizeElem = parent.element.querySelector(".e-text-font-size");
        var boldBtn = parent.element.querySelector("#" + id + "_bold");
        var italicBtn = parent.element.querySelector("#" + id + "_italic");
        if (parent.activeObj.strokeSettings && parent.activeObj.textSettings) {
          if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
            parent.activeObj.strokeSettings.strokeWidth = 2;
          }
          if (selFillElem) {
            var value = parent.activeObj.strokeSettings.fillColor;
            if (parent.activeObj.strokeSettings.fillColor === "") {
              selFillElem.classList.add("e-nocolor-item");
            } else {
              selFillElem.classList.remove("e-nocolor-item");
              selFillElem.style.background = value;
            }
            if (document.querySelector("#" + id + "_shape_fill")) {
              getComponent(id + "_shape_fill", "colorpicker").value = value;
            }
          }
          if (selStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selStrokeElem.style.background = value;
            if (document.querySelector("#" + id + "_shape_stroke")) {
              getComponent(id + "_shape_stroke", "colorpicker").value = value;
            }
          }
          if (selTextStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selTextStrokeElem.style.background = value;
            if (document.querySelector("#" + id + "_text_font")) {
              getComponent(id + "_text_font", "colorpicker").value = value;
            }
          }
          if (selPenStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selPenStrokeElem.style.background = value;
            if (document.querySelector("#" + id + "_pen_stroke")) {
              getComponent(id + "_pen_stroke", "colorpicker").value = value;
            }
            var obj = { penOpacity: 1 };
            parent.notify("freehand-draw", { prop: "getPenOpacity", onPropertyChange: false, value: { obj } });
          }
          if (fontFamilyElem) {
            if (Browser.isDevice) {
              fontFamilyElem.setAttribute("style", "font-family:" + parent.activeObj.textSettings.fontFamily.toLowerCase());
            } else {
              fontFamilyElem.textContent = parent.activeObj.textSettings.fontFamily;
            }
          }
          if (fontSizeElem) {
            for (var i = 0; i < parent.fontSizeColl.length; i++) {
              if (parseInt(parent.fontSizeColl[i].text, 10) >= Math.round(parent.activeObj.textSettings.fontSize)) {
                fontSizeElem.textContent = (i + 1).toString();
                break;
              }
            }
          }
          if (boldBtn) {
            if (parent.activeObj.textSettings.bold) {
              boldBtn.classList.add("e-selected-btn");
            } else {
              boldBtn.classList.remove("e-selected-btn");
            }
          }
          if (italicBtn) {
            if (parent.activeObj.textSettings.italic) {
              italicBtn.classList.add("e-selected-btn");
            } else {
              italicBtn.classList.remove("e-selected-btn");
            }
          }
          if (strokeWidthElem) {
            var strokeWidth = Math.round(parent.activeObj.strokeSettings.strokeWidth).toString();
            strokeWidthElem.textContent = this.getStrokeWidth(strokeWidth);
          }
        }
      }
    };
    ToolbarModule2.prototype.getStrokeWidth = function(text) {
      var strokeWidth;
      var currentWidth = parseInt(text, 10) / 2;
      switch (currentWidth) {
        case 0:
          strokeWidth = this.l10n.getConstant("NoOutline");
          break;
        case 1:
          strokeWidth = this.l10n.getConstant("XSmall");
          break;
        case 2:
          strokeWidth = this.l10n.getConstant("Small");
          break;
        case 3:
          strokeWidth = this.l10n.getConstant("Medium");
          break;
        case 4:
          strokeWidth = this.l10n.getConstant("Large");
          break;
        case 5:
          strokeWidth = this.l10n.getConstant("XLarge");
          break;
      }
      return strokeWidth;
    };
    ToolbarModule2.prototype.cancelPan = function() {
      var parent = this.parent;
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      var panBtn = parent.element.querySelector(".e-img-pan .e-btn");
      if (panBtn) {
        panBtn.classList.remove("e-selected-btn");
      }
      parent.pan(false);
    };
    ToolbarModule2.prototype.refreshMainToolbar = function() {
      if (this.currToolbar !== "main") {
        this.refreshToolbar("main");
      }
    };
    ToolbarModule2.prototype.destroySubComponents = function() {
      var parent = this.parent;
      var inputElement = parent.element.querySelectorAll("input.e-control");
      var btnElement = parent.element.querySelectorAll("button.e-control");
      for (var i = 0, len = inputElement.length; i < len; i++) {
        if (inputElement[i].classList.contains("e-color-picker")) {
          getComponent(inputElement[i], "color-picker").destroy();
          detach(select("input#" + inputElement[i].id, parent.element));
        }
      }
      for (var i = 0, len = btnElement.length; i < len; i++) {
        if (btnElement[i].classList.contains("e-dropdown-btn")) {
          getComponent(btnElement[i], "dropdown-btn").destroy();
          detach(select("button#" + btnElement[i].id, parent.element));
        } else if (btnElement[i].classList.contains("e-btn")) {
          getComponent(btnElement[i], "btn").destroy();
          detach(select("button#" + btnElement[i].id, parent.element));
        }
      }
    };
    ToolbarModule2.prototype.setInitialShapeSettings = function(args) {
      var parent = this.parent;
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.currObjType.shape = args.item.id;
      parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
      parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
      parent.activeObj.shapeDegree = parent.transform.degree;
      parent.activeObj.shapeFlip = parent.transform.currFlipState;
      parent.activeObj.textFlip = parent.transform.currFlipState;
      parent.activeObj.flipObjColl = [];
      var orderObj = { order: null };
      parent.notify("shape", { prop: "getNewOrder", onPropertyChange: false, value: { obj: orderObj } });
      parent.activeObj.order = orderObj["order"];
    };
    ToolbarModule2.prototype.isToolbarString = function(items) {
      var isString = false;
      for (var i = 0; i < items.length; i++) {
        if (typeof items[i] === "string") {
          isString = true;
          break;
        }
      }
      return isString;
    };
    ToolbarModule2.prototype.excludeItems = function(items) {
      var indexArr = [];
      for (var i = 0; i < items.length; i++) {
        var index = this.getIndex(items[i]);
        if (index !== -1) {
          indexArr.push(index);
        }
      }
      var negativeIndexArr = [];
      for (var i = 0; i < this.defToolbarItems.length; i++) {
        if (this.defToolbarItems[i].align === "Center" && !this.isSameIndex(indexArr, i) && this.defToolbarItems[i].id !== this.parent.element.id + "_annotation") {
          negativeIndexArr.push(i);
        }
      }
      for (var i = negativeIndexArr.length - 1; i >= 0; i--) {
        this.defToolbarItems.splice(negativeIndexArr[i], 1);
      }
    };
    ToolbarModule2.prototype.isSameIndex = function(indexArr, index) {
      for (var i = 0; i < indexArr.length; i++) {
        if (indexArr[i] === index) {
          return true;
        }
      }
      return false;
    };
    ToolbarModule2.prototype.getIndex = function(item) {
      var index = -1;
      var isFontColor = false;
      if (item === "rotateLeft") {
        item = "rotLeft";
      }
      if (item === "rotateRight") {
        item = "rotRight";
      }
      if (item === "horizontalFlip") {
        item = "hflip";
      }
      if (item === "verticalFlip") {
        item = "vflip";
      }
      if (item === "arrowStart") {
        item = "start";
      }
      if (item === "arrowEnd") {
        item = "end";
      }
      if (item === "fontColor") {
        item = "strokeColor";
        isFontColor = true;
      }
      for (var i = 0; i < this.defToolbarItems.length; i++) {
        var id = this.defToolbarItems[i].id;
        if (id && id.toLowerCase().indexOf(item.toLowerCase()) !== -1) {
          index = i;
          break;
        }
      }
      if (isFontColor) {
        item = "fontColor";
      }
      return index;
    };
    ToolbarModule2.prototype.getModuleName = function() {
      return "toolbar-module";
    };
    return ToolbarModule2;
  }()
);

// node_modules/@syncfusion/ej2-angular-image-editor/fesm2020/syncfusion-ej2-angular-image-editor.mjs
var _c0 = ["toolbarTemplate"];
var inputs = ["allowUndoRedo", "cssClass", "disabled", "enablePersistence", "enableRtl", "finetuneSettings", "fontFamily", "height", "isReadOnly", "locale", "quickAccessToolbarTemplate", "selectionSettings", "showQuickAccessToolbar", "theme", "toolbar", "toolbarTemplate", "width", "zoomSettings"];
var outputs = ["beforeSave", "click", "created", "cropping", "destroyed", "fileOpened", "finetuneValueChanging", "flipping", "frameChange", "imageFiltering", "panning", "quickAccessToolbarItemClick", "quickAccessToolbarOpen", "resizing", "rotating", "saved", "selectionChanging", "shapeChange", "shapeChanging", "toolbarCreated", "toolbarItemClicked", "toolbarUpdating", "zooming"];
var twoWays = [""];
var ImageEditorComponent = class ImageEditorComponent2 extends ImageEditor {
  constructor(ngEle, srenderer, viewContainerRef, injector) {
    super();
    this.ngEle = ngEle;
    this.srenderer = srenderer;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.element = this.ngEle.nativeElement;
    this.injectedModules = this.injectedModules || [];
    this.registerEvents(outputs);
    this.addTwoWay.call(this, twoWays);
    setValue2("currentInstance", this, this.viewContainerRef);
    this.context = new ComponentBase();
  }
  ngOnInit() {
    this.context.ngOnInit(this);
  }
  ngAfterViewInit() {
    this.context.ngAfterViewInit(this);
  }
  ngOnDestroy() {
    this.context.ngOnDestroy(this);
  }
  ngAfterContentChecked() {
    this.context.ngAfterContentChecked(this);
  }
};
ImageEditorComponent.ɵfac = function ImageEditorComponent_Factory(t) {
  return new (t || ImageEditorComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector));
};
ImageEditorComponent.ɵcmp = ɵɵdefineComponent({
  type: ImageEditorComponent,
  selectors: [["ejs-imageeditor"]],
  contentQueries: function ImageEditorComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, _c0, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);
    }
  },
  inputs: {
    allowUndoRedo: "allowUndoRedo",
    cssClass: "cssClass",
    disabled: "disabled",
    enablePersistence: "enablePersistence",
    enableRtl: "enableRtl",
    finetuneSettings: "finetuneSettings",
    fontFamily: "fontFamily",
    height: "height",
    isReadOnly: "isReadOnly",
    locale: "locale",
    quickAccessToolbarTemplate: "quickAccessToolbarTemplate",
    selectionSettings: "selectionSettings",
    showQuickAccessToolbar: "showQuickAccessToolbar",
    theme: "theme",
    toolbar: "toolbar",
    toolbarTemplate: "toolbarTemplate",
    width: "width",
    zoomSettings: "zoomSettings"
  },
  outputs: {
    beforeSave: "beforeSave",
    click: "click",
    created: "created",
    cropping: "cropping",
    destroyed: "destroyed",
    fileOpened: "fileOpened",
    finetuneValueChanging: "finetuneValueChanging",
    flipping: "flipping",
    frameChange: "frameChange",
    imageFiltering: "imageFiltering",
    panning: "panning",
    quickAccessToolbarItemClick: "quickAccessToolbarItemClick",
    quickAccessToolbarOpen: "quickAccessToolbarOpen",
    resizing: "resizing",
    rotating: "rotating",
    saved: "saved",
    selectionChanging: "selectionChanging",
    shapeChange: "shapeChange",
    shapeChanging: "shapeChanging",
    toolbarCreated: "toolbarCreated",
    toolbarItemClicked: "toolbarItemClicked",
    toolbarUpdating: "toolbarUpdating",
    zooming: "zooming"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ImageEditorComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
__decorate([Template()], ImageEditorComponent.prototype, "toolbarTemplate", void 0);
ImageEditorComponent = __decorate([ComponentMixins([ComponentBase])], ImageEditorComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImageEditorComponent, [{
    type: Component2,
    args: [{
      selector: "ejs-imageeditor",
      inputs,
      outputs,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      queries: {}
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }];
  }, {
    toolbarTemplate: [{
      type: ContentChild,
      args: ["toolbarTemplate"]
    }]
  });
})();
var ImageEditorModule = class {
};
ImageEditorModule.ɵfac = function ImageEditorModule_Factory(t) {
  return new (t || ImageEditorModule)();
};
ImageEditorModule.ɵmod = ɵɵdefineNgModule({
  type: ImageEditorModule,
  declarations: [ImageEditorComponent],
  imports: [CommonModule],
  exports: [ImageEditorComponent]
});
ImageEditorModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImageEditorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [ImageEditorComponent],
      exports: [ImageEditorComponent]
    }]
  }], null, null);
})();
var ImageEditorAllModule = class {
};
ImageEditorAllModule.ɵfac = function ImageEditorAllModule_Factory(t) {
  return new (t || ImageEditorAllModule)();
};
ImageEditorAllModule.ɵmod = ɵɵdefineNgModule({
  type: ImageEditorAllModule,
  imports: [CommonModule, ImageEditorModule],
  exports: [ImageEditorModule]
});
ImageEditorAllModule.ɵinj = ɵɵdefineInjector({
  providers: [],
  imports: [[CommonModule, ImageEditorModule], ImageEditorModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImageEditorAllModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ImageEditorModule],
      exports: [ImageEditorModule],
      providers: []
    }]
  }], null, null);
})();
export {
  ArrowheadType,
  Crop,
  Direction,
  Draw,
  Export,
  FileType,
  Filter,
  FinetuneSettings,
  FontFamily,
  FrameLineStyle,
  FrameType,
  FreehandDrawing,
  ImageEditor,
  ImageEditorAllModule,
  ImageEditorCommand,
  ImageEditorComponent,
  ImageEditorModule,
  ImageFilterOption,
  ImageFinetuneOption,
  Selection,
  SelectionSettings,
  Shape,
  ShapeType,
  Theme,
  ToolbarModule,
  Transform,
  UndoRedo,
  ZoomSettings,
  ZoomTrigger
};
//# sourceMappingURL=@syncfusion_ej2-angular-image-editor.js.map
